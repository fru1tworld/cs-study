# Java 8 금요일: Java 8이 데이터베이스 접근에 혁명을 일으킬 것이다

> 원문: https://blog.jooq.org/java-8-friday-java-8-will-revolutionize-database-access/

Data Geekery에서 우리는 Java 8에 열광하고 있습니다. 우리는 Java의 가장 큰 개선을 최대한 활용하기 위해 jOOQ의 API와 통합 기능을 개선하는 작업을 해왔습니다. 이 블로그 시리즈는 몇 가지 Java 8의 멋진 기능을 선보이며, Java 8과 관련된 Data Geekery의 몇 가지 생각들을 공유합니다.

## 게스트 포스트: Ming-Yee Iu 박사

이번 주에는 EPFL에서 자바 데이터베이스 쿼리에 관한 박사 학위를 마친 Ming-Yee Iu 박사의 게스트 포스트가 있습니다. 그는 자바에서 데이터베이스 쿼리를 지원하기 위한 새로운 기술을 시연하기 위해 오픈 소스 프로젝트 Jinq를 만들었습니다.

### 편집자 주

이 블로그에서는 LINQ 스타일 기능이 Java에 어떻게 추가될 수 있는지에 대해 여러 번 탐구했습니다:

- Java 8에 여전히 LINQ가 필요한가? 아니면 LINQ보다 나은가?
- LINQ와 Java
- Java Streams 미리보기 vs .NET LINQ
- Java가 JSR-341의 EL 3.0에 LINQ를 추가할까?
- 언제 Java에 LINQ가 생길까?

jOOQ와 같은 대부분의 LINQ에서 영감을 받은 API는 내부 도메인 특화 언어로 작동합니다. JaQu와 같은 다른 것들은 바이트코드 분석에 의존하며 쿼리를 통합합니다. JINQ는 런타임 바이트코드 분석을 통해 이 접근 방식을 공식화하고, "기호 실행(symbolic execution)"이라는 기술을 사용합니다.

## Java 8 멋진 기능: Java 8이 데이터베이스 접근에 혁명을 일으킬 것이다

Java 8이 드디어 여기에 왔습니다! 수년간의 기다림 끝에 Java 프로그래머들은 마침내 Java에서 함수형 프로그래밍을 지원받게 될 것입니다. 함수형 프로그래밍 지원은 기존 코드를 간소화하는 데 도움이 되지만, Java에 많은 새로운 기능도 가져다줍니다. 데이터베이스 작업은 Java 8로 인해 혁신될 영역 중 하나입니다. 이러한 새로운 기능은 C#의 LINQ와 같은 다른 프로그래밍 언어와 경쟁할 수 있는 새로운 데이터베이스 접근 방식을 가능하게 합니다.

### 데이터를 다루는 함수형 방식

Java 8의 함수형 프로그래밍은 컬렉션 작업을 간소화합니다. 예를 들어, 고객 컬렉션이 있다고 가정해 봅시다. 벨기에 출신의 모든 고객만 원한다면, 그들을 필터링해야 합니다. 구식 Java에서는 컬렉션을 순회하고 원하는 요소를 유지해야 합니다:

```java
Collection<Customer> customers;
Collection<Customer> belgians = new ArrayList<>();
for (Customer c : customers) {
    if (c.getCountry().equals("Belgium"))
        belgians.add(c);
}
```

이것은 5줄의 코드가 필요합니다. 또한 잘 추상화되어 있지 않습니다. 만약 1천만 명의 고객이 있고 여러 스레드에서 필터링하여 속도를 높이고 싶다면 어떨까요? 복잡한 멀티스레드 코드를 사용하여 처음부터 모든 것을 다시 작성해야 할 것입니다.

Java 8에서는 한 줄의 코드만 필요합니다:

```java
customers.stream().filter(
    c -> c.getCountry().equals("Belgium")
);
```

코드가 더 짧을 뿐만 아니라 더 이해하기 쉽습니다. 보일러플레이트가 거의 없습니다. 코드는 `filter()` 메서드를 호출합니다. 따라서 이 코드가 데이터를 필터링하고 있다는 것이 분명합니다.

또 다른 장점은 Java 8이 함수형 코드를 작성할 수 있게 해주기 때문에 필터링의 구현 세부 사항을 숨겨 Java가 그것을 실행하는 방법을 더 유연하게 할 수 있다는 것입니다. 여러 스레드에 걸쳐 필터링을 병렬화하려면 `stream()` 메서드를 `parallelStream()` 메서드로 바꾸기만 하면 됩니다.

```java
customers.parallelStream().filter(
    c -> c.getCountry().equals("Belgium")
);
```

더 흥미로운 것은 이 함수형 스타일의 코드가 데이터베이스에서도 작동한다는 것입니다!

### 데이터베이스를 다루는 함수형 방식

일반적으로 프로그래머는 특별한 데이터베이스 쿼리 언어를 사용하여 데이터베이스에 쿼리를 보냅니다. 예를 들어, 아래는 JDBC를 사용하여 벨기에 출신의 모든 고객을 찾는 코드입니다:

```java
PreparedStatement s = con.prepareStatement(
      "SELECT * "
    + "FROM Customer C "
    + "WHERE C.Country = ? ");
s.setString(1, "Belgium");
ResultSet rs = s.executeQuery();
```

이 코드의 대부분은 문자열 형태로 되어 있어서 컴파일러가 오류를 검사할 수 없고, 부주의한 코딩으로 인한 보안 문제로 이어질 수 있습니다. 객체-관계형 매퍼와 다른 데이터베이스 추상화 계층은 이 보일러플레이트 코드를 일부 숨길 수 있지만, 프로그래머가 복잡한 쿼리를 만들어야 할 때마다 데이터베이스 쿼리 언어로 돌아가야 합니다.

Jinq는 데이터베이스를 다루는 새로운 방법입니다. Java 컬렉션을 다루는 코드를 작성하는 것처럼 데이터베이스 쿼리를 작성할 수 있습니다. Jinq가 자동으로 코드를 데이터베이스 쿼리로 번역합니다. 다음은 Jinq를 사용하여 데이터베이스에서 벨기에 출신의 모든 고객을 찾는 예시입니다:

```java
customers.where(
    c -> c.getCountry().equals("Belgium")
);
```

이 코드는 Streams API를 사용하는 코드와 거의 동일합니다. 사실, Jinq의 미래 버전에서는 Streams API를 직접 사용하여 쿼리를 작성할 수 있을 것입니다. 코드는 데이터베이스 쿼리로 자동 번역됩니다. 새로운 언어를 배울 필요가 없습니다. 일반 Java 컴파일러로 코드를 컴파일합니다. 코드에 오류가 있으면 컴파일러가 찾아낼 것입니다.

그리고 쿼리는 컴팩트하며 복잡한 쿼리도 지원됩니다:

```java
customers
    .where( c -> c.getCountry().equals("Belgium") )
    .where( c -> {
        if (c.getSalary() < 100000)
            return c.getSalary() < c.getDebt();
        else
            return c.getSalary() < 2 * c.getDebt();
        } );
```

### 내부 작동 방식

이러한 새로운 함수형 스타일 데이터베이스 API를 지원하는 핵심은 기호 실행(symbolic execution)이라는 바이트코드 분석 유형입니다. 코드가 일반 Java 컴파일러로 컴파일되고 일반 Java 가상 머신에서 실행되지만, Jinq는 컴파일된 Java 코드가 실행될 때 분석하고 그로부터 데이터베이스 쿼리를 구성할 수 있습니다.

기호 실행이 어떻게 작동하는지 이해하기 위해, 아래 쿼리를 Jinq가 어떻게 실행하는지 살펴보겠습니다:

```java
customers
    .where( c -> c.getCountry().equals("Belgium") )
```

처음에 `customers` 변수는 데이터베이스에 있는 모든 고객의 컬렉션을 나타냅니다. 이는 다음과 같은 간단한 데이터베이스 쿼리로 표현됩니다:

```sql
SELECT *
  FROM Customers C
```

`where()` 메서드가 호출되면, 여기에 함수가 전달됩니다. Jinq는 이 함수의 `.class` 파일을 열고 그 안에 있는 컴파일된 바이트코드를 검사합니다. 이 예제에서는 바이트코드를 실제로 사용하는 대신 간단한 명령어 세트를 사용하겠습니다. 전달된 함수에 대한 컴파일된 코드가 다음과 같다고 가정해 봅시다:

```
1. d = c.getCountry()
2. e = "Belgium"
3. e = d.equals(e)
4. return e
```

일반적으로 컴퓨터는 이 코드를 실행하여 각 줄의 코드를 하나씩 실행하고, 한 줄이 완료되면 다음 줄로 이동합니다. 예를 들어, 위 코드를 실행하려면 컴퓨터는 먼저 고객 `c`의 국가를 찾아 변수 `d`에 저장합니다. 그런 다음 다음 줄로 이동합니다.

기호 실행에서는 컴퓨터가 실제로 코드를 실행하지 않습니다. 대신 코드를 추상적으로 또는 기호적으로 실행합니다. 코드 실행의 결과로 값을 만드는 대신, 모든 "부수 효과" 또는 컴퓨터에서 관찰할 수 있는 모든 상태 변경 목록을 만듭니다. 다음은 Jinq가 전달된 함수를 기호적으로 실행하는 방법입니다:

첫 번째 줄이 기호적으로 실행되면, Jinq는 두 가지 부수 효과를 발견합니다: 변수 `d`가 변경되었고 `Customer.getCountry()` 메서드가 호출되었습니다. 기호 실행에서 변수 `d`는 'USA'나 'Denmark'와 같은 실제 값이 주어지지 않습니다. 대신 `c.getCountry()`라는 기호적 값이 할당됩니다.

함수 전체를 기호적으로 실행하면 Jinq는 코드가 실행될 때 발생하는 모든 부수 효과를 수집할 수 있습니다. 그런 다음 Jinq는 관련 없는 부수 효과를 모두 제거합니다. 로컬 변수에 대한 변경은 함수 외부에서 관찰할 수 없으므로 이를 버릴 수 있습니다. 관찰 가능한 출력이 없는 메서드 호출은 버릴 수 있습니다. 그렇게 하면 Jinq는 함수를 실행하면 오직 하나의 효과만 생성된다고 결론지을 수 있습니다: `c.getCountry().equals("Belgium")`를 반환한다는 것입니다.

이것을 알게 되면, Jinq는 기본 데이터베이스 쿼리에 새로운 정보를 병합할 수 있습니다. `customers` 컬렉션이 데이터베이스의 모든 고객 쿼리로 표현된다는 것을 알기 때문에, Jinq는 이 정보를 함수를 기호적으로 실행하여 배운 것과 결합하여 `where()` 메서드의 결과를 나타내는 새로운 데이터베이스 쿼리를 생성할 수 있습니다.

### 흥미로운 미래

Java 8이 Java에서 데이터베이스를 다루는 새로운 방법을 가능하게 하는 것을 맛보게 해드렸기를 바랍니다. Java 8의 함수형 프로그래밍 지원은 Java 컬렉션을 다루는 코드를 작성하는 것과 유사한 방식으로 데이터베이스 코드를 작성할 수 있게 해줍니다. 기존 데이터베이스 API도 곧 이러한 스타일의 쿼리를 지원하도록 확장될 것입니다.

이러한 새로운 유형의 쿼리를 위한 프로토타입을 실험해 보려면 http://www.jinq.org 를 방문하세요.
