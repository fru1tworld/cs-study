# jOOQ 화요일: Rafael Winterhalter가 Byte Buddy로 바이트 코드와 씨름하다

> 원문: https://blog.jooq.org/jooq-tuesdays-rafael-winterhalter-is-wrestling-byte-code-with-byte-buddy/

jOOQ 화요일 시리즈에 오신 것을 환영합니다. 이 시리즈에서는 격월로 세 번째 화요일에 jOOQ 관점에서 우리 업계에서 흥미롭다고 생각하는 사람들을 인터뷰하는 기사를 게시합니다. 여기에는 SQL, Java, 오픈 소스 및 다양한 관련 주제를 다루는 사람들이 포함됩니다.

이번 일곱 번째 에디션에서는 Rafael Winterhalter와 이야기를 나누게 되었습니다. 그는 Java 바이트 코드의 깊은 세계와 바이트 코드 작업을 매우 쉽게 만들어주는 그의 라이브러리 Byte Buddy에 대해 이야기해 줄 것입니다.

Byte Buddy가 2015년 Duke's Choice Award를 수상했다는 점을 알려드립니다 - 우리 측에서 축하의 말씀을 드립니다!

## 질문 1: Byte Buddy는 무엇을 하나요?

안녕하세요 Rafael - 당신은 인기 있는 Byte Buddy 라이브러리의 저자입니다. Byte Buddy는 무엇을 하나요?

Byte Buddy는 코드 생성 및 조작 라이브러리입니다. 런타임에 새로운 Java 클래스를 생성하고 기존 클래스를 로드 전후에 변경하기 위한 API를 제공합니다.

얼핏 보면 이것이 매우 난해한 작업처럼 들릴 수 있지만, 런타임 코드 생성은 수많은 Java 프로젝트에서 사용됩니다. 코드 생성 도구는 라이브러리 개발자들이 관점 지향 프로그래밍(AOP)을 구현하는 데 자주 사용됩니다. 예를 들어, 모킹 라이브러리 Mockito는 런타임에 모킹된 클래스의 서브클래스를 생성하기 위해 Byte Buddy를 채택했습니다. 모킹을 구현하기 위해 Mockito는 클래스의 모든 메서드를 오버라이드하여 테스트에서 메서드가 호출될 때 사용자의 원래 코드가 실행되지 않도록 합니다. 그리고 코드 생성을 사용하는 잘 알려진 사용자들이 많이 있습니다. 예를 들어 Spring은 보안이나 트랜잭션과 같은 어노테이션 관점을 구현하기 위해 코드 생성을 사용합니다. 그리고 Hibernate는 getter 메서드에서 프로퍼티를 지연 로딩하기 위해 코드 생성을 사용합니다. 이 getter들을 오버라이드하여 실제로 호출될 때만 데이터베이스를 쿼리하도록 합니다.

## 질문 2: ASM, CGLIB, AspectJ 또는 Javassist와 같은 대안이 있는데 왜 Byte Buddy가 필요한가요?

ASM, CGLIB, AspectJ 또는 Javassist와 같은 대안이 있는데 왜 Byte Buddy가 필요한가요?

Byte Buddy 작업을 시작하기 전에, 저는 여러 다른 오픈 소스 프로젝트에 기여자로 참여했습니다. 앞서 언급했듯이 코드 생성은 많은 라이브러리를 구현하는 데 전형적인 요구 사항이므로 주로 CGLIB와 Javassist를 사용하는 데 익숙해졌습니다. 그러나 저는 이러한 라이브러리들의 한계에 계속해서 좌절감을 느꼈고 제가 발견한 문제들을 해결하고 싶었습니다. 결국 저는 나중에 Byte Buddy로 공개한 대안 라이브러리를 작성하기 시작했습니다.

대안 라이브러리들의 한계를 이해하기 위해 모킹이 좋은 예시 사용 사례입니다. Mockito의 모킹은 이전에 CGLIB를 사용하여 생성되었습니다. CGLIB는 상당히 성숙한 라이브러리입니다. 15년 이상 존재해왔고 원래 개발되었을 때, 라이브러리 개발자들은 당연히 어노테이션, 제네릭 타입 또는 디펜더 메서드와 같은 기능을 예상하지 못했습니다. 그러나 어노테이션은 많은 API의 중요한 부분이 되었고, 오버라이드된 메서드의 어노테이션이 손실되기 때문에 모킹 인스턴스를 받아들이지 않았습니다. Java에서 메서드의 어노테이션은 오버라이드될 때 절대 상속되지 않습니다. 그리고 타입의 어노테이션은 명시적으로 상속되도록 선언된 경우에만 상속됩니다. 이를 극복하기 위해 Byte Buddy는 서브클래스에 어노테이션을 복사할 수 있게 해주며, 이것은 이제 Mockito 2의 기능입니다.

반면에 Javassist는 어노테이션을 복사할 수 있지만, 저는 개인적으로 이 라이브러리의 접근 방식을 좋아하지 않습니다. Javassist에서 모든 생성된 코드는 문자열에 포함된 Java 코드로 표현됩니다. 결과적으로 Javassist 코드는 SQL을 연결된 문자열로만 설명하는 Java 코드와 유사하게 비구조적으로 발전합니다. 유지 관리하기 어려운 코드를 만드는 것 외에도, 이 접근 방식은 SQL 인젝션과 유사한 Java 코드 인젝션과 같은 취약점을 제공합니다. 때때로 임의의 코드를 컴파일하게 하여 Javassist 코드를 공격할 수 있으며, 이는 애플리케이션에 심각한 손상을 일으킬 수 있습니다.

AspectJ는 기존 코드를 조작할 때 강력한 도구입니다. 그러나 Byte Buddy는 AspectJ가 할 수 있는 모든 것을 평범하고 간단한 Java로 할 수 있게 해줍니다. 이렇게 하면 개발자들은 새로운 문법이나 프로그래밍 패러다임을 배우거나 빌드 프로세스와 IDE에 도구를 설치할 필요가 없습니다. 또한 저는 조인 포인트와 포인트 컷 용어가 직관적이지 않다고 생각하여 완전히 피하기로 결정했습니다. 대신 Byte Buddy의 첫 단계를 쉽게 하기 위해 개발자들이 Java 프로그래밍 언어에서 이미 알고 있는 용어를 모방하기로 결정했습니다.

반면 ASM은 Byte Buddy가 구현된 기반입니다. ASM은 코드 생성 라이브러리라기보다는 바이트 코드 파서입니다. ASM은 단일 클래스 파일을 처리하고 타입 계층 구조를 고려하지 않습니다. ASM은 클래스 로딩 개념이 없으며 바이트 코드 명령어 위에 더 높은 수준의 개념을 포함하지 않습니다. 그러나 Byte Buddy는 매우 특정한 코드 생성이 필요한 사용자에게 ASM API를 노출하는 어댑터를 제공합니다.

## 질문 3: 어떻게 저수준 Java에 그렇게 깊이 관여하게 되었나요?

어떻게 저수준 Java에 그렇게 깊이 관여하게 되었나요?

처음에 저는 제가 원래 필요했던 어노테이션 지원이 있는 CGLIB 버전만 만들겠다는 목표를 세웠습니다. 하지만 많은 개발자들이 오늘날 Byte Buddy가 된 솔루션을 찾고 있다는 것을 빠르게 알게 되었습니다. 따라서 저는 Java 가상 머신의 전체 기능 세트에 접근할 수 있게 만들 계획을 세우기 시작했습니다. 이를 위해 이러한 기능을 구현하기 위해 클래스 파일 형식의 모든 복잡한 세부 사항과 예외 케이스를 배우는 것이 필수가 되었습니다. 공정하게 말하자면, 클래스 파일 형식은 일단 익숙해지면 상당히 간단하며 제 라이브러리가 성숙해지는 것을 보는 것을 정말 즐깁니다.

## 질문 4: Java 바이트 코드와 SQL 사이에서 어디가 가장 편안하신가요?

Java 바이트 코드(2GL 언어)와 SQL(4GL 언어) 사이에는 많은 수준의 프로그래밍 추상화가 있습니다. 어디가 가장 편안하신가요?

저는 적절한 작업에 적절한 도구를 사용하고 싶습니다. 분명히 저는 바이트 코드 작업을 즐기지만, 프로덕션 프로젝트에서 작업할 때 바이트 코드를 수작업으로 만드는 것은 피할 것입니다. 결국 Byte Buddy와 같은 더 높은 수준의 추상화가 바로 이를 위해 만들어진 것입니다.

일반적인 사용 사례를 보면, Byte Buddy는 메서드의 어노테이션을 기반으로 코드를 변경하여 사용자 정의 기능을 구현하는 데 자주 사용됩니다. 어떤 면에서 Byte Buddy는 개발자들이 자신만의 4G 추상화를 구현할 수 있게 해줍니다. 선언적 프로그래밍은 특정 작업에 대한 훌륭한 추상화이며, SQL이 그 중 하나입니다.

## 질문 5: 인플루언서로서 가장 흥미로운 이야기는 무엇인가요?

당신은 매우 짧은 시간에 유명한 연사이자 도메인 전문가가 되었습니다. 인플루언서로서 가장 흥미로운 이야기는 무엇인가요?

주로 제 라이브러리의 사용자들을 만나는 것이 흥미롭습니다. 저는 제 소프트웨어를 기반으로 큰 팀과 함께 내부 프레임워크를 구현한 분들을 만났고, 당연히 Byte Buddy가 그렇게 유용하다는 것이 증명되어 자랑스럽습니다.
