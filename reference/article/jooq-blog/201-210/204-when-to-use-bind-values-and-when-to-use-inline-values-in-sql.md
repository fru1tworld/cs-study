> 원문: https://blog.jooq.org/when-to-use-bind-values-and-when-to-use-inline-values-in-sql/

# SQL에서 바인드 값을 사용해야 할 때와 인라인 값을 사용해야 할 때

이 글에서는 SQL 문에서 바인드 값(Bind Values, 매개변수화된 쿼리)과 인라인 값(Inline Values, 리터럴 값)을 사용하는 중요한 결정에 대해 논의합니다. 특히 Java, jOOQ, Oracle 데이터베이스 맥락에서 살펴봅니다.

## 바인드 값을 사용해야 하는 이유

### 보안

바인드 값은 SQL 인젝션(SQL Injection) 취약점을 방지합니다. 문자열 연결 방식은 피해야 하며, "사용자 입력에는 항상 바인드 값을 사용하라"는 것이 필수적인 실천 원칙입니다.

### 성능과 캐싱

더 미묘한 이점은 데이터베이스 실행 계획 캐싱(Execution Plan Caching)과 관련이 있습니다. 데이터베이스가 값만 다르고 동일한 SQL 구조를 받으면, 캐시된 실행 계획을 재사용할 수 있어 부하가 높은 상황에서 성능이 극적으로 향상됩니다. "이 계획 캐시를 최대한 활용하는 것이 매우 중요합니다."

Oracle 예제를 통해 이를 설명하면, 인라인 값은 데이터베이스에서 서로 다른 SQL ID를 생성하여 매번 비용이 많이 드는 계획 재계산을 강제합니다.

```sql
-- 인라인 값 사용 (권장하지 않음)
SELECT * FROM users WHERE id = 1;
SELECT * FROM users WHERE id = 2;
-- 위 두 쿼리는 서로 다른 SQL ID를 가지며 각각 계획을 계산

-- 바인드 값 사용 (권장)
SELECT * FROM users WHERE id = ?;
-- 동일한 SQL ID로 계획 캐시 재사용
```

## 인라인 값을 고려해야 할 때

바인드 값이 기본 원칙이지만, 인라인 리터럴이 더 나은 드문 예외 상황이 있습니다:

### 편향된 데이터 분포 (Skewed Data Distribution)

데이터가 매우 불균형한 컬럼을 조회할 때(예: 1개 행 대 99,999개 행), 옵티마이저가 캐시된 추정치로 인해 잘못된 계획을 선택할 수 있습니다. 인라인 값은 새로운 분석을 강제합니다.

### 판별자 쿼리 (Discriminator Queries)

CHECK 제약 조건의 열거형/범주형 값으로 필터링할 때 인라인 값이 유용할 수 있습니다.

### 일회성 보고서

계획 캐시 이점이 실현되지 않는 드물게 실행되는 쿼리의 경우입니다.

## 최신 완화 기법

### Oracle 11g+: 적응형 커서 공유 (Adaptive Cursor Sharing)

Oracle 11g 이상에서 도입된 적응형 커서 공유는 최적이 아닌 선택을 감지한 후 서로 다른 바인드 변수 값에 대해 별도의 계획 변형을 생성합니다.

### Oracle 12c: 적응형 실행 계획 (Adaptive Execution Plans)

Oracle 12c는 실행 중간에 전략을 조정하는 적응형 실행 계획을 도입하여 이를 더욱 발전시켰습니다.

## 실용적인 권장 사항

개발자는 약 99%의 경우에 바인드 값을 기본으로 사용해야 합니다. jOOQ, PL/SQL, T-SQL과 같은 고수준 API를 사용하면 바인딩을 자동으로 처리하여 수동 선택이 아닌 거의 자동화된 선택이 됩니다.

| 상황 | 권장 방식 |
|------|----------|
| 사용자 입력 처리 | 바인드 값 (필수) |
| 일반적인 OLTP 쿼리 | 바인드 값 |
| 편향된 데이터 분포 | 인라인 값 고려 |
| 열거형/판별자 컬럼 | 인라인 값 고려 |
| 일회성 보고서/분석 쿼리 | 인라인 값 고려 |

## 결론

바인드 값은 보안과 성능 모두를 위해 기본 선택이어야 합니다. SQL 인젝션 방지와 실행 계획 캐시 활용이라는 두 가지 중요한 이점을 제공합니다. 인라인 값은 데이터 분포가 극도로 편향되었거나, 일회성 쿼리이거나, 옵티마이저가 더 나은 결정을 내리기 위해 실제 값을 알아야 하는 특수한 상황에서만 고려해야 합니다.
