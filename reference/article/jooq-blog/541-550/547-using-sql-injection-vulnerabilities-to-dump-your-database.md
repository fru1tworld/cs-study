# SQL 인젝션 취약점을 이용하여 데이터베이스 덤프하기

> 원문: https://blog.jooq.org/using-sql-injection-vulnerabilities-to-dump-your-database/

## SQL 인젝션이란 무엇인가?

SQL 인젝션은 코드 인젝션 기법으로, 데이터 기반 애플리케이션을 공격하는 데 사용되며, 악의적인 SQL 문이 입력 필드에 삽입되어 실행됩니다. 위키피디아의 정의에 따르면: "SQL 인젝션은 코드 인젝션 기법으로, 데이터 기반 애플리케이션을 공격하는 데 사용되며, 악의적인 SQL 문이 입력 필드에 삽입되어 실행됩니다."

다음은 취약한 코드의 Java 예제로, 사용자 입력을 검증 없이 직접 SQL 쿼리에 연결하는 방식입니다:

```java
// 취약한 코드 - 절대 이렇게 하지 마세요!
String sql = "SELECT * FROM film WHERE title = '" + userInput + "'";
```

공격자는 title 파라미터로 `' OR '1'='1`을 입력할 수 있으며, 그 결과 항상 모든 레코드를 반환하는 쿼리가 생성됩니다.

## 취약점 발견 자동화

이 글에서는 SQL 인젝션 탐지를 자동화하는 오픈소스 GPLv2 라이선스 도구인 sqlmap을 시연합니다. MySQL Sakila 데이터베이스를 노출하는 취약한 RESTful Java/Jetty 애플리케이션을 사용하여, sqlmap은 59번의 HTTP 요청을 통해 성공적으로 취약점을 식별했습니다.

이 도구는 다음과 같은 체계적인 테스트를 수행합니다:
- 결정론적 쿼리 탐지
- 데이터베이스 서버 식별
- 취약점 분류
- UNION 절 기능 평가

## 데이터 추출 기법

### 오류 기반 추출 (Error-Based Extraction)

sqlmap은 MySQL 오류 메시지를 활용하여 정보를 추출합니다. 스택 트레이스가 노출되면, 데이터베이스 이름을 식별 가능한 구분자와 함께 중복 키 오류에 래핑할 수 있습니다.

공격자는 다음과 같은 악의적인 쿼리를 통해 민감한 데이터를 의도적인 오류 메시지 내에 래핑하여, 스택 트레이스에서 정보를 유출할 수 있습니다.

### 블라인드 추출 (Blind Extraction)

오류 메시지가 없으면, sqlmap은 문자 값에 대해 이진 검색을 수행하여, 타이밍 기반 또는 응답 차별화 방법을 통해 응답이 일관되게 유지되는지 확인합니다.

오류 메시지가 억제되면, sqlmap은 문자별로 이진 검색을 수행하여 데이터를 재구성합니다.

### 시간 기반 공격 (Time-Based Attacks)

UI 출력이 제거되면, 데이터베이스 지연(SLEEP 함수)을 사용하는 쿼리를 통해 UI 피드백이 없을 때도 추출이 가능합니다. 이 접근 방식은 많은 쿼리가 필요합니다.

UI 출력이 완전히 제거되면, sqlmap은 쿼리 지연을 사용하여 참/거짓 조건을 추론합니다.

## 점진적 데이터베이스 덤프

이 글에서는 다음을 추출하는 방법을 시연합니다:
- 데이터베이스 이름 (테스트 환경에서 총 8개)
- 테이블 구조
- 완전한 테이블 내용 (film 데이터 시연)
- 조인된 테이블에서의 임의 쿼리 실행

배우(actor) 쿼리 예제는 스키마 지식을 얻은 후 공격자가 어떻게 정교한 분석을 수행할 수 있는지 보여줍니다.

## 고급 sqlmap 기능

데이터 추출 외에도 sqlmap은 다음을 수행할 수 있습니다:
- 사용자 자격 증명 브루트포스
- 커스텀 SQL 스크립트 실행
- 사용자 정의 함수 주입
- 파일 시스템 파일 읽기/쓰기
- 데이터베이스 서버에서 셸 접근 열기
- Windows 레지스트리 조작

## 대응책과 완화 방법

### 핵심 원칙

- 절대 사용자 입력을 신뢰하지 마세요, 내부 사용자라도 마찬가지입니다. 내부 애플리케이션도 내부자 위협에 직면합니다.
- SQL 문에서 사용자 입력 사용을 최소화하세요
- 입력을 받는 즉시 검증하세요
- 바인드 변수를 일관되게 사용하세요

### 기술적 통제

바인드 변수 구현 - 저자는 파라미터화된 쿼리 사용을 "가장 간단하고 가장 효과적인 조치"로 강조하며, 사용자 입력이 SQL 구문으로 해석되는 것을 방지합니다.

```java
// 안전한 코드 - 바인드 변수 사용
PreparedStatement stmt = connection.prepareStatement(
    "SELECT * FROM film WHERE title = ?");
stmt.setString(1, userInput);
```

정적 코드 분석 도구 사용 - FindBugs, Alvor 등

SQL 추상화 계층 사용 - jOOQ, LINQ-to-SQL, JPA CriteriaQuery와 같은 도구는 타입 안전하고 문자열 기반이 아닌 SQL 구성을 강제하여 많은 인젝션 벡터를 제거합니다.

```java
// jOOQ 예제 - 타입 안전한 SQL
dsl.selectFrom(FILM)
   .where(FILM.TITLE.eq(userInput))
   .fetch();
```

```java
// JPA CriteriaQuery 예제
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Film> query = cb.createQuery(Film.class);
Root<Film> film = query.from(Film.class);
query.where(cb.equal(film.get("title"), userInput));
```

신중하게 설계된 데이터베이스 GRANT 문 구현 - 필요한 최소한의 권한으로 역할 기반 접근 제어를 구현하고, 직접 테이블 접근 대신 가능한 곳에서 뷰를 사용하세요.

방화벽 솔루션 배포 - URL 암호화 및 폼 보호 포함

### 프로세스 통제

- 의심스러운 활동을 감지하기 위한 오류 알림 서비스
- 이상 징후에 대한 로그 모니터링
- 프로덕션에서 기술적 오류 표시 비활성화
- sqlmap 테스트를 통한 지속적 통합
- 속도 제한 및 슬로우다운 메커니즘

### 코드 예제

이 글에서는 SQLJ, LINQ, JPA Criteria Query, jOOQ를 사용한 안전한 구현을 보여줍니다. 모두 정적 타이핑과 자동 바인드 변수 사용을 제공하여 인젝션을 방지합니다.

## 결론

대안적인 데이터 저장 모델에도 불구하고, SQL은 여전히 지배적입니다. 개발 팀은 종종 SQL 인젝션의 심각성을 과소평가합니다. 저자는 기술 리드가 바인드 변수, 정적 SQL, 포괄적인 교육, 자동화된 테스트, 그리고 진입 서버 구현을 통해 취약점 위험을 최소화해야 한다고 강조합니다.

이 글은 수백만 줄의 코드에서 간과된 하나의 취약점이 완전한 데이터베이스 침해를 가능하게 할 수 있으므로, 체계적인 예방이 필수적이라고 강조합니다. SQL 인젝션은 자동화된 도구를 통해 여전히 매우 악용 가능하며, 예방 조치는 개별 개발자의 재량이 아닌 아키텍처적 책임이 되어야 합니다.
