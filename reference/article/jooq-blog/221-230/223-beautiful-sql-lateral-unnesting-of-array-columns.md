> 원문: https://blog.jooq.org/beautiful-sql-lateral-unnesting-of-array-columns/

# 아름다운 SQL: 배열 컬럼의 LATERAL UNNEST

이 글에서는 SQL이 배열 타입(중첩 컬렉션)을 어떻게 우아하게 처리하는지 살펴봅니다. 배열을 네이티브로 지원하는 주요 데이터베이스는 Oracle과 PostgreSQL 두 가지뿐이며, Java 생태계에서는 HSQLDB와 H2도 지원합니다.

## PostgreSQL 배열 정의

```sql
CREATE TABLE blogs (
  id    SERIAL NOT NULL PRIMARY KEY,
  title text   NOT NULL,
  tags  text[]
)
```

## Oracle 배열 정의

```sql
CREATE TYPE tag_t AS VARRAY(100) OF VARCHAR2(100 CHAR);

CREATE TABLE blogs (
  id    NUMBER(18) GENERATED BY DEFAULT AS IDENTITY
                   NOT NULL PRIMARY KEY,
  title VARCHAR2(100 CHAR) NOT NULL,
  tags  tag_t
)
```

## 데이터 삽입 예제

PostgreSQL:

```sql
INSERT INTO blogs (title, tags)
VALUES (
  'How to Fetch Oracle 12c Implicit Cursors with JDBC and jOOQ',
  ARRAY[
    'implicit cursor',
    'batch',
    'oracle',
    'jooq',
    'jdbc',
    'resultset'
  ]
)
```

Oracle:

```sql
INSERT INTO blogs (title, tags)
VALUES (
  'How to Fetch Oracle 12c Implicit Cursors with JDBC and jOOQ',
  tag_t(
    'implicit cursor',
    'batch',
    'oracle',
    'jooq',
    'jdbc',
    'resultset'
  ))
```

## 기본 UNNEST

배열을 펼쳐서(unnest) 각 요소를 별도의 행으로 만들 수 있습니다.

PostgreSQL UNNEST:

```sql
SELECT title, tag
FROM blogs, LATERAL unnest(tags) AS tags(tag);
```

Oracle UNNEST (클래식 스타일):

```sql
SELECT title, tags.*
FROM blogs, TABLE(tags) tags;
```

Oracle UNNEST (Oracle 12c 이상):

```sql
SELECT title, tags.*
FROM blogs, LATERAL (SELECT * FROM TABLE(tags)) tags;
```

## 핵심 개념: LATERAL 키워드

`LATERAL` 키워드는 오른쪽의 테이블/서브쿼리가 왼쪽의 컬럼에 접근할 수 있게 해줍니다. T-SQL의 `APPLY`와 유사하며, 크로스 조인(cross join) 연산을 수행하여 각 배열 요소를 원본 레코드와 결합한 새로운 행을 생성합니다.

## 순서 정보와 함께 UNNEST하기 (WITH ORDINALITY)

배열을 펼칠 때 각 요소의 순서(인덱스) 정보도 함께 가져올 수 있습니다.

PostgreSQL WITH ORDINALITY:

```sql
SELECT title, tag
FROM blogs, LATERAL unnest(tags) WITH ORDINALITY AS tags(tag);
```

Oracle 동등 표현 (윈도우 함수 사용):

```sql
SELECT title, tags.*
FROM blogs, LATERAL (
  SELECT tags.*, ROW_NUMBER() OVER (ORDER BY NULL)
  FROM TABLE(tags) tags
) tags;
```

Oracle 동등 표현 (ROWNUM 사용):

```sql
SELECT title, tags.*
FROM blogs, LATERAL (
  SELECT tags.*, ROWNUM
  FROM TABLE(tags) tags
) tags;
```

## 배열 내 검색

배열 컬럼에서 특정 값을 검색하는 방법입니다.

PostgreSQL 배열 검색:

```sql
SELECT title
FROM blogs
WHERE 'jooq' = ANY(tags);
```

Oracle 배열 검색:

```sql
SELECT title
FROM blogs
WHERE 'jooq' IN (SELECT * FROM TABLE(tags));
```

## 결론

데이터를 중첩 컬렉션으로 비정규화(denormalize)한 후 UNNEST를 통해 다시 펼치는 방식은 Oracle과 PostgreSQL 모두에서 강력한 쿼리 기능을 제공합니다. 이를 통해 SQL 수준에서 우아한 데이터 변환이 가능합니다.
