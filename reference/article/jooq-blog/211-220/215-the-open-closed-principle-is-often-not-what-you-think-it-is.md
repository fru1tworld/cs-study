> 원문: https://blog.jooq.org/the-open-closed-principle-is-often-not-what-you-think-it-is/

# 개방-폐쇄 원칙(Open-Closed Principle)은 당신이 생각하는 것과 다를 수 있다

jOOQ는 내부적으로 모든 것을 `final`과 패키지 프라이빗(package private)으로 만드는 것을 좋아하는 라이브러리입니다. 우리는 다음과 같은 클래스를 수없이 가지고 있습니다:

```java
final class Concat extends AbstractFunction<String> {
    // ...
}
```

이 클래스는 SQL 문자열 연결(concatenation)의 의미를 구현합니다. 분명히, 당신은 이것을 건드릴 필요가 없습니다(또는 알 필요조차 없습니다). 왜냐하면 이것은 DSL 클래스의 해당 공개 API 뒤에 "보호"되어 있기 때문입니다:

```java
// 이것은 볼 수 있습니다:
public class DSL {

    // 이것은 볼 수 있지만 오버라이드할 수 없습니다:
    public static Field<String> concat(Field<?> ... fields) {

        // 하지만 이것은 직접 할 수 없습니다:
        return new Concat(nullSafe(fields));
    }
}
```

지난 수십 년간, 어떤 면에서 캡슐화(encapsulation) 개념에 반하는 여러 소프트웨어 설계 움직임들이 있었습니다. 그 원동력은 다음과 같았습니다:

- 테스트(특히 모킹(mocking))
- SOLID(특히 개방-폐쇄 원칙과 리스코프 치환 원칙)가 실제로 무엇을 의미하는지에 대한 오해

## 개방-폐쇄 원칙을 살펴보자

개방-폐쇄 원칙은 위키피디아에 따르면 다음과 같이 주장합니다: "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다"; 즉, 그러한 엔티티는 소스 코드를 수정하지 않고도 동작을 확장할 수 있어야 합니다.

이것은 일부 소프트웨어 엔티티에서 매우 바람직한 측면입니다. 예를 들어, 서비스 제공자 인터페이스(SPI, Service Provider Interface)에서는 설계상 항상 그렇습니다. SPI의 위키피디아 정의는: "서비스 제공자 인터페이스(SPI)는 제3자가 구현하거나 확장하도록 의도된 API입니다. 프레임워크 확장과 교체 가능한 컴포넌트를 가능하게 하는 데 사용될 수 있습니다."

완벽합니다. 예를 들어, jOOQ의 `Converter`는 SPI입니다. 람다를 사용한 전략 패턴(Strategy Pattern) 스타일로 `Converter` API를 사용하는 방법에 대한 최근 글이 있습니다 - 전략 패턴은 SPI와 정말 잘 맞습니다. 사실, 전략 패턴은 엄밀히 말해 객체 지향적 기능이 아닙니다; 함수형 프로그래밍에서는 멋진 이름을 붙이지 않고도 공짜로 얻을 수 있습니다. 그것은 그저 평범한 고차 함수(higher order function)일 뿐입니다.

SPI로 간주될 수 있는 또 다른 좋은 예는 `Iterable`입니다. `List`와 같은 `Iterable` 하위 타입들은 SPI(사용자가 구현자)보다는 API(사용자가 소비자)로 더 자주 사용되지만, `Iterable` API 자체는 foreach 루프 내에서 코드를 실행하는 데 필요한 기능을 제공하는 방법에 더 가깝습니다. 예를 들어, jOOQ의 `ResultQuery`는 `Iterable`을 구현하여 foreach 루프에서 사용할 수 있습니다:

```java
for (MyTableRecord rec : DSL
    .using(configuration)
    .selectFrom(MY_TABLE)
    .orderBy(MY_TABLE.COLUMN)) { // 자동 실행, 페칭

    doThingsWithRecord(rec);
}
```

따라서, 다음과 같이 말할 수 있습니다:

- `Iterable`은 개방-폐쇄 원칙을 따릅니다. 확장에 열려 있는(나만의 iterable 의미를 만들 수 있음) 엔티티를 모델링하면서도, 수정에는 닫혀 있습니다(Java 컴파일러와/또는 foreach 루프 의미를 절대 수정하지 않음)
- 리스코프 치환 원칙(Liskov Substitution Principle)도 당연히 따릅니다. foreach 루프는 내가 `Iterable`을 어떻게 구현하든 상관하지 않습니다. 단지 그것처럼 동작하기만 하면 됩니다(`Iterator` 제공)

이것은 쉬웠습니다.

## 그렇다면 언제 적용되지 않을까?

많은 상황에서 그렇습니다. 예를 들어, jOOQ는 여러 면에서 객체 지향적 확장을 위해 설계되지 않았습니다. 당신은 단순히 다음을 해서는 안 됩니다:

`concat()` 함수를 모킹하는 것.

당신은 이것을 하고 싶을 수 있습니다. 서드파티 라이브러리를 포함한 모든 것을 단위 테스트해야 한다고 생각할 수 있고, 그러면 데이터베이스 내의 문자열 연결 기능을 목(mock)으로 대체해야 한다고 생각할 수 있습니다. 하지만 그것은 작동하지 않습니다. `DSL.concat()` 메서드는 정적(static)이고, 구현은 숨겨져 있습니다. 일반적인 방법으로는 교체할 방법이 없습니다(몇 가지 더러운 트릭은 있습니다).

하지만 잠깐 기다려 보세요. 왜 이런 것을 하려고 합니까? 통합 테스트(integration test)가 여기서 더 나은 방법이 아닐까요? 정말로 전체 복잡한 구현을 목으로 대체하는 데 시간을 쓸 여유가 있고(그리고 그렇게 하고 싶습니까)? 저는 그렇게 생각하지 않습니다. 그것은 거의 작동하지 않습니다.

특정 사용 사례를 위해 연결 동작을 수정하는 것.

가끔은 빠른 승리를 위해 구현을 약간만 조정하고 싶다고 생각할 수 있지만, 그것은 확실히 개방-폐쇄 원칙이나 리스코프 치환 원칙의 저자들의 의도가 아닙니다. API 설계자인 우리는 당신이 우리의 모든 기능을 확장하기를 원하지 않습니다. 그것만큼 간단합니다. 왜일까요? 왜냐하면 우리는 당신이 빠른 승리를 위해 무언가를 조정하는 대신, 우리에게 연락하여 모든 사람을 위해 소프트웨어를 개선하는 것을 도와주기를 원하기 때문입니다.

이것을 깊이 생각해 보세요 - 특히 후자를요. 모든 것이 객체 지향적이어야 하고 모든 것이 확장 가능해야 한다는 전제는 틀렸습니다. 객체 지향(그리고 그것과 연결된 모든 철학)은 도구입니다. 그것은 매우 강력한 도구입니다. 예를 들어, API/SPI 설계자인 우리가 사용자가 소프트웨어를 확장할 수 있도록 허용하고 싶을 때(주로 SPI를 통해) 그렇습니다. 그리고 우리는 우리가 제어할 수 있고 하위 호환성을 유지할 수 있는 방식으로 99%의 확장성 문제를 해결하는, 정말 좋고, 범용적이고, 유용하고, 강력한 SPI를 생각하는 데 많은 시간을 씁니다.

## 대안적 정의

역사적 맥락을 고려하면, 두 원칙 모두 매우 흥미로운 것들입니다. 하지만 그것들의 객체 지향적 맥락은 우리 마음에서 자유로워져야 할 것입니다. 여기에 더 나은 정의가 있습니다:

개방-폐쇄 원칙:

"시스템은 확장에 대한 개방성을 추구해야 하지만, 어떤 대가를 치르더라도 그래야 하는 것은 아닙니다. 시스템/모듈/아마도 클래스의 일부 부분은 확장에 열려 있어야 합니다. 그 부분들은 매우 잘 설계되어야 하고 매우 하위 호환성이 유지되어야 합니다. 그리고 그 부분들의 벤더는 필요한 확장 지점을 더 잘 식별하기 위해 소비자의 말을 들어야 합니다. 반면에 소비자는 모든 것이 확장 가능하다고 맹목적으로 가정해서는 안 됩니다. 만약 그들이 (예상치 못한 하위 타입 다형성을 통해) 임의의 부분을 확장한다면, 그들은 실제로 시스템/부분을 수정하는 것과 같은 방식으로 해킹하는 것입니다. 확장하는 것에 더 이상의 이점이 없습니다."

리스코프 치환 원칙:

하위 타입 다형성(subtype polymorphism)은 단지 도구일 뿐이며, 2017년에 우리는 그것이 많은 것들에 대해 매우 잘못된 도구라는 것을 오래전부터 이해하기 시작했습니다. 상속보다 합성(composition over inheritance) 개념은 우리가 90년대의 하위 타입 다형성 열풍을 후회했다는 것을 보여주었습니다. 그러니 하위 타입 오버라이딩을 통한 목을 잊으세요. 이 원칙의 대안적 해석을 찾기 시작하세요. Jessica Kerr의 해석이 인용됩니다: "따라서, 리스코프 치환 원칙은 '사람들을 놀라게 하지 마라'고 말합니다."

그것은 객체 지향의 한 측면, 특히 하위 타입 다형성과 엄격하게 관련된 것보다 훨씬 더 나은 신조입니다.

## 결론

네. 패키지 프라이빗, final 클래스는 확장할 수 없다는 것을 의미합니다. 개방-폐쇄 원칙은 "위반"됩니다. 왜냐하면 시스템의 그 부분은 당신이 알도록 설계되지 않았기 때문입니다(캡슐화되어 있습니다). 때때로, 당신은 그러한 엔티티를 오버라이드할 수만 있다면, 빠른 승리를 얻고 원하는 동작을 서드파티 라이브러리/엔티티/클래스/모듈/시스템에 주입할 수 있다고 생각할 수 있습니다. 제 주장은: 대부분, 나중에 빠른 승리에 대한 욕구를 깊이 후회하게 될 것입니다. 개방-폐쇄나 리스코프 치환에 대해 논쟁해서는 안 됩니다. 이 원칙들은 여기에 단순히 적용되지 않습니다. 특히, 잘못 설계된 레거시 소프트웨어에는 전혀 적용되지 않습니다. 일단 소프트웨어가 "잘못 설계"되면, 어떤 원칙도 도움이 되지 않습니다. 대신, 문제가 생기면 벤더에게 연락하세요. 그러한 제한 사항에는 항상 훌륭한 새 기능에 대한 흥미로운 아이디어가 숨겨져 있습니다. 그리고 당분간은, 오버라이드하도록 의도되지 않은 것을 오버라이드하는 것은 실제로 그 엔티티를 수정하는 것과 같은 것임을 받아들이세요. 당신은 라이브러리를 패치하고 있는 것입니다. 그렇게 하고 계속 나아갑시다.
