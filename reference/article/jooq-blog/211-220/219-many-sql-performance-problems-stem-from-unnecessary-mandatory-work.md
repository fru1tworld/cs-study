> 원문: https://blog.jooq.org/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/

# 많은 SQL 성능 문제는 "불필요하지만 필수적인 작업"에서 비롯된다

## 핵심 개념

이 글에서는 중요한 성능 원칙을 소개합니다: 데이터베이스가 불필요하다는 것을 알지 못한 채 수행하는 "불필요하지만 필수적인 작업(Unnecessary, Mandatory Work)"을 피해야 한다는 것입니다.

핵심 정의: "불필요(Unnecessary)"란 클라이언트는 필요하지 않다는 것을 알고 있는 작업을 의미하고, "필수(Mandatory)"란 서버가 클라이언트 측의 이러한 지식을 감지할 수 없기 때문에 데이터베이스가 반드시 수행해야 하는 작업을 의미합니다.

## 주요 예시

### SELECT *의 비효율성

필요한 컬럼이 두 개뿐인데 모든 컬럼을 가져오는 경우:
- 제공된 Oracle 예제에서 8배의 메모리를 낭비
- 디스크 I/O, 네트워크 전송, 클라이언트 메모리 소비 증가
- 데이터베이스가 최적화할 수 없는 작업을 수행하도록 강제

### 커버링 인덱스(Covering Index) 제거

인덱스 내의 특정 컬럼만 쿼리할 때:

```sql
-- 인덱스에서 특정 컬럼만 선택하면
-- 테이블 접근 없이 인덱스만으로
-- 전체 쿼리 실행이 가능해집니다
```

벤치마크 결과: 100,000회 반복 시 2.479초(모든 컬럼) vs. 1.857초(인덱스된 컬럼만)—의미 있는 성능 향상을 보여줍니다.

### JOIN 제거(JOIN Elimination)

조인된 테이블의 컬럼을 선택하지 않으면 데이터베이스가 조인을 제거할 수 있습니다:
- 여러 to-one 관계를 통해 고객 데이터를 조인하는 뷰
- 고객 이름만 선택하면 불필요한 address/city/country 조인이 제거됨
- 최적화가 조인이 불필요하다는 것을 증명하면 실행 계획 비용이 크게 감소

### 존재 여부 확인에 COUNT(*) 사용

존재 여부만 확인하면 되는데 집계 함수를 사용하는 경우:

```sql
-- 비효율적: 일치하는 모든 행을 계산하도록 강제
SELECT COUNT(*) FROM orders WHERE user_id = :user_id

-- 더 나은 방법: 첫 번째 일치 항목을 찾으면 중단
SELECT EXISTS (SELECT * FROM orders WHERE user_id = :user_id)
```

## ORM에 대한 시사점

많은 ORM이 엔티티 수준 쿼리(전체 객체 가져오기)를 기본값으로 사용하여 `SELECT *` 패턴이 기본이 됩니다. 저자는 조회 후 수정이 따르지 않을 때는 맞춤형 쿼리를 사용할 것을 권장합니다.

## 시스템적 영향

개별 쿼리의 성능 저하는 시스템 전체에 걸쳐 누적되어 처리량과 확장성을 저하시킵니다. 해결책은: 정확한 쿼리를 통해 데이터베이스에 최대한의 정보를 제공하여 최적의 실행을 가능하게 하는 것입니다.

## 핵심 교훈

"명령을 실행하는 엔티티에 더 많은 정보를 제공할수록 해당 명령을 더 빠르게 실행할 수 있습니다." 개발자는 서버에 필수적인 부담을 주는 광범위한 선택에 의존하기보다 특정 사용 사례에 맞춘 쿼리를 작성해야 합니다.
