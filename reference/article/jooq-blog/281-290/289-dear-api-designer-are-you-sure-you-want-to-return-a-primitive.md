# API 설계자에게: 프리미티브를 반환하고 싶은 게 확실한가?

> 원문: https://blog.jooq.org/dear-api-designer-are-you-sure-you-want-to-return-a-primitive/

일부 API는 한 번 정해지면 바꿀 수 없다. 예를 들어 JDK의 API가 그렇다. 또는 데이터베이스와 데이터베이스 클라이언트(예: JDBC) 사이의 공개 API도 마찬가지다. 이러한 특성 때문에 이런 API를 설계하는 것은 상당히 어렵다. API를 공개하기 전에 많은 고민이 필요하기 때문이다. 이는 API를 설계할 때 방어적으로 접근하는 것이 좋은 선택임을 의미한다. 방어적 API 설계 전략 중 하나는 항상 파라미터 객체와 반환 객체를 사용하는 것이다. 파라미터 객체에 대해서는 이전에 블로그에서 다룬 적이 있다. 반환 객체를 사용하지 않는 API를 살펴보고, 왜 그것이 끔찍한지 알아보자.

## 데이터베이스 업데이트 문

데이터베이스에서 데이터를 가져올 때, 우리는 편리한 API 타입인 JDBC `ResultSet`을 받는다. Java 외의 다른 언어들도 데이터베이스 결과를 모델링하기 위한 유사한 타입을 가지고 있다. `ResultSet`은 주로 튜플의 집합을 모델링하지만, `ResultSet.getMetaData()`나 `ResultSet.getWarnings()`와 같은 다양한 추가적인 유용한 기능들도 포함하고 있다. 이것들은 `ResultSet`과 함께 임의의 추가 정보를 전달하기 위한 영리한 백도어이다. 이러한 결과 타입의 가장 좋은 점은 역호환성을 유지하면서 확장할 수 있다는 것이다. 다음을 수정하지 않고도 이러한 결과 타입에 새로운 메서드와 기능을 추가할 수 있다:

- 기존의 모든 계약(contract)
- 기존의 모든 클라이언트 코드

깨질 수 있는 유일한 것은 JDBC 드라이버였지만, Java 8, JDBC 4.2, 그리고 default 메서드 이후로 이것도 과거의 일이 되었다. 데이터베이스에서 업데이트 문을 호출할 때는 상황이 상당히 다르다:

```java
int count = stmt.executeUpdate();
```

으... `count` 값이라니. 이게 다인가? 트리거가 생성한 정보는 어떻게 되는 거지? 경고(warning)는? (물론 경고는 statement에서 사용할 수 있다. 하지만 호출에 의해 수정되는 statement 말이다.) 흥미롭게도, 이 `count` 값이 `int`라는 점이 오랫동안 사람들을 괴롭혔던 것 같다. 그래서 JDBC 4.2에서 이 메서드가 사실상 오버로드되었다:

```java
long count = stmt.executeLargeUpdate();
```

흠... "사실상 오버로드되었다"고 말하는 이유는, 기술적으로는 정말 오버로드이지만, Java가 반환 타입에 의한 오버로딩을 지원하지 않기 때문에 이름도 변경되었기 때문이다. (JVM은 지원하지만, 언어는 지원하지 않는다.) `executeUpdate()` 메서드의 Javadoc을 읽어보면, 이 단일 프리미티브 값에 서로 다른 상태들이 인코딩되어 있음을 알 수 있다:

> "반환값: (1) SQL 데이터 조작 언어(DML) 문의 경우 행 개수, 또는 (2) 아무것도 반환하지 않는 SQL 문의 경우 0"

더욱이, `getUpdateCount()`라는 유사한 메서드가 있는데, 이 메서드는 단일 프리미티브에 훨씬 더 복잡한 상태를 인코딩한다:

> "현재 결과를 업데이트 개수로 반환; 현재 결과가 ResultSet 객체이거나 더 이상 결과가 없는 경우 -1"

으... 그리고 이것만으로도 충분히 나쁘지 않다는 듯이, 위의 제한에 대한 매우 특이한 해결책이 MySQL 데이터베이스에 구현되어 있다. `UPSERT` 문에 대해 다음과 같이 서로 다른 상태를 인코딩한다:

> "ON DUPLICATE KEY UPDATE의 경우, 행당 영향받은 행 수 값은 새 행으로 삽입되면 1이고, 기존 행이 업데이트되면 2이다."

## 성능이 중요하지 않다면, 항상 참조 타입을 반환하라!

이것은 정말 나쁘다. 이 호출은 네트워크를 통해 데이터베이스에 대해 실행된다. 본질적으로 느리다. `executeUpdate()`의 결과로 `UpdateResult` 데이터 타입이 있었다면 우리는 아무것도 잃지 않았을 것이다. 다른 예로 `String.indexOf(...)`가 있는데, 이것은 성능상의 이유로 "찾지 못함"을 `-1`로 인코딩한다. 이 실수는 객체 지향 프로그래밍 이전의 오래된 API에서만 발생하는 것이 아니다. 유용한 메서드 결과로 처음 떠오르는 것이 프리미티브 값(또는 더 나쁜 경우: void)일 때, 많은 애플리케이션의 새로운 API에서도 반복된다. 플루언트 API(Java 8 Stream API나 jOOQ와 같은)를 작성하고 있다면, 사용자가 메서드 호출을 체이닝할 수 있도록 API가 항상 자기 자신의 타입을 반환하기 때문에 이것은 문제가 되지 않을 것이다. 다른 상황에서는, _부수 효과가 있는_ 연산을 구현하지 않기 때문에 반환 타입이 매우 명확하다. 그러나 부수 효과가 있는 연산을 구현한다면, 정말로 프리미티브만 반환하고 싶은 것인지 다시 한번 생각해 보라. 만약 API를 오랜 시간 동안 유지보수해야 한다면, 몇 년 후에 후회하게 될 수도 있다.
