# Java 개발자가 SQL 작성 시 범하는 또 다른 10가지 흔한 실수

> 원문: https://blog.jooq.org/yet-another-10-common-mistakes-java-developer-make-when-writing-sql-you-wont-believe-the-last-one/

이 글은 Java 개발자들이 SQL을 작성할 때 자주 범하는 10가지 치명적인 실수를 다룹니다. SQL을 제대로 이해하고 활용하면 더 깔끔하고 효율적인 코드를 작성할 수 있습니다.

## 10가지 실수

### 1. 윈도우 함수를 사용하지 않는 것

윈도우 함수는 "아마도 가장 멋진 SQL 기능"이라고 할 수 있습니다. 복잡한 애플리케이션 로직 없이도 정교한 데이터 분석이 가능하기 때문입니다. 특히 PostgreSQL과 같이 윈도우 함수를 잘 지원하는 데이터베이스를 사용하면, 수천 줄의 Java 코드를 간결한 SQL로 대체할 수 있으며, 대부분의 경우 더 나은 결과를 얻을 수 있습니다.

### 2. NOT NULL 제약 조건을 선언하지 않는 것

NULL을 허용하는 인덱스된 컬럼은 성능 문제를 야기합니다. 특히 Oracle에서 `NOT IN` 쿼리를 사용할 때 문제가 됩니다. 서브쿼리 결과에 `NULL` 값이 존재하면, 옵티마이저가 인덱스를 사용하는 대신 전체 테이블 스캔을 수행할 수 있습니다. Oracle에서 문제가 되는 NULL 허용 인덱스 컬럼을 식별하는 쿼리를 작성하여 확인하는 것이 좋습니다.

### 3. PL/SQL 패키지 상태를 사용하는 것

PL/SQL의 패키지 수준 상태는 커넥션 풀 재활용 시에도 세션 간에 지속되는 변수를 생성합니다. 이는 심각한 보안 위험을 초래합니다. 예를 들어, 신용카드 번호가 패키지 상태에 저장되어 다른 사용자 세션에서도 유지될 수 있습니다. 패키지 변수에 의존하는 대신 상태를 함수 인자로 전달하는 것을 권장합니다.

### 4. 동일한 쿼리를 반복적으로 실행하는 것

마스터 데이터를 조회하는 쿼리를 반복적으로 실행하면 불필요한 네트워크 리소스를 낭비하게 됩니다. 현대 데이터베이스는 결과를 효율적으로 캐싱하므로, 변경되지 않는 데이터에 대해 애플리케이션 수준에서 다시 쿼리할 필요가 없습니다. Guava와 같은 도구를 사용하여 캐싱 전략을 구현하는 것이 좋습니다.

### 5. N+1 문제를 모르는 것

N+1 문제는 연관된 엔티티를 조회할 때 처음에 하나의 쿼리를 실행하고, 그 후 연관관계마다 N개의 추가 쿼리가 발생하는 현상입니다. JPA에서는 `@NamedEntityGraph`와 같은 해결책을 제공하지만, 복잡한 어노테이션 설정보다는 직접 SQL을 사용하는 것이 더 단순하고 유지보수하기 쉬운 경우가 많습니다.

### 6. 공통 테이블 표현식(CTE)을 사용하지 않는 것

공통 테이블 표현식(CTE)은 SQL 변수처럼 작동하여 가독성을 높이고 쿼리 최적화를 개선하는 경우가 많습니다. 예를 들어, 환율 변환 쿼리를 CTE를 사용하여 재구성하면 실행 계획이 극적으로 단순해지고 중복 테이블 접근이 제거됩니다.

### 7. UPDATE 문에서 행 값 표현식을 사용하지 않는 것

행 값 표현식을 사용하면 단일 서브쿼리 결과에서 여러 컬럼을 한 번에 업데이트할 수 있어 테이블 접근 횟수를 줄일 수 있습니다. 각 컬럼에 대해 별도의 서브쿼리를 작성하는 대신, `(n, s) = ((SELECT n + 1, 'x' || s FROM t))`와 같이 튜플을 할당할 수 있습니다.

### 8. PostgreSQL을 사용할 수 있는데 MySQL을 사용하는 것

이 섹션은 2014년에 작성되었으며, MySQL이 "가장 인기 있는" 데이터베이스이지만 "가장 발전된" 데이터베이스는 아니라고 비판합니다. PostgreSQL의 우수한 기능 세트를 옹호하며, SQL 성능 문제는 SQL 자체보다는 데이터베이스의 한계에서 비롯되는 경우가 많다고 주장합니다. (참고: 저자는 MySQL 8.0이 이 글이 작성된 이후로 상당히 개선되었음을 인정합니다.)

### 9. UNDO/REDO 로그를 잊어버리는 것

대규모 벌크 업데이트는 트랜잭션 로그 오버헤드와 동시성 문제를 야기합니다. CAP 정리는 일관성과 가용성 사이의 트레이드오프를 요구합니다. NoSQL 솔루션보다는 대규모 작업 중 주기적인 커밋을 구현하는 것이 이러한 문제를 더 효과적으로 해결합니다.

### 10. BOOLEAN 타입을 올바르게 사용하지 않는 것

SQL:1999는 `BOOLEAN`을 일급 데이터 타입으로 도입하여 조건문을 컬럼 값으로 사용할 수 있게 했습니다. 이를 통해 `SELECT EXISTS(...) a, MY_COL IN (1,2,3) b FROM table`과 같은 구문이 가능해져, 개발자들이 거의 활용하지 않는 강력한 표현력을 제공합니다.

## 핵심 요약

이 글은 윈도우 함수나 CTE와 같은 현대적인 SQL 기능을 제대로 활용하면 수천 줄의 명령형 코드를 제거할 수 있다는 점을 강조합니다. ORM이나 캐싱 우회 방법에 의존하여 SQL과 싸우기보다는, SQL의 선언적 강력함을 인정하고 활용하는 것이 Java 개발자에게 권장됩니다.
