# SQL 표준 파생 열 목록(Derived Column List) 에뮬레이션

> 원문: https://blog.jooq.org/simulating-the-sql-standard/

SQL:2008 표준에는 정말 멋진 기능이 있는데, 아쉽게도 소수의 데이터베이스만 지원합니다. 바로 "파생 열 목록(derived column list)"입니다. 파생 열 목록은 파생 테이블의 이름과 열 이름을 동시에 변경할 수 있게 해줍니다. PostgreSQL에서 작동하는 예제를 보겠습니다:

```sql
SELECT t.a, t.b
FROM (
  SELECT 1, 2
) t(a, b)
```

여기서 `t(a, b)`는 파생 열 목록입니다. 파생 테이블의 이름을 `t`로 지정하면서 동시에 두 개의 열 이름을 각각 `a`와 `b`로 지정합니다.

## 왜 유용한가?

이 기능의 주요 장점은 파생 테이블의 차수(degree)만 알면 되고, 구체적인 (자동 생성될 수 있는) 열 이름은 알 필요가 없다는 것입니다. 이는 unnest된 테이블이나 배열/멀티셋 함수에서 반환된 데이터를 다룰 때 특히 유용합니다. 열 이름이 자동 생성되거나 예측하기 어려운 경우가 많기 때문입니다.

## 에뮬레이션 전략

하지만 모든 데이터베이스가 이 기능을 지원하지는 않습니다. 다행히 다양한 에뮬레이션 전략이 있습니다.

### 전략 1: 공통 테이블 표현식(CTE) 사용

Oracle처럼 파생 열 목록은 지원하지 않지만 CTE는 지원하는 데이터베이스에서는 WITH 절을 사용하여 다시 작성할 수 있습니다:

```sql
WITH t(a, b) AS (
  SELECT 1, 2 FROM DUAL
)
SELECT * FROM t
```

CTE에서는 열 목록을 지정할 수 있으므로, 이를 통해 원하는 열 이름을 부여할 수 있습니다.

### 전략 2: 인라인 열 별칭

MySQL이나 H2처럼 파생 열 목록도 CTE의 열 이름 지정도 지원하지 않는 데이터베이스에서는 열 이름 변경을 파생 테이블 내부로 밀어 넣을 수 있습니다:

```sql
SELECT t.a, t.b
FROM (
  SELECT 1 a, 2 b
) t
```

이 방법은 각 열에 직접 별칭을 지정하여 원하는 이름을 부여합니다.

### 전략 3: 범용 솔루션 (UNION ALL 사용)

모든 데이터베이스에서 작동하는 범용 솔루션이 있습니다. Stack Overflow의 Bill이 제안한 이 방법은 UNION ALL을 통해 빈 레코드를 앞에 추가하는 것입니다:

```sql
SELECT t.a, t.b
FROM (
  SELECT null a, null b FROM DUAL WHERE 1 = 0
  UNION ALL
  SELECT 1, 2 FROM DUAL
) t
```

이 접근 방식은 UNION 연산을 통해 결과 집합에 열 이름을 강제로 부여합니다. 첫 번째 SELECT 문은 `WHERE 1 = 0` 조건 때문에 실제로 행을 반환하지 않지만, 열 이름 `a`와 `b`는 전체 UNION 결과에 적용됩니다.

## 결론

파생 열 목록은 SQL 코드를 더 깔끔하고 유지보수하기 쉽게 만드는 유용한 SQL 표준 기능입니다. 사용하는 데이터베이스가 이를 직접 지원하지 않더라도, 위의 에뮬레이션 전략을 통해 동일한 결과를 얻을 수 있습니다. jOOQ는 이러한 에뮬레이션을 자동으로 처리하여 다양한 데이터베이스에서 일관된 SQL 작성 경험을 제공합니다.
