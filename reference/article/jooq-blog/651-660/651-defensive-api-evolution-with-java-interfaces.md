# Java 인터페이스를 활용한 방어적 API 진화

> 원문: https://blog.jooq.org/defensive-api-evolution-with-java-interfaces/

게시일: 2013년 2월 1일 | 저자: Lukas Eder

## 개요

이 글은 공개 API를 진화시킬 때의 도전 과제들, 특히 Java의 인터페이스 수정과 관련된 문제들을 다룹니다. 인터페이스에 메서드를 추가하면, 메이저 버전 릴리스가 아닌 이상 기존 구현체들이 모두 깨지게 됩니다. Java 8 이전에는 인터페이스에 새로운 메서드를 추가하면 해당 인터페이스를 구현하는 모든 코드가 영향을 받았습니다.

## 7가지 API 진화 전략

### 1. 신경 쓰지 않기

단순히 하위 호환성을 깨뜨리는 방법입니다. 만약 친절하다면, 최소한 새로운 메서드를 도입하기 전에 메이저 릴리스까지 기다릴 것입니다. 이 방식은 널리 사용되지 않는 API에는 적용할 수 있지만, 시맨틱 버저닝 원칙을 위반하고 사용자들을 멀어지게 할 위험이 있습니다.

### 2. Java 방식

인터페이스를 절대 진화시키지 않는 방법입니다. StringBuffer/StringBuilder, Hashtable/HashMap 같은 중복이 생기지만 절대적인 안정성을 유지합니다. 하지만 JDBC는 이 접근 방식이 보편적이지 않다는 것을 보여줍니다. 이 방식은 "공룡 같은" API를 만들어내며 상당한 중복을 초래합니다.

### 3. Eclipse 방식

원래 인터페이스와 함께 확장 인터페이스를 도입하는 방법입니다. 클래스가 `IAnnotationHover`, `IAnnotationHoverExtension`, `IAnnotationHoverExtension2`를 구현할 수 있습니다. 기능적으로는 작동하지만, 이 방식은 "유지보수, 테스트, 문서화가 꽤 어려워집니다." 여러 관련 타입을 탐색해야 하는 사용자들에게 혼란을 줍니다.

### 4. Java 8 기다리기

디펜더 메서드(기본 구현)를 활용하여 선택적 기능을 추가하는 방법입니다. `Iterator` 인터페이스가 이를 보여주는데, `forEach()`와 같은 새로운 메서드에 기본 구현을 제공합니다. 모든 구현자가 새 메서드를 추가하도록 강제하지 않고 기본 구현을 포함합니다.

```java
default void forEach(Consumer<? super E> consumer) {
    Objects.requireNonNull(consumer);
    // ... 구현부
}
```

### 5. 공개 기본 구현 제공하기

인터페이스와 함께 추상 클래스나 구체 클래스를 제공하는 방법입니다. `AbstractList`가 이를 잘 보여주는데, 구현자는 `get(int)`과 `size()`만 오버라이드하면 다른 동작들은 자동으로 파생됩니다. 명명 규칙으로는 AbstractXXX나 DefaultXXX를 사용합니다.

### 6. API를 구현하기 어렵게 만들기

수백 개의 메서드를 가진 API는 직접 구현하는 것을 막습니다. jOOQ의 `Field` 인터페이스가 도메인 특화 언어의 복잡성으로 인해 이런 목적을 달성합니다. 비록 이것은 일반적으로 "전반적인 설계가 나쁘다는 신호일 수 있다"고 인정하지만, DSL 복잡성 내에서는 의도치 않게 이런 효과를 냅니다.

### 7. 컴파일러/IDE 트릭 추가하기

deprecated 메서드를 자기 문서화 이름과 함께 친절한 알림으로 사용하는 방법입니다. Hamcrest의 `Matcher` 인터페이스가 개발자들을 적절한 확장 패턴으로 안내하기 위해 deprecated 메서드를 포함합니다:

```java
@Deprecated
void _dont_implement_Matcher___instead_extend_BaseMatcher_();
```

이렇게 하면 개발자들이 컴파일러 경고나 에러를 통해 의도를 마주하게 됩니다.

## 핵심 통찰

시맨틱 버저닝은 호환되지 않는 변경사항을 메이저 릴리스에서 발표하고, 마이너 릴리스에서는 호환성을 유지할 것을 요구합니다. 이것이 전략적인 API 설계를 필수적으로 만듭니다.

"미리 계획을 세운다면, 다음 메이저 릴리스를 발표하기 훨씬 전에 대부분의 호환되지 않는 변경사항을 예측할 수 있을 것입니다."

## 토론

한 댓글 작성자(agentgt)는 비프레임워크 코드에서는 인터페이스보다 추상 클래스를 옹호하며, 패키지 이름 변경과 브릿지 메서드 주입을 추가적인 기법으로 제안했습니다.
