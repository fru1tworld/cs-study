# 미묘한 SQL 차이: IDENTITY 컬럼

> 원문: https://blog.jooq.org/subtle-sql-differences-identity-columns/

2012년 2월 19일 lukaseder 작성

저는 주로 Oracle을 사용해왔기 때문에, jOOQ에서 IDENTITY 컬럼을 지원하기 시작하기 전까지는 그다지 중요하게 여기지 않았습니다. 그런데 지원을 시작하고 나서, 다양한 데이터베이스들이 DDL과 DML에서 IDENTITY 컬럼을 처리하는 방식에 또다시 많은 차이가 있다는 것을 알게 되었습니다.

SQL에서 레코드를 식별하는 방법에는 본질적으로 세 가지 직교적인 개념이 있습니다 (제가 놓치고 있는 벤더 고유의 개념이 있다면 알려주세요):

1. 기본 키(Primary Key): 가장 잘 알려진 개념입니다. 기본 키는 테이블의 "주요 유니크 키"로, 최소 하나의 컬럼에 부여되는 제약 조건입니다. 여러 컬럼에 걸쳐 부여할 수도 있습니다. 기본 키는 관계형 모델에서 기원합니다.

2. 아이덴티티(Identity): 아이덴티티/아이덴티티 컬럼은 테이블당 최대 하나의 컬럼에 부여됩니다. 레코드 삽입 시 시퀀스로부터 고유한 ID를 생성합니다 - 클라이언트 DML에 의해 올바르게 삽입될 것으로 기대되는 기본 키와는 다릅니다. 아이덴티티는 종종 기본 키와 일치하지만, 반드시 그래야 하는 것은 아닙니다. 항상 유니크해야 하는 것도 아닙니다.

3. ROW ID / OID: 많은 데이터베이스는 보통 데이터베이스 스키마의 논리적 표현에서 사용되지 않는 내부 ID를 가지고 있습니다. 이 row id는 대부분 기술적 목적을 가지며, 기본 키나 아이덴티티 컬럼이 없는 테이블에도 존재합니다.

### SQL 2008 표준

기본 키 제약 조건은 거의 모든 SQL 방언에서 동일한 방식으로 정의되고, ROWID는 매우 벤더에 특화된 것인 반면, 아이덴티티는 비교적 새로운 것입니다. SQL 1992 표준에서는 아직 아이덴티티 컬럼을 정의하지 않았습니다. 아이덴티티 컬럼은 SQL:2003에서 비로소 공식적으로 도입되었습니다. 다음은 명세의 일부입니다:

```
<column definition> ::=
  <column name> [ <data type or domain name> ]
  [ <default clause> | <identity column specification> ]
  [ ... ]

<identity column specification> ::=
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
  [ <left paren> <common sequence generator options> <right paren> ]
```

깔끔해 보입니다. 실제로 컬럼 제약 조건 외에도, 컬럼은 시퀀스 기반의 아이덴티티 생성 표현식을 지정할 수 있습니다. 현실은 어떨까요?

### 현실

DB2, Derby, HSQLDB, Ingres

이 SQL 방언들은 표준을 매우 깔끔하게 구현합니다.

```sql
id INTEGER GENERATED BY DEFAULT AS IDENTITY
id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1)
```

H2, MySQL, Postgres, SQL Server, Sybase ASE, Sybase SQL Anywhere

이 SQL 방언들은 아이덴티티를 구현하지만, DDL 구문이 표준을 따르지 않습니다.

```sql
-- H2는 MySQL과 SQL Server의 구문을 모방합니다
ID INTEGER IDENTITY(1,1)
ID INTEGER AUTO_INCREMENT
-- MySQL
ID INTEGER NOT NULL AUTO_INCREMENT

-- Postgres의 serial은 암묵적으로 시퀀스를 생성합니다
-- Postgres는 또한 커스텀 시퀀스에서 선택하는 것도 허용합니다
-- 이 방식으로 시퀀스를 여러 테이블 간에 공유할 수 있습니다
id SERIAL NOT NULL

-- SQL Server
ID INTEGER IDENTITY(1,1) NOT NULL
-- Sybase ASE
id INTEGER IDENTITY NOT NULL
-- Sybase SQL Anywhere
id INTEGER NOT NULL IDENTITY
```

Oracle

Oracle은 아이덴티티 컬럼을 전혀 알지 못합니다. 대신 트리거를 사용하여 커스텀 시퀀스로 ID 컬럼을 직접 업데이트해야 합니다. 대략 다음과 같은 방식입니다:

```sql
CREATE OR REPLACE TRIGGER my_trigger BEFORE INSERT ON my_table
REFERENCING NEW AS new FOR EACH ROW BEGIN
  SELECT my_sequence.nextval
  INTO :new.id
  FROM dual;
END my_trigger;
```

이 방식은 시퀀스와 트리거를 지원하는 대부분의 데이터베이스에서 사용할 수 있다는 점에 주목하세요! 이것은 표준 아이덴티티보다 훨씬 더 유연합니다.

SQLite

SQLite도 아이덴티티 컬럼을 알지 못합니다. MySQL의 AUTO_INCREMENT 절을 가지고 있는 것처럼 보이지만, 실제로는 이것이 ROWID 생성에 대한 몇 가지 규칙을 설정하는 것일 뿐이며, SQL 표준에 따른 진정한 아이덴티티 컬럼이 아닙니다.

### 결론

SQL의 많은 것들이 그렇듯이, 아이덴티티는 데이터베이스를 전환하거나 여러 데이터베이스에서 올바르게 동작하는 SQL DDL과 DML을 작성할 때 큰 골칫거리입니다.

jOOQ는 아이덴티티 컬럼 및/또는 트리거로 생성된 ID 값을 가진 테이블에 대해 실행되는 DML을 지원합니다. 이 문제에 대해 더 자세히 다루는 이전 블로그 포스트를 참고하세요:

https://blog.jooq.org/postgres-insert-returning-clause-and-how-this-can-be-simulated-in-other-rdbms/
