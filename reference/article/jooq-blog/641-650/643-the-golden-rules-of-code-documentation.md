# 코드 문서화의 황금률

> 원문: https://blog.jooq.org/the-golden-rules-of-code-documentation/

게시일: 2013년 2월 26일, 작성자: lukaseder

이것은 매우 주관적인 주제이며, 열띤 토론과 종교 전쟁으로 이어지지만, 객관적으로 옳고 그름이 없는 주제입니다. 제 블로그의 이전 게시물이 JavaCodeGeeks에 다시 올라갔습니다. 이 블로그가 JCG에서 불러일으킨 양극화된 비난의 양은 재미있습니다. 특히, 사람들이 다음과 같은 독단적인 주장을 하는 경향이 있다는 점이 마음에 듭니다:

"코드를 명확히 하기 위해 주석이 필요하다면, 더 이해하기 쉽도록 코드를 다르게 작성하는 방법을 생각하는 것이 낫습니다. 기본 언어(코드)를 어지럽히기 위해 또 다른 언어(주석)가 필요하지 않습니다."

분명히 이 사람은 1-2개의 "Hello world" 애플리케이션을 작성했는데, 거기서는 이것이 분명히 맞습니다. 이에 대한 답변은 다음과 같았습니다:

"주석 없이도 살 수 있도록 이 비즈니스 로직을 어떻게 코드로 작성하시겠습니까? 청산 유형 코드 27의 증권거래소 주문은 반올림 로트가 0.01 미만인 경우에만 다른 모든 후속 유형 코드 27 주문과 그룹화되어야 하며, 실제로 최대 35초의 시간 프레임 내에 언로딩됩니다(실제 애플리케이션의 가상 예시)."

물론입니다. 코드는 "무엇을" 하는지 전달할 수 있습니다. 하지만 "왜" 그것을 하는지는 오직 주석만이 전달할 수 있습니다! "왜"는 단순히 코드로 표현할 수 없는 더 넓은 진실입니다. 여기에는 요구사항, 감정, 경험 등이 포함됩니다. 그래서 (바라건대!) 더 열띤 토론으로 이어질 또 다른 양극화 블로그 게시물을 작성할 때입니다! 이것은 다음에 관한 것입니다:

### 코드 문서화의 황금률

좋은 문서화는 애플리케이션 및/또는 API에 가독성, 투명성, 안정성, 신뢰성을 더합니다. 하지만 좋은 문서화란 무엇일까요? 좋은 문서화의 구성 요소는 무엇일까요?

코드는 문서입니다

우선, 실제로 코드는 가장 중요한 문서입니다. 코드는 소프트웨어에 대한 궁극적인 진실을 담고 있습니다. 코드가 무엇을 하는지 설명하는 다른 모든 방법은 다음과 같은 사람들을 위한 근사치일 뿐입니다:

- 코드를 모르는 사람 (다른 사람이 작성함)
- 코드를 읽을 시간이 없는 사람 (너무 복잡함)
- 코드를 읽고 싶지 않은 사람 (무슨 일이 일어나고 있는지 이해하기 위해 Hibernate나 Xerces 코드를 읽고 싶은 사람이 있을까요??)
- 코드에 접근할 수 없는 사람 (디컴파일할 수는 있지만)

다른 모든 사람들에게 코드는 문서입니다. 따라서 분명히 코드는 그 목적을 문서화하는 방식으로 작성되어야 합니다. 그러므로 영리한 코드를 작성하지 말고, 우아한 코드를 작성하세요. 다음은 "목적"을 문서화하지 않는 방법의 좋은 예입니다(소수의 Perl 원어민을 제외하고):

```
$=`;$_=\%!;($_)=/(.)/;$==++$|;($.,$/,$,,$\,$",$;,$^,$#,$~,$*,$:,@%)=(
$!=~/(.)(.).(.)(.)(.)(.)..(.)(.)(.)..(.)......(.)/,$"),$=++;$.++;$.++;
$_++;$_++;($_,$\,$,)=($~.$"."$;$/$%[$?]$_$\$,$:$%[$?]",$"&$~,$#,);$,++
;$,++;$^|=$";`$_$\$,$/$:$;$~$*$%[$?]$.$~$*${#}$%[$?]$;$\$"$^$~$*. >&$=`
```

출처: http://fwebde.com/programming/write-unreadable-code/

분명히 이것은 "Just another Perl hacker."를 출력합니다. 그러나 저는 확실히 이것을 제 컴퓨터에서 실행하지 않을 것입니다. 데이터 손실에 대해 저를 탓하지 마세요 ;-)

API는 문서입니다

API는 여전히 코드이지만, 대부분의 다른 사람들에게 노출되는 코드의 일부입니다. 따라서 다음과 같아야 합니다:

- 매우 단순해야 합니다
- 매우 간결해야 합니다

단순함이 왕입니다. 그러나 간결함은 정확히 같은 것이 아닙니다. 간결하지 않은 API를 사용하는 것이 여전히 단순할 수 있습니다. Spring의 J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource를 사용하는 것이 단순하다고 생각합니다. 구성하고, 주입하면 끝입니다. 하지만 이름은 간결함을 나타내지 않습니다. 이것은 단지 문서화에 관한 것이 아니라 일반적인 API 설계에 관한 것입니다. API를 사용하기가 매우 쉬워야 합니다. 그러면 API가 그 의도를 명확하게 전달하기 때문입니다. 그리고 자신의 의도를 전달하는 것이 문서화입니다. 간결함에 도달하기 위한 좋은 설계(따라서 문서화) 규칙은 다음과 같습니다:

- 3개 이상의 인수를 가진 메서드가 공개 API에 노출되지 않도록 하세요.
- 이름에 3개 이상의 단어가 있는 메서드/타입이 공개 API에 노출되지 않도록 하세요.

위의 것들을 피하는 것이 가장 좋습니다. 그러한 메서드를 피할 수 없다면, 비공개로 유지하세요. 이러한 메서드는 재사용이 불가능하므로 API에서 문서화할 가치가 없습니다.

API는 글로 문서화되어야 합니다

코드가 공개 API로 "노출"되면, 사람이 읽을 수 있는 글로 문서화되어야 합니다. 사실, java.util.List.add()는 이미 꽤 간결합니다. 그 의도를 명확하게 전달합니다. 하지만 어떻게 동작하고 왜 그런가요? Javadoc에서 발췌:

"이 작업을 지원하는 리스트는 이 리스트에 추가될 수 있는 요소에 제한을 둘 수 있습니다. 특히, 일부 리스트는 null 요소 추가를 거부하고, 다른 리스트는 추가될 수 있는 요소의 유형에 제한을 부과합니다. 리스트 클래스는 추가될 수 있는 요소에 대한 모든 제한을 문서에 명확하게 명시해야 합니다."

따라서 null 요소 추가를 거부하는 잘 알려진 리스트가 있고, 추가될 수 있는 요소에 제한이 있을 수 있습니다. 이것은 API의 메서드 시그니처만으로는 이해할 수 없습니다 - 간결한 시그니처 만들기를 거부하지 않는 한.

추적 도구는 문서입니다

추적 도구는 이해관계자와의 인간 인터페이스입니다. 이것은 논의하고 코드가 궁극적으로 왜 그런 방식으로 작성되었는지에 대한 역사적 논거를 제공하는 데 도움이 됩니다. 여기서 DRY를 유지하세요. 중복을 인식하고 이슈당 하나의 단순하고 간결한 티켓만 유지하려고 노력하세요. 명확하지 않은 방식으로 코드를 수정할 때(이해관계자가 명확하지 않은 요구사항을 가지고 있기 때문에), 관련 코드 섹션에 추적 ID를 참조하는 짧은 주석을 추가하세요:

```java
// [#1296] FOR UPDATE는 일부 방언에서
// ResultSet.CONCUR_UPDATABLE을 사용하여 시뮬레이션됩니다
if (forUpdate &&
    !asList(CUBRID, SQLSERVER).contains(context.getDialect())) {
```

네, 코드 자체가 이미 후속 섹션이 forUpdate 쿼리에서만 그리고 CUBRID와 SQLSERVER 방언에서만 실행된다고 설명합니다. 하지만 왜? 미래의 개발자는 이슈 #1296에 대해 찾을 수 있는 모든 것을 기꺼이 읽을 것입니다. 관련이 있다면, 다음에서 이 티켓 ID를 참조해야 합니다:

- 메일링 리스트
- 소스 코드
- API 문서
- 버전 관리 체크인 주석
- Stack Overflow 질문
- 모든 종류의 검색 가능한 문서
- 등등

버전 관리는 문서입니다

문서화의 이 부분은 훌륭합니다! 변경을 문서화합니다. 대규모 프로젝트에서, 오래전에 회사를 떠난 동료가 지금 당장 이해하지 못하는 이상한 변경을 한 이유를 여전히 재구성할 수 있습니다. 따라서 변경에 앞서 언급한 티켓 ID를 포함하는 것도 중요합니다. 따라서 이 규칙을 따르세요: 변경이 사소하지 않습니까(철자 수정, 들여쓰기 수정, 지역 변수 이름 변경 등)? 그러면 티켓을 만들고 커밋에서 티켓 ID로 이 변경을 문서화하세요. 해당 티켓을 만들고 참조하는 데 1분밖에 걸리지 않지만, 미래의 동료에게 조사 시간을 몇 시간 절약해 줄 것입니다!

버전 번호는 문서입니다

단순하고 간결한 버전 번호 시스템은 사용자가 어떤 버전으로 업그레이드해야 하는지 이해하는 데 도움이 됩니다. 이것을 올바르게 수행하는 방법의 좋은 예는 시맨틱 버저닝입니다. 여기서 황금률은 다음과 같이 요약할 수 있는 [X].[Y].[Z] 버전 체계를 사용하는 것입니다:

- 패치 릴리스에 버그 수정, 성능 개선 및 API와 관련 없는 새로운 기능이 포함되면, [Z]가 1씩 증가합니다.
- 마이너 릴리스에 하위 호환되는 API 관련 새로운 기능이 포함되면, [Y]가 1씩 증가하고 [Z]는 0으로 재설정됩니다.
- 메이저 릴리스에 하위 호환되지 않는 API 관련 새로운 기능이 포함되면, [X]가 1씩 증가하고 [Y], [Z]는 0으로 재설정됩니다.

릴리스된 버전 간의 변경 범위를 전달하기 위해 이러한 규칙을 엄격하게 따르세요.

### 문제가 발생하는 곳

이제 여기서부터 감정적이 됩니다...

문서화를 위한 UML은 잊으세요!

수동으로 큰 UML 다이어그램을 만들지 마세요. 음, 만드세요. 다른 사람들에게 무언가를 이해/설명하는 데 도움이 될 수 있습니다. 회의를 위한 즉석 UML 다이어그램을 만들거나, 고수준 튜토리얼을 위한 비공식 UML 다이어그램을 만드세요. 코드의 관련 부분에서 UML 다이어그램을 생성하거나(또는 데이터베이스에서 엔티티 다이어그램을 생성하거나), 하지만 코드 문서화의 중심 부분으로 간주하지 마세요. 아무도 수백 개의 클래스와 수천 개의 관계가 있는 UML 다이어그램을 수동으로 업데이트하지 않을 것입니다. 이 규칙의 예외는 UML이 실제로 문서가 아닌 코드의 일부인 UML 기반 모델 주도 아키텍처일 수 있습니다.

문서화를 위한 MS Word나 HTML은 잊으세요(가능하다면)!

문서를 코드 가까이에 유지하세요. 극도의 규율 없이는 외부 문서를 실제 코드 및/또는 API와 동기화 상태로 유지하는 것은 거의 불가능합니다. 가능하다면, DRY를 유지하기 위해 코드의 문서에서 외부 문서를 자동 생성하세요. 하지만 피할 수 있다면, 외부 문서를 작성하지 마세요. 그것은 거의 정확하지 않습니다. 물론 항상 외부 문서를 피할 수 있는 것은 아닙니다. 때때로 매뉴얼, 튜토리얼, 하우투, 베스트 프랙티스 등을 작성해야 합니다. 단지 그러한 문서를 "진짜 진실": 코드와 동기화 상태로 유지하는 것이 거의 불가능하다는 것을 명심하세요.

초기 문서화 작성은 잊으세요!

API는 진화할 것입니다. Java API처럼 영원히 지속되는 API를 작성하는 사람은 거의 없습니다. 따라서 클래스 A를 타입 B 및 알고리즘 C와 영원히 연결하는 방법을 생각하는 데 모든 시간을 쓰지 마세요. 코드를 작성하고, API로 노출되는 코드의 부분을 문서화하고, 코드/커밋에서 티켓 ID를 참조하세요.

보일러플레이트 코드 문서화는 잊으세요!

예를 들어 getter와 setter. 이것들은 보통 가져오고 설정하는 것 이상을 하지 않습니다. 그렇지 않다면, 문서화하지 마세요. 왜냐하면 지루한 문서는 오래되어 틀리게 되기 때문입니다. 속성(따라서 getter/setter 이름)을 리팩토링했지만 Javadoc은 리팩토링하지 않은 적이 몇 번이나 있습니까? 정확히요. 아무도 보일러플레이트 API 문서를 업데이트하지 않습니다.

```java
/
 * id를 반환합니다
 *
 * @return id
 */
public int getId() {
    return id;
}
```

아, ID! 놀랍죠.

사소한 코드 문서화는 잊으세요!

이렇게 하지 마세요:

```java
// 아직 할 일이 있는지 확인
if (!jobs.isEmpty()) {

    // 실행할 다음 작업을 가져옴
    Job job = jobs.pollFirst();

    // ... 그리고 실행
    job.execute();
}
```

당연하죠. 그 코드는 우리가 전에 본 것처럼 이미 단순하고 간결합니다. 주석이 전혀 필요하지 않습니다:

```java
if (!jobs.isEmpty()) {
    Job job = jobs.pollFirst();
    job.execute();
}
```

### TL;DR: 단순하고 간결하게 유지하세요

좋은 문서화를 만드세요:

- 문서화를 단순하고 간결하게 유지함으로써.
- 문서화를 애플리케이션의 궁극적인 진실인 코드와 API 가까이에 유지함으로써.
- 문서화를 DRY하게 유지함으로써.
- 티켓 시스템, 버전 관리, 시맨틱 버저닝을 통해 다른 사람들이 문서화를 이용할 수 있게 함으로써.
- 사용 가능한 미디어 전체에서 티켓 ID를 참조함으로써.
- 가능한 한 "외부" 문서화를 잊음으로써.

좋은 문서화를 제공하는 애플리케이션, API, 라이브러리는 더 나은 소프트웨어를 만드는 데 도움이 됩니다. 왜냐하면 잘 문서화된 애플리케이션, API, 라이브러리는 그 자체로 더 나은 소프트웨어이기 때문입니다. 스택을 비판적으로 확인하고 잘 문서화되지 않은 부분은 피하려고 노력하세요.
