# jOOQ의 존재 이유

> 원문: https://blog.jooq.org/jooqs-reason-of-being/

아래 단락들은 jOOQ 매뉴얼의 서문에서 발췌한 것입니다. 주어진 프로젝트에서 jOOQ를 사용해야 하는지(또는 사용하지 말아야 하는지) 생각해 볼 가치가 있습니다. 구체적으로, jOOQ와 JPA, jOOQ와 Hibernate, 또는 jOOQ와 SLICK(Scala 컨텍스트에서) 중에서 선택해야 할 수 있습니다. 여기에 약간의 가이드가 있습니다(물론 jOOQ 쪽으로 약간 편향되어 있습니다…):

## jOOQ의 존재 이유 – JPA와 비교

Java와 SQL은 오랜 길을 걸어왔습니다. SQL은 "고대의" 기술이지만, 확립되어 있고 잘 이해된 기술입니다. Java도 레거시이지만, 그 플랫폼인 JVM은 그 위에 구축된 많은 새롭고 현대적인 언어들을 허용합니다. 그러나 이 모든 세월이 지난 후에도, SQL과 Java 사이의 인터페이스를 다루는 라이브러리들은 왔다가 사라졌고, JPA만이 살아남은 옵션이 없는 상황에서 의구심과 함께 받아들여지는 표준으로 남아 있습니다.

지금까지, SQL을 언어들 중에서 일급 시민으로 진정으로 존중하는 데이터베이스 추상화 프레임워크나 라이브러리는 거의 없었습니다. 업계 표준인 JPA, EJB, Hibernate, JDO, Criteria Query 등을 포함한 대부분의 프레임워크들은 SQL 자체를 숨기려고 하며, 그 범위를 JPQL, HQL, JDOQL 및 다양한 기타 열등한 쿼리 언어라고 불리는 것들로 최소화합니다.

jOOQ는 이 공백을 채우기 위해 등장했습니다.

## jOOQ의 존재 이유 – LINQ와 비교

다른 플랫폼들은 LINQ(LINQ-to-SQL 포함)나 Scala의 SLICK과 같은 아이디어를 통합하여 쿼리를 개념으로서 각각의 언어에 더 잘 통합합니다. 쿼리라고 하면, 그들은 SQL, XML, 컬렉션 및 기타 이질적인 데이터 저장소와 같은 임의의 대상에 대한 쿼리를 의미합니다. jOOQ는 이것 역시 잘못된 방향이라고 주장합니다.

더 고급 쿼리 사용 사례(단순한 CRUD와 가끔 있는 JOIN을 넘어서)에서, 사람들은 SQL의 표현력으로부터 이익을 얻고 싶어할 것입니다. SQL의 관계형 특성으로 인해, 이것은 C#, Scala, Java와 같은 객체 지향적이고 부분적으로 함수형인 언어들이 제공할 수 있는 것과는 상당히 다릅니다.

조인과 그것들이 생성하는 임시 테이블 표현식 타입을 형식적으로 표현하고 검증하는 것은 매우 어렵습니다. 피벗 테이블, 언네스트된 커서, 또는 파생 테이블로부터의 임의 프로젝션과 같은 더 고급 테이블 표현식을 지원하고 싶을 때 더욱 어려워집니다. 매우 강력한 객체 지향 타이핑 모델에서는, 이러한 기능들이 아마도 범위 밖에 머물 것입니다.

본질적으로, SQL처럼 보이는 API를 만들 것인지 아니면 C#, Scala, Java처럼 보이는 API를 만들 것인지에 대한 결정은 둘 중 하나의 플랫폼을 확실히 선택하는 결정입니다. SLICK을 LINQ와 비슷한 방식으로 발전시키는 것이 더 쉬울 것이지만, 기저의 의도를 명확하게 전달하는 SQL 기능 범위는 나중에 추가하기가 매우 어려울 것입니다(예를 들어, Oracle의 파티션드 아우터 조인 구문을 어떻게 모델링하시겠습니까? ANSI/ISO SQL:1999 그룹핑 셋을 어떻게 모델링하시겠습니까? 스칼라 서브쿼리 캐싱을 어떻게 지원할 수 있습니까? 등등…).

jOOQ는 이 공백을 채우기 위해 등장했습니다.

## jOOQ는 다릅니다

SQL은 결코 추상화되도록 의도된 것이 아닙니다. 관계형 데이터의 아름다움과 단순함을 숨기는 무거운 매퍼의 좁은 경계에 갇히도록 의도된 것이 아닙니다. SQL은 결코 객체 지향적이 되도록 의도된 것이 아닙니다. SQL은 결코 SQL이 아닌 다른 무엇이 되도록 의도된 것이 아닙니다… SQL!
