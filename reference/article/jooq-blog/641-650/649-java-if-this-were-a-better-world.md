# Java, 만약 이 세상이 더 나은 세상이라면

> 원문: https://blog.jooq.org/java-if-this-were-a-better-world/

저는 Java를 사랑합니다. 완벽한 언어이기 때문이 아닙니다. Java는 배우기 쉽고 새로운 것에 대해 보수적이기 때문입니다. 이것은 JavaScript가 미래의 "멋진" 기능에 압도당하는 것을 흥미롭게 지켜보는 이유이기도 합니다.

그러나 Java의 보수주의는 때때로 정말 짜증나는 한계를 만들어냅니다. 저는 이것을 지금까지의 Java에 대한 비판이라기보다는 미래의 Java 및/또는 경쟁 언어에 대한 희망 목록으로 생각합니다 - 비록 저의 이러한 바람 중 일부는 매우 순진하고 잘 생각되지 않았을 수 있지만 말입니다.

다음은 완전한 목록이 아닙니다. 더 나은 세상이라면 Java가 가졌으면 하는 것들의 목록일 뿐입니다:

## Serialisability (직렬화 가능성)

더 나은 세상에서는 모든 객체가 기본적으로 Serializable이어야 합니다. 직렬화 불가능성이 명시적으로 표시되어야 하는 "기능"이어야 합니다. 즉, 기본적으로 직렬화가 가능하고, 직렬화를 원하지 않는 경우에만 별도로 표시하는 것이 맞습니다.

## Cloning (복제)

복제도 마찬가지입니다. 더 나은 세상에서는 모든 것이 기본적으로 deep-cloneable해야 합니다. 실제로 clone 메서드는 Object에 있어서는 안 되며, 별도의 유틸리티에 있어야 합니다. 그래야 실수로 이름이 충돌하는 것을 피할 수 있습니다.

## Unsigned (부호 없는 정수)

더 나은 세상에서는 unsigned 정수 원시 타입과 그에 대응하는 래퍼 클래스가 있을 것입니다.

## Primitives (원시 타입)

더 나은 세상에서는 원시 타입과 래퍼 클래스 사이에 더 나은 통합이 있을 것입니다. 원시 타입(int)과 래퍼(Integer)의 분리는 API 마찰과 불일치를 만들어냅니다.

## Properties (프로퍼티)

더 나은 세상에서는 공식적인 프로퍼티 문법이 있어서 현재 JavaBeans 규약에서 요구하는 getter/setter 패턴을 개선할 것입니다.

## Collections (컬렉션)

더 나은 세상에서는 컬렉션에 대한 JSON과 유사한 문법이 있을 것입니다:

```java
List<Integer> list = [ 1, 2, 3 ];
Map<String, Integer> map = { "A": 1, "B": 2 };
```

## ThreadLocal

더 나은 세상에서는 `threadlocal`이 `volatile`이나 `transient`처럼 언어 키워드가 되어 더 깔끔한 문법을 가능하게 할 것입니다.

## References (참조)

더 나은 세상에서는 `java.lang.ref` 클래스들이 특별한 JVM 처리가 아닌 전용 키워드 지원을 받을 것입니다.

## Reflection (리플렉션)

더 나은 세상에서는 리플렉션이 불필요하게 장황하지 않을 것입니다. 언어 수준의 문법 설탕(syntactic sugar)이 도움이 될 것입니다.

## Interfaces (인터페이스)

더 나은 세상에서는 인터페이스와 클래스 문법이 수렴하여 두 가지 모두에서 동일한 접근 제한자와 메서드 타입을 허용할 것입니다.

## Default visibility (기본 가시성)

더 나은 세상에서는 패키지 수준 가시성이 제한자의 부재에 의존하지 않고 명시적인 키워드("package" 또는 "local")를 사용할 것입니다.

## Literals (리터럴)

더 나은 세상에서는 컬렉션, 정규식, 튜플, 레코드, 범위 리터럴에 대한 지원이 있을 것입니다:

```java
#[ 1, 2, 3 ]              // 배열/리스트/세트
#/(\\d+)$/                // 정규식
#(a, b)                   // 튜플
#(1..10)                  // 범위
```

## Final

더 나은 세상에서는 `final`이 멤버와 변수의 기본값이 될 것입니다. 가변성은 명시적인 "var" 선언을 필요로 해야 합니다.

## Override

더 나은 세상에서는 `@Override`와 같은 키워드가 메서드 오버라이드에 필수가 되어 실수로 인한 섀도잉을 방지할 것입니다.

## Modules (모듈)

더 나은 세상에서는 모듈/jar 파일로 표현되는 컴파일 단위가 Maven 스타일의 의존성 관리 문제를 제거할 것입니다.

## Varargs and Generics (가변 인자와 제네릭)

더 나은 세상에서는 제네릭 타입 소거가 `@SafeVarargs` 어노테이션을 야기하지 않을 것입니다. 진정한 타입 보존이 안전성을 향상시킬 것입니다.

## Tuples and Records (튜플과 레코드)

더 나은 세상에서는 고정 크기 컬렉션과 구조화된 데이터에 대한 언어 수준 지원이 보일러플레이트를 제거할 것입니다.

## Compiler API (컴파일러 API)

더 나은 세상에서는 확장 가능한 컴파일러 기능이 내장된 SQL과 같은 도메인 특화 언어를 가능하게 할 것입니다.

## Type inference (타입 추론)

더 나은 세상에서는 Scala의 강력함에 맞먹는 로컬 타입 추론이 메서드 본문에서의 장황함을 줄일 것입니다.

## Operator overloading (연산자 오버로딩)

더 나은 세상에서는 연산자를 지원하여 `BigInteger`와 `BigDecimal`과 같은 숫자 타입에 대한 API를 개선할 것입니다.

## 결론

물론 이것은 단지 희망 목록일 뿐입니다. 모든 언어에는 트레이드오프가 있습니다. Java의 보수주의는 장단점이 있습니다 - 새로운 기능을 느리게 추가하지만, 그만큼 언어가 안정적이고 예측 가능하게 유지됩니다. 하지만 더 나은 세상에서는 이러한 기능들 중 일부가 Java에 도입되어 개발자의 삶을 조금 더 쉽게 만들어줄 것입니다.
