# 재미있는 SQL 시간: 접두사 합 계산

> 원문: https://blog.jooq.org/time-for-some-funky-sql-prefix-sum-calculation/

이 글은 Stack Overflow에 올라온 질문에서 영감을 받아 작성되었습니다. 문제는 다음과 같습니다:

N개의 요소로 이루어진 배열이 있고, 모든 요소는 0으로 초기화되어 있습니다. M개의 연산이 주어지며, 각 연산은 `(p, q, r)` 형태로, 인덱스 `p`부터 `q`까지의 모든 요소에 정수 `r`을 더합니다. 모든 연산을 수행한 후 배열에서 가장 큰 값을 찾아야 합니다.

단순한 접근 방식은 모든 연산을 순차적으로 수행하는 것으로, `O(MN)` 시간 복잡도를 가집니다. 하지만 더 효율적인 `O(M+N)` 솔루션이 있습니다.

## Java 솔루션

핵심 최적화는 연산을 "신호(signal)"로 변환하는 것입니다. 각 연산 `(p, q, r)`에 대해 위치 `p`에 `+r`을, 위치 `q+1`에 `-r`을 배치합니다. 그런 다음 접두사 합(누적 합)을 순차적으로 계산합니다.

Java 구현은 다음과 같은 과정을 따릅니다:
- 연산을 클래스에 저장
- 연산으로부터 신호 쌍 생성
- 루프에서 접두사 합 계산
- 최댓값 추적

Java 8에서는 `Arrays.parallelPrefix()`를 사용하면 병렬 계산을 활용하여 순차 솔루션보다 더 빠른 결과를 얻을 수 있습니다.

예를 들어, 다음과 같은 연산들이 주어졌다고 가정합니다:
- (4, 12, 2): 인덱스 4부터 12까지 2를 더함
- (2, 8, 3): 인덱스 2부터 8까지 3을 더함
- (6, 7, 1): 인덱스 6부터 7까지 1을 더함
- (3, 7, 2): 인덱스 3부터 7까지 2를 더함

신호 방식을 사용하면:
- 위치 4에 +2, 위치 13에 -2
- 위치 2에 +3, 위치 9에 -3
- 위치 6에 +1, 위치 8에 -1
- 위치 3에 +2, 위치 8에 -2

이 신호들의 누적 합을 계산하면 위치 6에서 최댓값 8을 얻습니다.

## SQL 솔루션 (PostgreSQL)

SQL은 이 문제를 매우 우아하게 해결할 수 있습니다. PostgreSQL 구현은 다음을 사용합니다:
- 공통 테이블 표현식 (WITH 절): 중간 테이블 선언
- UNION ALL: 신호 쌍 결합
- 윈도우 함수 (`SUM() OVER (ORDER BY x)`): 누적 합 계산

완전한 SQL 솔루션:

```sql
WITH
  -- 연산 데이터 정의
  op (p, q, r) AS (
    VALUES (4,12,2), (2,8,3), (6,7,1), (3,7,2)
  ),
  -- 각 연산을 신호 쌍으로 변환
  signal(x, r) AS (
    SELECT p, r FROM op        -- 시작 위치에 양수 신호
    UNION ALL
    SELECT q + 1, -r FROM op   -- 종료 위치+1에 음수 신호
  )
-- 윈도우 함수로 누적 합 계산하고 최댓값 찾기
SELECT x, SUM(r) OVER (ORDER BY x) AS s
FROM signal
ORDER BY s DESC
LIMIT 1
```

이 쿼리는 모든 연산에 걸쳐 누적된 최댓값과 해당 위치를 반환합니다. 명령형 접근 방식과 비교했을 때 놀라울 정도로 간결합니다.

## 결론

이 SQL 구현은 데이터베이스 SQL이 윈도우 함수와 CTE를 통해 알고리즘 문제를 우아하게 해결할 수 있음을 보여줍니다. 명령형 프로그래밍 언어와 비교해도 손색없는 결과를 달성하면서도, 선언적 방식의 간결함을 유지합니다.

접두사 합 기법은 범위 업데이트 문제를 효율적으로 해결하는 강력한 도구이며, SQL의 윈도우 함수와 결합하면 복잡한 계산도 간단한 쿼리로 표현할 수 있습니다.
