> 원문: https://blog.jooq.org/why-you-should-avoid-expressions-in-sql-predicates/

# SQL 조건절(Predicate)에서 표현식(Expression) 사용을 피해야 하는 이유

이 글은 Oracle 11g 프로덕션 시스템에서 발견한 중요한 성능 이슈에 대해 설명합니다. 핵심 발견 사항은 SQL 조건절에서 `SYSDATE - some_value`와 같은 표현식을 사용하면 예상치 못한 성능 병목 현상이 발생할 수 있다는 것입니다.

## 문제 상황

고객의 야간 배치 작업에서 다음과 같은 쿼리로 오래된 결제 기록을 삭제하고 있었습니다:

```sql
DELETE FROM payment WHERE payment_date < SYSDATE - 470
```

`payment_date` 컬럼에 인덱스가 있고 해당 인덱스가 사용되고 있었지만, 다른 접근 방식에 비해 쿼리 성능이 좋지 않았습니다.

## 테스트한 세 가지 접근 방식

저자는 동일한 결과를 반환하는 세 가지 쿼리를 벤치마크했습니다:

1. 인라인 표현식(Inline Expression): `WHERE payment_date < SYSDATE - v_range`
2. 바인드 변수(Bind Variable): `WHERE payment_date < v_date` (미리 계산된 값)
3. 스칼라 서브쿼리(Scalar Subquery): `WHERE payment_date < (SELECT SYSDATE - v_range FROM dual)`

## Oracle 11g에서의 결과

상대적 시간 단위를 사용한 첫 번째 실행 결과:

- 문장 1 (인라인 표현식): 1.98 wombos
- 문장 2 (바인드 변수): 1.17 wombos
- 문장 3 (스칼라 서브쿼리): 0.80 wombos

스칼라 서브쿼리 접근 방식이 가장 큰 성능 향상을 보여주었으며, 인라인 표현식 버전보다 거의 2.5배 더 빨랐습니다.

## Oracle 12c에서의 발견

새로운 버전에서는 성능 특성이 크게 달라졌습니다: 바인드 변수가 가장 빠르고, 스칼라 서브쿼리가 약간 느리며, 인라인 표현식이 가장 느렸습니다.

## 핵심 요점

저자는 데이터베이스 최적화가 여전히 버전에 따라 다르다는 점을 강조합니다:

> "SQL에서는 항상 자신의 환경에서 직접 측정해봐야 합니다. 설정과 데이터베이스 버전이 다를 수 있기 때문입니다."

### 실무 권장 사항

1. 조건절에서 계산 표현식을 직접 사용하는 것을 피하세요 - 바인드 변수로 미리 계산된 값을 전달하는 것이 더 나을 수 있습니다.
2. 성능 테스트는 필수입니다 - 사용 중인 데이터베이스 버전과 환경에서 직접 벤치마크하세요.
3. 스칼라 서브쿼리를 고려해보세요 - 경우에 따라 표현식을 서브쿼리로 감싸는 것이 옵티마이저가 더 나은 실행 계획을 선택하도록 도울 수 있습니다.
