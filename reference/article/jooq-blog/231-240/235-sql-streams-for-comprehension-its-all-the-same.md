> 원문: https://blog.jooq.org/sql-streams-for-comprehension-its-all-the-same/

# SQL, 스트림(Streams), For Comprehension... 결국 다 같은 것이다

## 개요

이 글에서는 수학의 집합-빌더 표기법(set-builder notation), SQL 쿼리, 그리고 Java 8 스트림(Streams) 사이의 수학적, 개념적 유사성을 탐구합니다. 핵심 논점은 이처럼 겉보기에 다른 접근 방식들이 공통된 선언적(declarative) 기반을 공유한다는 것입니다.

## 수학적 기초

이 글은 Devoxx에서 열린 Kevlin Henney의 발표를 참조하며 시작합니다. 그 발표에서는 선언적 접근 방식을 사용하여 FizzBuzz 문제를 우아하게 해결하는 방법을 보여주었습니다. 이 기반은 수학의 집합-빌더 표기법에 있습니다. 예를 들어 다음과 같이 표현됩니다: "모든 n이 정수(ℤ)일 때, n = 2k를 만족하는 또 다른 정수 k가 존재하는 n만 취한다" - 이것은 본질적으로 모든 짝수를 정의합니다.

수학적 표기법:
```
{n | n ∈ ℤ, ∃k: n = 2k}
```

이것을 명령형(imperative) 접근 방식과 대조해 봅시다. 명령형 방식에서는 시작점, 끝점, 그리고 중간 저장 컬렉션을 지정해야 합니다. 저자는 다음과 같이 관찰합니다: "현실적으로 어딘가에서 시작해야 하고", "모든 값을 중간 컬렉션에 저장해야 한다."

## SQL과 선언적 프로그래밍

이 글은 SQL이 수학적 표기법과 어떻게 일치하는지 보여줍니다. 명령형으로 반복하는 대신, SQL은 집합(set)을 선언할 수 있게 해줍니다:

```sql
SELECT n
FROM integers
WHERE EXISTS (
  SELECT k
  FROM integers
  WHERE n = 2 * k
)
```

옵티마이저(optimizer)는 중간 결과를 구체화(materialize)하지 않고도 이러한 표현식을 변환할 수 있습니다 - 이것은 명령형 루프에서는 얻을 수 없는 핵심적인 장점입니다.

## Java 8 스트림과의 연결

저자는 SQL 절(clause)이 Java 8 스트림에서 어떻게 동등하게 표현되는지를 보여주는 이전 글을 참조하며, "집합-빌더 표기법과 SQL 언어는 매우 유사한 것"이라고 설명합니다.

## 선언적 접근의 장점

핵심 이점은 조합 가능성(composability)에 있습니다. 요구사항이 변경될 때(다르게 필터링하거나, 계산을 재사용할 때) 코드를 리팩토링하는 대신, 선언적 표현식은 안정적으로 유지됩니다. SQL 옵티마이저든 스트림 프로세서든, 구현 엔진이 최적화를 투명하게 처리합니다.

주요 장점들:

1. 조합 가능성(Composability) - 선언적 표현식은 조기 실행 없이 중첩되고 재사용될 수 있습니다
2. 최적화(Optimization) - 데이터베이스 옵티마이저는 순서가 정해진 스트림 파이프라인과 달리 표현식 트리를 자유롭게 변환할 수 있습니다
3. 효율성(Efficiency) - 중간 컬렉션은 최종 결과가 필요할 때까지 구체화될 필요가 없습니다

## 실제 애플리케이션에서의 복잡성

Mario Fusco의 트윗을 참조하며, 명령형과 함수형 접근 방식을 대조합니다. 이를 통해 선언적 사고를 통해 "관심사의 분리(Separation of Concerns)"가 극적으로 개선됨을 보여줍니다.

## 결론 및 주의사항

저자는 현대 SQL의 구현이 기본적인 for comprehension이 제공하는 것보다 "훨씬 더 정교하다"고 강조하며, 지나친 단순화에 대해 경고합니다: "SQL 사용을 for comprehension이 제공하는 것에 제한하지 마세요."

집합(set)의 관점에서 생각하면 엔지니어들은 알고리즘 최적화를 SQL 데이터베이스 옵티마이저든 언어 런타임이든 구현 엔진에 위임할 수 있습니다. 하지만 현대 SQL은 이러한 수학적 뿌리를 넘어 발전해왔다는 점을 기억해야 합니다.
