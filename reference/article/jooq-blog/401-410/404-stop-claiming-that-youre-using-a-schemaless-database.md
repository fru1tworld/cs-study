# 스키마 없는 데이터베이스를 사용하고 있다고 주장하지 마라

> 원문: https://blog.jooq.org/stop-claiming-that-youre-using-a-schemaless-database/

MongoDB를 전도할 때 MongoDB의 주장 중 하나는 MongoDB가 "스키마 없는(schemaless)" 데이터베이스라는 사실입니다. 그들은 다음과 같이 말합니다:

> 왜 스키마 없는가? MongoDB는 JSON 스타일의 데이터 저장소입니다. 데이터베이스에 저장된 문서는 다양한 필드 집합을 가질 수 있으며, 각 필드는 서로 다른 타입을 가질 수 있습니다.

이것은 사실입니다. 하지만 스키마가 없다는 것을 의미하지는 않습니다. 사실 다양한 스키마가 있습니다:

- 당신의 머릿속에 있는 스키마 - 데이터 구조를 설계할 때 생각한 것
- 실제로 데이터베이스가 구현한 스키마 - 당신의 데이터 구조를 저장하기 위해
- 당신이 구현했어야 할 스키마 - 요구사항을 충족하기 위해

실수를 깨달을 때마다, 또는 요구사항이 변경될 때마다, 당신은 데이터를 마이그레이션해야 할 것입니다.

## 동적 타입 vs 정적 타입

그들은 또한 이렇게 말합니다:

> 일반적으로, 이 '스키마 없는' 스타일과 동적 타입 언어 사이에는 직접적인 유사성이 있습니다. 위와 같은 구조는 PHP, Python, Ruby에서 쉽게 표현할 수 있습니다. 우리가 여기서 하려는 것은 이 매핑을 데이터베이스에 자연스럽게 만드는 것입니다.

정확히 맞습니다. "스키마 없음"이라고 말할 때, 실제로는 "동적 타입 스키마"라고 말하는 것입니다 - SQL 데이터베이스에서 사용 가능한 정적 타입 스키마와 반대로요.

이것을 이해하는 것이 중요합니다! 당신이 정적으로 타입을 지정하지 않더라도 항상 스키마가 있습니다. JavaScript를 작성하더라도 여전히 타입이 있으며, 코드의 멘탈 모델에서 그 타입들을 완전히 인식하고 있어야 합니다. 단지 컴파일러(또는 IDE)가 100% 확실하게 타입을 추론하는 것을 도와줄 수 없을 뿐입니다.

JSON은 여전히 완전히 스키마가 없는 데이터 구조 표준입니다. XML과 달리 XML은 필요하다면 XSD를 지정하거나, 문서 지향적이고 "스키마 없는"(즉, 동적 타입) 스키마에서 작동할 수 있게 해줍니다. (그리고 json-schema가 있다고 말하지 마세요. 그것은 XSD를 흉내 내려는 우스꽝스러운 시도입니다)

## SQL로 번역해 보자

좋습니다, 다음 주장을 검토해 봅시다:

> 스키마 없는 데이터베이스를 사용하면, 90%의 경우 데이터베이스 조정이 투명하고 자동으로 됩니다. 예를 들어, 학생 객체에 GPA를 추가하고 싶다면, 속성을 추가하고 다시 저장하면 모든 것이 잘 됩니다 - 기존 학생을 조회하고 GPA를 참조하면 그냥 null을 돌려받습니다. 더 나아가, 코드를 롤백하면 기존 객체의 새 GPA 필드는 코드가 잘 작성되었다면 문제를 일으킬 가능성이 낮습니다.

하지만 이것을 SQL로 번역해 봅시다(또는 다른 "스키마가 있는" 데이터베이스를 사용해도 됩니다):

```sql
ALTER TABLE student ADD gpa VARCHAR(10);
```

그리고 끝입니다! 우리는 컬럼을 추가했고, 모든 행에 추가했습니다. 투명했습니다. 자동이었습니다. 기존 학생을 조회하고 GPA를 참조하면 그냥 null을 돌려받습니다 (우리가 명시적으로 `DEFAULT`를 지정하지 않았기 때문입니다). 코드를 롤백하면, 그냥 다음을 실행합니다:

```sql
ALTER TABLE student DROP gpa;
```

... 그리고 기존 객체의 새 GPA 필드는 전혀 문제를 일으키지 않을 것입니다. 왜냐하면 그 필드가 이미 가버렸기 때문입니다!

## 이제 1:N을 M:N으로 바꾸고 싶다면?

정말 복잡한 스키마 변경의 경우, 예를 들어 학생-교사 1:N 관계를 학생-교사 M:N 관계로 변경하고 싶다면, 관계형 데이터 모델이 계층형 모델보다 훨씬 우수하다는 것이 증명됩니다. SQL에서는 이렇게 합니다:

```sql
CREATE TABLE student_to_teacher
AS
SELECT id AS student_id, teacher_id
FROM student;

ALTER TABLE student DROP teacher_id;
```

... 그리고 끝입니다! 새 JSON으로 기존 JSON을 변환해야 하는 지루한 작업을 생각해 보세요. 그 작업을 위한 XSLT나 XQuery조차 없고, JavaScript만 있습니다!

## 추악한 진실

그래서, "스키마 없는" 데이터베이스가 "스키마가 있는" 데이터베이스보다 정말로 더 쉬운 것은 절대적으로 아무것도 없습니다. 당신은 그저 스키마를 정제하는 불가피한 작업을 나중의 어떤 시점으로 미룰 뿐입니다. 그리고 사실, SQL의 힘과 표현력은 유연한 데이터 마이그레이션을 도와줄 것입니다. 반면에 여러분은 JSON 문서에서 수동으로 동일한 작업을 수행해야 할 것입니다.

하지만 MongoDB가 계속해서 그들의 주장을 반복하게 두겠습니다:

> ... 기존 객체의 새 GPA 필드는 코드가 잘 작성되었다면 문제를 일으킬 가능성이 낮습니다.

하지만 제가 추악한 진실을 말씀드리겠습니다:

> 잘못될 수 있는 모든 것은 잘못된다 - Murphy

당신의 동적 타입 언어와 동적 타입 데이터베이스 스키마에 행운을 빕니다 - 우리는 타입 안전한 SQL을 고수하겠습니다.

## 주석 - 2014년 10월 21일

Twitter에서 Mark Madsen이 제안했듯이, 우리가 찾고 있는 실제 용어는 다음과 같습니다:

- Schema-on-Read (구어체로 "스키마 없음"이라고 불림)
- Schema-on-Write

Schema-on-Read는 읽기 시점에 스키마가 적용되는 것을 의미하고, Schema-on-Write는 쓰기 시점에 스키마가 적용되는 것을 의미합니다. 이것이 핵심적인 차이입니다.
