# 대부분의 프로그래머가 페이지네이션을 잘못하는 이유

> 원문: https://blog.jooq.org/why-most-programmers-get-pagination-wrong/

대부분의 애플리케이션에서 페이지네이션은 흔히 다음 두 가지 방식으로 잘못 구현됩니다:

1. UX 관점에서
2. 성능 관점에서

## UX 측면의 문제

대부분의 경우 사용자는 결과 집합의 정확한 총 개수를 별로 신경 쓰지 않습니다. 다음과 같은 UI를 생각해 보세요:

```
페이지 번호: 1 2 3 ... 315 316 317 318 319 ... 50194
```

이게 과연 쓸모가 있을까요? 현재 317페이지에 있고, 총 50,194페이지가 있다는 정보가 사용자에게 의미 있는 정보인가요? 과연 사용자가 42,123페이지로 점프해야 할 일이 있을까요? 아마 없을 겁니다. 사용자가 원하는 것은 대부분 "다음 10개의 행"을 가져오는 것입니다. 마치 게임에서 다음 턴을 진행하는 것처럼, 현재 어디쯤 와있는지 정확한 수치가 아니라 계속해서 다음으로 넘어갈 수 있다는 것만 알면 됩니다.

Facebook, Twitter, Reddit과 같은 플랫폼들이 페이지네이션을 어떻게 구현하는지 생각해 보세요. 이런 플랫폼들은 타임라인 기반 네비게이션을 사용합니다. 사용자는 페이지 번호를 지정하거나 총 결과 수를 확인하지 않고, 단순히 "다음 페이지"를 요청합니다. 무한 스크롤 패턴이 바로 이런 접근 방식입니다.

실제로 사용자가 결과 집합에서 더 깊이 탐색해야 할 때는 어떻게 할까요? 사용자는 임의의 페이지 번호로 점프하는 대신, 검색 조건을 수정하거나 정렬 방식을 변경합니다. 이것이 훨씬 더 자연스러운 사용자 행동입니다.

## 성능 측면의 문제

OFFSET 기반 페이지네이션은 데이터베이스에게 결과를 반환하기 전에 고정된 수의 행을 건너뛰도록 강제합니다. 317페이지로 점프하려면(페이지당 10개 행 기준) 데이터베이스가 정렬과 필터링을 수행한 후 3,170개의 레코드를 건너뛰어야 합니다. 이것은 순수한 낭비입니다.

오프셋이 커질수록 이 작업은 점점 더 비용이 많이 들게 됩니다. 기본적으로 다음과 같은 쿼리를 실행하는 것입니다:

```sql
SELECT *
FROM rental
WHERE customer_id = 1
ORDER BY rental_date
LIMIT 10 OFFSET 3170
```

데이터베이스는 3,180개의 행을 처리한 후 처음 3,170개를 버리고 마지막 10개만 반환해야 합니다. 페이지 번호가 높아질수록 성능은 기하급수적으로 저하됩니다.

## 해결책: 키셋 페이지네이션

OFFSET 페이지네이션 대신 "키셋 페이지네이션"(또는 "seek 페이지네이션"이라고도 함)을 사용해야 합니다. 이 방식은 행 수 대신 실제 데이터 값을 앵커로 사용합니다.

기본 개념은 간단합니다. 마지막으로 본 행의 값을 기억하고, 그 다음부터 시작하는 것입니다.

jOOQ를 사용한 구현 예시:

```java
DSL.using(configuration)
   .select(PLAYERS.PLAYER_ID, PLAYERS.FIRST_NAME,
           PLAYERS.LAST_NAME, PLAYERS.SCORE)
   .from(PLAYERS)
   .where(PLAYERS.GAME_ID.eq(42))
   .orderBy(PLAYERS.SCORE.desc(), PLAYERS.PLAYER_ID.asc())
   .seek(949, 15)  // SCORE 949, ID 15 이후의 다음 행들을 가져옴
   .limit(10)
   .fetch();
```

이 쿼리는 점수 949이고 ID가 15인 플레이어 다음의 10명의 플레이어를 가져옵니다. 수천 개의 행을 건너뛸 필요가 없습니다. 데이터베이스는 인덱스를 사용하여 정확한 시작 지점으로 직접 이동할 수 있습니다.

### 키셋 페이지네이션의 장점

1. 오프셋 건너뛰기 비용 제거: 데이터베이스가 불필요한 행을 처리하지 않아도 됩니다.
2. 동시 데이터 변경 처리: 데이터가 추가되거나 삭제되어도 페이지네이션이 안정적으로 동작합니다.
3. 더 나은 사용자 경험: "다음 페이지" 버튼만 있으면 됩니다.
4. 무한 스크롤 패턴과 호환: 현대적인 UI 패턴에 자연스럽게 적합합니다.
5. 일관된 성능: 데이터셋에서의 위치와 관계없이 성능이 일정합니다.

## 그래도 총 개수가 필요하다면?

일부 UI에서는 여전히 총 행 수가 필요할 수 있습니다. 이 경우 윈도우 함수를 사용하여 별도의 쿼리 없이 결과와 함께 총 개수를 얻을 수 있습니다:

```sql
SELECT rental_date, inventory_id, COUNT(*) OVER()
FROM rental
WHERE customer_id = 1
ORDER BY rental_date
LIMIT 10
```

이 쿼리는 페이지네이션된 결과와 함께 총 행 수를 반환합니다. 추가적인 데이터베이스 호출이 필요 없습니다.

### 성능 벤치마크

하지만 `COUNT(*) OVER()`를 사용하면 성능 오버헤드가 발생합니다. PostgreSQL에서의 벤치마크 결과:

- COUNT(*) 없이: 00:00:01.041823 (10,000회 반복)
- COUNT(*) OVER() 포함: 00:00:03.57145 (10,000회 반복)

윈도우 함수가 상당한 계산 오버헤드를 추가하여 약 3.4배 느려졌습니다.

반면 Oracle에서는 이 차이가 훨씬 작았습니다. 약 1% 정도의 성능 차이만 보였는데, Oracle이 이런 종류의 쿼리를 더 잘 최적화하기 때문입니다.

## 결론

OFFSET 페이지네이션은 나쁩니다. 키셋 페이지네이션이 좋습니다.

실제로 98%의 UI에서 정확한 페이지 수, 총 행 수, 또는 임의의 페이지로 점프하는 기능이 필요하지 않습니다. 키셋 페이지네이션을 구현하면 성능과 사용자 경험 모두에서 윈-윈 상황을 만들 수 있습니다.

다음에 페이지네이션을 구현할 때는 스스로에게 물어보세요: "정말로 페이지 번호와 총 개수가 필요한가?" 대부분의 경우 답은 "아니오"입니다. 그리고 키셋 페이지네이션이 더 나은 선택입니다.

## 참고 자료

- [Faster SQL Pagination with jOOQ Using the Seek Method](https://blog.jooq.org/faster-sql-pagination-with-jooq-using-the-seek-method/)
- [Faster SQL Pagination with Keysets, Continued](https://blog.jooq.org/faster-sql-pagination-with-keysets-continued/)
- [use-the-index-luke.com](https://use-the-index-luke.com/) - SQL 성능 및 인덱싱에 대한 훌륭한 자료
