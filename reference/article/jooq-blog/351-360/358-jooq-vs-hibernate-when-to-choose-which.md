# jOOQ vs. Hibernate: 언제 어느 것을 선택할 것인가

> 원문: https://blog.jooq.org/jooq-vs-hibernate-when-to-choose-which/

게시일: 2015년 3월 24일 (2015년 3월 2일)
저자: lukaseder

## 본문

Hibernate는 Java 생태계에서 사실상의 표준이 되었으며, 사후적으로 실제 JavaEE 표준 구현체가 되기도 했습니다. 물론 표준이 중요하고, JCP를 ISO, ANSI, IEEE 등과 동일한 수준에 놓는다면 말입니다.

이 글은 표준을 논하려는 것이 아니라 비전을 논하려는 것입니다. Hibernate는 JPA의 ORM 비전을 공유합니다. jOOQ는 SQL의 강력한 쿼리 비전을 공유합니다. 따라서 논의를 위해 Hibernate / JPA / ORM을 서로 바꿔 사용할 수 있는 것으로 보겠습니다. jOOQ / JDBC / SQL도 마찬가지입니다.

"요즘 왜 Hibernate를 사용하지 않아야 하는가?"라는 질문이 자주 등장하는데, 이는 정확히 Hibernate가 사실상의 표준이고 Grails(GORM을 사용하고, GORM은 다시 Hibernate를 사용함)와 같은 많은 다른 프레임워크에서 첫 번째 프레임워크 선택지이기 때문입니다.

그러나 Hibernate의 창시자인 Gavin King조차도 Hibernate가 모든 것에 사용되어야 한다고 믿지 않습니다.

그렇다면, 언제 ORM을 사용하고 언제 SQL을 사용해야 하는지 고려할 수 있는 객관적인 결정 포인트가 있을까요?

## 높은 수준에서 논의하기

먼저, 이 논의를 더 높은 수준으로 끌어올려 봅시다. Hibernate와 jOOQ라는 구체적인 구현체 사이에서 결정하는 대신, ORM과 SQL, 그리고 그들의 서로 다른 사용 사례에 대해 생각해 봅시다.

ORM(예: Hibernate)과 SQL(예: jOOQ) 사이에서 결정할 때, 스스로에게 물어야 할 핵심 질문은 프로젝트 복잡성에 대한 질문이 아닙니다. 우리의 가장 까다로운 고객 중 일부는 수천 개의 테이블/뷰가 있는 중간 규모의 스키마에서 jOOQ를 사용하고 있습니다. 종종 이러한 스키마는 극도로 정규화되어 있고 때로는 최대 6개의 서로 다른 RDBMS에 배포되기도 합니다. jOOQ는 단순한 사용 사례도 염두에 두면서 이러한 시나리오에서 작동하도록 특별히 설계되었습니다.

따라서 프로젝트 복잡성에 대해 생각하는 대신, 다음 질문들을 스스로에게 해보세요:

### 질문 1: 데이터 모델 vs. 애플리케이션 설계

데이터 모델이 애플리케이션 설계를 주도할 것인가, 아니면 애플리케이션 설계가 데이터 모델을 주도할 것인가?

여기서 주요 측면은 데이터베이스가 애플리케이션보다 오래 살아남을 수 있다는 의미에서 데이터베이스를 "중요하게 여기는지"에 대한 질문입니다. 매우 자주, 애플리케이션은 왔다가 사라집니다. 5년 후에 Python / JavaScript 등으로 다시 작성될 수도 있습니다. 또는 동일한 데이터베이스에 접근하는 여러 애플리케이션이 있을 수 있습니다: Java 애플리케이션, 일부 Perl 스크립트, 저장 프로시저 등. 이 경우 데이터베이스 설계가 프로젝트에서 우선순위가 되며, jOOQ는 이러한 설정에서 매우 잘 작동합니다.

데이터베이스를 "중요하게 여기지" 않는다면, 즉 Java 도메인을 어딘가에 "영속화"하고 싶고 그것이 관계형 데이터베이스인 경우, Hibernate가 더 나은 선택일 수 있습니다. 적어도 프로젝트 초기 단계에서는 Entity 모델에서 데이터베이스 스키마를 쉽게 생성할 수 있기 때문입니다.

### 질문 2: 읽기 vs. 쓰기 복잡성

주로 복잡한 읽기와 단순한 쓰기를 할 것인가, 아니면 복잡한 쓰기에 관여할 것인가?

SQL은 읽기가 복잡할 때 정말 빛을 발합니다. 많은 테이블을 조인할 때, 데이터베이스에서 데이터를 집계할 때, 리포팅을 할 때, 대량 읽기 및 쓰기를 할 때 말입니다. 데이터를 집합론의 관점에서, 예를 들어 데이터를 전체로 생각합니다. 하지만 SQL로 CRUD를 작성하는 것은 지루합니다. 이것이 jOOQ가 단일 테이블에서 작업할 때 지루한 부분을 처리하는 ActiveRecord 스타일 API도 제공하는 이유입니다.

그러나 쓰기가 복잡해진다면, 즉 20개의 엔티티가 관련된 복잡한 객체 그래프를 메모리에 로드하고, 낙관적 잠금을 수행하고, 여러 가지 다른 방식으로 수정한 다음 한 번에 다시 영속화해야 한다면, SQL / jOOQ는 도움이 되지 않을 것입니다. 이것이 Hibernate가 원래 만들어진 목적입니다.

## 견해

저는 데이터는 영원하다고 믿습니다. 항상 데이터베이스가 애플리케이션보다 오래 살아남는다고 가정해야 합니다. 데이터베이스를 마이그레이션하는 것보다 애플리케이션의 (일부를) 다시 작성하는 것이 훨씬 쉽습니다. 깨끗하고 잘 설계된 데이터베이스 스키마를 갖는 것은 프로젝트 라인을 따라, 특히 복잡한 프로젝트에서 항상 성과를 거둘 것입니다.

또한, 대부분의 프로젝트는 정말로 90%의 읽기와 10%의 쓰기를 수행하며, 쓰기는 종종 복잡하지 않습니다(트랜잭션 내에서 2-3개의 테이블 수정). 이는 대부분의 경우 Hibernate / JPA의 1차 및 2차 캐시로 해결되는 복잡성이 필요하지 않다는 것을 의미합니다. 사람들은 종종 이러한 기능을 오해하고 단순히 캐싱을 끄고, Hibernate의 캐시를 항상 서버로 플러시하여 Hibernate를 잘못된 방식으로 사용합니다.

그러나 위의 두 가지 결정 축에 대해 확신이 없다면, 중간 길을 선택하여 jOOQ를 리포팅, 배치 처리 등에만 사용하고 Hibernate를 CRUD에 사용할 수 있습니다. CQRS(Command Query Responsibility Segregation) 스타일로 말입니다. 이 경로를 선택한 jOOQ 사용자들도 꽤 있습니다.

## 추가 읽을거리

- Throughput vs. Complexity – When should I use an ORM? by Mike Hadlow
- Why should you use an ORM? by Bill Karwin
- Are there any good reasons not to use an ORM? on Stack Overflow
- Why should you use an ORM? on Stack Overflow

태그: hibernate, jooq, ORM, sql
