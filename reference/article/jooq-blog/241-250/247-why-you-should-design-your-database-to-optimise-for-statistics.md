# 통계 최적화를 위해 데이터베이스를 설계해야 하는 이유

> 원문: https://blog.jooq.org/why-you-should-design-your-database-to-optimise-for-statistics/

## 핵심 문제

데이터베이스 옵티마이저(Optimizer)는 쿼리 비용을 추정하기 위해 통계(Statistics)에 의존합니다. 데이터가 옵티마이저의 가정을 위반하는 방식으로 인코딩되면, 카디널리티(Cardinality) 추정이 심각하게 부정확해지고, 통계가 최신 상태임에도 불구하고 잘못된 실행 계획이 수립됩니다.

## 트랜잭션 금액 예제

은행 거래의 종형 분포(Bell-curve Distribution)를 사용하여, 동일한 범위 크기(4000 단위)를 가진 두 조건이 매우 다른 비율의 행을 선택할 수 있음을 보여줍니다. 하나는 데이터의 95%를 가져오고, 다른 하나는 2-3%만 가져옵니다. 통계는 옵티마이저가 이 차이를 인식하는 데 도움을 줍니다.

## YEAR_MONTH 인코딩 사례 연구

이 글에서는 시간 데이터를 위한 네 가지 인코딩 전략을 비교합니다:

1. DATE 타입 - 해당 월의 첫 번째 날 저장 (예: 2016-12-01)
2. VARCHAR2 문자열 - 사람이 읽기 쉬운 형식 (예: '201612')
3. NUMBER 인코딩 - 직접적인 숫자 표현 (예: 201612)
4. NUMBER 연속형 - 기준 시점(Epoch)부터의 개월 수 (예: 2016년 12월의 경우 564)

### 성능 결과

2016년 12월부터 2017년 1월까지 쿼리할 때, 문자열과 숫자 인코딩은 통계가 최신 상태임에도 불구하고 풀 테이블 스캔(Full Table Scan)을 수행했습니다. 반면 DATE와 연속형 인코딩은 인덱스를 올바르게 사용했습니다.

왜 그럴까요? "문자열 표현은 나쁩니다. 균일하게 분포되어야 하는 경우에도 실제로는 균일하게 분포되지 않기 때문입니다."

문자열과 숫자 방식은 유효한 값 사이에 간격을 만듭니다('2016aa' 같은 값은 존재하지 않음). 이로 인해 히스토그램(Histogram) 기반 통계가 혼란스러워집니다. DATE 타입의 균일한 간격과 연속형 인코딩의 간격 없는 특성은 모두 통계 정확도를 유지합니다.

## 권장 사항

- 기본 DATE 또는 TIMESTAMP 타입을 선호하세요
- 유닉스 타임스탬프(Unix Timestamp)와 같은 기준 시점 기반 숫자 인코딩을 고려하세요
- 가독성이 좋음에도 불구하고 문자열 표현은 피하세요
- 기억하세요: "때로는 데이터를 읽는 사람보다 기계가 작업을 수행하는 것을 돕는 데 더 집중해야 합니다. 후자는 여전히 UI에서 처리할 수 있습니다."

## 결론

근본적인 원칙은 데이터 구조 선택이 현대의 비용 기반 옵티마이저(Cost-based Optimizer)가 지능적인 실행 결정을 내릴 수 있는지 여부에 큰 영향을 미친다는 것입니다.
