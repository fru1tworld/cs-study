# 모든 사람이 연산자 오버로딩을 싫어하는 이유

> 원문: https://blog.jooq.org/why-everyone-hates-operator-overloading/

작성자: lukaseder
작성일: 2014년 2월 10일 (2015년 5월 26일 업데이트)

우리는 Perl이 연산자 오버로딩을 사용하여 코드를 읽기 어렵게 만드는 방식에 대해 모두 알고 있습니다. 우리는 누구나 Perl 유머 페이지에서 "Perl 6 설계하기"라는 유명한 이미지를 본 적이 있습니다.

하지만 모든 사람이 동의하지는 않습니다. C++가 처음으로 연산자 오버로딩을 도입했고, 그것은 Scala에도 반영되었습니다. 이에 대해 상반된 의견이 있습니다:

- "Scala는 연산자 오버로딩을 올바르게 구현했다"
- "Scala는 연산자 오버로딩을 잘못 구현했다"

## 좋은 사용 사례: 복소수

우선 좋은 사용 사례를 살펴보겠습니다. 복소수에 대한 덧셈과 곱셈을 연산자 오버로딩을 통해 구현하면 다음과 같습니다:

```scala
class Complex(val real:Int, val imaginary:Int) {
    def +(operand:Complex):Complex = {
        new Complex(real + operand.real,
                    imaginary + operand.imaginary)
    }
    def *(operand:Complex):Complex = {
        new Complex(real * operand.real -
                    imaginary * operand.imaginary,
            real * operand.imaginary +
            imaginary * operand.real)
    }
}
```

사용 예시:

```scala
val c1 = new Complex(1, 2)
val c2 = new Complex(2, -3)
val c3 = c1 + c2
val res = c1 + c2 * c3
```

이것은 꽤 괜찮아 보입니다. 수학적 연산을 표현하는 데 있어 연산자 오버로딩이 코드의 가독성을 높여줍니다.

## 문제점: 임의의 기호들

그러나 문제는 사람들이 이상한 구두점 기호들을 만들어내기 시작할 때 발생합니다. `->`, `||=`, `++=`, `<=`, `_._`, `::`, `:+=` 같은 것들 말입니다. Scala 그래프 라이브러리를 예로 들면, `~%#+>` 같은 기호들이 사용되는데, 이는 코드를 거의 이해할 수 없게 만듭니다.

사람들이 이런 식으로 연산자 오버로딩을 사용하면, 코드는 그야말로 미쳐 날뛰게 됩니다. 이것이 바로 모든 사람이 연산자 오버로딩을 싫어하는 이유입니다.

## 연산자 오버로딩이 동작해야 하는 방식

자바 개발자라면 `BigDecimal`에 대한 더 나은 상호작용을 원할 것입니다:

현재 방식:
```java
bigdecimal1.add(bigdecimal2.multiply(bigdecimal3));
```

원하는 방식:
```java
bigdecimal1 + bigdecimal2 * bigdecimal3
```

이것이 연산자 오버로딩이 유용할 수 있는 실질적인 사례입니다. 그렇다면 어떻게 하면 연산자 오버로딩을 올바르게 구현할 수 있을까요?

## Kotlin의 구현

Kotlin은 아마도 가장 좋은 표준 연산자 오버로딩 메커니즘을 구현한 언어일 것입니다. Kotlin에서 연산자는 예측 가능한 방식으로 특정 메서드 이름에 매핑됩니다:

이항 연산:
| 표현식 | 변환되는 메서드 |
|--------|----------------|
| `a + b` | `a.plus(b)` |
| `a - b` | `a.minus(b)` |
| `a * b` | `a.times(b)` |
| `a / b` | `a.div(b)` |
| `a % b` | `a.mod(b)` |
| `a..b` | `a.rangeTo(b)` |

배열 접근:
| 표현식 | 변환되는 메서드 |
|--------|----------------|
| `a[i]` | `a.get(i)` |
| `a[i, j]` | `a.get(i, j)` |
| `a[i] = b` | `a.set(i, b)` |

메서드 호출:
| 표현식 | 변환되는 메서드 |
|--------|----------------|
| `a(i)` | `a.invoke(i)` |
| `a(i, j)` | `a.invoke(i, j)` |

이러한 방식은 연산자 오버로딩의 이점을 제공하면서도, Perl이나 Scala에서 볼 수 있는 기호적 혼란을 방지합니다. Ceylon, Groovy, Xtend도 연산자 오버로딩을 합리적으로 구현했지만, Kotlin이 가장 훌륭한 표준 연산자 오버로딩 메커니즘을 달성했습니다.

## 결론

연산자 오버로딩 자체가 나쁜 것은 아닙니다. 문제는 그것을 어떻게 구현하느냐에 달려 있습니다. 언어가 임의의 기호 조합을 허용하면 혼란이 발생합니다. 하지만 Kotlin처럼 연산자를 예측 가능한 메서드 이름에 매핑하면, 가독성의 이점을 얻으면서도 기호적 혼란을 피할 수 있습니다.

Java가 미래 버전에서 Kotlin 스타일의 연산자 오버로딩을 채택하기를 바랍니다. 이것은 연산자가 예측 가능한 방식으로 일반적인 메서드 이름에 매핑되는 방식으로, "Java에 연산자 오버로딩을 도입하려는 다른 모든 종류의 욕구"를 영원히 제거할 수 있을 것입니다.

어떤 도구든 잘못 사용하면 남용될 수 있습니다. 연산자 오버로딩도 마찬가지입니다. 핵심은 언어가 남용을 방지하면서도 유용한 기능을 제공하는 것입니다.
