# 흥미로운 Java 언어 기능과 그것이 만든 미묘한 버그

> 원문: https://blog.jooq.org/a-curious-java-language-feature-and-how-it-produced-a-subtle-bug/

Java의 가시성 규칙은 때때로 까다롭습니다. 다음 코드가 무엇을 출력할지 아시나요?

```java
package p;

import static p.A.x;

class A {
    static String x = "A.x";
}

class B {
    String x = "B.x";
}

class C {
    String x = "C.x";

    class D extends B {
        void m() {
            System.out.println(x);
        }
    }
}

public class X {
    public static void main(String[] args) {
        new C().new D().m();
    }
}
```

정답은 다음과 같습니다:

```
B.x
```

슈퍼 타입 B의 멤버가 둘러싸는 타입 C의 멤버를 숨기고, 이는 다시 A의 정적 임포트를 숨깁니다.

이것이 바로 Java에서 멤버 가시성이 해결되는 순서입니다:

1. 슈퍼 타입의 멤버
2. 둘러싸는 타입의 멤버
3. 정적 임포트

## 버그가 발생하는 방식

문제는 가시성을 수정할 때 발생합니다. `B.x`를 `private`으로 변경하면:

```java
class B {
    private String x = "B.x"; // 이제 private
}
```

이제 출력은 다음과 같이 변경됩니다:

```
C.x
```

`B.x`가 `private`이 되면, D의 메서드 `m()`에서 접근할 수 없게 됩니다. 해결 순서가 바뀌어서 이제 둘러싸는 타입의 멤버가 정적 임포트를 숨기게 됩니다.

내부 클래스나 그 메서드에는 아무런 변경도 하지 않았는데, 출력이 `B.x`에서 `C.x`로 변경되었습니다!

## 더 나아가서

추가적인 수정 - `C.x`를 `C.xOld`로 이름 변경 - 을 하면 둘러싸는 멤버가 완전히 제거되어, 정적 임포트만 가시적으로 남게 됩니다:

```java
class C {
    String xOld = "C.x"; // x를 xOld로 이름 변경

    class D extends B {
        void m() {
            System.out.println(x);
        }
    }
}
```

이제 출력은 다음과 같습니다:

```
A.x
```

## 실제 위험

무언가를 덜 가시적으로 만드는 것은 위험합니다. 왜냐하면 하위 타입이 그것에 의존하고 있었을 수 있지만, 어떤 우연의 일치로 인해 덜 "중요한" 스코프에 같은 이름의 다른 멤버가 있었고 그것이 이제 뛰어들기 때문입니다.

이 미묘함은 대규모 코드베이스에서 중요합니다. 개발자가 하위 타입 의존성을 고려하지 않고 멤버 가시성을 수정하거나, 정적 임포트를 리팩토링할 때, 다른 클래스들이 우연한 섀도잉을 통해 조용히 다른 멤버에 접근할 수 있습니다.

## 권장사항

1. 클래스를 final로 만들 수 있다면, 아무도 그것을 상속받아 새로 추가한 멤버로부터 우연히 "이득"을 얻지 못할 것입니다.

2. 멤버의 가시성을 변경할 때마다, 우연히 같은 이름을 가진 잠재적 멤버들에 대해 매우 주의하세요.

가시성 해결 순서는 다음과 같습니다: 슈퍼타입 멤버 > 둘러싸는 타입 멤버 > 정적 임포트

이것은 Java의 스코프 규칙이 리팩토링 중에 조용한 동작 변경에 취약한 취약한 코드를 어떻게 만들 수 있는지를 보여줍니다.
