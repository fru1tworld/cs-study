# 기본 프로그래밍 패턴: 먼저 필터, 나중에 맵

> 원문: https://blog.jooq.org/a-basic-programming-pattern-filter-first-map-later/

이것은 프로그래밍에 있어 매우 기본적이고 중요한 최적화 원칙입니다. 그리고 놀랍게도 많은 개발자들이 이 원칙을 간과합니다.

## 문제점

다음과 같은 코드를 본 적이 있을 것입니다:

```java
hugeCollection
    .stream()
    .map(e -> superExpensiveMapping(e))
    .collect(Collectors.toList())
    .subList(0, 2);
```

이 코드에서 무엇이 잘못되었을까요? `hugeCollection`이 매우 큰 컬렉션이고, `superExpensiveMapping()`이 비용이 많이 드는 연산이라고 가정해 봅시다. 이 코드는 컬렉션의 모든 요소에 대해 비싼 매핑 연산을 수행한 다음, 결과 리스트에서 처음 2개의 요소만 가져옵니다.

이것은 O(N) 복잡도를 가지지만, 실제로는 O(1)이어야 합니다!

## 해결책

연산의 순서를 바꾸면 됩니다. 먼저 필터링(또는 제한)하고, 나중에 매핑하세요:

```java
hugeCollection
    .stream()
    .limit(2)
    .map(e -> superExpensiveMapping(e))
    .collect(Collectors.toList());
```

이제 비싼 변환 연산은 실제로 필요한 요소에 대해서만 실행됩니다. 우리는 처음 2개의 요소만 필요하므로, 2개의 요소에 대해서만 매핑을 수행합니다. 나머지 거대한 컬렉션의 요소들은 전혀 처리되지 않습니다.

## 이것이 중요한 이유

알고리즘 복잡도를 줄이는 것은 거의 절대로 조기 최적화가 아닙니다. 데이터셋이 커질수록, 잘못된 복잡도는 _항상_ 문제를 일으킵니다.

SQL은 선언적 언어이며, 쿼리 옵티마이저가 이것을 자동으로 올바르게 처리합니다. SQL에서 WHERE 절(필터링)은 SELECT 연산(변환) 전에 적용됩니다. 이것이 바로 SQL 옵티마이저가 하는 일입니다 - 데이터를 가능한 한 빨리 줄이고, 그 다음에 변환을 적용합니다.

하지만 Java Streams와 같은 명령형/함수형 프로그래밍에서는 개발자가 이 원칙을 수동으로 적용해야 합니다. 스트림 API는 여러분이 작성한 순서대로 연산을 실행합니다.

## 핵심 요점

먼저 필터, 나중에 맵(Filter First, Map Later)

이 보편적인 원칙은 SQL과 명령형 프로그래밍 모두에 적용됩니다. 이렇게 하면 궁극적으로 버려질 데이터에 대한 불필요한 계산 리소스 낭비를 방지하고, 데이터셋이 커져도 시스템이 성능을 유지할 수 있습니다.

`filter()`, `limit()`, `distinct()`, `takeWhile()` 등의 연산을 `map()`, `flatMap()` 같은 변환 연산보다 먼저 배치하는 습관을 들이세요. 이것은 단순한 마이크로 최적화가 아니라, 확장 가능한 코드를 작성하기 위한 기본 원칙입니다.
