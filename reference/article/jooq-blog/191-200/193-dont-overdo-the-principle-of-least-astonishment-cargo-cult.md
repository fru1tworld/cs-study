# "최소 놀라움의 원칙" 카고 컬트를 과도하게 적용하지 마라

> 원문: https://blog.jooq.org/dont-overdo-the-principle-of-least-astonishment-cargo-cult/

2017년 7월 18일, lukaseder 작성

---

우리 모두 동의하듯이, GOTO는 악이다, 맞지 않은가? (관련 XKCD 참조)

## 물론, GOTO는 악이 아니다

물론, 우리의 전문적인 자아 깊은 곳 어딘가에서, GOTO가 악이 아니라 초기 어셈블리 코드 시대부터 존재했던 매우 기본적인 프로세서 명령어라는 것을 알고 있다. GOTO는 어디에나 있다. 예를 들어 다음 Java 코드를 보자:

```java
public class Goto {
    public static void main(String[] args) {
        if (args.length == 0)
            System.out.println("No args");
        else
            System.out.println("Args");
    }
}
```

위 로직에서 생성되는 바이트코드는 다음과 같다:

```
// Method descriptor #15 ([Ljava/lang/String;)V
// Stack: 2, Locals: 1
public static void main(java.lang.String[] args);
   0  aload_0 [args]
   1  arraylength
   2  ifne 16
   5  getstatic java.lang.System.out : java.io.PrintStream [16]
   8  ldc  [22]
  10  invokevirtual java.io.PrintStream.println(java.lang.String) : void [24]
  13  goto 24
  16  getstatic java.lang.System.out : java.io.PrintStream [16]
  19  ldc  [30]
  21  invokevirtual java.io.PrintStream.println(java.lang.String) : void [24]
  24  return
```

두 개의 점프가 있다. 바이트코드는 (어셈블리 코드처럼) 로컬 스코프 중첩에 대해 아무것도 모른다. 명령어 스트림만 있고 우리는 그 사이를 점프한다. 만약 Java에서 `goto`가 가능하다면(키워드는 예약되어 있으니, 미래의 Java에서 어떻게 될지 누가 알겠는가...?), 우리는 이렇게 작성할 수 있을 것이다:

```java
public class Goto {
    public static void main(String[] args) {
        if (args.length != 0)
            goto args;

        System.out.println("No args");
        goto end;

        args:
        System.out.println("Args");

        end:
        return;
    }
}
```

물론, `if-else` 구조가 더 읽기 쉽고 오류가 적다. 과거 진정한 `GOTO` 명령어에서 겪었던 가장 큰 문제 중 일부는 스파게티 코드로 이어지는 경향이 있다는 것이다. 특히, "args 문"에서 "end 문"으로 점프하지 않는 것을 주목하라. 우리는 "나쁜" switch 문처럼 그냥 "폴스루(fall through)"한다:

```java
switch (i) {
    case 1:
    case 2:
        System.out.println("1 or 2");
        // break 없음
    case 3:
        System.out.println("3 (or 1 or 2!)");
}
```

이렇게 보면, switch 문은 `GOTO` 명령어 집합과 매우 유사하다.

---

## 오늘날의 논쟁은 가독성에 관한 것이지, 실행 가능성에 관한 것이 아니다

"고전적인" GOTO에 대한 반대 주장은 정확성을 위한 주장이다. 그러나 요즘에는 더 이상 코드를 16KB RAM에 짜맞출 필요가 없고, 이러한 문제들은 과거의 문제다. 그래서 우리는 "모범 사례"에 따라 코드를 "엔지니어링"하기 시작했고, 대부분은 기계보다 인간과 더 관련이 있다. 더 높은 형태의 제어 흐름 추상화가 있으므로 실제로 더 이상 "GOTO"가 필요하지 않다. Java에는 레이블 문(labelled statements)과 `break` 및 `continue` 문 형태로 "GOTO"가 있다. 예를 들어:

앞으로 점프

```java
label: {
  // 작업 수행
  if (check) break label;
  // 더 많은 작업 수행
}
```

바이트코드:

```
2  iload_1 [check]
3  ifeq 6          // 앞으로 점프
6  ..
```

뒤로 점프

```java
label: do {
  // 작업 수행
  if (check) continue label;
  // 더 많은 작업 수행
  break label;
} while(true);
```

바이트코드:

```
 2  iload_1 [check]
 3  ifeq 9
 6  goto 2          // 뒤로 점프
 9  ..
```

최근에 나는 모든 것을 메서드로 추출하는 것에 반대하는 주장을 하면서 레이블 문에 대해 블로그에 글을 썼다. 왜? 레이블 문이 로컬 "메서드"를 만드는 (약간 특이한) 방법이기 때문이다. 잠시 눈을 가늘게 뜨고 이것에 대해 상상력을 발휘해 보라:

| 레이블 문 | 메서드 |
|---|---|
| 레이블 이름 | 메서드 이름 |
| 레이블 이전의 로컬 변수 | 메서드 인수 |
| Break 문 | Return 문 |
| Continue 문 | 재귀 (기억하라: 눈을 가늘게) |

따라서 위를 인정한다면, Java의 레이블 문은 거의 일회성 로컬 메서드와 같다(오, Java에 실제 로컬 메서드가 있었으면 얼마나 좋을까). `GOTO`처럼 잘못될 위험이 없다. 여전히 로컬 중첩 스코프가 있고 모든 것이 잘 정의되어 있기 때문에 잘못된 위치로 점프하는 사고의 위험이 없다. 따라서 레이블 문 사용에 대한 정확성 논쟁은 없다.

---

## 최소 놀라움의 원칙

왜 더 자주 사용되지 않을까? 아마도 레이블 문이 정말 유용해지는 그런 복잡한 명령형 코드를 거의 작성하지 않기 때문일 것이다. 나는 가끔 그렇게 한다, 특히 jOOQ의 파서 로직 내부에서. 레이블이 있는 continue는 내부 루프에서 벗어나 외부 루프를 계속하는 데 특히 유용하다. 레이블이 있는 break는 덜 일반적으로 유용하다. 보통 if-else 분기를 더 읽기 쉬운 버전으로 리팩토링하는 것(예: if와 else를 반전시키는 것)이 break로 벗어나는 것보다 쉽다. 하지만 때로는 break _가_ 더 읽기 쉬운 버전이다. 예를 들어 각 분기가 같은 수준의 들여쓰기에 있는 더 일관된 들여쓰기로 이어지기 때문이다.

메서드와의 비유를 기억하는가? Break는 return과 같다. 메서드에서 일찍 반환하고 싶을 때마다 문에서 일찍 break할 수 있다. 왜 안 되겠는가? 매번 새 메서드여야 하나? 절대 아니다. 때로는 메서드로 점프하는 것이 로컬로 점프하는 것보다 더 산만하다(다시 말하지만, Java에 로컬 메서드가 없는 한).

여기서 중요한 점은 단순함과 가독성은, 아름다움처럼, 보는 사람의 눈에 달려 있다는 것이다. 무언가가 옳고 그른지 명확하게 말할 수 없는 영역에 있다. 더 좋거나 나쁘거나. 왜냐하면 다시 말하지만, `GOTO`와 달리 레이블 문에서 break하는 것은 정확성 위험이 없기 때문이다.

그래서 사람들은 "최소 놀라움의 원칙"(특히 내 게시물의 DZone 버전 댓글에서)을 찬성하며 주장하기 시작한다. 물론이다. 레이블이 있는 break는 우리 코드에서 거의 볼 수 없기 때문에 읽기가 조금 더 어렵다. 그렇다고 나쁜 것은 아니다. 요즘에는 `synchronized`를 거의 사용하지 않는다(JDK 라이브러리 지원이 훨씬 좋아졌으니까), 하지만 그렇다고 `synchronized`가 나쁘고 사용해서는 안 된다는 것은 아니다. 드물기 때문에 놀랄 수 있다.

우리는 보통 예외를 제어 흐름 신호로 사용하지 않지만, 왜 안 되겠는가? 최소 놀라움의 원칙은 예외를 허용하는 일반적인 지침이라는 것을 상기시키는 것이 중요하다. 결국, 놀라움은 우리가 멈추고 코드에 대해 더 철저하게 생각하게 만드는 것이다. 우리는 레이블 문에서 break할 수 있다는 사실처럼 새로운 것을 배울 수도 있다.

---

## 주요 인용문

"만약 내가 이 원칙의 완고한 노예였다면 vim을 배우지 않았을 것이다. 나는 그것을 휴리스틱처럼 더 많이 볼 것이다" — Ryan James Spencer

"지난 6개월 동안 Mac을 3번만 재시작했는데, 매번 Vim을 안전하게 종료하기 위해서였다." — I Am Developer

"아이디어는 놀라움이 무작위 참신함의 끊임없는 맹공격이 아니라 선별되고 가치 있어야 한다는 것이라고 생각한다" — Chris Martin

---

## 결론

vim 배우기... 프로그래머들이 vim을 종료하는 방법을 모른다는 것은 농담이 되었다. 요점은, 그렇다, 이것은 놀랍고, 경이롭고, 예상치 못한 것이다. vim을 자주 사용하지 않는다면. 자주 사용한다면, 다른 펑키한 IDE 키보드 단축키처럼 당연하다. 또는 거의 모든 프로그램에서 탭을 닫기 위해 마우스 가운데 버튼을 사용하는 것처럼(_그것_은 계시였다).

생산적이기 위해, 우리는 끊임없이 놀라서는 안 된다. 우리는 대부분 기술/인프라 컴포트 존에 있어야 한다, 왜냐하면 우리 대부분은 비즈니스 로직을 작성하고, 인프라 로직이 아니라 그것에 소중한 시간과 뇌 세포를 쓰고 싶기 때문이다. 모든 사람이 SQL을 좋아한다. 아무도 펑키한 JDBC 엣지 케이스를 해결하는 것을 좋아하지 않는다.

여기서 중요한 점은 놀라움은 선별되고 가치 있어야 한다는 것이다. 그것이 이전 기사의 요점이었다. 레이블 문에서 break하는 것은 가끔 멋지다. 매일 복잡한 알고리즘(파서 같은)을 작성하지 않는다면 놀라울 수 있다. 그렇게 한다면 전혀 놀랍지 않다.

그러니, 제발. 열린 마음을 가져라. 카고 컬팅을 멈춰라. 레이블 문을 사용하고 그것에서 break하라. 가끔, 그것이 코드를 더 명확하게 만든다고 생각될 때.
