# jOOQ로 편향된 데이터 쿼리 시 실행 계획 문제를 방지하는 방법

> 원문: https://blog.jooq.org/how-to-prevent-execution-plan-troubles-when-querying-skewed-data-with-jooq/

jOOQ를 사용하는 가장 큰 장점 중 하나는 단 몇 줄의 코드만으로 복잡한 애플리케이션의 모든 생성된 SQL을 변경할 수 있다는 것입니다. 이 글에서는 애플리케이션 코드를 건드리지 않고 일부 일반적인 바인드 피킹(bind peeking) 문제를 해결하는 방법을 살펴봅니다.

## 바인드 값은 어디에 좋은가?

바인드 값(Bind values)이 좋은 점은 기본적으로 세 가지입니다:

1. SQL 인젝션 방지
2. 구문의 정확성 보장
3. 성능 향상 (상용 DBMS의 실행 계획 캐시 활용)

### SQL 인젝션 방지

바인드 파라미터를 사용하면 사용자 입력이 자동으로 이스케이프 처리되어 악의적인 SQL 인젝션 공격을 방지합니다. 사용자 입력을 SQL 문자열에 직접 연결하면 심각한 보안 취약점이 발생합니다.

### 성능과 계획 캐싱

데이터베이스는 SQL 문의 시그니처를 사용하여 실행 계획을 캐시합니다. 동일한 쿼리 구조를 다른 바인드 값으로 재사용하면 캐시를 활용하여 성능이 크게 향상됩니다. 다른 값을 인라인하면 별개의 SQL 문이 생성되어 매번 비용이 많이 드는 계획 재계산을 강제합니다.

바인드 변수는 기본적으로 좋은 것입니다. 왜냐하면 데이터베이스가 실행 계획을 효율적으로 캐시할 수 있게 해주기 때문입니다.

## 바인드 피킹 문제

실행 계획 캐시는 SQL 문자열(또는 그 해시)을 가져와서 가능한 대안 실행 계획과 같은 메타데이터를 연결합니다. SQL 문자열이 변경되면 캐시 조회가 실패하고 "새로운" 쿼리가 다시 계획되어야 합니다.

어떤 경우에는 캐시된 계획이 최적이 아닙니다. 이것은 실제 바인드 값이 계획 수립에 중요한 경우에 해당합니다 - 값 1은 값 2와는 크게 다른 계획을 생성하거나, 더 자주 있는 일로, `DELETED` 값은 `PROCESSED`나 `NEW`와는 다른 계획을 생성합니다.

"바인드 피킹"은 Oracle 데이터베이스가 바인드 변수를 들여다보아 바인드 값을 모를 때의 평균 계획보다 더 정확한 계획을 얻기 위한 기술입니다.

이것은 열거형 타입과 같이 데이터가 편향되어 있을 때 문제가 됩니다. 예를 들어 `ProcessingState`라는 열거형이 있다고 합시다:

- `NEW`
- `PROCESSING`
- `EXECUTED`
- `DELETED`

`PROCESSED` 레코드에 대한 쿼리는 인덱스 사용이 유리할 수 있지만, 1,700만 개 이상의 행을 포함하는 `EXECUTED` 레코드를 검색할 때는 동일한 인덱스를 사용하면 안 됩니다.

## 데이터가 편향되었을 때

모든 데이터가 생각만큼 편향되어 있지는 않지만, 일부 데이터는 거의 항상 편향되어 있습니다: 바로 열거형 타입입니다.

실제 데이터 분포 예시:

| processing_state | 행 수 |
|------------------|-------|
| new | 10,234 |
| processing | 15 |
| executed | 17,581,684 |
| deleted | 83,193 |

하지만 때때로 데이터가 편향되어 있고, 개발자로서 여러분은 아마 그것을 알고 있을 것입니다. 그런 경우에는 때때로 우리가 부르는 "인라인 값"(또는 상수, 리터럴 등)이 옵티마이저가 더 나은 추정을 할 수 있도록 도와주는 더 나은 선택일 수 있습니다.

옵티마이저의 추정이 처음에는 좋더라도, 프로덕션에서 어떤 이상한 이유로 계획이 바뀔 수 있습니다. 캐시가 가득 차서 일부 계획이 제거되거나, DBA가 버튼을 클릭했거나, 등등의 이유로 말입니다. 그때 갑자기 쿼리가 불필요하게 느려질 수 있습니다.

## jOOQ에서 인라인 값 사용하기

기본적으로 jOOQ는 바인드 값을 생성합니다:

```java
ctx.selectFrom(TRANSACTION)
   .where(TRANSACTION.PROCESSING_STATE.eq("processing"))
   .fetch();
```

이것은 다음과 같은 SQL을 생성합니다:

```sql
SELECT * FROM transaction WHERE processing_state = ?
```

`DSL.inline()` 함수를 사용하면 인라인 리터럴 버전을 생성할 수 있습니다:

```java
ctx.selectFrom(TRANSACTION)
   .where(TRANSACTION.PROCESSING_STATE.eq(inline("processing")))
   .fetch();
```

이것은 다음과 같은 SQL을 생성합니다:

```sql
SELECT * FROM transaction WHERE processing_state = 'processing'
```

## 해결책: 커스텀 바인딩

매번 `inline()`을 수동으로 추가하는 대신, 재사용 가능한 `Binding` 구현을 만드는 것이 더 좋습니다.

가장 간단한 접근법(jOOQ 3.15 이상)은 `DefaultBinding`을 확장하는 것입니다:

```java
class AlwaysInlineBinding<T> extends DefaultBinding<T, T> {

    public AlwaysInlineBinding(DataType<T> type) {
        super(DefaultBinding.binding(type));
    }

    @Override
    public void sql(BindingSQLContext<T> ctx) throws SQLException {
        // 바인드 변수 대신 인라인 리터럴로 렌더링
        ctx.render().visit(inline(ctx.value()));
    }

    @Override
    public void set(BindingSetStatementContext<T> ctx) throws SQLException {
        // 바인드 변수를 사용하지 않으므로 구현 불필요
    }
}
```

이 바인딩은 SQL 생성 시 바인드 파라미터를 리터럴 값으로 자동 변환하고, JDBC 파라미터 설정은 건너뜁니다. 플레이스홀더 `?` 마커 대신 생성된 SQL에 리터럴 값을 강제로 삽입하여, 애플리케이션 코드 변경 없이 더 나은 옵티마이저 결정을 가능하게 합니다.

## 구현 및 적용

이 바인딩은 "강제 타입(forced type)" 메커니즘을 사용하여 jOOQ의 코드 제너레이터 설정을 통해 연결됩니다. 이렇게 하면 관련된 모든 스키마 컬럼이 자동으로 이 동작을 사용하도록 보장됩니다.

코드 제너레이터의 강제 타입 설정을 통해 관련 컬럼에 이 바인딩을 연결하면, 쿼리 로직을 수정하지 않고도 전체 애플리케이션에서 일관된 인라인 동작을 보장할 수 있습니다.

열거형 타입이나 유사한 편향된 데이터가 있다면, 위의 간단한 트릭을 적용하고, 스키마에서 의미 있는 모든 곳에 적용한 다음, 이 문제를 영원히 잊어버리세요.

## 데이터베이스의 발전

데이터베이스들은 서서히 진정한 적응형 쿼리 실행 모델로 발전하고 있습니다. 이 모델에서는 추정이 분명히 잘못되었을 때 실행 중에 실행 계획을 수정할 수 있습니다. Db2는 이 부분에서 꽤 강력하고, Oracle도 점점 나아지고 있습니다.

### Oracle의 적응형 커서 공유

Oracle 11g 이상에서는 적응형 커서 공유(Adaptive Cursor Sharing)를 통해 이 문제를 해결합니다. 실제 바인드 값을 기반으로 동일한 SQL_ID에 대해 여러 자식 계획을 생성하여 시간이 지남에 따라 추정을 개선합니다.

## 핵심 요점

기본적으로 바인드 값을 사용하세요. 기본적으로 좋은 것입니다.

바인드 값은 SQL 인젝션 방지를 위한 자동 보호와 쿼리 계획 재사용을 극대화합니다 - 특히 프로덕션 부하에서 중요합니다.

하지만 편향된 데이터가 인라인 리터럴을 필요로 하는 경우를 인식하고, 스키마 레벨에서 체계적으로 해결책을 적용해야 합니다. 열거형 타입의 술어에 전략적으로 인라인을 사용하면 편향된 데이터에서 옵티마이저의 잘못된 계산을 방지할 수 있습니다.
