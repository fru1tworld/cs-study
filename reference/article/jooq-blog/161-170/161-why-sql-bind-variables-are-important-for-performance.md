# SQL 바인드 변수(Bind Variables)가 성능에 중요한 이유

> 원문: https://blog.jooq.org/why-sql-bind-variables-are-important-for-performance/

## 핵심 문제

이 글에서는 중요한 성능 이슈를 다룹니다: 개발자가 동적 SQL에서 바인드 변수를 사용하지 않으면, 데이터베이스는 서로 다른 리터럴 값을 가진 동일한 쿼리를 반복적으로 파싱해야 하며, 이로 인해 효과적인 캐싱이 불가능해집니다.

## 실행 계획 캐싱(Execution Plan Caching)

현대의 데이터베이스들은 이전에 파싱된 SQL 문과 그 실행 계획을 재사용하기 위해 저장하는 실행 계획 캐시(Oracle의 "커서 캐시(cursor cache)")를 유지합니다. 바인드 변수의 근본적인 장점은 데이터베이스가 캐시된 계획을 인식하고 재사용할 수 있게 해준다는 것입니다. 다음 예시를 보겠습니다:

```sql
-- 바인드 변수 없이 - 별도의 캐시 항목 생성
SELECT first_name, last_name FROM actor WHERE actor_id = 1;
SELECT first_name, last_name FROM actor WHERE actor_id = 2;

-- 바인드 변수 사용 - 단일 캐시된 계획 재사용
SELECT first_name, last_name FROM actor WHERE actor_id = ?;
SELECT first_name, last_name FROM actor WHERE actor_id = ?;
```

## 성능 벤치마크

저자의 Oracle 테스트에서 바인드 변수를 사용하지 않을 때 상당한 성능 저하가 나타났습니다:

- 개별 실행 영향: 5번의 벤치마크 실행에서 파라미터화된 방식을 사용한 쿼리가 바인드 변수를 사용하지 않은 쿼리보다 약 2.5배 빠르게 수행되었습니다.
- 시스템 전체 영향: 바인드 변수 없이 20,000개의 서로 다른 리터럴 쿼리를 실행하면 단일 재사용 가능한 항목 대신 약 15,738개의 캐시 항목을 소비하게 되어, 유용한 쿼리가 제한된 캐시 공간에서 제거됩니다.

## 확장성 문제

2,000개의 쿼리를 실행하면 평균 실행 횟수가 약 10회인 2,000개의 개별 캐시 항목이 생성되었습니다. 20,000개의 쿼리를 실행하면 평균 실행 횟수가 약 3.4회에 불과한 15,738개의 항목이 생성되었으며, 이는 심각한 캐시 스래싱(cache thrashing)을 나타내며 시스템 전체 성능을 저하시킵니다.

최악의 경우, 하드코딩된 값을 통해 많은 고유한 쿼리를 생성하면 전체 서버를 다운시킬 수 있습니다.

## 권장 사항

- 균등하게 분포된 값(ID, 타임스탬프, 이름)에 대해서는 기본적으로 항상 바인드 변수를 사용하세요.
- 예외: 매우 적은 수의 고유 값을 가진 상수(불리언 플래그, 상태 코드)는 파라미터화가 필요하지 않을 수 있습니다.
- jOOQ나 Hibernate 같은 프레임워크는 일반적으로 바인드 변수를 자동으로 처리합니다.
- 순수 JDBC와 네이티브 JPA 쿼리는 개발자가 명시적으로 관리해야 합니다.

## 우회 방법

일부 데이터베이스는 자동 적용 옵션을 제공합니다:

- Oracle: `CURSOR_SHARING = FORCE`
- SQL Server: 강제 파라미터화(Forced parametrization)

그러나 이러한 접근 방식은 자체적인 파싱 오버헤드가 발생하며, 애플리케이션 레벨에서 적절히 구현하는 것보다 최적화되지 않습니다.

## 결론

바인드 변수는 단순히 SQL 인젝션을 방지하는 것 이상의 역할을 합니다. 데이터베이스가 실행 계획을 효율적으로 캐싱하고 재사용할 수 있게 해주어 개별 쿼리 성능과 시스템 전체 성능 모두를 향상시킵니다. 특히 많은 고유 값을 가진 컬럼을 조건으로 사용할 때는 반드시 바인드 변수를 사용해야 합니다.
