# SQL로 Tupper의 자기 참조 공식 계산하기

> 원문: https://blog.jooq.org/calculating-tuppers-self-referential-formula-with-sql/

정말 괴짜스러운 월요일 아침을 시작하는 방법은 멋진 Fermat's Library 트위터 계정에 의해 너드 스나이프(nerd-sniped)되는 것입니다:

[Fermat's Library 트윗 - Tupper의 자기 참조 공식에 대한 내용]

Tupper의 자기 참조 공식은 특정 위치에서 그래프를 그리면 자기 자신을 시각적으로 표현하는 공식입니다. 위키피디아에서 더 자세한 정보를 확인할 수 있습니다.

## 공식

공식은 다음과 같습니다:

```
1/2 < floor(mod(floor(y/17)*2^(-17*floor(x)-mod(floor(y), 17)),2))
```

이 구문이 SQL과 호환된다는 것을 눈치채셨나요? 그래서 당연히 "이것이 SQL로 가능한가?™"라는 질문을 해야 했습니다.

## k 상수

이 공식은 `x BETWEEN 0 AND 105`이고 `y BETWEEN k AND k + 16`인 범위에서 플로팅됩니다. 여기서 k는 다음과 같은 임의의 큰 숫자입니다:

```
960939379918958884971672962127852754715004339660129306651505519271702802395266424689642842174350718121267153782770623355993237280874144307891325963941337723487857735749823926629715517173716995165232890538221612403238855866184013235585136048828693337902491454229288667081096184496091705183454067827731551705405381627380967602565625016981482083418783163849115590225610003652351370343874461848378737238198224849863465033159410054974700593138339226497249461751545728366702369745461014655997933798537483143786841806593422227898388722980000748404719
```

## PostgreSQL 구현

자, 대부분의 SQL 데이터베이스는 이렇게 큰 숫자를 처리할 수 없습니다. 하지만 PostgreSQL은 가능합니다! PostgreSQL의 NUMERIC 타입에 대한 문서에 따르면:

> 소수점 앞에 최대 131072자리, 소수점 뒤에 최대 16383자리까지 지원합니다

하지만 기본적으로 PostgreSQL은 이런 정밀도/스케일을 처리할 수 없습니다. 그래서 약간의 트릭을 사용해야 합니다. 다음 쿼리를 살펴보세요:

```sql
WITH
  t1(k, z) AS (
    SELECT
      ('96093937991895888497167296212785275471500433966012930665'
    || '15055192717028023952664246896428421743507181212671537827'
    || '70623355993237280874144307891325963941337723487857735749'
    || '82392662971551717371699516523289053822161240323885586618'
    || '40132355851360488286933379024914542292886670810961844960'
    || '91705183454067827731551705405381627380967602565625016981'
    || '48208341878316384911559022561000365235137034387446184837'
    || '87372381982248498634650331594100549747005931383392264972'
    || '49461751545728366702369745461014655997933798537483143786'
    || '841806593422227898388722980000748404719')::numeric,
      (repeat('0', 2000) || '.'
    || repeat('0', 1000) || '1')::numeric
  ),
  tupper(x, y, b) AS (
    SELECT
      x, y,
      0.5 < floor(mod(floor(y / 17)
              * 2 ^ (-17 * x - mod(y, 17)), 2))
    FROM
      t1,
      LATERAL (
        SELECT z + x AS x
        FROM generate_series(0, 105) t2(x)) t2,
      LATERAL (
        SELECT z + k + y AS y
        FROM generate_series(0, 16) t3(y)) t3
  )
SELECT string_agg(
  CASE WHEN b THEN '@@' ELSE '  ' END, ''
  ORDER BY x DESC)
FROM tupper
GROUP BY y
ORDER BY y ASC;
```

## z 변수의 역할

여기서 `z` 변수는 정밀도 우회를 위한 것입니다. 이것은 다음과 같이 정의됩니다:

```sql
(repeat('0', 2000) || '.' || repeat('0', 1000) || '1')::numeric
```

이것은 매우 작은 소수(본질적으로 소수점 뒤에 1000개의 0이 있는 0.00...01)를 생성합니다. 이 변수는 `x`와 `k` 좌표 모두에 더해져서 PostgreSQL의 기본 1000자리 정밀도 제한을 인위적으로 확장합니다. 이 트릭 없이는 거대한 상수 `k` 값이 PostgreSQL의 기본 숫자 정밀도를 초과하여 계산 시 언더플로우 오류가 발생합니다.

## 실행 결과

이 쿼리는 17비트 너비의 비트맵에 자기 자신을 플로팅할 수 있는 공식을 생성합니다:

```
                @@                                      @@                                @@  @@@@  @@          @@                                @@    @@  @@          @@        @@  @@@@  @@            @@
                @@                                      @@  @@            @@              @@    @@  @@          @@                                @@    @@  @@          @@        @@    @@  @@            @@      @@
@@@@            @@                                    @@    @@            @@        @@@@  @@    @@  @@  @@  @@  @@  @@@@  @@@@@@@@    @@@@@@  @@@@@@  @@    @@  @@  @@  @@        @@    @@    @@            @@    @@
  @@            @@                                    @@    @@    @@  @@  @@              @@  @@    @@    @@    @@        @@  @@  @@  @@  @@  @@  @@  @@    @@  @@  @@  @@        @@  @@      @@            @@    @@
  @@            @@                                    @@    @@    @@  @@  @@              @@  @@    @@  @@  @@  @@        @@  @@  @@  @@@@@@  @@@@@@  @@    @@    @@    @@        @@  @@      @@            @@    @@
  @@            @@                              @@  @@      @@      @@    @@    @@@@                @@          @@                                    @@    @@  @@      @@    @@              @@      @@@@    @@  @@
@@@@@@      @@  @@                              @@  @@      @@    @@      @@  @@    @@              @@          @@                                      @@  @@          @@    @@            @@      @@    @@  @@  @@
          @@    @@  @@@@  @@      @@@@      @@@@@@  @@      @@            @@      @@                @@@@@@  @@@@@@                                      @@  @@@@@@  @@@@@@  @@              @@          @@    @@  @@
@@@@@@  @@      @@  @@  @@  @@  @@    @@  @@    @@  @@      @@  @@@@@@@@  @@    @@                                                                                                                    @@      @@  @@
          @@    @@  @@  @@  @@  @@    @@  @@    @@  @@      @@            @@  @@                                                                                                                    @@        @@  @@
@@@@        @@  @@  @@  @@  @@    @@@@      @@@@@@  @@      @@  @@  @@@@  @@  @@@@@@@@                                                                                                              @@@@@@@@  @@  @@
    @@          @@                                  @@      @@  @@    @@  @@                                                                                                                    @@            @@  @@
  @@            @@                                    @@    @@  @@    @@  @@                                                                                                                    @@          @@    @@
@@              @@                                    @@    @@  @@  @@    @@                                                                                                                  @@            @@    @@
@@@@@@          @@                                    @@    @@  @@  @@    @@                                                                                                                                @@    @@
                @@                                      @@  @@            @@                                                                                                                              @@      @@
                @@@@@@                                  @@  @@@@@@    @@@@@@                                                                                                                              @@  @@@@@@
```

정말 멋지지 않나요!

## 댓글

### Tagir Valeev

> 여기서 k는 다음과 같은 임의의 큰 숫자입니다

"임의의" 숫자라고요 :-)

### Torsten Grust

정밀도 트릭 대신, 거듭제곱에서 언더플로우를 피하는 것이 핵심입니다. 핵심적인 통찰은 다음과 같습니다:

`a * 2^(-17*b)`는 b > 3일 때 0.0으로 평가됩니다.

하지만 `a / 2^(-(-17*b))`는 원하는 대로 평가됩니다.

음수 거듭제곱을 곱하는 대신 나눗셈으로 변환하면 계산 중 숫자 정밀도 손실을 방지할 수 있습니다.

다음은 최적화된 PostgreSQL 구현입니다:

```sql
WITH tupper(x, y, pixel) AS (
  SELECT x, y - :k AS y,
         0.5 < floor(mod(floor(y / 17.0) /
         2^(-(-17 * floor(x) - mod(floor(y), 17))) :: numeric, 2))
  FROM generate_series(0, 105) AS x,
       generate_series(:k, :k+16) AS y
)
SELECT string_agg(CASE WHEN t.pixel THEN '█' ELSE ' ' END,
       NULL ORDER BY t.x DESC) AS "Tupper's Formula"
FROM tupper AS t
GROUP BY t.y
ORDER BY t.y;
```

GitHub gist에서 전체 구현을 확인할 수 있습니다: https://gist.github.com/Teggy/89239f5a61717c890e0bd209a632480e
