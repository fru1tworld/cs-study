# sun.misc.Unsafe 사태가 우리에게 가르쳐 주는 것

> 원문: https://blog.jooq.org/what-the-sun-misc-unsafe-misery-teaches-us/

Oracle은 Java 9에서 내부 클래스인 `sun.misc.Unsafe`를 제거할 예정이다. 대부분의 사람들은 아마 이 변경에 대해 무관심하겠지만, 일부 사람들 - 주로 라이브러리 개발자들 - 은 그렇지 않다. 최근 블로그권에서 이 변경이 의미하는 바에 대해 암울한 그림을 그리는 글들이 몇 개 있었다:

- Dripstat의 "Removal of sun.misc.Unsafe in Java 9 – A disaster in the making"
- Lluis Martinez의 "Removal of sun.misc.Unsafe in Java 9 will break Spring, Hibernate"
- Lucy Carey의 "Will Removal of .Unsafe Trigger Javapocalypse?"
- Rafael Winterhalter의 "Understanding sun.misc.Unsafe"

공개 API를 유지 관리하는 것은 극도로 어려운 일이며, 특히 JDK처럼 인기 있는 API의 경우에는 더욱 그렇다. 사람들이 스스로 발등을 찍는 것을 막을 방법은 (거의) 없다. Oracle(그리고 이전의 Sun)은 _항상_ `sun.*` 패키지들을 _내부용_이며 사용하지 말아야 한다고 선언해왔다. "'sun' 패키지를 호출하는 프로그램을 개발자들이 작성하면 안 되는 이유"라는 페이지에서 인용하면:

> "sun.* 패키지들은 지원되는 공개 인터페이스의 일부가 아닙니다."

`sun.*` 패키지를 직접 호출하는 Java 프로그램은 모든 Java 호환 플랫폼에서 작동한다는 보장이 없다. 사실, 그런 프로그램은 같은 플랫폼의 향후 버전에서조차 작동한다는 보장이 없다.

이 면책 조항은 여러 유사한 면책 조항과 경고들 중 하나에 불과하다. `Unsafe`를 사용하는 사람은 ... "_안전하지 않게(unsafely)_" 사용하는 것이다.

## 우리가 이것에서 배워야 할 점

이 사태를 해결하기 위한 구체적인 방안은 논의 중이며 아직 열려 있다. 좋은 아이디어는 문제가 되는 라이브러리들의 마이그레이션 경로를 허용하기 위해 `Unsafe`를 제거하기 _전에_ 공식적이고 공개적인 대체재를 제공하는 것이다.

하지만 이 모든 것에는 더 중요한 메시지가 있다. 그 메시지는:

> "망치밖에 없으면 모든 문제가 엄지손가락처럼 보인다"

이 상황에 번역하면: 망치는 `Unsafe`이고, 그것이 매우 형편없는 망치이지만 유일한 선택지라는 점을 감안하면, 글쎄, 라이브러리 개발자들은 별로 선택의 여지가 없었을 수도 있다. 그들을 탓할 수는 없다. 사실, 그들은 세계에서 가장 안정적이고 하위 호환성이 좋은 소프트웨어 환경(= Java) 중 하나에서 도박을 했고 10년 넘게 매우 잘 해왔다. 비슷한 상황에서 당신은 다른 선택을 했을까? 아니면, 다르게 물어보자. 당시 AWT나 Swing에 베팅하는 것이 훨씬 더 안전한 선택이었을까?

무언가가 어떻게든 누군가에 의해 사용될 수 있다면, 그것은 사용될 것이다. 그들이 얼마나 명백하게 자신의 발등을 찍을 것인지와 상관없이 말이다. 현재 라이브러리/API를 작성하면서 사용자가 내부에 접근하는 것을 정말로 막을 수 있는 유일한 방법은 모든 것을 단일 패키지에 넣고 모든 것을 package-private으로 만드는 것이다. 이것이 우리가 jOOQ에서 처음부터 해온 것이며, jOOQ의 내부가 극도로 민감하고 항상 변경될 수 있다는 것을 알고 있었기 때문이다.

이 근거에 대한 더 자세한 내용은 다음을 참고하라:

- "Top 5 Use-Cases For Nested Types"
- "Try to make methods final by default (item #9 in the list)" from "10 Subtle Best Practices When Coding Java"

그러나 이 해결책은 그러한 내부를 개발하는 사람들에게 심각한 단점이 있다. 구조가 거의 없는 지옥 같은 패키지가 된다. 이것은 개발을 상당히 어렵게 만든다.

## 그렇다면 더 나은 Java는 어떤 모습일까?

Java는 항상 불충분한 가시성 집합을 가지고 있었다:

- `public`
- `protected`
- `default` (package-private)
- `private`

모듈 "외부"에서의 접근을 방지하면서 `public`처럼 동작하는 다섯 번째 가시성이 있어야 한다. 어떤 면에서 이것은 기존의 `public`과 `default` 가시성 사이에 있다. 저자는 이것을 가상의 `module` 가시성이라고 부른다.

사실, 우리는 클래스나 멤버에 이 가시성을 선언할 수 있어야 할 뿐만 아니라, Ceylon 언어가 허용하는 것처럼 최상위 수준에서 모듈 간 의존성을 관리할 수 있어야 한다:

```
module org.hibernate "3.0.0.beta" {
    import ceylon.collection "1.0.0";
    import java.base "7";
    shared import java.jdbc "7";
}
```

이것은 OSGi의 번들 시스템과 매우 유사하게 읽히며, 번들을 가져오기/내보내기할 수 있지만, 위의 모듈 구문은 OSGi를 구성하는 것보다 훨씬 훨씬 간단하다.

정교한 모듈 시스템은 더 나아갈 것이다. OSGi의 기능에 맞출 뿐만 아니라 Maven의 기능에도 맞출 것이다. Java 언어 모듈 기반으로 의존성을 선언할 수 있는 가능성과 함께, 우리는 더 이상 XML 기반의 Maven 디스크립터가 필요하지 않을 수도 있다. 왜냐하면 그것들은 간단한 모듈 구문(또는 Gradle, 또는 ant/ivy)에서 생성될 수 있기 때문이다.

그리고 이 모든 것이 갖춰지면, `sun.misc.Unsafe`와 같은 클래스들은 전 세계가 아닌 몇몇 JDK 모듈에만 `module` 가시성으로 선언될 수 있을 것이다. 저자는 그러한 내부에 접근하기 위해 리플렉션을 남용하는 사람들의 수가 50%는 줄어들 것이라고 확신한다.

## 결론

저자는 미래의 Java에서 이 Ceylon 언어 기능(그리고 Fantom 언어 기능도)이 Java 언어에 통합되기를 희망한다. Java 9 / Jigsaw의 모듈식 캡슐화에 대한 좋은 개요는 관련 블로그 포스트에서 볼 수 있다.

그때까지, API 설계자라면 모든 면책 조항이 소용없다는 것을 알아라. 당신의 내부 API는 클라이언트에 의해 사용되고 남용될 것이다. 그것들은 당신이 공개한 첫날부터 일반 공개 API의 일부이다. 이것은 당신의 사용자의 잘못이 아니다. 세상이 돌아가는 방식이 그런 것이다.
