# 수천 개의 스레드가 아닌 수백만 개의 파이버에서 데이터베이스 쿼리하기

> 원문: https://blog.jooq.org/querying-your-database-from-millions-of-fibers-rather-than-thousands-of-threads/

"jOOQ는 Java에서 SQL을 다루는 훌륭한 방법이며, Quasar 파이버는 크게 개선된 동시성을 제공합니다"

Parallel Universe의 Fabio Tudone이 작성한 또 다른 매우 흥미로운 게스트 포스트를 jOOQ 블로그에서 발표하게 되어 기쁩니다. Parallel Universe는 개발자들이 JVM에서 극도로 높은 동시성을 가진 애플리케이션을 쉽게 코딩할 수 있게 해주는 오픈소스 스택을 개발합니다. Parallel Universe 스택을 사용하면 프로그래밍 언어와 단순하고 익숙한 프로그래밍 스타일을 유지하면서도, 매 순간 현대 하드웨어와 싸우는 대신 조화롭게 작동하는 소프트웨어를 구축할 수 있습니다.

Fabio Tudone은 Comsat 프로젝트의 일환으로 Quasar 통합 모듈을 개발하고 유지보수합니다. 그는 Parallel Universe 팀에 합류하기 전 수년간 클라우드 기반 엔터프라이즈 콘텐츠 거버넌스 플랫폼의 개발에 참여하고 이끌어왔으며, 전문 경력 전반에 걸쳐 주로 JVM 소프트웨어를 작성해왔습니다. 그의 관심사에는 Dev 및 DevOps 관행, 확장성, 동시성 및 함수형 프로그래밍, 그리고 런타임 플랫폼이 포함됩니다. 자연스럽게 호기심이 많고 탐구를 좋아하며, 사람, 장소, 문화로부터 지식과 이해를 수집하는 것을 즐깁니다. 또한 인식 수련에 관심이 있으며 다양한 글쓰기를 좋아합니다.

Quasar는 Comsat 프로젝트의 일부로 JDBC와 jOOQ에 대한 통합을 제공하므로, 그 내부를 살펴보겠습니다.

## JDBC, jOOQ 그리고 Quasar

comsat-jdbc는 JDBC API의 파이버 블로킹 래퍼를 제공하여 일반 Java 스레드가 아닌 파이버 내에서 커넥션을 사용할 수 있게 해줍니다. 왜 그렇게 하고 싶을까요? 파이버는 경량 스레드이고, 실행 중인 JVM에서 스레드보다 훨씬 더 많은 파이버를 가질 수 있기 때문입니다. "훨씬 더 많이"라는 것은 수천 개 대비 수백만 개를 말하는 것입니다. 이는 JDBC 실행을 기다리는 동안 다른 작업을 병렬로 수행할 수 있는 훨씬 더 많은 동시성 용량이 시스템에 있다는 것을 의미합니다. 동시/병렬 계산(예: 고신뢰성 Quasar Erlang 스타일 액터 시스템에서 액터 메시지 교환)이든, 파이버 블로킹 I/O(예: 웹 요청 처리, 마이크로서비스 호출, 파이버 NIO를 통한 파일 읽기, MongoDB와 같은 다른 파이버 지원 데이터 소스 접근)이든 말입니다.

DB가 감당할 수 있고 몇 개의 추가 일반 스레드가 시스템을 (아직) 폭파시키지 않는다면, 파이버-JDBC 풀을 늘려서 더 많은 동시 jOOQ 명령을 보낼 수도 있습니다.

jOOQ는 데이터베이스에 접근하기 위해 JDBC 커넥션을 사용하므로, 파이버에서 jOOQ를 실행하는 것은 comsat-jooq 의존성을 가져오고 파이버 지원 JDBC 커넥션을 jOOQ 컨텍스트에 전달하는 것만큼 쉽습니다:

```java
import java.sql.Connection;
import static org.jooq.impl.DSL.*;

// ...

Connection conn = FiberDataSource.wrap(dataSource)
                                .getConnection();
DSLContext create = DSL.using(connection);

// ...
```

물론 FiberDataSource에서 커넥션을 가져오도록 ConnectionProvider를 구성할 수도 있습니다. 이 순간부터 일반 jOOQ를 사용할 수 있으며 모든 것이 스레드 블로킹 모드가 아닌 파이버 블로킹 모드로 발생합니다. 그게 전부입니다. 아니, 정말로 그 이상 아무것도 없습니다: 훌륭한 jOOQ를 계속 사용하되, 스레드 대신 훨씬 더 효율적인 파이버와 함께 사용하면 됩니다.

Quasar는 좋은 시민이며 새로운 API를 강요하지 않습니다(특히 원래 API가 이미 훌륭할 때 이것은 좋은 점입니다).

현재 JVM은 네이티브 그린 스레드나 경량 스레드를 구현하는 데 사용할 수 있는 컨티뉴에이션을 지원하지 않으므로, Quasar는 바이트코드 계측을 통해 컨티뉴에이션(그리고 그 위에 파이버)을 구현합니다. 이것은 컴파일 시점에 수행할 수 있지만, 종종 Quasar의 에이전트를 사용하는 것이 더 편리합니다(특히 서드파티 라이브러리를 계측할 때). 다음은 Quasar 에이전트 설정도 포함하는 Dropwizard 기반 예제 Gradle 프로젝트입니다(모든 요구사항에 맞는 정말 훌륭한 Java 배포 도구인 Capsule을 잊지 마세요. 물론 Quasar와 일반적으로 에이전트 사용을 아주 쉽게 만들어줍니다).

예제는 jOOQ의 모든 기능을 사용하지는 않고, SQL 빌딩 사용 사례(쿼리와 CRUD 모두)에 해당하지만, 필요에 맞게 변경하는 것을 권장합니다. without-comsat 브랜치에는 스레드 블로킹 버전이 포함되어 있어 Comsat 버전과 (최소한의) 차이점을 비교할 수 있습니다.

## 대기 줄은 어디에 있는가?

이제 궁금하실 수 있습니다: 좋아요, 하지만 JDBC는 스레드 블로킹 API인데, Quasar는 어떻게 그것을 파이버 블로킹으로 전환할 수 있나요? JDBC에는 비동기 모드가 없기 때문에, Quasar는 내부적으로 스레드 풀을 사용하여 파이버가 JDBC 작업을 디스패치하고, JDBC 작업이 완료되면 파이버가 해동되어 재개를 위해 스케줄링됩니다.

네, 여기에 성가신 대기 줄이 있습니다: 스레드 풀에 의해 실행되기를 기다리는 JDBC 명령들. JDBC 스레드 풀 크기를 넘어서는 DB 병렬성을 개선하지는 않지만, 단순하고 익숙한 블로킹 API를 계속 사용하면서도 파이버에 해를 끼치지 않습니다. 여전히 수백만 개의 파이버를 가질 수 있습니다.

전체적인 상황을 개선하는 것이 가능할까요? 표준 비동기 Java RDBMS API 없이는 우리가 할 수 있는 일이 많지 않습니다. 그러나 데이터베이스가 병목 지점이라면 이것은 전혀 문제가 되지 않을 수 있습니다.

## 보너스: 이 멋진 jOOQ 통합은 내부적으로 어떻게 작동하는가?

현재 Quasar는 개발자(또는 통합자)에게 무엇을 계측할지 알려줄 것을 요구하지만, 완전 자동 계측은 개발 중입니다. 소스 코드(또는 컴파일된 클래스)를 편리하게 변경할 수 있다면 메서드에 @Suspendable 어노테이션을 추가하거나 throws SuspendExecution을 선언하는 것으로 충분하지만, 라이브러리의 경우 보통 그렇게 하기 어렵습니다.

하지만 계측할 잘 알려진 고정된 이름의 메서드들은 META-INF/suspendables와 META-INF/suspendable-supers에 나열할 수 있습니다. 각각 구체적인 메서드와 일시 중단 가능한 구현을 가질 수 있는 추상/인터페이스 메서드를 위한 것입니다. 많은 메서드가 있거나 코드 생성이 관련되어 있다면, SuspendableClassifier를 작성하여 통합과 함께 제공하고 Quasar의 SPI에 등록하여 추가적인 계측 로직을 제공할 수 있습니다.

SuspendableClassifier의 역할은 계측 단계에서 런타임 클래스패스의 모든 메서드에 대한 시그니처 정보를 검사하고, 그것이 일시 중단 가능한지, 일시 중단 가능한 구현을 가질 수 있는지, 확실히 둘 다 아닌지, 또는 알 수 없는지를 알려주는 것입니다(다른 분류기가 나중에 "일시 중단 가능" 또는 "일시 중단 가능-슈퍼"라고 말할 수도 있습니다).

## 마무리

음... 그냥 효율적인 파이버에서 훌륭한 jOOQ를 즐기세요!
