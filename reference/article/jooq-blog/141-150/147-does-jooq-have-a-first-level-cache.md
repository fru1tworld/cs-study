# 자주 묻는 질문: jOOQ에 1차 캐시가 있나요?

> 원문: https://blog.jooq.org/a-frequent-question-does-jooq-have-a-first-level-cache/

JPA에서 jOOQ로 전환할 때 사람들이 가장 자주 묻는 질문 중 하나는 JPA의 1차 캐시를 어떻게 마이그레이션하느냐는 것입니다.

이 글은 Dmitry Gusev가 JPA를 대체하기 위한 jOOQ 가이드와 EntityManager의 merge() 기능 및 1차 캐싱 없이 인메모리 상태를 관리하는 방법에 대해 트위터에서 질문한 것을 참조합니다.

## jOOQ는 주로 JPA 사용자들이 '프로젝션'이라고 부르는 용도로 사용됩니다

JPA만 사용하고 있다면, 가끔 프로젝션을 통해 DTO를 가져온 적이 있을 것입니다. "프로젝션"이라는 용어는 관계 대수학에서 유래했으며, 프로젝션은 단순히 SQL 문의 SELECT 절입니다. 프로젝션은 쿼리 결과가 수정 사항을 데이터베이스에 다시 저장하지 않고 데이터 처리에만 사용될 것임을 알고 있을 때 유용합니다.

프로젝션의 두 가지 장점은 다음과 같습니다:
1. 엔티티에 매핑할 수 없는 것들을 포함하여 임의의 표현식을 프로젝션할 수 있습니다
2. 1차 및 2차 캐시를 포함한 대부분의 엔티티 관리 로직을 우회할 수 있습니다

이렇게 할 때는 SQL을 사용하게 될 것입니다—주로 JPQL(또는 HQL)이 범위가 매우 제한적이기 때문입니다. 이상적으로는 jOOQ를 사용하면 프로젝션 쿼리가 타입 안전하고 벤더에 독립적이 됩니다. jOOQ를 사용해서 쿼리만 빌드하고 JPA로 실행할 수도 있지만, 엔티티를 가져오지 않는 경우 jOOQ가 제공했을 모든 결과 타입 정보를 잃게 됩니다. 프로젝션에 JPA 대신 jOOQ를 사용하는 장점은 명백합니다. JPA를 고수하는 것은 프로젝션 사용 사례가 매우 적고 매우 단순한 경우에만 정당화됩니다.

## jOOQ는 기본적인 CRUD에도 사용될 수 있습니다

이 질문은 SQL이 기본적인 CRUD를 구현하기에 그다지 좋은 언어가 아니라는 점을 암시합니다. "수동으로 CRUD를 작성하기엔 인생이 너무 짧다"(2018년 8월 28일 트윗)라고 말한 바 있습니다.

이것이 의미하는 바는 다음과 같은 개별 문장을 수동으로 표현하는 것이 정말 지루하다는 것입니다:
```sql
INSERT INTO foo (a, b) VALUES (?, ?)
INSERT INTO bar (a, b, c) VALUES (?, ?, ?)
UPDATE baz SET x = ? WHERE id = ?
```

이러한 대부분의 CRUD 작업에서는 단순히 모든 컬럼 또는 주어진 컬럼의 하위 집합을 대상 테이블에 삽입합니다. 또는 해당 테이블에서 변경된 모든 컬럼을 수정합니다. 이러한 문장은 항상 동일하지만, 컬럼을 추가/제거하자마자 깨지므로 애플리케이션 전체에서 수정해야 합니다. Hibernate와 같은 ORM을 사용하면 주석이 달린 메타 모델만 변경하면 되고, 생성된 쿼리는 애플리케이션 전체에서 자동으로 적응합니다. 이것은 엄청난 이점입니다!

### 추가 기능들

Hibernate와 같은 본격적인 ORM은 다음을 포함한 수많은 추가 기능을 제공합니다:
- 엔티티 간의 관계를 매핑하는 방법
- 클라이언트에서 엔티티를 캐시하는 방법

이 두 기능은 애플리케이션이 많은 엔티티가 관련된 복잡한 객체 그래프를 로드, 변형 및 저장하기를 원하는 더 정교한 CRUD 사용 사례에서 매우 유용합니다.

### 이것이 정말 필요한가요?

그러나 단순한 경우에는 jOOQ를 사용하여 명시적으로 1-2개의 엔티티만 로드하고(jOOQ에서는 이를 `UpdatableRecord`라고 부릅니다), 수정한 다음, 데이터베이스에 다시 저장하는 것만으로 충분할 수 있습니다. 이러한 경우에는 클라이언트에서 엔티티를 캐시하거나 클라이언트에서 엔티티 관계를 모델링하는 것이 의미가 없는 경우가 많습니다. 대신 다음과 같은 코드를 작성할 수 있습니다:

```java
// 저자 가져오기
AuthorRecord author = create.fetchOne(AUTHOR, AUTHOR.ID.eq(1));

// 저자가 아직 존재하지 않으면 새로 생성
if (author == null) {
    author = create.newRecord(AUTHOR);
    author.setId(1);
    author.setFirstName("Dan");
    author.setLastName("Brown");
}

// 저자를 "저명한" 저자로 표시하고 저장
author.setDistinguished(1);

// 기존 저자에 대해서는 update를, 새 저자에 대해서는 insert를 실행
author.store();
```

단 하나의 SQL 문도 직접 작성하지 않았다는 점에 주목하세요. 대신, 내부적으로 jOOQ가 필요한 INSERT 또는 UPDATE 문을 생성해 주었습니다. 이것만으로 충분하다면, JPA가 전혀 필요 없으며, jOOQ를 직접 사용하여 더 가벼운 프로그래밍 모델을 사용할 수 있습니다. 다음을 포함한 몇 가지 추가 기능을 사용할 수 있습니다:

- 낙관적 잠금(Optimistic locking)
- RecordListeners (CRUD 생명주기 이벤트 리스너)
- 배치 처리(Batching)

## 결론

결론은, jOOQ로 마이그레이션하면서 JPA의 1차 캐시를 대체하고 싶어서 이 글을 찾아 읽었다면: 마이그레이션을 다시 생각하세요

JPA 전체를 대체할 필요는 없습니다. 더 정교한 기능이 필요하다면, 반드시 jOOQ와 함께 계속 사용하세요. 그러나 더 정교한 기능이 필요하지 않고 위의 jOOQ CRUD 기능으로 충분하다면, 1차 캐시가 필요하다는 생각을 버리고 더 많은 로직을 SQL 쿼리로 옮기는 것을 받아들이세요.
