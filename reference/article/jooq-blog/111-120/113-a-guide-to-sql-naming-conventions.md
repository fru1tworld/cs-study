# SQL 명명 규칙 가이드

> 원문: https://blog.jooq.org/a-guide-to-sql-naming-conventions/

제 생각에 Java의 큰 장점 중 하나는 대부분의 명명 규칙이 언어 창시자들에 의해 확립되어 있다는 점입니다. 예를 들어:

- 클래스 이름은 PascalCase
- 멤버 이름은 camelCase
- 상수는 SNAKE_CASE

누군가 이러한 규칙을 따르지 않으면, 결과 코드는 금방 비관용적으로 보이게 됩니다.

## SQL은 어떨까요?

많은 사람들이 "올바른" 대소문자 표기에 동의하지 않습니다:

> SQL을 어떻게 작성하시나요?

식별자를 소문자로 작성하는 경향이 있는 것 같지만, 키워드의 대소문자에 대해서는 합의가 없습니다. 또한 대부분의 방언에서 사람들은 식별자에 `snake_case`를 선호하지만, SQL Server에서는 `PascalCase`나 `camelCase`를 선호하는 것 같습니다.

이것은 스타일에 관한 것입니다. 댓글에서 스타일과 명명 규칙에 대한 여러분의 의견을 듣고 싶습니다!

## 명명 규칙은 어떨까요?

많은 언어에서 (식별자의) 명명 규칙은 그다지 중요하지 않습니다. 왜냐하면 언어가 네임스페이스를 설계하는 방식 덕분에 충돌의 위험이 상대적으로 적기 때문입니다. SQL에서는 이것이 조금 다릅니다. 대부분의 SQL 데이터베이스는 3-4개 계층의 네임스페이스 집합만 지원합니다:

1. 카탈로그(Catalog)
2. 스키마(Schema)
3. 테이블(또는 프로시저, 타입)
4. 컬럼(또는 파라미터, 속성)

방언에 따른 몇 가지 주의사항:

- SQL Server는 카탈로그와 스키마를 모두 지원하지만, 대부분의 방언은 둘 중 하나만 지원합니다
- MySQL은 카탈로그("데이터베이스")를 스키마로 취급합니다
- Oracle은 스키마와 프로시저 사이에 프로시저를 위한 패키지 네임스페이스를 지원합니다

어쨌든, Java와 같은 언어에 있는 패키지("스키마") 계층 구조와 같은 개념이 없어서 SQL에서의 네임스페이스 지정은 꽤 까다롭습니다. 저장 프로시저를 작성할 때 쉽게 발생할 수 있는 문제가 있습니다:

```sql
FUNCTION get_name (id NUMBER) IS
  result NUMBER;
BEGIN
  SELECT name
  INTO result
  FROM customer
  WHERE id = id; -- 음...

  RETURN result;
END;
```

위에서 볼 수 있듯이, `CUSTOMER.ID` 컬럼과 `GET_NAME.ID` 파라미터 둘 다 한정되지 않은 `ID` 표현식으로 해석될 수 있습니다. 이것은 쉽게 해결할 수 있지만, 항상 생각해야 하는 지루한 문제입니다.

또 다른 예는 테이블을 조인할 때입니다. 아마도 중복된 컬럼 이름이 있을 것입니다:

```sql
SELECT *
FROM customer c
JOIN address a ON c.id = a.customer_id
```

이 쿼리는 두 개의 모호한 ID 컬럼을 생성할 수 있습니다: `CUSTOMER.ID`와 `ADDRESS.ID`. SQL 언어에서는 대부분 한정자를 붙여서 구분하기 쉽습니다. 하지만 클라이언트(예: Java)에서는 적절하게 한정하기가 덜 쉽습니다. 쿼리를 뷰에 넣으면 더욱 까다로워집니다.

## "헝가리안 표기법"

따라서 SQL과 절차적 언어는 어떤 유형의 헝가리안 표기법이 유용할 수 있는 드문 경우입니다. 데이터 타입을 이름에 인코딩하는 헝가리안 표기법 자체와 달리, 이 경우에는 다른 정보 조각을 이름에 인코딩할 수 있습니다. 과거에 매우 유용하다고 느꼈던 규칙 목록은 다음과 같습니다:

1. 의미론적 타입별로 객체에 접두사 붙이기

테이블, 뷰, 그리고 다른 "테이블 형태의 것들"은 서로 빠르게 충돌할 수 있습니다. 특히 Oracle에서는 단순히 스키마를 생성하지 않습니다. 이것이 만들어내는 모든 보안 문제 때문입니다(스키마와 사용자가 거의 같은 것인데, 물론 이것은 미친 짓입니다. 스키마는 사용자와 완전히 독립적으로 존재해야 합니다). 객체 이름에 스키마를 인코딩하는 것이 유용할 수 있습니다:

- `C_TABLE`: `C_` 접두사는 "고객 데이터"를 나타냅니다. 예를 들어 다음과 대조됩니다:
- `S_TABLE`: `S_` 접두사는 "시스템 데이터" 또는 "마스터 데이터"를 나타냅니다
- `L_TABLE`: `L_` 접두사는 "로그 데이터"를 나타냅니다
- `V_VIEW`: `V_` 접두사는 뷰를 나타냅니다
- `P_PARAMETER`: `P_` 접두사는 프로시저 또는 함수 파라미터를 나타냅니다
- `L_VARIABLE`: `L_` 접두사는 로컬 변수를 나타냅니다

게다가, 보안 및 접근 제어를 위해 뷰를 사용할 때, 뷰의 스타일을 나타내는 추가 접두사나 접미사가 있을 수 있습니다:

- `_R`: `_R` 접미사는 읽기 전용 뷰를 나타냅니다
- `_W`: `_W` 접미사는 쓰기 가능한(업데이트 가능한) 뷰를 나타냅니다

이 목록은 명백히 불완전합니다. 이것이 일반적으로 반드시 좋은 것인지 확신이 없습니다. 예를 들어, 패키지, 프로시저, 시퀀스, 제약 조건에도 접두사를 붙여야 할까요? 종종 그것들은 네임스페이스 해석에서 모호성을 유발하지 않습니다. 하지만 때때로 그럴 수 있습니다. 항상 그렇듯이 중요한 것은 규칙 집합에 일관성을 유지하는 것입니다. 따라서 이 관행을 수용하면 모든 곳에 적용해야 합니다.

2. 단수 또는 복수 테이블 이름

누가 신경 쓰나요. 그냥 하나를 선택하고 일관되게 사용하세요.

3. 표준 별칭 설정

과거에 매우 유용하다고 느꼈던 또 다른 기법은 별칭을 붙이는 표준 접근 방식입니다. 예를 들어 다음과 같은 쿼리에서 항상 테이블에 별칭을 붙여야 합니다:

```sql
SELECT *
FROM customer c
JOIN address a ON c.id = a.customer_id
```

하지만 `ACCOUNT`도 조인해야 한다면 어떨까요? 이미 `ADDRESS`에 `A`를 사용했으므로 `A`를 재사용할 수 없습니다. 하지만 모든 쿼리에서 같은 별칭을 재사용하지 않으면 쿼리를 읽기가 약간 혼란스러워지기 시작합니다.

별칭을 사용하지 않고 항상 모든 식별자를 완전히 한정할 수도 있습니다:

```sql
SELECT *
FROM customer
JOIN address ON customer.id = address.customer_id
```

하지만 특히 긴 테이블 이름의 경우 금방 장황해지므로 가독성도 좋지 않습니다. 별칭을 붙이는 표준 접근 방식으로 매우 유용하다고 느꼈던 것은 모든 테이블에 대해 4글자 별칭을 생성하는 이 간단한 알고리즘입니다. Sakila 데이터베이스를 예로 들면 다음을 설정할 수 있습니다:

| 접두사 | 테이블 이름 |
|--------|-----------|
| `ACTO` | `ACTOR` |
| `ADDR` | `ADDRESS` |
| `CATE` | `CATEGORY` |
| `CITY` | `CITY` |
| `COUN` | `COUNTRY` |
| `CUST` | `CUSTOMER` |
| `FILM` | `FILM` |
| `FIAC` | `FILM_ACTOR` |
| `FICA` | `FILM_CATEGORY` |
| `FITE` | `FILM_TEXT` |
| `INVE` | `INVENTORY` |
| `LANG` | `LANGUAGE` |
| `PAYM` | `PAYMENT` |
| `RENT` | `RENTAL` |
| `STAF` | `STAFF` |
| `STOR` | `STORE` |

테이블 이름을 줄이는 알고리즘은 간단합니다:

- 이름에 밑줄이 없으면, 처음 네 글자를 취합니다. 예: `CUSTOMER`는 `CUST`가 됩니다
- 이름에 밑줄이 1개 있으면, 각 단어의 처음 두 글자를 취합니다. 예: `FILM_ACTOR`는 `FIAC`가 됩니다
- 이름에 밑줄이 2개 있으면, 첫 번째 단어의 처음 두 글자와 나머지 단어들의 첫 글자를 취합니다. 예: `FILM_CATEGORY_DETAILS`는 `FICD`가 됩니다
- 이름에 밑줄이 3개 이상 있으면, 각 단어의 첫 글자를 취합니다
- 새 약어가 기존 것들과 충돌하면 실용적인 선택을 합니다

이 기법은 500개 이상의 테이블이 있는 대규모 스키마에서 잘 작동했습니다. `FICD`와 같은 약어가 의미 없다고 생각할 수 있고, 실제로 처음에는 의미가 없습니다. 하지만 이 스키마에 대해 많은 SQL을 작성하기 시작하면 약어를 "배우기" 시작하고 의미 있게 됩니다.

게다가, 조인을 작성할 때뿐만 아니라 모든 곳에서 이러한 약어를 사용할 수 있습니다:

```sql
SELECT
  cust.first_name,
  cust.last_name,
  addr.city
FROM customer cust
JOIN address addr ON cust.id = addr.customer_id
```

뷰나 파생 테이블에서 컬럼에 별칭을 붙일 때도 마찬가지입니다:

```sql
SELECT
  cust.first_name AS cust_first_name,
  cust.last_name AS cust_last_name,
  addr.city AS addr_city
FROM customer cust
JOIN address addr ON cust.id = addr.customer_id
```

이것은 쿼리가 더 복잡해지고(예: 20-30개 조인) 다른 뷰를 선택하는 다른 뷰를 선택하는 뷰 라이브러리에서 많은 컬럼을 투영하기 시작할 때 매우 귀중해집니다. 일관성을 유지하기 쉽고, 다음과 같은 것들을 쉽게 인식할 수 있습니다:

- 주어진 컬럼이 어떤 테이블에서 유래했는지
- 그 컬럼에 사용할 수 있는 인덱스가 있는지 (뷰에 대한 쿼리에서!)
- 같아 보이는 두 컬럼(예: `FIRST_NAME`)이 실제로 같은지

뷰를 광범위하게 사용한다면(과거에 1000개 이상의 뷰가 있는 스키마로 작업한 적이 있습니다), 이러한 명명 규칙은 거의 필수적이라고 생각합니다.

## 결론

SQL을 포함한 어떤 언어에서도 것들에 이름을 붙이는 "올바른" 방법은 실제로 없습니다. 하지만 일부 SQL 방언의 한계나 조인 후 두 이름이 쉽게 충돌할 수 있다는 사실을 고려할 때, 과거에 위의 두 가지 도구가 매우 유용했습니다: 1) 식별자에 객체 타입에 대한 힌트를 접두사로 붙이기, 2) 테이블 별칭에 대한 표준을 설정하고 항상 그에 따라 컬럼 이름에 별칭 붙이기.

jOOQ의 코드 생성기를 사용하면, 뷰에서 생성된 컬럼 이름에 이미 테이블 이름이 접두사로 포함되어 있어서 무엇을 쿼리하고 있는지 쉽게 "볼" 수 있습니다.

여러분 자신의 명명 규칙이 궁금합니다. 댓글 섹션에서 여러분의 의견을 기다리겠습니다!
