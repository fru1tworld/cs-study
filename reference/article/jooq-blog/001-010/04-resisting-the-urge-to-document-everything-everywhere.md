# 모든 것을 어디에나 문서화하려는 충동에 저항하기

> 원문: [Resisting the Urge to Document Everything Everywhere](https://blog.jooq.org/resisting-the-urge-to-document-everything-everywhere/)

모든 제품 관리자는 이런 상황을 알고 있다:

- 사용자가 기능 `X1`을 사용한다.
- 한계 / 버그 / 예상치 못한 동작을 발견하고 이를 우회하고 싶어한다.
- 완벽한 우회 방법이나 대안은 기능 `X2`이지만, `X2`가 존재하는지 모르기 때문에 사용자는 이를 찾지 못하고 많은 시간을 소비한다.
- 사용자는 `X2`를 `X1`에 문서화해 달라고 요청한다. 그렇게 되었더라면 엄청난 시간을 절약할 수 있었을 것이기 때문이다.

이것은 매우 흔한 패턴이며, 이런 사용자가 이러한 요청을 하는 것은 완벽하게 이해할 수 있지만, 이 사용자의 요청에 응하는 것은 매우 잘못된 일이다. 왜 잘못된 것일까?

## 기능들은 서로 관련이 없다

대부분의 경우 두 기능 `X1`과 `X2`는 서로 관련이 없으며, 이 특정 사용자의 상황에서 "우연히" 연결된 것일 뿐이다. jOOQ를 예로 들어보자. `SUM(X)` 집계 함수를 사용한다고 상상해 보자. 역사적인 이유로, 이 함수는 (다른 많은 산술 함수와 마찬가지로) 입력 타입과 관계없이 오버플로가 발생하지 않도록 jOOQ에서 `BigDecimal`을 반환한다. 함수의 시그니처는 다음과 같다:

```java
public static AggregateFunction<BigDecimal> sum(
    Field<? extends Number> field
) { ... }
```

이것이 좋은 것일 수도 있고 아닐 수도 있다. 결국 사람들은 jOOQ의 API에서 제네릭에 익숙하기 때문에, 다음과 같은 시그니처를 선호했을 수도 있다(이 경우 `TINYINT` / `Byte`와 같은 타입에서 오버플로 위험이 있다):

```java
public static <T extends Number> AggregateFunction<T> sum(
    Field<T> field
) { ... }
```

따라서 기능 `X1`은 `SUM(X)`이다. "예상치 못한 동작"은 예상치 못한 타입을 반환할 수 있다는 것이다.

이제 대안적인 시그니처를 선호하는 일부 사용자에게 기능 `X2`는 `coerce()` 함수이다. 이것은 SQL의 `cast()`처럼 작동하지만 생성되는 SQL에 영향을 미치지 않는 jOOQ 함수이다. 전적으로 클라이언트에서 구현된다. 물론, `cast()`도 여기서 동작한다.

예를 들어, `Integer` 합계를 얻으려면:

```java
// Instead of:
Record1<BigDecimal> r1 = ctx
    .select(sum(TABLE.COLUMN))
    .from(TABLE)
    .fetchOne();

// Get this (where SQLDataType.INTEGER is used):
Record1<Integer> r2 = ctx
    .select(sum(TABLE.COLUMN).coerce(INTEGER))
    .from(TABLE)
    .fetchOne();
```

`coerce()`는 jOOQ에서 매우 유용한 기능 `X2`이며, jOOQ 파워 유저라면 알아둘 가치가 있다. 이 기능은 `X1`(`SUM(X)` 집계 함수)과 관련이 없지만, `SUM(X)`(그리고 수십 개의 다른 산술 함수)에 특화된 "문제"(또는 예상치 못한 동작 / 역사적 API 설계 선택 등)를 우회하는 데 도움이 된다.

## 기능의 존재를 모른다

하지만 사용자가 가질 수 있는 문제는 이것이다:

- 사용자는 `SUM(X)`, 즉 `X1`을 찾는 데 문제가 없다. 지원되는 모든 SQL 함수에는 `DSL`에 대응하는 jOOQ 메서드가 있으며, jOOQ 사용자들은 SQL에서 이미 알고 있는 것이 있으면 그곳을 찾아보도록 빠르게 훈련된다.
- 사용자는 데이터 타입을 `coerce()`하거나 `cast()`하는 방법을 찾는 데 어려움을 겪는다. 첫째, 1) 그 개념을 모를 수 있고(또는 잊었거나, 연결 짓지 못할 수 있고), 2) 그것은 단순히 사용자가 현재 수행 중인 작업과 관련이 없기 때문이다.

그래서 해결책을 찾는 데 많은 시간이 소비될 수 있다. 최선의 해결책이 무엇인지 모르면 대안을 탐색하게 된다. 최악의 경우, 그 대안들도 (관련 없는!) 문제를 일으키고, 더욱 좌절스러운 XY 문제가 뒤따르게 된다.

XY 문제가 없더라도, 해결책 `X2`를 찾는 데 많은 시간이 낭비될 수 있다.

## 문서화하려는 충동

사용자가 결국 `X2`(`coerce()` 함수)에 대해 알게 되면, `X2`를 `X1`에 문서화해 달라고 요청할 수 있다. 그렇게 했다면 정말 도움이 되었을 것이기 때문이다. 그리고 이러한 종류의 문서화가 이 *특정* 사용자에게 도움이 되었을 것이라는 데는 의심의 여지가 없다.

하지만!

`SUM(X)`를 사용하는 대부분의 사용자는 `coerce()`에 대해 알 필요가 없다. 그들은 `BigDecimal`에 완벽하게 만족하거나, 또는 `BigDecimal`을 `Integer`로 변환하는 완전히 다른 방법(예: `BigDecimal::intValue`)을 찾았고 자신의 해결책 `X3`에 완벽하게 만족한다.

만약 `X2`가 `X1`에 문서화되었다면, 대부분의 사용자에게 그것은 그저 잡음(노이즈)이었을 것이다. 아마도 끔찍한 잡음은 아닐 수 있지만:

- 관련 없는 기능 `X2`에 대한 `X1`의 첫 번째 잡음이다.
- 다음 사용자는 `X2`가 자신의 문제에 불충분하다고 생각하여 `X3`도 문서화해 달라고 요청할 것이다.
- 다음 사용자는 `X1`에서 완전히 다른 한계를 발견하고 *자신의* 우회 방법 `X4`를 문서화해 달라고 요청할 것이다(예를 들어, `SUM(X)`가 빈 입력 집합에 대해 항등원 `0` 대신 `NULL`을 반환한다는 사실, 이는 흔한 SQL "예상치 못한 동작"이다).
- 다음 사용자는 `X5`에서 한계를 발견하고 `X1`과 `X6`을 거기에 문서화해 달라고 요청할 것이다.

기능 집합 `X = {X1, X2, ..., Xn}`은 크며, 제품이 잘 설계되어 있고 jOOQ처럼 재사용성이 높은 컴포넌트가 많다면, 원칙적으로 거의 모든 기능이 다른 모든 기능과 상호작용할 수 있다.

이것만으로도 테스트하기 충분히 어렵지만, 모든 조합에 대해 예상치 못한 동작, 주의사항, 함정, 우회 방법 등의 목록도 함께 문서화해야 한다면, 99%의 사용자가 결코 알 필요가 없어서 잡음으로 인식할 내용을 문서화하는 일을 결코 끝낼 수 없게 된다.

극단적인 예를 들어보자: `method(List<T>)`에 `List<T>`를 전달해야 하는 사용자를 상상해 보자. 하지만 그들은 `ArrayList`를 모른다. 그들은 `ArrayList`를 `method()`에 문서화해 달라고 요청할 뿐만 아니라, `ArrayList`가 `new`를 사용하여 생성될 수 있다는 사실도 문서화해 달라고 요청한다. 이것은 완전히 관련 없는 잡음이다!

잡음이 너무 많아서 `X2`(`coerce()` 함수)를 `X1`(`SUM(X)` 집계 함수)에 문서화해 달라고 요청했던 사용자조차 끝없는 예상치 못한 동작 목록에서 이 정보를 찾지 못할 것이다. 말할 것도 없이, 그 특정 예상치 못한 동작을 목록의 맨 위로 옮기는 것은 이 정보를 찾기 위한 올바른 해결책이 되지 않을 것이다.

## 그렇다면 이 사용자를 돕는 가장 좋은 방법은 무엇인가?

개인적으로, 나는 Stack Overflow를 좋아한다. 사람들은 그 중재(모더레이션)를 가혹하다고 인식하지만, 이 중재의 큰 이점은 좋은 질문이 항상 *매우 구체적*이어서 Google에서 질문을 찾는 다음 사용자에게 유용하다는 것이다. Stack Overflow에서 `X1`과 `X2`의 조합에 대해 질문하는 것은 전혀 문제가 없다. 기능들은 관련이 없지만, 그 조합은 이 특정 사용자에게 도움이 된다. 따라서 이 사용자가 다음과 같이 질문하면:

> `X1`을 사용하고 싶은데, 이런 예상치 못한 동작에 부딪혔습니다. 어떻게 우회할 수 있나요?

그러면 나는 이렇게 답변할 수 있다:

> 우회 방법으로 `X2`를 사용하세요. 방법은 다음과 같습니다: [ ... ]

이것은 Javadoc이나 매뉴얼의 문서화보다 훨씬 더 낫다:

- 잡음을 생성하지 않는다. 99%의 jOOQ 사용자는 이 Q&A와 관련이 없으므로, 이것을 Google에서 검색하지 않을 것이고, 따라서 이 질문을 접하지 않을 것이다. 그래서 그들은 행복하다.
- 매우 구체적이다. 같은 질문을 가진 1%의 jOOQ 사용자는 Stack Overflow(또는 Stack Overflow를 표절하는 ChatGPT 등)에서 이 답변을 찾을 것이므로, 그들도 행복하다.

## 결론

예상치 못한 동작을 문서화하는 것은 미끄러운 비탈길이다. 제품이 성장하고 성숙해지면서 예상치 못한 동작이 축적된다. 이것에 예외는 없다. 이러한 모든 예상치 못한 동작을 *어딘가에* 문서화하는 것은 중요하다. 이를 접한 사용자들이 답을 원할 것이기 때문이다.

하지만 이러한 예상치 못한 동작을 기능 문서 자체에 문서화하는 것은 올바른 선택이 아니다. 대부분의 사용자는 그 예상치 못한 동작과 관련이 없기 때문이다. 문서화된 예상치 못한 동작 목록은 금세 압도적이 될 것이다.

어떤 형태의 Q&A가 보통 가장 좋은 접근법이다:

- Stack Overflow의 질문
- 이슈 트래커의 이슈와 그 예상치 못한 동작 및 가능한 모든 우회 방법에 대한 관련 토론
