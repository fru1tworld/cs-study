# 이 깔끔한 윈도우 함수 트릭으로 시계열에서 시간 차이 계산하기

> 원문: https://blog.jooq.org/use-this-neat-window-function-trick-to-calculate-time-differences-in-a-time-series/

"이걸 SQL로 계산할 수 없을까?"라는 생각이 들 때마다... 답은: 네, 할 수 있습니다! 그리고 해야 합니다! 어떻게 하는지 살펴봅시다...

## 행 간의 시간 차이 계산하기

다음과 같이 타임스탬프가 포함된 데이터베이스(예: 로그 데이터베이스)를 가정해 봅시다. PostgreSQL 문법을 사용합니다:

```sql
CREATE TABLE timestamps (
  ts timestamp
);

INSERT INTO timestamps VALUES
  ('2015-05-01 12:15:23.0'),
  ('2015-05-01 12:15:24.0'),
  ('2015-05-01 12:15:27.0'),
  ('2015-05-01 12:15:31.0'),
  ('2015-05-01 12:15:40.0'),
  ('2015-05-01 12:15:55.0'),
  ('2015-05-01 12:16:01.0'),
  ('2015-05-01 12:16:03.0'),
  ('2015-05-01 12:16:04.0'),
  ('2015-05-01 12:16:04.0');
```

당연히 제약 조건과 인덱스 등을 추가하게 될 것입니다. 이제 각각의 타임스탬프가 시스템의 이벤트를 나타내고, 이전 이벤트가 얼마나 전에 발생했는지 추적하고 싶다고 가정해 봅시다. 즉, 다음과 같은 결과를 원합니다:

```
ts                   delta
-------------------------------
2015-05-01 12:15:23
2015-05-01 12:15:24  00:00:01
2015-05-01 12:15:27  00:00:03
2015-05-01 12:15:31  00:00:04
2015-05-01 12:15:40  00:00:09
2015-05-01 12:15:55  00:00:15
2015-05-01 12:16:01  00:00:06
2015-05-01 12:16:03  00:00:02
2015-05-01 12:16:04  00:00:01
2015-05-01 12:16:04  00:00:00
```

다시 말해서

- ts1 (12:15:23) + delta (00:00:01) = ts2 (12:15:24)
- ts2 (12:15:24) + delta (00:00:03) = ts3 (12:15:27)
- ...

이것은 `LAG()` 윈도우 함수를 사용하면 매우 쉽게 달성할 수 있습니다:

```sql
SELECT
  ts,
  ts - lag(ts, 1) OVER (ORDER BY ts) delta
FROM timestamps
ORDER BY ts;
```

위 쿼리는 단순히 다음과 같이 읽힙니다: '현재 행의 ts 값과 ts 순서로 정렬했을 때 현재 행보다 하나 뒤에 있는("lag") 행의 ts 값 사이의 차이를 구해라.'

쉽죠? `LAG()`를 사용하면 단순히 lag 인덱스를 지정함으로써 "슬라이딩 윈도우" 내의 다른 행에서 실제로 어떤 행이든 접근할 수 있습니다. 이 훌륭한 윈도우 함수에 대해서는 이전 블로그 글에서 이미 설명한 바 있습니다.

## 보너스: 누적 시간 간격

이 타임스탬프와 이전 타임스탬프 사이의 차이 외에도, 이 타임스탬프와 첫 번째 타임스탬프 사이의 총 차이에 관심이 있을 수 있습니다. 이것은 누계(running total)처럼 들릴 수 있지만(SQL을 사용한 누계에 대한 이전 글 참조), `FIRST_VALUE()` - `LAG()`의 "사촌" - 를 사용하면 훨씬 더 쉽게 계산할 수 있습니다:

```sql
SELECT
  ts,
  ts - lag(ts, 1) OVER w delta,
  ts - first_value(ts) OVER w total
FROM timestamps
WINDOW w AS (ORDER BY ts)
ORDER BY ts;
```

... 위 쿼리는 다음을 생성합니다:

```
ts                   delta     total
---------------------------------------
2015-05-01 12:15:23            00:00:00
2015-05-01 12:15:24  00:00:01  00:00:01
2015-05-01 12:15:27  00:00:03  00:00:04
2015-05-01 12:15:31  00:00:04  00:00:08
2015-05-01 12:15:40  00:00:09  00:00:17
2015-05-01 12:15:55  00:00:15  00:00:32
2015-05-01 12:16:01  00:00:06  00:00:38
2015-05-01 12:16:03  00:00:02  00:00:40
2015-05-01 12:16:04  00:00:01  00:00:41
2015-05-01 12:16:04  00:00:00  00:00:41
```

## 추가 보너스: "리셋" 이벤트 이후의 총계

이것을 원하는 만큼 확장할 수 있습니다. 때때로 총계를 리셋하고 싶다고 가정해 봅시다:

```sql
CREATE TABLE timestamps (
  ts timestamp,
  event varchar(50)
);

INSERT INTO timestamps VALUES
  ('2015-05-01 12:15:23.0', null),
  ('2015-05-01 12:15:24.0', null),
  ('2015-05-01 12:15:27.0', 'reset'),
  ('2015-05-01 12:15:31.0', null),
  ('2015-05-01 12:15:40.0', null),
  ('2015-05-01 12:15:55.0', 'reset'),
  ('2015-05-01 12:16:01.0', null),
  ('2015-05-01 12:16:03.0', null),
  ('2015-05-01 12:16:04.0', null),
  ('2015-05-01 12:16:04.0', null);
```

이제 다음 쿼리를 실행할 수 있습니다:

```sql
SELECT
  ts,
  ts - lag(ts, 1)
       OVER (ORDER BY ts) delta,
  ts - first_value(ts)
       OVER (PARTITION BY c ORDER BY ts) total
FROM (
  SELECT
    COUNT(*) FILTER (WHERE EVENT = 'reset')
             OVER (ORDER BY ts) c,
    ts
  FROM timestamps
) timestamps
ORDER BY ts;
```

... 다음을 생성합니다:

```
ts                   delta     total
---------------------------------------
2015-05-01 12:15:23            00:00:00
2015-05-01 12:15:24  00:00:01  00:00:01
2015-05-01 12:15:27  00:00:03  00:00:00 <-- 리셋
2015-05-01 12:15:31  00:00:04  00:00:04
2015-05-01 12:15:40  00:00:09  00:00:13
2015-05-01 12:15:55  00:00:15  00:00:00 <-- 리셋
2015-05-01 12:16:01  00:00:06  00:00:06
2015-05-01 12:16:03  00:00:02  00:00:08
2015-05-01 12:16:04  00:00:01  00:00:09
2015-05-01 12:16:04  00:00:00  00:00:09
```

아름다운 부분은 파생 테이블에 있습니다:

```sql
  SELECT
    COUNT(*) FILTER (WHERE EVENT = 'reset')
             OVER (ORDER BY ts) c,
    ts
  FROM timestamps
```

이 파생 테이블은 가장 최근의 "리셋" 이벤트를 기준으로 각 타임스탬프 집합에 "파티션"을 추가하기만 합니다. 위 서브쿼리의 결과는 다음과 같습니다:

```
c  ts
----------------------
0  2015-05-01 12:15:23
0  2015-05-01 12:15:24
1  2015-05-01 12:15:27 <-- 리셋
1  2015-05-01 12:15:31
1  2015-05-01 12:15:40
2  2015-05-01 12:15:55 <-- 리셋
2  2015-05-01 12:16:01
2  2015-05-01 12:16:03
2  2015-05-01 12:16:04
2  2015-05-01 12:16:04
```

보시다시피, `COUNT(*)` 윈도우 함수는 타임스탬프 순서로 이전의 모든 "리셋" 이벤트를 셉니다. 이 정보는 각 파티션의 첫 번째 타임스탬프, 즉 가장 최근의 "리셋" 이벤트 시점의 타임스탬프를 찾기 위한 `FIRST_VALUE()` 윈도우 함수의 `PARTITION`으로 사용할 수 있습니다:

```sql
  ts - first_value(ts)
       OVER (PARTITION BY c ORDER BY ts) total
```

## 결론

이 블로그에서 거의 반복되는 농담이 되었지만... "윈도우 함수 이전의 SQL과 윈도우 함수 이후의 SQL이 있습니다."

윈도우 함수는 매우 강력하며 대부분의 상용 데이터베이스, PostgreSQL, Firebird 3.0, 그리고 CUBRID에서 지원되는 SQL 표준의 일부입니다. 아직 사용하고 있지 않다면, 오늘부터 시작하세요!
