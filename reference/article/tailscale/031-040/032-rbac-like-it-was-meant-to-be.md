# RBAC의 본래 의도대로

저자: Avery Pennarun
날짜: 2021년 8월 27일

---

## 소개

대부분의 사람들은 역할 기반 접근 제어(RBAC, Role-Based Access Control)와 속성 기반 접근 제어(ABAC, Attribute-Based Access Control)에 대해 들어봤지만, 그 근본적인 개념을 충분히 이해하지 못하고 있습니다. 현재의 "RBAC" 시스템들은 원래의 군사적 개념에서 상당히 단순화되어, 본래 의도했던 것보다 훨씬 약해졌습니다. 기초 원칙으로 돌아감으로써, 조직은 모든 규모의 네트워크에 대해 더 단순하면서도 더 강력한 보안 모델을 구축할 수 있습니다.

이 글에서는 사람들이 종종 자신의 보안 정책에 필요한 규칙이 얼마나 적은지에 놀라곤 한다는 점을 언급합니다—이것은 우연이 아니라 의도적인 설계입니다.

## DAC에서 MAC으로

접근 제어 개념은 수십 년 전 미군 연구에서 시작되었습니다. 그 진화는 임의적 접근 제어(DAC, Discretionary Access Control)에서 시작되었는데, 여기서는 객체 소유자가 자유롭게 권한을 부여할 수 있습니다. Unix 파일 권한이나 Google Docs 공유를 생각해 보세요—사용자가 누가 접근할 수 있는지 결정합니다.

강제적 접근 제어(MAC, Mandatory Access Control)는 이러한 원칙을 더 엄격하게 만든 것입니다. MAC에서는 어떤 능력을 가지고 있다고 해서 그 능력을 다른 사람과 공유할 수 있는 것이 아닙니다. 포트 바인딩이 이를 잘 보여줍니다: 일단 네트워크 포트에 바인딩하면, 권한 수준에 관계없이 아무도 그 포트를 사용할 수 없습니다. 이 제한은 시스템 전체에서 강제됩니다.

군대는 민감한 자료의 무단 재공유를 방지하기 때문에 MAC을 선호했습니다. 그러나 실제로 진정한 MAC 시행은 어렵습니다. 디지털 저작권 관리(DRM)가 MAC을 시도하지만 정기적으로 실패합니다—BitTorrent 사용자들이 이 한계를 일관되게 보여줍니다.

## MAC으로서의 이중 인증

다중 인증(Multi-factor Authentication)은 현대 시스템에서 MAC의 예를 보여줍니다. 비밀번호는 공유할 수 있지만(DAC 특성), 하드웨어 보안 토큰은 공유할 수 없습니다(MAC 특성). 이러한 분리는 적절한 시스템 잠금을 전제로, 사용자가 원하더라도 접근을 재공유하는 것을 방지합니다.

## 사진 공유: DAC vs. MAC

서로 다른 서비스들은 공유를 다르게 구현합니다. 보안이 취약한 플랫폼은 비밀 URL을 가진 누구나 콘텐츠를 재공유할 수 있게 합니다—이것이 DAC입니다. 더 나은 시스템은 URL과 명시적 권한이 있는 인증된 계정 모두를 요구합니다—이것이 MAC입니다. 누군가 URL을 통해 파일에 접근하더라도, 인증되지 않은 사용자에게 접근을 재공유할 수 없습니다.

이 구분은 중요합니다: URL 접근은 취소할 수 있지만, 이미 다운로드된 파일은 회수할 수 없습니다.

## MAC의 복잡성 문제

군사적 MAC은 전통적으로 "다중 레벨 보안"을 사용했습니다—"일급 비밀" 대 "비밀"과 같은 기밀 등급 계층 구조입니다. 이것은 표현력이 부족했습니다. 현대 시스템은 대신 별도의 플래그를 사용합니다. SELinux가 이 접근 방식의 복잡성을 보여줍니다: 세밀한 제어를 제공하지만 대부분의 사용자에게는 악몽처럼 복잡해집니다—심지어 NSA의 제작자들조차 어려움을 겪었습니다.

근본적인 문제: MAC은 너무 제한적이면서 동시에 너무 모호하고, 구현하기가 확실히 성가십니다.

## RBAC와 ABAC의 정의

RBAC는 MAC의 구체적인 하위 집합입니다. 관리자가 사용자를 그룹에 할당하고; 리소스 소유자가 이러한 그룹과 공유하며; 시스템이 접근을 강제합니다. 수신자는 복사하지 않고는 재공유할 수 없습니다.

ABAC는 속성을 추가하여 RBAC를 개선합니다: 위치, 기기 플랫폼, 인증 방법, HTTP 쿠키 등. 로그인할 때 reCAPTCHA를 만났는데 이웃은 그렇지 않다면, ABAC를 경험한 것입니다. 이러한 시스템은 역할 멤버십뿐만 아니라 추가적인 상황적 요소도 확인합니다.

## 실제 RBAC의 과제

Windows 파일 시스템 ACL은 전통적인 RBAC 구현을 보여줍니다. 각 파일에는 어떤 사용자와 그룹이 어떤 작업을 수행할 수 있는지 지정하는 접근 제어 목록(ACL)이 있습니다. 파일은 상위 디렉토리에서 ACL 항목을 상속받습니다.

문제는 규모에서 발생합니다: 많은 파일의 권한을 변경하려면 그룹 멤버십을 수정하거나(간단함) 각 파일의 ACL을 개별적으로 업데이트해야 합니다(느리고 오류가 발생하기 쉬움). 여러 스토리지 백엔드에 걸친 분산 시스템에서, 오류를 수정하기 위해 모든 권한 복사본을 추적하는 것은 보안 악몽이 됩니다.

## ACL당 하나의 그룹 접근 방식

조직은 전용 그룹을 생성하여 대응합니다: `report-readers`와 `report-writers`. 모든 보고서가 동일한 권한을 상속받습니다—접근 제어에 적용된 DRY(Don't Repeat Yourself) 원칙입니다.

이것이 도움이 되지만 새로운 문제를 만듭니다:

1. 그룹 멤버십 변경에는 IAM 관리자 접근이 필요하여, 관리 권한을 과도하게 분산시키려는 압력이 생깁니다
2. 사용자들이 여전히 예외를 위해 개별 파일 ACL을 편집하여, 시스템을 은밀하게 깨뜨립니다
3. 그룹의 폭발적 증가(엔지니어당 975개 이상)가 관리 불가능해지고, 모든 리소스 유형에 대해 읽기 및 쓰기 변형이 생깁니다

## 누락된 개념: 객체 태그

현대 시스템은 비밀번호 없는 sudo로 상태 비저장(stateless) 컨테이너와 VM을 실행하여, 파일 시스템 보안이 대체로 무관해집니다. 웹 애플리케이션과 데이터베이스는 대신 API를 통해 권한을 강제합니다.

이것은 더 나은 접근 방식을 가능하게 합니다: 인간 관련 역할(회계, DevOps, 엔지니어링, 임원) 대 리소스 유형 태그(database, sourcefile, report). 이 분리는 중요한 의미론적 명확성을 추가합니다.

리소스 유형에 따라 그룹 이름을 짓는 대신, 직무 기능에 따라 이름을 지으세요. Bob이 직무를 변경할 때, 수십 개의 파일별 그룹을 추적하는 대신 하나의 역할 멤버십을 업데이트하면 됩니다.

## 정책 규칙 접근 방식

권한을 역할-태그 매핑으로 정의합니다:
- 회계(Accounting)는 financial-report를 읽을 수 있지만 쓸 수 없음
- DevOps는 database를 읽고 쓸 수 있음
- 엔지니어링(Engineering)은 sourcefile을 읽을 수 있음

이 중앙 집중화되고 사람이 읽을 수 있는 접근 방식은 수백만 개의 객체에 흩어진 ACL보다 낫습니다.

## 객체당 여러 태그

객체는 0개 이상의 태그를 가질 수 있습니다. `database.go` 파일은 `database`와 `sourcefile` 모두로 태그될 수 있으며, 두 권한 집합의 합집합을 받습니다.

중요한 시행 규칙: 태그 소유자만 태그를 적용할 수 있습니다. 엔지니어링 외부의 누구도 무언가를 `sourcefile`로 태그할 수 없습니다. 이것은 우발적인 격리 위반과 잘못된 정책 적용을 방지합니다.

## 네트워크 적용 예시

Tailscale의 네트워크 컨텍스트에서, 규칙은 노드와 포트 연결성을 정의합니다:

엔지니어는 `dev-api-client` 노드로부터 암호화되지 않은 연결을 수락하는 `dev-api-server` 노드를 시작할 수 있습니다. Ops만 `prod-api-server`와 `prod-api-client` 노드를 시작할 수 있습니다(HTTPS로 구성되었다고 가정).

태그 이름은 권한을 재귀적으로 적용합니다: Ops의 누군가가 노드에 `prod-api-server` 태그를 지정하면, Ops 권한 대신 관련 권한이 부여됩니다. 이것은 `prod-api-server` 인스턴스가 추가 인스턴스를 생성하는 것을 방지합니다.

## 책임의 분리

세 그룹이 시스템의 서로 다른 측면을 처리합니다:

- 역할(HR 도메인): 채용, 승진 또는 이동 시 드물게 변경됨
- 태그(소유자 도메인): 객체 생성 시 적용됨
- 권한 부여(보안 도메인): 정책에 의해 프로그래밍 방식으로 정의됨

각 그룹은 최소한의 의사소통만 필요합니다. 회계는 임원의 신원이나 권한에 신경 쓰지 않습니다—재무 보고서에 올바르게 태그를 지정하기만 하면 됩니다. 보안은 특정 파일을 추적하지 않습니다—`financial-report` 태그가 적절하게 접근을 제한하기만 하면 됩니다.

이 분리는 조직의 마찰을 상당히 줄여줍니다. 엔지니어는 보안 티켓을 제출하지 않고도 개발 클러스터를 배포할 수 있습니다; 정책은 수동 방화벽 규칙 관리가 아닌 코드 전체에서 시행됩니다.

## 완전한 RBAC 모델

대부분의 시스템은 RBAC를 주장하지만 완전히 구현하지 않습니다. 완전한 모델에는 다음이 필요합니다:

1. 모든 사람은 사용자(주체)입니다
2. 모든 사용자는 하나 이상의 역할을 가집니다
3. 모든 객체는 하나 이상의 태그를 가집니다
4. "보안 정책" 공식이 (역할, 태그)를 권한 부여로 변환합니다
5. 시행 계층이 정책을 컴파일하고 각 객체에 대한 효과적인 ACL을 생성합니다

이 모델은 기본 사용자-그룹 시스템보다 구축하기 어렵지 않습니다—처음부터 시스템에 통합되어 있다면, 나중에 개조하는 것이 아니라.

## Tailscale 구현

Tailscale은 이러한 원칙을 파일이 아닌 네트워크 접근에 적용합니다. 장치와 포트가 전통적인 파일 객체를 대체합니다. 장치 소유자가 태그를 적용하고; 보안 팀이 태그 소유권과 역할별 권한을 정의하며; 신원 팀이 사용자 역할을 관리합니다.

결과: 세 이해관계자 그룹이 최소한의 상호 의존성으로 운영되면서 포괄적인 보안 시행을 유지하는 기만적으로 깔끔한 설계입니다.

---

참고: 원본 글에는 이러한 개념을 설명하는 수많은 다이어그램이 포함되어 있습니다. 텍스트는 이러한 시각 자료를 참조하지만 다이어그램 자체는 텍스트 형식으로 재현할 수 없습니다.

---

*원문: [RBAC like it was meant to be](https://tailscale.com/blog/rbac-like-it-was-meant-to-be)*
