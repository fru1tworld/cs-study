# 모듈, 모놀리스, 마이크로서비스: 시스템 설계 관점

- 원문: [Modules, Monoliths, and Microservices](https://tailscale.com/blog/modules-monoliths-and-microservices)
- 작성일: 2021년 2월 23일
- 작성자: Avery Pennarun (CEO, Tailscale)

---

요즘 사람들이 마이크로서비스가 언제 좋은 아이디어인지 물어봅니다. 시스템 설계가 세상을 설명한다에서 저는 세컨드 시스템 효과, 혁신자의 딜레마 등과 같은 큰 그림의 문제에 대해 이야기했습니다. 시스템 설계가 마이크로서비스 질문에 답할 수 있을까요?

네, 하지만 답이 마음에 들지 않을 수도 있습니다. 먼저 역사가 필요합니다.

## 마이크로서비스란 무엇인가?

인터넷에서 다양한 정의를 찾을 수 있습니다. 제 정의는 이렇습니다: 마이크로서비스는 모놀리스에 대한 가장 극단적인 반발입니다.

모놀리스는 앱에 필요한 모든 것을 하나의 거대한 프로그램에 링크하고 하나의 큰 블롭으로 배포할 때 발생하는 것입니다. 모놀리스는 CGI, Django, Rails, PHP와 같은 프레임워크까지 거슬러 올라가는 긴 역사를 가지고 있습니다.

바로 말해두겠습니다, 모놀리스와 마이크로서비스 플릿이 유일한 두 가지 옵션이라는 가정을 버립시다. "모든 것을 하는 하나의 거대한 서비스"에서 "거의 아무것도 하지 않는 무한한 작은 서비스"까지 넓고 미묘한 연속체가 있습니다.

유행을 따른다면, 적어도 한 번은 모놀리스를 구축했을 것입니다(의도적으로든, 전통적인 프레임워크가 그렇게 하도록 권장했기 때문이든). 그런 다음 모놀리스의 일부 문제를 발견하고, 마이크로서비스가 답이라고 들었으며, 모든 것을 마이크로서비스로 재설계하기 시작했을 것입니다.

하지만 유행을 따르지 마세요. 그 극단 사이에는 많은 지점이 있습니다. 그중 하나가 아마도 여러분에게 맞을 것입니다. 더 나은 접근 방식은 인터페이스를 어디에 놓을지에서 시작합니다.

## 박스와 화살표

인터페이스는 모듈 간의 연결입니다. 모듈은 관련 코드의 모음입니다. 시스템 설계에서 우리는 "박스와 화살표" 엔지니어링에 대해 이야기합니다: 모듈은 박스이고, 인터페이스는 화살표입니다.

그러면 더 깊은 질문은: 박스가 얼마나 큰가? 각 박스에 얼마나 많이 들어가나? 하나의 큰 박스를 두 개의 작은 박스로 분할할 때 어떻게 결정하나? 박스를 연결하는 가장 좋은 방법은 무엇인가? 이 모든 것에 대한 많은 접근 방식이 있습니다. 무엇이 최선인지 아무도 모릅니다. 이것은 소프트웨어 아키텍처에서 가장 어려운 문제 중 하나입니다.

수십 년에 걸쳐 우리는 많은 종류의 "박스"를 통해 발전해 왔습니다. Goto 문은 주로 계층 구조를 전혀 방지했기 때문에 "해롭다고 여겨졌습니다". 그런 다음 함수나 프로시저를 추가했습니다; 이것들은 매우 간단한 박스이며, 그 사이에 인터페이스(매개변수와 반환 코드)가 있습니다.

프로그래밍의 어느 분야로 가느냐에 따라, 재귀 함수, 결합자, 정적 함수 프로토타입, 라이브러리(정적 또는 런타임 링크), 객체(OOP), 코루틴, 보호된 가상 메모리, 프로세스, 스레드, JIT, 네임스페이스, 샌드박스, chroot, jail, 컨테이너, 가상 머신, 슈퍼바이저, 하이퍼바이저, 마이크로커널, 유니커널을 발견하게 됩니다.

그리고 그것은 박스에 불과합니다! 박스를 서로 격리하면 화살표로 연결해야 합니다. 이를 위해 ABI, API, 시스템 호출, 소켓, RPC, 파일시스템, 데이터베이스, 메시지 전달 시스템, "가상화된 하드웨어"가 있습니다.

현대 Unix 시스템의 완전한 박스와 화살표 다이어그램을 그리려고 한다면(그렇게 하지 않겠습니다), 정말 엄청날 것입니다: 스레드 내의 함수, 프로세스 내의 스레드, 컨테이너 내의 프로세스, 유저스페이스 내의 컨테이너가 커널 아래에 레이어되어 있고, VM 내부에서 데이터센터의 랙의 하드웨어에서 실행되며 오케스트레이션 시스템에 의해 함께 연결된 클라우드 제공업체 안에 있습니다.

각 추상화 계층의 각 박스는 어떻게든 다른 일부와 격리되어 있고 그 다음 연결됩니다, 같은 계층이든 다른 계층이든. 일부는 다른 것 안에 있습니다. 선이 절망적으로 교차하지 않고는 이 그림의 정직한 버전을 단순한 2차원으로 그릴 수 없습니다.

이 모든 것은 수십 년에 걸쳐 진화했습니다. 멋진 사람들은 이를 "경로 의존성"이라고 부릅니다. 저는 이를 엉망이라고 부릅니다. 그리고 분명히 합시다: 대부분의 엉망은 더 이상 큰 가치를 제공하지 않습니다.

매우 추한 진화적 결과에 초점을 맞추는 대신, 그 모든 것을 발명하는 동안 사람들이 무엇을 하려고 했는지 이야기합시다.

## 모듈화를 향한 탐구

모듈 시스템의 최상위 목표는 항상 동일합니다:

1. 각 코드 조각을 다른 조각들로부터 격리합니다.
2. 명시적으로 의도된 곳에서만(잘 정의된 인터페이스를 통해) 그 조각들을 다시 연결합니다.
3. 변경한 조각이 여전히 올바른 다른 조각들과 호환되도록 보장합니다.
4. 모든 다른 조각을 동시에 업그레이드하지 않고도 일부 조각을 업그레이드, 다운그레이드, 스케일링합니다.

컴퓨터 산업은 개발을 가능한 한 고통스럽지 않고 쉽게 유지하면서 이 모든 모듈화 문제의 완벽한 균형을 찾으려고 절대적으로 엄청난 시간을 허비합니다.

간단히 말해서, 우리는 성공하지 못하고 있습니다.

우리가 가장 못하는 부분은 단연 #1, 격리입니다. 진정으로 효율적으로 한 코드 조각을 다른 것으로부터 격리할 수 있다면, 다른 목표들은 대부분 제자리를 찾을 것입니다. 하지만 우리는 단순히 방법을 모릅니다.

격리는 매우 어려운 문제입니다. 사람들이 시도해 왔다는 것은 하느님이 아십니다. 그러나 브라우저 샌드박스 탈출은 여전히 정기적으로 발생하고, 탐지되지 않은 권한 상승 공격은 모든 OS에 존재한다고 단순히 가정되며, iOS는 여전히 주기적으로 탈옥되고, DRM은 절대 작동하지 않으며(좋든 나쁘든), 가상 머신과 컨테이너는 정기적으로 취약점이 발견되고, k8s와 같은 시스템은 컨테이너가 기본적으로 안전하지 않게 구성되어 있습니다.

사람들은 심지어 인터넷을 통해 잘 타이밍된 패킷을 보내 원격 서버의 암호화 키를 알아낸 적도 있습니다. 한편, 최근 기억에 가장 극적인 격리 실패는 Meltdown과 Spectre 공격이었는데, 이는 컴퓨터의 모든 프로그램, 심지어 웹 브라우저의 자바스크립트 앱도 샌드박스나 가상 머신을 넘어 같은 컴퓨터의 다른 프로그램의 메모리를 읽을 수 있게 했습니다.

모든 새로운 격리 기술은 낙관에서 절망까지 다음과 같은 주기를 거칩니다:

- 새로운 아이디어: 이번에는 드디어, 단 한 번에 제대로 할 것입니다!
- 초기 실험은 작동하는 것 같습니다.
- (사용자들은 그것이 지난번에 시도한 것보다 더 느리고 지루하다고 불평합니다.)
- 초기의 치명적인 결함이 발견되고 수정됩니다.
- 광범위한 배포.
- 점점 더 미묘한 결함이 연이어 발견되고 수정됩니다.
- 결국, 우리는 단순히 패치하는 방법을 모르는 결함을 발견합니다.
- 이 방법으로 효율적인 격리가 가능하다는 희망을 잃습니다.
- 하지만 또한 너무 많은 사람들이 이제 이에 의존하고 있기 때문에 이 격리 방법을 은퇴시킬 수 없습니다.
- 반복합니다.

예를 들어, 이 시점에서 보안 담당자들은 다음 중 어느 것도(각각 당시 사용 가능한 최고의 기술) 완전히 안전하다고 믿지 않습니다:

- Unix 시스템에서의 프로세스 격리와 메모리 보호.
- 원격 코드 실행("RCE"라고 보안 담당자들은 부릅니다)이 허용될 때 OS 프로세스 간의 권한 분리.
- 프로세스를 격리하기 위한 시스템 호출 필터링.
- CPU 하이퍼스레드를 공유하는 상호 신뢰하지 않는 프로세스.
- CPU 코어의 가상 머신 간 메모리 격리.

제가 아는 한, 최첨단, 가장 좋은 격리는 Chrome 샌드박스나 gVisor와 같은 것입니다. 대형 브라우저 벤더와 클라우드 제공업체들은 모두 이러한 도구를 사용합니다. 도구들은 불완전하지만, 제공업체들은 가능한 빨리 모든 새로운 침해를 추적하며, 새로운 결함의 비율은 상당히 느립니다.

격리는 이전보다 더 좋습니다... 가상 머신(VM) 수준에서 모든 격리를 두어 클라우드 제공업체가 대신 할 수 있게 하면 됩니다. 왜냐하면 다른 누구도 방법을 모르거나 충분히 자주 업데이트하지 않기 때문입니다.

클라우드 제공업체의 VM 격리를 신뢰한다면, 알려진 모든 문제가 완화되었다는 희망을 가질 수 있습니다; 하지만 더 많은 문제가 발견될 것이라고 생각할 모든 이유가 있습니다.

모든 것을 고려하면 그것은... 실제로 꽤 좋습니다. 적어도 작동하는 것이 있습니다.

## 좋아요! 모든 것에 VM을!

잠깐요. 모든 작은 모듈에 대해 격리된 VM을 스핀업하는 것은 고통스럽습니다. 그리고 모듈은 얼마나 커야 할까요?

오래전, Java가 처음 나왔을 때, 꿈은 모든 객체의 모든 함수의 모든 줄에 권한이 적용되어, 같은 애플리케이션 바이너리의 객체 간에도, CPU가 강제하는 메모리 보호가 필요하지 않게 하는 것이었습니다. 아무도 더 이상 그것이 작동할 수 있다고 믿지 않습니다. 그리고 "클라우드 함수"와 같은 마케팅 주장을 제외하고, 아무도 실제로 시도해야 한다고 생각하지 않습니다.

현재 알려진 격리 방법 중 어느 것도 완벽하게 작동하지 않지만, 각각은 어느 정도 근사치로 작동합니다. 점점 더 숙련된 공격자나 점점 더 가치 있는 대상은 더 좋고 더 성가신 격리를 필요로 합니다. 우리가 지금 알고 있는 가장 좋은 격리는 1등급 클라우드 제공업체가 제공하는 VM 간 샌드박싱입니다. 가장 나쁜 것은, 음, 제로까지 내려갑니다.

또한 증거를 건너뛰고 가정해 봅시다. 대부분의 시스템은 너무 밀접하게 결합되어 있어 합리적으로 숙련된 공격자가 모듈 사이를 측면으로 뚫을 수 있습니다. 따라서 예를 들어, 누군가가 악성 라이브러리를 Go나 C++ 프로그램에 링크할 수 있다면, 아마도 그 전체 프로그램을 장악할 수 있습니다.

마찬가지로, 프로그램이 데이터베이스에 쓰기 권한이 있다면, 공격자는 아마도 데이터베이스 어디에나 쓸 수 있게 만들 수 있습니다. 네트워크에 연결할 수 있다면, 아마도 네트워크 어디에나 연결할 수 있습니다. 임의의 Unix 명령이나 시스템 호출을 실행할 수 있다면, 아마도 Unix root 액세스를 얻을 수 있습니다. 컨테이너에 있다면, 아마도 컨테이너를 벗어나 다른 컨테이너로 들어갈 수 있습니다. 악성 데이터가 png 디코더를 충돌시킬 수 있다면, 아마도 디코더 프로그램이 할 수 있는 다른 무엇이든 하게 만들 수 있습니다. 등등.

특히 강력한 형태의 공격은 코드를 커밋할 수 있는 능력을 얻는 것입니다. 그 코드는 결국 개발자 머신에서 실행될 것이고, 어딘가의 일부 개발자나 프로덕션 머신은 아마도 여러분이 하고 싶은 것에 대한 액세스 권한을 가지고 있을 것입니다.

위의 내용은 아마도 조금 너무 비관적이지만, 그런 가정을 하면 실제 보안을 향상시키지 않으면서 시스템을 과도하게 복잡하게 만드는 것을 피하는 데 도움이 될 수 있습니다. "qmail 1.0 10년 후의 보안에 대한 몇 가지 생각"에서 Daniel J. Bernstein은 (제가 많이 의역할 수 있다면) qmail에 추가한 많은 방어, 특히 chroot와 다른 Unix uid를 사용하여 다른 구성 요소를 서로 격리하는 것이 가치가 없었고 결코 성과를 거두지 못했다고 지적합니다.

어쨌든, 코드를 실행할 수 있는 능력을 가진 공격자가 거의 모든 모듈 격리 기술에 대해 결합된 모듈 사이를 "보통" 측면으로 점프할 수 있다고 당연하게 여깁시다. 이것은 두 종류의 모듈 경계만 있다는 것을 의미합니다:

- 신뢰할 수 있음: 두 모듈이 서로 악의적이지 않다고 상호 신뢰하여 약한 격리를 사용할 수 있는 경계.
- 신뢰할 수 없음: 모듈이 서로 신뢰하지 않아 강한 격리를 사용해야 하는 경계.

여기서 매우 통찰력 있는 말을 하는 것은 아닙니다. 인기 있는 현대 플랫폼은 이미 이 구분을 중심으로 구축되어 있습니다.

예를 들어, Chrome은 웹 페이지가 신뢰할 수 없기 때문에 임의의 웹 자바스크립트를 강력하게 격리된 샌드박스 VM에서 실행합니다.

대부분의 OS는 공유된 파일시스템, 네트워크 네임스페이스 등으로 네이티브 앱을 단순한 프로세스(샌드박스 없이)로 실행합니다. 왜냐하면 우리는 한때 그것들이 상대적으로 신뢰할 수 있다고 생각했기 때문입니다. (그리고 그것이 바이러스가 발생한 방식입니다.)

전문가들은 프로세스 격리가 약하다는 것이 밝혀졌기 때문에 더 이상 다중 사용자 유닉스 시스템을 신뢰하지 않습니다. 클라우드 VM은 기본적으로 비밀번호 없는 sudo를 사용합니다. root 대 non-root 격리가 약하다는 것이 밝혀졌기 때문에 굳이 신경 쓸 필요가 없습니다.

(우리는 여전히 모든 파일을 삭제하는 등의 인적 오류의 영향을 줄이기 위해 사람들에게 sudo를 입력하게 합니다.)

다른 벤더의 공유 라이브러리와 DLL이 다른 벤더의 앱에 링크됩니다. 왜냐하면 모든 코드가 신뢰할 수 있다고 가정되기 때문입니다. (이것은 오픈 소스 라이브러리 벤더를 통한 공급망 공격의 길을 엽니다. 이런 일이 훨씬 더 자주 발생하지 않는 것이 놀랍습니다. 제 냉소적인 순간에는, 아마도 그렇지만 거의 감지되지 않을 뿐이라고 생각합니다.)

앱 스토어 제한이 앱 샌드박스를 충분히 신뢰할 수 있게 만들어야 하지만, 격리가 여전히 변함없이 너무 약하다는 것이 밝혀졌기 때문에 폰 OS는 탈옥됩니다.

Kubernetes와 Docker는 단일 머신이나 VM에서 여러 개의 잘 격리되지 않은 컨테이너를 실행합니다. 왜냐하면 컨테이너는 모두 암묵적으로 신뢰할 수 있다고 여겨지기 때문입니다. 그들은 "다중 테넌트" Kubernetes 클러스터(별도의, 상호 신뢰하지 않는 사용자를 대신하여 행동하는 신뢰할 수 없는 앱과 함께)를 실행하려고 시도하지 말라고 강력히 권장합니다. 왜냐하면 컨테이너 격리가 약하다는 것이 밝혀졌기 때문입니다.

아, 또한 모든 서비스에 대해 gVisor VM과 같은 강력한 격리를 사용하더라도, 코드 자체가 강력하게 격리된 툴체인을 사용하여 빌드되지 않으면 도움이 되지 않습니다. 한 세트의 사람들이 일련의 앱에 링크되는 라이브러리를 업데이트할 수 있다면, 그 앱들은 어떻게 실행되든 실제로 서로 격리되지 않습니다.

## 모듈 경계 대 서비스 경계

이렇게 많은 격리 계층이 약하다면, 왜 굳이 신경 쓰나요?

대부분 역사 때문입니다; 이러한 계층의 대부분을 버린다면 보안에는 큰 영향이 없고 단순성은 향상될 것입니다. 시간이 지나면 이것이 일어날 것으로 예상합니다. 이미 이 트렌드를 보고 있습니다. 다중 사용자 유닉스 시스템은 거의 멸종했습니다; "서버리스" 서버는 가장 강력한 종류를 제외한 모든 격리 유형을 버리고 거기 있는 동안 클라우드 제공업체에 종속시키려고 친절하게 시도합니다.

하지만 역사는 제쳐두고. 더 간단한 것을 말할 수 있도록 모든 격리 개념을 소개해야 했습니다: "보안상의 이유로 모듈 경계를 정의하는 경우는 거의 없습니다."

대신, 모듈 경계는 일반적으로 Conway의 법칙을 따릅니다. 사람들은 팀에서 개발 작업을 어떻게 세분화하고 싶은지에 따라 모듈을 분할하고, 모듈은 팀과 팀원이 소통하는 방식에 따라 소통하게 됩니다. (Conway의 법칙은 매력적이고 실제적이지만, 다른 많은 곳에서 읽을 수 있습니다. 지금은 건너뜁시다.)

모듈 경계가 하지 않는 것은 배포 단위의 크기를 정의하는 것입니다.

예를 들어 운영 체제를 봅시다:

- ChromeOS는 수천 명의 개발자가 있지만, 사용자는 Linux 커널, 장치 드라이버, 윈도우 매니저, 웹 브라우저 등의 완전히 테스트된 조합을 포함하는 단일 업데이트를 받습니다. 이러한 모듈 간의 인터페이스는 어떤 버전에서든 변경될 수 있습니다. 왜냐하면 (물론 하드웨어와 웹을 제외하고) 하위 호환성이 필요하지 않기 때문입니다. macOS, iOS, Android도 비슷한 모델을 따릅니다.
- Debian Linux는 수천 명의 개발자가 있지만, 사용자는 개별 패키지를 다운로드하고 설치합니다. 고대의 Debian-oldstable에서 온 패키지 하나를 오늘의 Debian-unstable에서 온 새 패키지와 함께 실행할 수 있으며, 아마도 작동할 것입니다. 아마도 아무도 여러분의 특정 조합을 테스트한 적이 없지만, 패키지 간의 매우 강력하게 정의된 인터페이스 때문에 아마도 작동합니다.

("데스크톱의 Linux"의 불안정성에 대해 사람들은 농담을 합니다. 그들은 항상 첫 번째 주류의 테스트하기 쉬운 종류가 아니라 두 번째 틈새의 테스트하기 어려운 종류에 대해 이야기합니다. 인지된 품질 차이가 실제로 기업 자금 대 오픈 소스에 의해 발생한 것이 아니라고 생각합니다. 차이점은 배포 모델입니다.)

두 시스템 모두 팀으로 조직된 수많은 개발자들이 개발한 수많은 패키지(모듈)를 포함합니다. 둘 다 모듈 간에 인터페이스가 있습니다. 각 시스템의 박스와 화살표 다이어그램을 그린다면, 아마도 꽤 비슷해 보일 것입니다: 커널, 드라이버, 윈도우 시스템, 샌드박스, 웹 브라우저 등.

그러나 이것들이 OS 대신 백엔드 클라우드 서비스였다면, 배포 모델 때문에 이 두 모델을 각각 모놀리스와 마이크로서비스라고 부를 것입니다. 하나는 배포된 "서비스"가 하나뿐이고, 다른 하나는 각각 별도로 배포된 많은 서비스가 있습니다. 같은 모듈 아키텍처에 대해! 무슨 일이 일어나고 있나요?

모듈 경계와 서비스 경계는 두 가지 다른 것입니다.

## 서비스 경계를 어디에 두어야 할까요?

원래의 모듈화 목표를 검토합시다:

1. 격리: 보안 목적으로 정말로 강력한 격리가 필요하다면, 현재로서는 별도의 서비스가 필요합니다. 왜냐하면 격리된 VM을 롤아웃하는 유일한 방법은 별도로 하는 것이기 때문입니다. (그러나 주의하세요: 이것은 아키텍처 목표라기보다 격리 시스템의 한계입니다. "코드로서의 인프라"와 블루/그린 배포는 이러한 서비스를 다시 동기화하여 모놀리식 배포 모델을 가질 수 있도록 노력합니다.)

2. 연결: Conway의 법칙을 따릅니다. 모듈 경계는 팀의 개인적 커뮤니케이션 패턴을 따르는 경향이 있습니다. 하지만 역설적으로, Conway의 법칙은 서비스 경계를 정의할 필요가 없습니다.

3. 호환성 보장: 모놀리스 쪽으로 압력을 가합니다. 모놀리스가 Go, TypeScript, Rust, 또는 심지어 C++와 같은 타입 안전 언어로 작성된 경우 특히 그렇습니다. (예: Chrome은 하나의 거대한 바이너리입니다.)

4. 업그레이드, 다운그레이드, 확장성: 이것들이 주로 서비스 경계를 결정합니다. 조금 더 이야기해 봅시다.

서비스 경계를 선택할 때 고려해야 할 몇 가지 사항이 있습니다:

- 모놀리스가 시작하는 데 오래 걸리나요? 그러면 업그레이드가 고통스러워지므로, 다른 것들의 업그레이드를 더 빠르게 하기 위해 느린 부분을 분리하고 싶을 수 있습니다.

- 올바른 데이터스토어 스키마 버전이 필요한가요? 그것은 때때로 모든 백엔드 인스턴스가 같은 스키마 버전에 있도록 동시 업그레이드/다운그레이드가 필요합니다. 동시 업그레이드는 위험하고 롤백을 방지하는 경향이 있습니다; 때때로 스키마 종속 부분을 가능한 작게 유지하고 싶을 것입니다.

- 지속적 통합 테스트가 자주 실패하나요? 그렇다면 나쁜 소식이 있습니다. 실패하는 테스트는 코드가 망가졌다고 말하고 있습니다. 그것은 기능입니다! 서비스를 분할하고 별도로 롤아웃하면 아마도 테스트가 통과하도록 속일 수 있지만, 그러면 대신 프로덕션에서 호환성과 버전 스큐 문제가 생깁니다. 그것은 도움이 되지 않습니다.

- 일부 부분이 다른 부분과 다르게 스케일되나요? 예를 들어, 일부 작업은 메모리 집약적이고 다른 작업은 CPU 집약적입니다. 이것은 생각만큼 자주 중요하지 않습니다. 모든 인스턴스가 적절하게 로드 밸런싱되면, 부하는 자연스럽게 꽤 효율적인 방식으로 퍼지는 경향이 있습니다. 로드 밸런싱이 문제가 되면, 나중에 측정하고 특정 세분화 문제를 수정할 수 있습니다.

- 비싼 요청을 더 적은 병렬 처리로 실행해야 하나요? 일반적인 마이크로서비스 아키텍처는 요청을 메시지 큐에 덤프하고 워커 인스턴스가 순차적으로 요청을 처리하게 하는 것입니다. 하지만 이것은 생각보다 더 자주 잘못되며, "큐 폭발" 문제를 피하는 더 나은 설계가 있습니다. 모놀리스에서도 같은 설계를 구현할 수 있습니다.

- 품질/신뢰성 목표가 다른 서비스가 있나요? 이것은 서비스를 분할하는 좋은 이유가 될 수 있습니다. 예를 들어, Tailscale에서 우리는 매우 엄격한 가동 시간 목표를 가진 서비스가 몇 개뿐입니다: 조정 서비스와 로그 캐처 서비스. 로그가 매우 민감하기 때문에 이 두 가지는 이미 보안 격리를 위해 분할되어 있습니다. 게다가 우리의 "실시간" 로그/메트릭 처리 파이프라인은 더 많은 다운타임을 허용할 수 있고 따라서 더 많은 실험을 허용하므로, 고신뢰성 서비스와 분리되어 있고 다른 배포 절차를 가질 수 있습니다.

사실, 위의 대부분은 보통 서비스 간 경계를 만드는 꽤 설득력 없는 이유입니다. 모듈이나 팀 간 경계를 만드는 훌륭한 이유가 될 수 있습니다! 하지만 하나 또는 몇 개의 모놀리스로 재결합한 후 모듈을 롤아웃할 수 있습니다.

기억하세요, ChromeOS는 모놀리스입니다. iOS는 모놀리스입니다. 여러분의 팀은 아마도 그 팀들보다 훨씬 작습니다. 원하는 것을 얻기 위해 많은 마이크로서비스를 저글링할 필요가 없습니다. 어려운 방식으로 해야 할 때까지 쉬운 방식으로 설계하세요. 그것이 우리가 하는 것입니다.

2021-02-24 업데이트: 아 맞다, 결합자도
