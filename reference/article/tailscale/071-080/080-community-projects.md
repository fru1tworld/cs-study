# 영원히 하위 호환되는 소프트웨어

저자: Avery Pennarun (CEO)

날짜: 2025년 3월 25일

카테고리: 회사

---

오늘 우리는 Tailscale 커뮤니티 프로젝트(Tailscale Community Projects)를 발표합니다. 이것은 우리와 커뮤니티가 만든 프로젝트들로, Tailscale과 잘 작동하고, 협업하기 쉬우며, 여러분이 도입하면 계속 작동할 것입니다.

이것은 특이한 약속들입니다. 왜 그런지 이야기해 봅시다.

## 업그레이드 러닝머신 멈추기

여러분은 더 이상 눈치채지 못할 수도 있습니다: 소프트웨어 업그레이드를 멈추면 결국 망가질 것이라는 만연한 생각 말입니다. 아니면 최소한 보안 취약점이 생기거나, 벤더가 더 이상 지원하지 않거나, 뭔지는 모르겠지만 분명히 뭔가 나쁜 일이 생길 것입니다. 오래된 소프트웨어는 나쁘다. 그러니 업그레이드하는 게 좋다.

이것은 모든 애플리케이션에 재귀적으로 적용됩니다. 앱이 업데이트된 프레임워크에 의존한다면, 앱 벤더가 프레임워크를 업데이트해야 합니다. 그리고 그것이 앱을 망가뜨리면, 벤더가 앱을 변경해야 합니다. 그래서 여러분은 앱을 업그레이드해야 합니다.

현대 앱과 프레임워크는 수백 개의 의존성을 가지고 있으며, 모든 의존성은 업그레이드 러닝머신 위에 있습니다. 의존성은 매주, 매일, 또는 더 자주 변경될 수 있습니다. 지속적으로 업그레이드하지 않으면 나쁜 일이 발생할 것이므로, 그렇게 하기 위한 프로세스를 마련하는 것이 좋습니다. 이제 풀타임 DevOps 팀, 지속적 배포, 지속적 통합이 필요합니다... 단지 제자리에 머무르기 위해서 말입니다.

음, 거의 제자리입니다. 새 버전의 앱은 또한 버튼을 이리저리 옮기고, API를 변경하고, 오래된 API를 깨뜨리고, 기능을 폐기하고, 여러분이 요청하지도 않은 기능에 더 많은 돈을 청구하며, 때때로 벤더에 의해 버려져서 다시는 업그레이드되지 않습니다 — 이는 업그레이드 러닝머신이 멈추지 않기 때문에 급히 마이그레이션해야 한다는 것을 의미합니다. 러닝머신의 끝에 절망의 절벽이 있더라도 말입니다. 그리고 그 절벽이 다행히도 제 비유의 끝입니다.

Tailscale에서 우리는 다른 길을 가고 있으며, 저는 이것을 "하지만 그러지 않으면 어떨까?"라고 부릅니다.

그 재귀적인 업그레이드 러닝머신을 완전히 멈추려면 무엇이 필요할까요? 저는 이렇게 작동해야 한다고 생각합니다:

- 앱을 업그레이드하지 않겠다
- 왜냐하면 내가 신뢰하는 사람들만 앱에 접근할 수 있다고 확신하기 때문이다
- 그래서 앱의 보안 취약점은 중요하지 않다
- 그리고 그 신뢰할 수 있다고 여겨지는 사람들이 취약점을 악용하더라도, 거기서 내 네트워크의 다른 곳을 공격하기 위해 횡적 이동할 수 없다
- 그리고 앱이 실행되는 플랫폼은 영원히 하위 호환될 것이다
- 그러므로 앱이 의존하는 라이브러리와 프레임워크도 영원히 작동할 것이다
- 그러므로 실제로 새 기능을 원할 때만 업그레이드하면 된다
- 그리고 새 기능을 원하더라도, 여러 프레임워크를 업그레이드하지 않고 앱을 수정할 수 있다
- 정말로 새 버전의 프레임워크에 있는 기능을 원하지 않는 한.

휴. 그 전체 해방적인 연쇄는 위에서 굵게 표시한 두 가지 항목에 달려 있습니다.

첫째, 내가 신뢰하는 사람들만 앱에 접근할 수 있다. 이것은 보안 취약점을 없애는 것이 아니라, 그것을 무관하게 만듭니다. Tailscale의 창립 원칙 중 하나는 LAN을 기억하는 것(Remembering the LAN)입니다: 인터넷 이전에는 보안 취약점이 중요하지 않았습니다. 왜냐하면 그것을 악용할 사람이 없었기 때문입니다. 적절한 보안 조치를 통해 그 세상을 다시 가져올 수 있습니다. 보안 용어로, 여러 "좋은" 보안 계층이 단일 포괄적인 보안 계층만큼 좋지 않다는 강력한 증거가 있습니다. 정말로 모든 달걀을 한 바구니에 담을 수 있습니다. 하지만, 그 바구니를 지키세요.

둘째, 앱이 실행되는 플랫폼은 영원히 하위 호환될 것이다. 영원히. 기반 플랫폼의 ABI가 변경되면 — "플랫폼"을 어떤 수준에서 정의하든 — 표면까지 보일 수 있는 업그레이드의 연쇄 반응이 발생합니다.

우리는 모든 계층에서 보안 취약점에 대해 편집증적이 되도록 훈련받았습니다. 자연스러운 결과로, 플랫폼은 항상 변경되어야 합니다 — 취약점이 있을 때마다. 그러므로 어떤 플랫폼도 안정될 수 없고, 따라서 업그레이드 러닝머신은 체계적으로 불가피합니다.

하지만 사실이 아닙니다.

## 안정적인 플랫폼은 존재하지만, 유지하는 데 비용이 많이 든다

기술 세계의 플랫폼을 보면, 새로운 기능과 보안 수정으로 업그레이드되더라도 항상 무언가를 깨뜨리는 패턴을 따르지 않는 예를 찾을 수 있습니다. 거의 모든 것이 이 플랫폼들 위에 구축되어 있는 것은 우연이 아닙니다.

- 컴퓨팅 플랫폼: x86 (그리고 요즘은 최신 arm64)
- OS 플랫폼: DOS. Win32/Win64. Linux 커널 ABI.
- 웹 플랫폼: HTML과 JavaScript (그리고 이제 wasm)

이 모든 플랫폼에서, 어떤 중앙 회사나 위원회가 해마다, 버전마다, 영원히, 고통스러운 아키텍처 보안 취약점을 막아야 하거나 원래 아이디어가 정말 별로였을 때조차도 호환성을 유지하기 위해 놀라운 양의 작업을 합니다.

[에뮬레이션 다이어그램 이미지]

플랫폼이 사라지더라도 — DOS가 그랬고, win32가 그랬고, x86도 결국 그렇게 될 것입니다 — 그 플랫폼 위에 구축된 것들은 에뮬레이션 덕분에 살아남습니다. 플랫폼을 그대로 유지하는 것이 너무나 가치 있어서 우리는 사라진 플랫폼 아래에 새로운 호환 계층을 삽입하여 위에 있는 것을 투명하게 수정합니다.

이러한 안정적인 플랫폼을 유지하는 것은 정말 비용이 많이 듭니다. 그런데 왜 사람들이 그렇게 할까요? 그것이 또한 정말 수익성이 있기 때문입니다. 사실, 이것은 생존 특성입니다: 장기적으로 살아남는 유일한 플랫폼은 이것을 하는 플랫폼들입니다.

벤더가 플랫폼을 깨뜨릴 때마다, 그들은 두 가지 선택을 줍니다: 그들의 새로운 것으로 업그레이드하거나, 다른 사람의 새로운 것으로 업그레이드하거나. "그냥 유지하기"가 선택이 될 때마다, 그들은 일부 사람들을 잃습니다. 플랫폼을 안정적으로 유지하는 벤더는 압도적 다수, 즉 현상 유지에 만족하는 사람들의 혜택을 받습니다. 대부분의 사람들은 단순히 작동하는 플랫폼과 그 위의 작동하는 솔루션에서 벗어나는 것보다 더 나은 일이 있습니다.

## 인터넷은 플랫폼이다

위의 안정적인 플랫폼 목록에서 하나를 빠뜨렸습니다: TCP/IP.

역사는 매혹적입니다. TCP-over-IPv4는 1980년대부터, 셀 수 없이 많은 하드웨어 플랫폼, OS, 재구현, 최적화, 혼잡 제어 알고리즘, 보안 수정, 우회책, 확장, 미들박스, 프록시, NAT를 거쳐 지속되어 왔습니다. 그런데도, 1983년에 TCP over IPv4를 사용하여 프로그램을 작성하고 오늘날 그 시대의 에뮬레이션된 컴퓨터에서 실행하면, 42년 후인 2025년 iPhone과 통신할 수 있을 가능성이 높습니다. 와우. 이것이야말로 안정적인 것입니다.

하지만, [The New Internet](https://tailscale.com/blog/new-internet)에서 썼듯이, 인터넷 플랫폼은 너무 오랫동안 안정적이어서 가장 오래된 설계 결함이 정말로 우리를 방해하고 있습니다. 호환되지 않는 IPv6를 배포하기 위한 우리의 긴 싸움은 — 당신이 선택받은 자였는데! — 원래의 그리고 여전히 지배적인 IPv4를 대부분 그대로 두고, 그 위에 계속 늘어나는 해킹 더미만 남겼습니다.

우리는 더 잘할 수 있습니다. 그리고, 아무것도 깨뜨리지 않고 더 잘할 수 있습니다.

## Tailscale은 안정적인 플랫폼이다

우리는 많이 이야기하지 않지만, Tailscale을 시작할 때 우리 자신에게 몇 가지 조용한 약속을 했습니다.

첫째, 사람들이 아직 사용하고 있는 어떤 클라이언트 릴리스도 절대 깨뜨리지 않겠다는 것입니다.

둘째, 우리의 공개 코디네이션 서버 API나 정책 파일 문법을 절대 깨뜨리지 않겠다는 것입니다.

셋째, Go로 작성된 Tailscale 클라이언트에서 깨뜨리지 않겠다고 약속하는 API 세트를 명확히 식별하겠다는 것입니다. (그리고 반대로, 구현 세부 사항이므로 건드리지 말아야 할 것들도.)

넷째, 원하는 모든 노드에 대해 IPv4와 IPv6를 모두 지원할 방법을 찾겠다는 것입니다. 영원히. 둘 사이를 투명하게 교차 연결하는 것을 포함해서. 그리고 공용 인터넷이 어떤 형태를 취하든 (순수 IPv4, 순수 IPv6, 또는 새로운 무언가).

다섯째, 보안을 애플리케이션에 투명한 방식으로 기존에 있는 것에 통합하겠다는 것입니다. telnet, ftp, rsh, SMB 같은 구식 IPv4 앱들은 공용 인터넷에서 절망적으로 안전하지 않습니다. 하지만 Tailscale에서는 완전히 안전하게 사용할 수 있습니다. 우리는 엔드투엔드 암호화와 신원을 추가하여 결함을 수정했습니다. 그리고 어떤 앱, 어떤 프로토콜, 스택의 어떤 부분도 수정하지 않고 말입니다.

[에뮬레이션 다이어그램 위의 Tailscale 계층]

결과적으로, 3년 전에 공장의 임베디드 장치에 Tailscale 노드를 배포한 사람들은 3년 후에 상자에서 꺼낼 때 불쾌한 놀라움을 겪지 않을 것입니다. 잘 작동할 것입니다 (키 만료를 올바르게 설정했다고 가정하면 :))

## 우리는 자체 Tailscale 플랫폼을 독파이팅했다

좋습니다, 그래서 이제 더 짧은 결론을 위한 긴 설정이었습니다.

Tailscale에서 수년간 우리는 핵심 제품에 의존하는 여러 작은 도구를 만들었습니다. 이 중 일부는 한 사람이 작성했고 프로덕션에서 많이 사용하더라도 산발적으로만 유지됩니다.

대부분의 상황에서 "산발적으로 유지됨"은 약간 무서울 것입니다. 그것을 사용할 수 없죠, 그렇죠? 모든 의존성을 따라잡기 위해 매주 업데이트되지 않는 도구에 정말로 의존할 수 있을까요? 음, Tailscale에 있다면: 네. 우리는 그렇게 하고, 여러분도 할 수 있습니다. 멋집니다. 우리는 그 멋진 것을 여러분과 공유하고 싶습니다.

아래의 Tailscale 소유 도구들에 대해, 저는 대담한 주장의 조합을 하겠습니다.

- 유지되지 않습니다 (악용 가능한 보안 취약점을 정말로 발견하면 예외... 또는 우리가 그럴 기분일 때).
- 하지만, 지원됩니다.

다시 읽어봅시다. 보통은 반대입니다. 일반적으로 인기 있는 프로젝트는 많이 유지되지만, 돈을 내지 않으면 요청할 때 공식적인 도움을 받지 못합니다. 하지만 Tailscale은 무료 사용자를 포함한 모든 사람에게 우리 제품에 대한 무료 이메일 지원을 제공하며, 오늘부터 이것은 커뮤니티 프로젝트로 확장됩니다.

네, 우리는 여러분의 테일넷에서 이 도구들이 작동하도록 도와드리겠습니다. 도구들이 공식적으로 유지되지 않으므로, 새 기능이나 버그 수정도 보장할 수 없습니다. 있는 그대로 제공됩니다. 하지만, 작동합니다. 그리고 더 중요한 것은, 일단 작동하게 하면, 예외 없이 계속 작동할 것입니다. 그것이 약속입니다.

물론, 패치는 환영합니다. Tailscale의 핵심은 어려운 부분(하위 호환성, 연결성, NAT 통과, 인증, 권한 부여)을 담당하며, 그것에 기여하는 것이 까다로울 수 있다는 것을 알고 있습니다. 그에 비해, 이 커뮤니티 프로젝트들은 포크하고 해킹하기 재미있고 쉬운 경향이 있습니다. 훌륭한 장난감, 새 장난감을 위한 템플릿, 또는 새로운 오픈 소스 개발자를 위한 스타터 프로젝트가 됩니다.

## Avery가 좋아하는 Tailscale 커뮤니티 프로젝트들

좋습니다, 오늘 우리는 첫 번째 프로젝트 배치를 출시합니다. 이 중 일부는 한동안 있었지만, 많은 경우 가볍게만 문서화되었거나 큰 경고 표시가 있었거나, 유지되는지 신뢰할 수 있는지 명확하지 않았습니다. 우리는 이 모든 문제를 해결하기 위해 약간의 작업을 해서 여러분이 더 안전하게 가지고 놀 수 있도록 했습니다.

제가 좋아하는 것들입니다!

- JIT accessbot은 Tailscale과 Slack API를 호출할 수 있는 Slackbot을 테일넷에 호스팅하는 방법의 훌륭하고 직관적인 예입니다. 현재 버전은 우리의 엔터프라이즈 장치 상태(device posture) API(개인 플랜에서도 사용 가능)를 사용하여 요청/승인 프로세스 후에 장치 상태를 일시적으로 조정하고, 이는 접근 권한에 영향을 미칩니다. 하지만 원하는 트리거나 원하는 UI에 따라 원하는 테일넷 변경을 일으키도록 간단히 수정할 수 있습니다.

- setec은 키와 기타 비밀을 위한 일종의 "안전 금고"입니다. 비밀을 저장하는 가장 어려운 부분은 부트스트래핑입니다: 비밀 저장소에 자신을 인증하는 데 사용할 키를 어디에 둘까요? 그리고 그 모든 것을 완료했으면, 정말로 다른 비밀 저장소가 필요할까요 아니면 그것만 사용해도 될까요? 하지만 Tailscale에서는 이미 인증을 해 주므로, 어려운 부트스트랩 문제가 이미 해결되었습니다. 이것은 setec이 정말 간단할 수 있다는 것을 의미합니다; 누가 어떤 것을 읽고 쓸 수 있는지에 대한 안전한 키/값 저장소와 일부 구성 설정일 뿐입니다. 또한 ACL Grants를 사용하여 Tailscale로 구성되는 앱을 작성하는 방법의 훌륭한 예입니다.

- tsidp는 세계에서 가장 작은 OIDC 공급자입니다. 모든 Tailscale 패킷에는 신원이 첨부되어 있습니다. 하지만, 모든 앱이 Tailscale에서 그 신원을 읽는 방법을 아는 것은 아닙니다. 반면에, 많은 앱이 OIDC 공급자에 대해 인증하는 방법을 알고 있습니다. 그래서, tsidp가 둘을 연결합니다. OIDC 키를 요청하면, 이미 누구인지 알기 때문에 즉시 제공합니다. 그리고, Tailscale Funnel을 통해 내보내면 테일넷 외부의 앱(다른 사람의 SaaS 앱 같은!)과도 작동합니다. 그리고 가장 좋은 것은, 아무도 여러분의 tsidp 신원으로 어떤 앱을 사용하는지 추적할 수 없습니다 — 왜냐하면 우리가 아닌 여러분이 신원 제공자이기 때문입니다. Tailscale과 Funnel에서 항상 그렇듯이, 여러분의 트래픽은 엔드투엔드 암호화되어 있고 우리 자신도 복호화할 수 없습니다.

- golink는 Tailscale의 내장 인증, 내장 https, MagicDNS를 사용하여 간단한 앱을 만드는 방법의 예입니다. 어딘가 컨테이너에 golink를 설치하면, 테일넷의 모든 사람에 대해 원하는 URL로 리디렉션하는 기억하기 쉬운 "go/whatever" 링크를 만들 수 있습니다. 브라우저 확장이 필요 없습니다. 또한, 음, 더 예쁘게 만드는 패치를 주시면 감사하겠습니다.

- tclip은 간단한 명령줄 클라이언트가 있는 비공개로 호스팅되는 pastebin 대안입니다. 명령줄에서 텍스트를 잘라내어 붙여넣고 다른 사람과 공유하세요. 명령줄 도구는 로그인, 키나 토큰, 매직 문자열이 필요 없습니다. 왜냐하면 Tailscale 덕분에 서버는 항상 여러분인 것을 알기 때문입니다.

- Caddy용 Tailscale 플러그인은 자동 LetsEncrypt 인증서와 테일넷으로의 포워딩을 갖춘 자체 도메인 이름을 사용하여 내부 서비스를 공개적으로 게시하기 쉽게 만듭니다.

[Tailscale 커뮤니티 프로젝트 홈페이지 스크린샷]

전체 도구 및 확장 목록을 확인하려면, 우리의 새롭고 반짝이는 [커뮤니티 프로젝트 홈페이지](https://tailscale.com/community-projects)를 살펴보세요.

미래에 사는 것을 즐기세요! 그리고 [Bluesky](https://bsky.app/profile/tailscale.com), [Twitter](https://twitter.com/tailscale)... 죄송합니다, X, [Mastodon](https://hachyderm.io/@tailscale), [LinkedIn](https://www.linkedin.com/company/tailscale/)에서 여러분의 의견을 보내주세요. 또는 그 중 어느 것도 작동하지 않으면, 전서구나 병 속의 메시지를 시도해 보세요.

## 각주

[1] 동료를 신뢰할 수 없다면, 그것은 다른 문제이며, 아무리 많은 소프트웨어 업그레이드로도 해결되지 않습니다.

[2] 이 전체 기사는 공용 인터넷에서 공격에 노출된 공개 SaaS 앱이 아닌, 친구와 동료를 위한 작은 앱 인스턴스에 관한 것입니다. 크고 확장 가능한 앱에는 크고 확장 가능한 보안이 필요합니다. 하지만 동료만 접근할 수 있는 앱에는 그렇지 않습니다.

[3] 오랫동안 ARM은 MIPS만큼이나 호환되지 않는 변형으로 유명한 임베디드 아키텍처였습니다. 다행히 그들은 그 나쁜 습관을 극복한 것 같고 이제 "arm64용으로" 컴파일하면 많은 장치에서 일관되게 작동하는 바이너리를 얻을 수 있습니다.

[4] 하지만 macOS와 iOS는 아닙니다. 그들은 항상 사과도 없이 무언가를 깨뜨립니다. Linux 사용자 공간은 반쯤 노력하지만 충분하지 않아서 컨테이너가 인기를 얻었습니다.

[5] IPv6는 이전 플랫폼과 호환되지 않는 고전적인 실수를 저질렀습니다. 그래서 사람들은 유지(지금 당장 작동함)할지 전환(지금 당장 작동하지 않음)할지 선택해야 했습니다. 당연히, IPv6 채택은 25년 동안 느렸습니다. 이것은 닭과 달걀 문제입니다.

[6] 그것들이 조용했던 이유는 우리가 지킬 수 있을지 확신하지 못했기 때문이고, 약속을 어기는 것은 항상 당황스럽기 때문입니다. 수년 후인 지금 우리는 그것들에 대해 더 자신감이 있습니다.

[7] 참고로, 이것은 들리는 것보다 약간 더 달성 가능합니다. 우리의 코디네이션 서버는 "롤 포워드"입니다. 즉, 새 서버 버전은 이전 클라이언트를 지원해야 하지만, 새 클라이언트는 이전 서버를 지원할 필요가 없습니다. 그들은 이전 서버를 절대 보지 않을 것입니다. 이것은 검증 테스트 오버헤드가 (서버, 클라이언트) 버전 쌍의 수에 대한 O(m*n)이 아니라 클라이언트 버전 수에 대한 O(n)일 수 있다는 것을 의미합니다.

[8] 예외는 사람들의 headscale 배포입니다. 우리는 항상 새 클라이언트를 이해할 것이라고 보장할 수 없습니다. 죄송합니다. 우리는 headscale에 대한 자동화된 테스트에 노력을 기울입니다. 하지만 모든 조합을 완벽하게 만드는 데 필요한 O(m*n) 테스트를 따라잡는 것은 불가능합니다. headscale을 사용하면, 적어도 그 구성 요소는 업그레이드 러닝머신 위에 두어야 합니다. 이것은 어차피 좋은 생각입니다. 왜냐하면 그것이 수십억 명의 신뢰할 수 없는 사람들이 공격할 기회가 있는 유일한 공개 구성 요소이기 때문입니다.

[9] 이것을 안전하게 만드는 몇 가지 트릭이 있습니다. 핵심 Tailscale은 공용 네트워크를 향하는 두 종류의 포트만 있습니다: TLS와 코디네이션 서버가 안전한 한 안전한 코디네이션 서버로의 발신 연결; 그리고 10년 전 출시 이후 보안 취약점이 보고된 적이 없을 정도로 단순한 WireGuard 프로토콜을 통한 수신 연결.

[10] Tailscale SSH와 Taildrop 같은 다른 Tailscale 수신 포트는 치명적인 버그를 발견할 경우 클라이언트 소프트웨어 버전에 따라 코디네이션 서버에 의해 노드별로 선택적으로 비활성화될 수 있습니다. 지금까지 이것은 필요하지 않았습니다. 부분적으로 Go의 메모리 안전 프로그래밍 모델 덕분입니다.

[11] 네, 저는 예상하는 만큼의 내부 눈썹 치켜올림을 받습니다. 하지만 그것은 계속 높아지는 미친 듯이 높은 품질 기준을 유지하는 데 도움이 됩니다. 그리고 네, 그 약속에도 불구하고 우리의 총 마진은 여전히 건전합니다. 왜냐하면 훌륭한 무료 지원을 받은 팬들은 훌륭한 무료 지원을 받았다고 말하는 슈퍼팬이 되기 때문입니다. 또한, 우리 지원 팀은 영웅들입니다. 다음에 그들과 이야기할 때, Avery가 감사하다고 전해주세요.

[12] 최소한, 우리가 그것들을 깨뜨리지는 않을 것입니다. 다른 사람들의 API를 호출하면 (예를 들어, JIT accessbot은 Slack API를 호출해야 합니다) 다른 사람들이 API를 깨뜨리거나 폐기하는 것을 막을 수 없습니다. 또는, 컨테이너 플랫폼이 마음을 정하지 못하면, 그것은 우리 잘못이 아닙니다.

[13] 이것에 대해 생각하면 할수록, 더 재미있어집니다. 타사 제공자가 여러분이 어떤 앱에 로그인하는지 아는 것이 싫으신가요? Google, Microsoft, 또는 Okta를 사용하여 매우 안전한 최상위 IdP를 통해 Tailscale 계정에 로그인할 수 있습니다. 하지만 그 다음에는 tsidp를 사용하여 다른 모든 것에 로그인할 수 있으므로, 그들이 아는 유일한 앱은 Tailscale입니다. 이것을 Tailnet lock과 결합하면 전체 SSO 체인이 Tailscale 코디네이션 서버의 침해와 선택한 SSO 공급자의 침해로부터 보호됩니다.

[14] 작은 예외가 하나 있습니다. Tailscale Funnel이 외부 대면 tsidp를 위한 TLS 인증서를 발급하고 우리가 ts.net 도메인을 소유하므로, Tailscale 코디네이션 서비스의 침해가 tsidp 인증서의 침해로 이어질 수 있습니다. 우리를 신뢰하지 않는다면, Funnel을 건너뛰고, ts.net 대신 자체 도메인을 사용하고, 대신 완전히 통제 하에 있는 TLS 인증서로 자체 공개 서버를 호스팅하여 이 의존성을 제거할 수 있습니다.

---

저자: Avery Pennarun

게시일: 2025년 3월 25일
