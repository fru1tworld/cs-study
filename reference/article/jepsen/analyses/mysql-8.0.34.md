# MySQL 8.0.34 Jepsen 분석

## 개요
Jepsen은 MySQL 8.0.34의 트랜잭션 격리 수준을 독립적으로 검증했습니다. 보고서는 MySQL의 Repeatable Read가 공식 문서의 주장과 달리 심각한 일관성 문제를 가지고 있음을 보여줍니다.

## 주요 발견사항

### 1. G2-item 위반 (쓰기 스큐)
MySQL Repeatable Read에서 두 트랜잭션이 서로의 영향을 관찰하지 못하는 사례가 발생합니다. 예를 들어, 회로 차단기 패널 시나리오에서 두 전기 기술자가 각각 20암페어 회로를 추가하면서 총 110암페어(제한값 100)를 초과할 수 있습니다.

### 2. G-single 위반 (읽기 스큐)
"트랜잭션이 다른 트랜잭션의 영향을 관찰하지 못하면서도 해당 행을 덮어쓸 수 있는" 상황이 발생합니다. 40초 테스트에서 214개의 순환 참조가 감지되었습니다.

### 3. 손실된 업데이트 (P4 현상)
두 트랜잭션이 동일한 키의 동일 버전을 읽은 후 모두 업데이트하는 경우입니다. 9,048개 성공 트랜잭션 중 198개 인스턴스에서 446개 트랜잭션이 관여했습니다.

### 4. 내부 일관성 위반
단일 트랜잭션 내에서 문제가 발생합니다. 예시:
- 키 읽음: nil → 값 6 추가 → 다시 읽음: [3 4 2 6] (세 요소가 갑자기 나타남)
- 거의 모든 성공 트랜잭션의 1.4%가 내부 일관성 오류를 보임

### 5. 반복 불가능한 읽기 (Non-Repeatable Read)
"트랜잭션이 이름을 읽고(pebble), 성별을 업데이트한 후 동일한 이름을 다시 읽었지만(moss), 트랜잭션이 변경하지 않았는데도 값이 변경됨"

### 6. 단조 원자 뷰 위반 (Monotonic Atomic View)
트랜잭션이 행 0의 이전 값을 본 후 행 1의 업데이트된 값을 본 다음, 행 0의 이전 값을 다시 봅니다.

### 7. AWS RDS의 Serializable 격리 위반
RDS MySQL은 "Serializable" 수준에서도 G-single 및 G2-item 이상을 보입니다. `replica_preserve_commit_order=OFF` 기본값이 원인으로 추정됩니다.

## 기술적 배경

### ANSI SQL 격리 수준의 문제
- 1977년 Gray et al.이 정의한 4가지 일관성 수준이 1992년 SQL 표준에 채택됨
- 1995년 Berenson et al.이 이들 정의가 "모호하고 불완전"함을 증명
- 28년이 지난 2023년도 표준이 여전히 동일한 문제 있는 정의 유지

### Adya의 형식화 (1999)
더 정확한 정의를 제시:
- PL-1: G0 금지 (더티 쓰기)
- PL-2: G0, G1 금지 (읽기 커밋)
- PL-2.99: G0, G1, G2-item 금지 (Repeatable Read)
- PL-3: 모든 순환 금지 (Serializable)

MySQL Repeatable Read는 "PL-2.99보다 약함"

## 테스트 방법

### 워크로드
1. List-Append: Elle 트랜잭션 일관성 검사기 사용, 목록에 정수 요소 추가
2. Non-Repeatable Read: 사람 테이블에서 이름/성별 필드 반복 읽기
3. Monotonic Atomic View: 두 행의 값을 단조 증가하는 방식으로 업데이트

### 환경
- MySQL 8.0.34 및 MariaDB 10.11.3
- 단일 노드 및 바이너리 로그 복제 클러스터
- AWS RDS MySQL 다중 AZ 클러스터
- LazyFS를 이용한 fsync 손실 시뮬레이션

## 권장사항

### MySQL 사용자
"Repeatable Read 시맨틱이 필요하면 MySQL의 Serializable 격리를 사용하거나 `SELECT ... FOR UPDATE`를 이용한 명시적 잠금 사용"

### MySQL 커뮤니티
두 가지 해결 방안 제시:
1. 현재 동작 유지: "Repeatable Read는 실제로 읽기 커밋에 몇 가지 추가 보장을 제공"이라고 명확히 문서화
2. 버그로 취급: PL-2.99 또는 ANSI 정의 Repeatable Read 구현

### AWS RDS
`slave_preserve_commit_order`를 기본값에서 `ON`으로 변경하거나 Serializable 수준의 알려진 제한사항을 명확히 문서화

## 커뮤니티 이해도 부재

MySQL 문서와 다양한 서적에서:
- "Repeatable Read는 lost update를 방지한다"고 주장 (거짓)
- "트랜잭션은 첫 읽기로 확립된 스냅샷을 본다"고 명시 (실제로는 쓰기 후 더 새로운 버전 관찰)

이러한 부정확한 정보는 개발자들을 위험한 ORM 패턴(읽기-수정-쓰기)으로 인도합니다.

## 결론

MySQL 8.0.34의 Repeatable Read는 공식 문서의 주장과 일치하지 않습니다. 읽기가 반복 불가능하며, 트랜잭션 내 일관성을 위반하고, 원자성을 보장하지 않습니다. 현재 구현은 어떤 표준 격리 수준과도 정확히 일치하지 않으며, 명확한 형식화 없이는 분류하기 어렵습니다.
