# VoltDB 6.3 Jepsen 분석

## 개요
이 보고서는 VoltDB 6.3의 일관성 문제를 상세히 분석합니다. VoltDB는 엄격한 직렬화 가능성을 주장하지만, 실제로는 "부실한 읽기, 더티 읽기, 손실된 업데이트"를 허용합니다.

## 주요 발견사항

### 1. 부실한 읽기 (Stale Reads)
VoltDB의 최적화로 인해 읽기 전용 트랜잭션이 SPI(Single-Partition Initiator)를 거치지 않습니다. 네트워크 분할 중에 고립된 노드는 이전 데이터를 반환할 수 있습니다. 보고서는 한 프로세스가 값 4를 읽는데 다른 프로세스들이 2를 읽는 상황을 보여줍니다.

### 2. 더티 읽기 (Dirty Reads)
복제가 완료되기 전에 부분적으로 복제된 쓰기 결과가 읽기에 표시될 수 있습니다. 테스트 결과 "93개의 더티 읽기 발생"이 확인되었습니다.

### 3. 손실된 업데이트 (Lost Updates)
두 가지 메커니즘으로 인해 발생합니다:

- 분할 감지 경쟁: 소수 측 노드가 응답을 클라이언트에 반환한 후 종료되는 경쟁 조건
- 잘못된 복구 계획: 가장 긴 로그를 선택하는 방식이 소수 측 노드의 더 긴 로그를 우선순위하여 다수 측의 확인된 쓰기를 삭제

## 기술적 근거

VoltDB는 모든 복제본의 승인을 요구하지만, 응답 불가능한 노드를 제거할 수 있습니다. 네트워크 분할 시 "양쪽이 서로를 죽은 것으로 선언하여 독립적인 클러스터로 분할"될 수 있습니다. 분할 감지기는 비동기이므로, 소수 측이 종료되기 전에 대기 중인 트랜잭션을 완료시킬 수 있습니다.

## 해결책

VoltDB 6.4에서 모든 주요 문제가 수정되었습니다:
- 읽기가 쓰기 완료를 기다리도록 강제 (ENG-10389)
- 분할 감지 전에 클라이언트 응답 반환 (ENG-10453)
- 로그에서 최종 클러스터 토폴로지 재구성 (ENG-10486)

## 권장사항

6.3 사용자는 읽기 전용 트랜잭션에 "사용되지 않는 업데이트 문을 포함"하여 분석기가 최적화된 경로를 우회하도록 할 수 있습니다. 그러나 손실된 업데이트 위험은 여전히 존재합니다.

결론: VoltDB 6.4는 테스트를 통과했으며 엄격한 직렬화 가능성을 제공하는 것으로 보입니다.
