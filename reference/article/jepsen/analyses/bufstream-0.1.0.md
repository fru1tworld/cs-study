# Jepsen 분석: Bufstream 0.1.0

## 개요
이 Jepsen 보고서는 Kyle Kingsbury가 수행하고 Buf Technologies가 후원한 것으로, S3와 같은 객체 스토리지 백엔드를 사용하는 Kafka 호환 스트리밍 시스템인 Bufstream 0.1.0을 평가합니다.

## Bufstream 특정 문제

### 안전성 문제 (3개)

1. 가짜 제로 오프셋 (#3) - etcd 또는 Bufstream이 일시 중지/충돌될 때 레코드가 오프셋 `0`을 여러 번 받았습니다. 발신자만 제로 오프셋을 보았고 폴러는 더 높은 값을 보았습니다. Bufstream이 오류 필드를 생략하여 Java 클라이언트가 오류를 성공적인 쓰기로 잘못 해석했습니다. 0.1.3-rc.6에서 수정됨.

2. 트랜잭션 쓰기 손실 (#4) - 0.1.2에서 커밋된 트랜잭션 레코드가 완전히 사라졌습니다. 동시 트랜잭션 번호 추적의 버그로 인해 프로듀서 에포크 간에 일부 커밋이 무시되었습니다. 0.1.3-rc.2에서 수정됨.

3. 서버 측 필터링을 통한 쓰기 손실 (#5) - 0.1.3-rc.8의 응답 크기 제한 로직이 지연된 컨슈머로부터 레코드를 숨겨 데이터 손실처럼 나타났습니다. 0.1.3-rc.12에서 수정됨.

### 활성도 문제 (2개)

1. 멈춘 컨슈머 (#1) - 승인된 레코드가 남아있음에도 최종 읽기 단계가 무기한 정지되었습니다. Bufstream이 재시작 후 오래된 워터마크 값을 캐시했습니다. 0.1.3-rc.6에서 수정됨.

2. 멈춘 프로듀서/컨슈머 (#2) - 짧은 코디네이터 일시 중지가 몇 분간 지속되는 준안정 장애를 유발했습니다. etcd 리스 삭제가 에이전트에 전파되지 않았습니다. 0.1.3-rc.8에 추가 폴링 로직 추가됨.

## Kafka 전체에 영향을 미치는 문제

분석에서 모든 호환 시스템에 영향을 미치는 네 가지 근본적인 Kafka 문제를 식별했습니다:

1. KIP-588 - 잘못된 오류 메시지: 경쟁 프로듀서가 없음에도 트랜잭션 타임아웃에 대해 `ProducerFencedException`이 발생합니다. 2년 된 미해결 문제.

2. KAFKA-17734 - 타임아웃 매개변수에도 불구하고 Consumer.close()가 무한 차단됩니다. wakeup()을 통한 스레드 인터럽트도 실패합니다.

3. KAFKA-17582 - 트랜잭션 실패 후 예측 불가능한 컨슈머 오프셋 동작. 문서에서는 컨슈머가 되감긴다고 주장하지만 실제 동작: 리밸런스 이벤트 중에만 되감깁니다. 사용자가 수동으로 되감아야 합니다.

4. KAFKA-17754 - 중단된 읽기, 손실된 쓰기, "찢어진 트랜잭션"(부분 원자성 위반)을 유발하는 중요한 프로토콜 결함. Kafka 트랜잭션 프로토콜은 TCP 소켓 간 클라이언트 메시지 순서를 정하기 위한 시퀀스 번호나 트랜잭션 ID가 없습니다. 지연된 `EndTxn` 메시지가 잘못된 트랜잭션을 커밋/중단할 수 있습니다. 프로세스 일시 중지 또는 재시도 시 발생합니다. 제안된 수정: KIP-890(트랜잭션당 에포크 증가).

## 테스트 방법론

- 플랫폼: 3-5개 Debian Bookworm 노드(LXC 컨테이너 및 EC2 VM)
- 구성 요소: etcd 코디네이터, Minio S3 스토리지, Bufstream 에이전트
- 클라이언트: Java Kafka Client 3.8.0
- 구성: 보수적인 안전 설정(acks=all, 멱등성 활성화, read_committed 격리, 자동 커밋 비활성화)
- 주입된 결함: 프로세스 일시 중지, 충돌, 클럭 스큐, 네트워크 분할

두 가지 워크로드가 설계되었습니다:

큐 워크로드 - 지수 키 분포를 가진 다중 프로세스 프로듀서 및 컨슈머. 승인된 쓰기 간의 오프셋 단조성, 중복 및 손실된 레코드 검증.

중단 워크로드 - 의도적인 중단 후 오프셋 동작을 관찰하는 단일 파티션 트랜잭션 테스트. 예측 불가능한 되감기/전진 패턴 발견.

## 핵심 기술적 통찰

분석은 Bufstream의 아키텍처—불변 객체 스토리지 청크의 순서를 설정하기 위해 etcd를 조정 서비스로 사용—가 근본적으로 건전하다는 것을 보여줍니다. 그러나 Kafka의 트랜잭션 프로토콜 설계로부터 중요한 취약점을 상속받습니다.

핵심 문제: Kafka는 존재하지 않는 순서화된 신뢰할 수 있는 메시지 전달을 가정합니다. 클라이언트는 노드와 TCP 소켓 간에 메시지를 분배하고, 자동으로 재시도하며, 0이 아닌 지연 시간을 경험합니다. 프로토콜에는 메시지가 순서가 맞지 않거나 중복될 때 의도를 재구성하기 위한 시퀀스 번호나 트랜잭션 식별자가 포함되어 있지 않습니다.

## 권장 사항

Bufstream 사용자를 위해:
- 즉시 0.1.3+로 업그레이드(모든 문제 해결됨)
- Kafka 프로토콜 결함으로 인해 트랜잭션이 여전히 안전하지 않음을 인식
- 잠재적으로 더 안전한 대안으로 Franz-go 클라이언트 고려
- 에이전트 재시작을 위한 프로세스 감독 구현

Kafka 커뮤니티를 위해:
- 권위 있는 트랜잭션 의미론 문서 작성(KAFKA-17671)
- KIP-890을 통해 프로토콜 수정(트랜잭션당 에포크)
- Confluent 문서를 실제 동작과 일치시킴
- 컨슈머 오프셋 되감기 모호성 해결

보고서는 성공적인 버그 수정에도 불구하고 KAFKA-17754가 미해결 상태로 남아 있으며 클라이언트 라이브러리 및 프로토콜 개선이 구현될 때까지 모든 Kafka 호환 시스템에 영향을 미친다고 강조합니다.
