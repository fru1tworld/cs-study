# 배포 (Deployment)

> 이 문서는 Vector 공식 문서의 Deployment 섹션을 한국어로 번역한 것입니다.
> 원문: https://vector.dev/docs/setup/deployment/

Vector는 에이전트로 배포할 수 있을 만큼 효율적이면서 동시에 애그리게이터로 배포할 수 있을 만큼 강력합니다. 이 문서에서는 Vector의 배포 역할과 토폴로지에 대해 설명합니다.

## 목차

1. [배포 역할 (Roles)](#1-배포-역할-roles)
   - [에이전트 (Agent)](#11-에이전트-agent)
   - [애그리게이터 (Aggregator)](#12-애그리게이터-aggregator)
2. [토폴로지 (Topologies)](#2-토폴로지-topologies)
   - [분산형 (Distributed)](#21-분산형-distributed)
   - [중앙 집중형 (Centralized)](#22-중앙-집중형-centralized)
   - [스트림 기반 (Stream-based)](#23-스트림-기반-stream-based)
3. [배포 전략 선택](#3-배포-전략-선택)

---

## 1. 배포 역할 (Roles)

> 원문: https://vector.dev/docs/setup/deployment/roles/

Vector는 데이터 파이프라인 아키텍처를 위한 세 가지 주요 배포 역할을 지원합니다.

### 1.1 에이전트 (Agent)

에이전트 역할은 단일 호스트에서 모든 데이터를 수집하도록 설계되었습니다. 에이전트는 두 가지 구성 방식으로 배포할 수 있습니다: 데몬(Daemon) 과 사이드카(Sidecar).

#### 1.1.1 데몬 (Daemon)

데몬 역할은 단일 호스트의 모든 서비스에서 데이터를 수집합니다. 효율적인 방향성 비순환 그래프(DAG) 토폴로지 모델을 사용하여 여러 서비스에서 동시에 데이터를 수집하고 처리할 수 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                            호스트                                │
│                                                                  │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                          │
│  │ 서비스 A │  │ 서비스 B │  │ 서비스 C │                          │
│  └────┬────┘  └────┬────┘  └────┬────┘                          │
│       │            │            │                                │
│       │   STDOUT   │   STDOUT   │   STDOUT                       │
│       ▼            ▼            ▼                                │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                      플랫폼 캡처                          │   │
│  └──────────────────────────┬───────────────────────────────┘   │
│                             │                                    │
│                             ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Vector (데몬)                          │   │
│  └─────────┬─────────────────┬─────────────────┬────────────┘   │
│            │                 │                 │                 │
└────────────┼─────────────────┼─────────────────┼─────────────────┘
             │                 │                 │
             ▼                 ▼                 ▼
        ┌─────────┐       ┌─────────┐       ┌─────────┐
        │  목적지 A │       │  목적지 B │       │  목적지 C │
        └─────────┘       └─────────┘       └─────────┘
```

데이터 흐름:

1. 서비스가 STDOUT으로 출력 (12-factor 앱 원칙 준수)
2. 플랫폼이 STDOUT을 캡처
3. Vector가 데이터를 수집하여 여러 목적지로 분배

장점:

- 호스트 리소스를 가장 효율적으로 사용
- 여러 서비스에서 동시에 데이터 수집 가능
- 중앙 집중식 로그 관리

권장 사항:

데몬 역할은 호스트 리소스를 가장 효율적으로 사용하므로 대부분의 배포에서 권장됩니다.

#### 1.1.2 사이드카 (Sidecar)

사이드카 역할은 Vector를 개별 서비스에 결합하여 단일 서비스의 데이터를 수집합니다. 데몬 방식보다 효율성은 낮지만 관리가 더 간단할 수 있으며, 수집 책임을 서비스 소유자에게 이전할 수 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                            호스트                                │
│                                                                  │
│  ┌─────────────────────────┐  ┌─────────────────────────┐       │
│  │        Pod A            │  │        Pod B            │       │
│  │  ┌─────────┐            │  │  ┌─────────┐            │       │
│  │  │ 서비스 A │            │  │  │ 서비스 B │            │       │
│  │  └────┬────┘            │  │  └────┬────┘            │       │
│  │       │ 공유 볼륨/파일    │  │       │ 공유 볼륨/파일    │       │
│  │       ▼                 │  │       ▼                 │       │
│  │  ┌─────────────┐        │  │  ┌─────────────┐        │       │
│  │  │   Vector    │        │  │  │   Vector    │        │       │
│  │  │ (사이드카)   │        │  │  │ (사이드카)   │        │       │
│  │  └──────┬──────┘        │  │  └──────┬──────┘        │       │
│  └─────────┼───────────────┘  └─────────┼───────────────┘       │
│            │                            │                        │
└────────────┼────────────────────────────┼────────────────────────┘
             │                            │
             ▼                            ▼
        ┌─────────────────────────────────────┐
        │           다운스트림 서비스            │
        └─────────────────────────────────────┘
```

데이터 흐름:

1. 서비스가 공유 리소스(볼륨의 파일, 접근 가능한 위치)로 출력
2. Vector가 데이터를 수집
3. Vector가 다운스트림으로 데이터 전달

장점:

- 서비스별 독립적인 수집 관리
- 수집 책임을 서비스 소유자에게 위임 가능
- 서비스별 맞춤 설정 용이

사용 사례:

- 조직 구조상 서비스 소유자가 로그 수집을 담당해야 하는 경우
- 서비스별로 다른 수집 설정이 필요한 경우
- 컨테이너화된 환경에서 Pod 단위 관리가 필요한 경우

### 1.2 애그리게이터 (Aggregator)

애그리게이터 역할은 중앙 처리를 위해 설계되었으며, 여러 업스트림 소스에서 데이터를 수집하고 호스트 간 집계 및 분석을 수행합니다.

```
┌──────────┐   ┌──────────┐   ┌──────────┐
│  호스트 A  │   │  호스트 B  │   │  호스트 C  │
│ (에이전트) │   │ (에이전트) │   │ (에이전트) │
└─────┬────┘   └─────┬────┘   └─────┬────┘
      │              │              │
      └──────────────┼──────────────┘
                     │
                     ▼
      ┌─────────────────────────────┐
      │    Vector (애그리게이터)      │
      │                             │
      │  - 파싱                      │
      │  - 변환                      │
      │  - 보강                      │
      │  - 호스트 간 집계             │
      └──────────────┬──────────────┘
                     │
         ┌───────────┼───────────┐
         │           │           │
         ▼           ▼           ▼
    ┌─────────┐ ┌─────────┐ ┌─────────┐
    │  목적지 A │ │  목적지 B │ │  목적지 C │
    └─────────┘ └─────────┘ └─────────┘
```

핵심 기능:

1. 데이터 수신: 업스트림 Vector 인스턴스로부터 데이터 수신
2. 처리: 데이터 파싱, 변환, 보강
3. 분배: 하나 이상의 다운스트림 서비스로 데이터 팬아웃

장점:

- 호스트 간 데이터 집계 및 분석 가능
- 글로벌 메트릭 계산 (예: 전체 인프라의 에러율)
- 중앙에서 복잡한 처리 로직 관리
- 다운스트림 서비스 보호 (버퍼링, 재시도)

권장 사항:

> 중요: 가능하면 처리를 엣지로 푸시하는 것이 좋습니다. 엣지에서 처리하는 것이 더 효율적이고 관리하기 쉽습니다.

애그리게이터 역할은 호스트 간 집계와 분석이 실제로 필요한 경우에만 사용해야 합니다. Vector의 고유한 기능 중 하나는 에이전트와 애그리게이터로 동시에 작동할 수 있다는 것입니다.

Kubernetes에서의 배포:

Kubernetes 환경에서 애그리게이터를 배포하려면 Helm 패키지 매니저를 사용할 수 있습니다.

```bash
# Helm 저장소 추가
helm repo add vector https://helm.vector.dev
helm repo update

# 애그리게이터로 Vector 설치
helm install vector vector/vector \
  --set role=Aggregator
```

---

## 2. 토폴로지 (Topologies)

> 원문: https://vector.dev/docs/setup/deployment/topologies/

토폴로지는 Vector 인스턴스들이 어떻게 연결되고 데이터가 어떻게 흐르는지를 정의합니다. Vector는 세 가지 주요 배포 토폴로지를 지원합니다.

### 2.1 분산형 (Distributed)

분산형 토폴로지에서는 Vector가 클라이언트 노드에서 직접 다운스트림 서비스와 통신합니다. 중간 구성 요소 없이 가장 단순한 배포 방식입니다.

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   호스트 A    │  │   호스트 B    │  │   호스트 C    │
│              │  │              │  │              │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  서비스   │ │  │ │  서비스   │ │  │ │  서비스   │ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
│      ▼       │  │      ▼       │  │      ▼       │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  Vector  │ │  │ │  Vector  │ │  │ │  Vector  │ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
└──────┼───────┘  └──────┼───────┘  └──────┼───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         ▼
              ┌─────────────────────┐
              │  다운스트림 서비스     │
              │  (Elasticsearch 등)  │
              └─────────────────────┘
```

#### 장점

| 장점 | 설명 |
|------|------|
| 단순함 | 구성 요소가 적어 이해하고 구현하기 쉽습니다. |
| 애플리케이션과 함께 확장 | 리소스가 앱 확장에 따라 자연스럽게 증가합니다. |

#### 단점

| 단점 | 설명 |
|------|------|
| 리소스 비효율성 | 복잡한 파이프라인은 상당한 로컬 리소스를 소비하여 동일 호스트에서 실행되는 애플리케이션 성능을 저하시킬 수 있습니다. |
| 데이터 손실 위험 | 데이터가 호스트에서 버퍼링되므로 복구 불가능한 크래시 발생 시 버퍼링된 데이터를 잃을 가능성이 높습니다. |
| 다운스트림 부담 | 통합된 페이로드 대신 다운스트림 서비스에 작은 요청이 여러 번 전송되어 안정성에 영향을 줄 수 있습니다. |
| 용량 제한 | 빠른 확장이나 예기치 않은 트래픽 급증 시 중앙 버퍼링 없이는 다운스트림 서비스가 과부하될 수 있습니다. |
| 호스트 간 작업 불가 | 개별 노드 격리로 인해 인프라 전체의 글로벌 메트릭 계산과 같은 다중 호스트 집계 작업이 불가능합니다. |

#### 사용 사례

- 소규모 배포
- 단순한 파이프라인
- 빠른 프로토타이핑

### 2.2 중앙 집중형 (Centralized)

중앙 집중형 토폴로지는 분산형과 스트림 기반 토폴로지 사이의 좋은 균형점입니다. 많은 사용 사례에서 단순성, 안정성, 제어 사이의 좋은 절충안입니다.

이 접근 방식에서는 Vector가 에이전트와 애그리게이터 역할 모두에서 작동합니다. 클라이언트 노드의 에이전트가 중앙 Vector 서비스로 데이터를 전달하고, 중앙 서비스가 다운스트림 통신을 처리합니다.

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   호스트 A    │  │   호스트 B    │  │   호스트 C    │
│              │  │              │  │              │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  서비스   │ │  │ │  서비스   │ │  │ │  서비스   │ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
│      ▼       │  │      ▼       │  │      ▼       │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  Vector  │ │  │ │  Vector  │ │  │ │  Vector  │ │
│ │ (에이전트)│ │  │ │ (에이전트)│ │  │ │ (에이전트)│ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
└──────┼───────┘  └──────┼───────┘  └──────┼───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         ▼
           ┌─────────────────────────┐
           │         Vector          │
           │      (애그리게이터)       │
           │                         │
           │  - 버퍼링               │
           │  - 압축                 │
           │  - 배치 최적화          │
           │  - 호스트 간 집계        │
           └────────────┬────────────┘
                        │
            ┌───────────┼───────────┐
            ▼           ▼           ▼
       ┌─────────┐ ┌─────────┐ ┌─────────┐
       │  목적지 A │ │  목적지 B │ │  목적지 C │
       └─────────┘ └─────────┘ └─────────┘
```

#### 장점

| 장점 | 설명 |
|------|------|
| 효율성 향상 | 중앙 집중형 토폴로지는 일반적으로 클라이언트 노드와 다운스트림 서비스 모두에 더 효율적입니다. Vector 에이전트는 더 적은 작업을 수행하므로 리소스를 적게 사용합니다. 중앙 서비스가 데이터를 버퍼링하고, 압축을 적용하고, 다운스트림 시스템에 대한 요청 배치를 최적화합니다. |
| 안정성 보호 | Vector가 데이터를 버퍼링하고 완만한 간격으로 플러시하여 다운스트림 서비스를 볼륨 급증으로부터 보호합니다. |
| 호스트 간 작업 가능 | 데이터가 중앙 집중화되어 있으므로 로그를 글로벌 메트릭으로 축소하는 등 호스트 간 작업을 수행할 수 있습니다. 이 기능은 집계된 인사이트가 필요한 대규모 배포에 유용합니다. |

#### 단점

| 단점 | 설명 |
|------|------|
| 아키텍처 복잡성 | 여러 역할에서 Vector를 실행하면 단순한 분산형 설정에 비해 운영상 구성 요소가 증가합니다. |
| 내구성 제한 | 에이전트 노드는 가능한 한 빨리 머신에서 데이터를 전송하도록 설계되었습니다. 중앙 Vector 서비스가 다운되면 버퍼링된 데이터가 손실될 가능성이 있습니다. 데이터 손실이 허용되지 않는 사용 사례에는 스트림 기반 토폴로지가 권장됩니다. |

#### 설정 예시

에이전트 설정 (호스트):

```yaml
# /etc/vector/vector.yaml (에이전트)
sources:
  host_logs:
    type: file
    include:
      - /var/log/*.log

sinks:
  to_aggregator:
    type: vector
    inputs:
      - host_logs
    address: "aggregator.example.com:6000"
```

애그리게이터 설정:

```yaml
# /etc/vector/vector.yaml (애그리게이터)
sources:
  from_agents:
    type: vector
    address: "0.0.0.0:6000"

transforms:
  parse_logs:
    type: remap
    inputs:
      - from_agents
    source: |
      . = parse_json!(.message)

sinks:
  elasticsearch:
    type: elasticsearch
    inputs:
      - parse_logs
    endpoints:
      - "https://elasticsearch.example.com:9200"
```

#### 사용 사례

- 중간 규모 배포
- 호스트 간 집계가 필요한 경우
- 다운스트림 서비스 보호가 필요한 경우
- 약간의 데이터 손실이 허용되는 경우

### 2.3 스트림 기반 (Stream-based)

스트림 기반 토폴로지는 가장 내구성이 높고 탄력적인 토폴로지입니다. Kafka와 같은 스트림 서비스를 운영한 경험이 있는 팀이 대규모 데이터 스트림에 사용합니다.

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   호스트 A    │  │   호스트 B    │  │   호스트 C    │
│              │  │              │  │              │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  서비스   │ │  │ │  서비스   │ │  │ │  서비스   │ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
│      ▼       │  │      ▼       │  │      ▼       │
│ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
│ │  Vector  │ │  │ │  Vector  │ │  │ │  Vector  │ │
│ │ (에이전트)│ │  │ │ (에이전트)│ │  │ │ (에이전트)│ │
│ └────┬─────┘ │  │ └────┬─────┘ │  │ └────┬─────┘ │
└──────┼───────┘  └──────┼───────┘  └──────┼───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         ▼
           ┌─────────────────────────┐
           │    스트림 서비스          │
           │       (Kafka)           │
           │                         │
           │  - 여러 노드에 복제       │
           │  - 높은 내구성           │
           │  - 데이터 보존           │
           └────────────┬────────────┘
                        │
                        ▼
           ┌─────────────────────────┐
           │         Vector          │
           │      (애그리게이터)       │
           └────────────┬────────────┘
                        │
            ┌───────────┼───────────┐
            ▼           ▼           ▼
       ┌─────────┐ ┌─────────┐ ┌─────────┐
       │  목적지 A │ │  목적지 B │ │  목적지 C │
       └─────────┘ └─────────┘ └─────────┘
```

#### 장점

| 장점 | 설명 |
|------|------|
| 가장 높은 내구성과 신뢰성 | Kafka와 같은 스트림 서비스는 높은 내구성과 신뢰성을 위해 설계되었으며, 여러 노드에 데이터를 복제합니다. |
| 가장 높은 효율성 | Vector 에이전트는 최소한의 작업만 수행하고, Vector 서비스는 내구성 문제보다 성능에 집중할 수 있습니다. |
| 데이터 재스트리밍 가능 | 스트림의 보존 기간에 따라 데이터를 재스트리밍할 수 있습니다. |
| 책임의 명확한 분리 | Vector는 순수하게 라우팅 레이어로 사용되며 내구성에 대한 책임이 없습니다. 내구성은 시간이 지남에 따라 전환하고 발전시킬 수 있는 전용 서비스에 위임됩니다. |

#### 단점

| 단점 | 설명 |
|------|------|
| 관리 오버헤드 증가 | Kafka와 같은 스트림 서비스를 관리하는 것은 복잡한 작업이며 일반적으로 경험 있는 팀이 필요합니다. |
| 더 복잡함 | 이 접근 방식은 프로덕션 수준의 스트림 관리 및 인프라에 대한 깊은 이해가 필요합니다. |
| 더 비쌈 | 운영 복잡성 외에도 전용 스트림 클러스터를 유지하려면 추가 리소스가 필요하여 전체 비용이 증가합니다. |

#### 설정 예시

에이전트 설정 (호스트):

```yaml
# /etc/vector/vector.yaml (에이전트)
sources:
  host_logs:
    type: file
    include:
      - /var/log/*.log

sinks:
  to_kafka:
    type: kafka
    inputs:
      - host_logs
    bootstrap_servers: "kafka1:9092,kafka2:9092,kafka3:9092"
    topic: "logs"
    encoding:
      codec: json
```

애그리게이터 설정:

```yaml
# /etc/vector/vector.yaml (애그리게이터)
sources:
  from_kafka:
    type: kafka
    bootstrap_servers: "kafka1:9092,kafka2:9092,kafka3:9092"
    topics:
      - "logs"
    group_id: "vector-aggregator"

transforms:
  parse_logs:
    type: remap
    inputs:
      - from_kafka
    source: |
      . = parse_json!(.message)

sinks:
  elasticsearch:
    type: elasticsearch
    inputs:
      - parse_logs
    endpoints:
      - "https://elasticsearch.example.com:9200"
```

#### 사용 사례

- 대규모 배포
- 데이터 손실이 허용되지 않는 경우
- 데이터 재처리가 필요한 경우
- 여러 컨슈머가 동일한 데이터를 처리해야 하는 경우
- Kafka 운영 경험이 있는 팀

---

## 3. 배포 전략 선택

올바른 배포 전략을 선택하는 것은 조직의 요구 사항, 규모, 팀 역량에 따라 달라집니다.

### 3.1 의사 결정 가이드

| 요소 | 분산형 | 중앙 집중형 | 스트림 기반 |
|------|--------|-------------|-------------|
| 복잡성 | 낮음 | 중간 | 높음 |
| 내구성 | 낮음 | 중간 | 높음 |
| 확장성 | 제한적 | 좋음 | 매우 좋음 |
| 호스트 간 집계 | 불가능 | 가능 | 가능 |
| 운영 오버헤드 | 낮음 | 중간 | 높음 |
| 비용 | 낮음 | 중간 | 높음 |
| 데이터 손실 위험 | 높음 | 중간 | 낮음 |

### 3.2 권장 시나리오

#### 분산형 권장

- 개발/테스트 환경
- 소규모 인프라 (호스트 10개 미만)
- 단순한 로그 수집 요구사항
- 빠른 구현이 필요한 경우

#### 중앙 집중형 권장

- 중간 규모 인프라 (호스트 10~100개)
- 호스트 간 집계가 필요한 경우
- 다운스트림 서비스 보호가 중요한 경우
- 약간의 데이터 손실이 허용되는 프로덕션 환경

#### 스트림 기반 권장

- 대규모 인프라 (호스트 100개 이상)
- 데이터 손실이 절대 허용되지 않는 경우
- 데이터 재처리가 필요한 경우
- Kafka 운영 경험이 있는 팀
- 여러 시스템이 동일한 데이터를 소비하는 경우

### 3.3 하이브리드 접근 방식

실제 환경에서는 여러 토폴로지를 조합하여 사용할 수 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        프로덕션 환경                              │
│                                                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │ 중요 서비스들  │  │ 일반 서비스들  │  │  개발 환경    │              │
│  │             │  │             │  │             │              │
│  │ 스트림 기반   │  │ 중앙 집중형   │  │   분산형     │              │
│  │  (Kafka)    │  │             │  │             │              │
│  └─────────────┘  └─────────────┘  └─────────────┘              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

예시:

- 결제, 인증 등 중요 서비스: 스트림 기반 토폴로지
- 일반 애플리케이션 서비스: 중앙 집중형 토폴로지
- 개발/테스트 환경: 분산형 토폴로지

---

## 참고 자료

- [Vector 배포 문서](https://vector.dev/docs/setup/deployment/)
- [Vector 배포 역할](https://vector.dev/docs/setup/deployment/roles/)
- [Vector 배포 토폴로지](https://vector.dev/docs/setup/deployment/topologies/)
- [Helm 설치 가이드](https://vector.dev/docs/setup/installation/package-managers/helm/)
- [Vector 소스/싱크](https://vector.dev/docs/reference/configuration/sources/vector/)
- [Kafka 소스](https://vector.dev/docs/reference/configuration/sources/kafka/)
- [Kafka 싱크](https://vector.dev/docs/reference/configuration/sinks/kafka/)
