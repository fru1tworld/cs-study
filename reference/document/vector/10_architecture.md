# 아키텍처 (Architecture)

> 이 문서는 [Vector 공식 문서](https://vector.dev/docs/)의 Architecture 섹션을 한국어로 번역한 것입니다.
>
> 원문: https://vector.dev/docs/architecture/

---

## 목차

1. [개요](#개요)
2. [데이터 모델 (Data Model)](#데이터-모델-data-model)
   - [로그 이벤트 (Log Events)](#로그-이벤트-log-events)
   - [메트릭 이벤트 (Metric Events)](#메트릭-이벤트-metric-events)
3. [파이프라인 모델 (Pipeline Model)](#파이프라인-모델-pipeline-model)
   - [파이프라인 정의](#파이프라인-정의)
   - [실행 중 조작](#실행-중-조작)
4. [런타임 모델 (Runtime Model)](#런타임-모델-runtime-model)
   - [태스크](#태스크)
   - [스케줄러](#스케줄러)
   - [데이터 플레인](#데이터-플레인)
5. [버퍼링 모델 (Buffering Model)](#버퍼링-모델-buffering-model)
   - [버퍼 유형](#버퍼-유형)
   - [버퍼가 가득 찼을 때의 동작](#버퍼가-가득-찼을-때의-동작)
   - [권장 구성](#권장-구성)
6. [동시성 모델 (Concurrency Model)](#동시성-모델-concurrency-model)
   - [소스별 동시성](#소스별-동시성)
   - [상태 비저장 함수 변환](#상태-비저장-함수-변환)
7. [적응형 요청 동시성 (Adaptive Request Concurrency)](#적응형-요청-동시성-adaptive-request-concurrency)
   - [작동 원리](#작동-원리)
   - [주요 이점](#주요-이점)
8. [보장 (Guarantees)](#보장-guarantees)
   - [전달 보장](#전달-보장)
   - [안정성 보장](#안정성-보장)
9. [엔드투엔드 확인 (End-to-end Acknowledgements)](#엔드투엔드-확인-end-to-end-acknowledgements)
   - [작동 방식](#작동-방식)
   - [여러 목적지 처리](#여러-목적지-처리)
   - [구성](#구성)

---

## 개요

Vector의 아키텍처는 다양한 모델이 결합하여 형성됩니다. 이러한 주제는 데이터 모델에서 시작하여 Vector의 런타임 모델까지 점진적으로 확장되는 순서로 정리되어 있습니다.

Vector의 아키텍처는 다음과 같은 핵심 모델들로 구성됩니다:

| 모델 | 설명 |
|------|------|
| 데이터 모델 (Data Model) | 정보가 어떻게 구조화되는지 설명 |
| 파이프라인 모델 (Pipeline Model) | 워크플로 구성 방식 설명 |
| 런타임 모델 (Runtime Model) | 실행 환경 설명 |
| 버퍼링 모델 (Buffering Model) | 데이터 큐 관리 방식 설명 |
| 동시성 모델 (Concurrency Model) | 병렬 처리 방식 설명 |
| 엔드투엔드 확인 (End-to-end Acknowledgements) | 전달 보장 방식 설명 |

---

## 데이터 모델 (Data Model)

Vector를 통해 흐르는 개별 데이터 단위를 이벤트(Events) 라고 합니다. 이벤트는 Vector에서 정의한 옵저버빌리티 유형 중 하나에 해당해야 합니다.

정교한 데이터 모델은 다양한 데이터 유형을 고려하여 옵저버빌리티 시스템 간의 올바른 상호 운용성을 가능하게 합니다. 예를 들어, StatsD 소스와 Prometheus 싱크를 연결하는 파이프라인은 올바른 내부 메트릭 데이터 유형이 없으면 불가능합니다.

### 이벤트 유형

Vector는 이벤트를 다음과 같은 주요 하위 유형으로 분류합니다:

| 유형 | 설명 |
|------|------|
| 로그 이벤트 (Log Events) | 이벤트의 일반적인 키/값 표현 |
| 메트릭 이벤트 (Metric Events) | 시계열에서 수행된 수치 연산을 나타냄 |
| 트레이스 이벤트 (Trace Events) | 특별한 종류의 로그 이벤트 (알파 단계, 지원 제한적) |

### 왜 범용 이벤트 모델을 사용하지 않는가?

이상적인 시나리오에서는 모든 서비스가 완벽하게 계측되어 있겠지만, 현실은 다양한 데이터 품질을 다루어야 합니다. Vector는 서비스가 있는 곳에서 만나도록 설계되어 새로운 표준으로의 가교 역할을 합니다.

---

### 로그 이벤트 (Log Events)

로그 이벤트는 이벤트의 일반적인 키/값 표현입니다.

#### 기본 구조

```json
{
  "log": {
    "custom": "field",
    "host": "my.host.com",
    "message": "Hello world",
    "timestamp": "2020-11-01T21:15:47+00:00"
  }
}
```

#### 스키마

Vector는 다양한 데이터 구조와의 호환성을 보장하기 위해 스키마 중립적 접근 방식을 유지합니다. 시스템은 특정 필드를 요구하지 않으며, 컴포넌트는 자체적으로 필드 제공을 문서화합니다.

#### 지원되는 데이터 유형

| 유형 | 설명 |
|------|------|
| 문자열 (Strings) | UTF-8 호환, 가용 시스템 메모리에 의해서만 제한됨 |
| 정수 (Integers) | 최대 64비트의 부호 있는 정수 |
| 부동소수점 (Floats) | 64비트 IEEE 754 형식 |
| 불리언 (Booleans) | 이진 true/false 값 |
| 타임스탬프 (Timestamps) | UTC로 저장된 DateTime Rust 구조체로 표현 |
| Null 값 | JSON 호환성을 위해 지원 |
| 맵 (Maps) | 문자열 필드를 모든 값 유형에 매핑하는 연관 배열 |
| 배열 (Arrays) | 모든 값 유형의 시퀀스 |

#### 타임스탬프 변환

형식이 공식적인 타임스탬프 정의가 없는 경우(예: JSON), Vector는 타임스탬프를 원시 형태로 수집하고 `parse_timestamp` VRL 함수를 통한 변환을 허용합니다.

#### 시간대 처리

시간대 정보가 없는 타임스탬프는 로컬 시간으로 간주되어 UTC로 변환됩니다.

---

### 메트릭 이벤트 (Metric Events)

Vector는 메트릭을 구조화된 로그가 아닌 일급 시민(first-class citizens) 으로 취급합니다. Vector 메트릭 이벤트는 시계열에서 수행된 수치 연산을 나타냅니다.

#### 설계 철학

Vector의 메트릭 데이터 모델은 이념적 순수성보다 정확성과 올바름을 우선시합니다. Prometheus와 StatsD의 메트릭 유형을 통합하여 상호 운용성을 보장합니다.

#### 메트릭 유형

| 유형 | 설명 |
|------|------|
| 카운터 (Counter) | 증가하거나 0으로 재설정되는 값 (절대 감소하지 않음). 양의 float 값 필요 |
| 게이지 (Gauge) | 위아래로 변동하는 특정 시점의 값. 메모리나 CPU 사용량 같은 측정값 추적 |
| 분포 (Distribution) | 글로벌 히스토그램과 요약을 지원하는 서비스를 위한 샘플링된 값 분포. 샘플 배열과 통계 유형(히스토그램 또는 요약) 필요 |
| 히스토그램 (Histogram) | 요청 지속 시간과 같은 관측값을 샘플링하고, 구성 가능한 버킷에 계수하며, 집계 합계 제공. 버킷 배열, 카운트(uint), 합계(float) 필요 |
| 요약 (Summary) | 히스토그램과 유사하지만 슬라이딩 시간 창에 대해 구성 가능한 분위수 계산. 카운트(uint), 분위수 배열, 합계(float) 필요 |
| 집합 (Set) | 리스트로서 고유 값의 배열 표현 |

#### 필수 필드

| 필드 | 유형 | 설명 |
|------|------|------|
| name | string | 메트릭 식별자 |
| kind | string | 메트릭 값의 종류 |
| tags | table | 태그 이름을 문자열/null 값에 매핑 |
| timestamp | timestamp | 메트릭 생성 시점 |

#### 선택 필드

| 필드 | 유형 | 설명 |
|------|------|------|
| namespace | string | 이름 앞에 접두사를 붙이거나 네이티브 네임스페이싱 사용 |
| interval_ms | number | 값이 나타내는 시간 간격 |

---

## 파이프라인 모델 (Pipeline Model)

Vector의 파이프라인 모델은 독립적인 하위 그래프를 포함하는 컴포넌트의 방향성 비순환 그래프(DAG)를 기반으로 합니다.

이벤트는 순환 종속성을 생성하지 않고 소스에서 싱크 방향으로 단방향으로 이동해야 합니다. 모든 컴포넌트는 0개 이상의 이벤트를 생성할 수 있습니다.

### 파이프라인 정의

설정은 YAML, TOML 또는 JSON 형식을 사용합니다. 유지보수성을 위해 많은 Vector 사용자들은 Jsonnet 또는 CUE와 같은 설정 및 데이터 템플릿 언어를 사용합니다.

#### 컴파일 타임 검증

설정은 파이프라인 컴파일 타임(Vector 부팅 시)에 검사됩니다. 이를 통해 간단한 실수를 방지하고 DAG 속성을 강제합니다.

```yaml
# 기본 파이프라인 예제
sources:
  my_source:
    type: "stdin"

transforms:
  my_transform:
    inputs:
      - "my_source"
    type: "remap"
    source: |
      . = parse_json!(.message)

sinks:
  my_sink:
    inputs:
      - "my_transform"
    type: "console"
    encoding:
      codec: "json"
```

### 실행 중 조작

#### 핫 리로드

Vector의 구성된 파이프라인은 Vector를 재시작하지 않고도 실시간으로 조정할 수 있습니다. Vector는 설정 변경을 적용하기 위한 핫 리로드 를 지원하며, 이는 Vector 프로세스에 `SIGHUP` 프로세스 신호를 전송하여 수행됩니다.

```bash
# 설정 리로드 트리거
kill -SIGHUP $(pidof vector)
```

#### API 접근

Vector는 실행 중인 Vector 인스턴스의 실시간 관찰 및 조작을 허용하는 API도 포함합니다.

---

## 런타임 모델 (Runtime Model)

Vector의 런타임은 Vector의 DAG 토폴로지 모델의 노드가 채널을 통해 통신하는 비동기 태스크에 대략적으로 매핑되는 퓨처 기반 비동기 런타임이며, 모두 Tokio 런타임에 의해 스케줄링됩니다.

### 태스크

#### 소스 태스크

소스는 출력 채널이 있는 태스크입니다. 이 인터페이스는 의도적으로 단순하며, Vector의 다양한 소스 유형에 걸쳐 최대의 유연성을 허용하기 위해 내부 구성 가능성을 선호합니다.

#### 변환 태스크

변환은 목적에 따라 태스크 또는 상태 비저장 함수일 수 있습니다.

| 유형 | 설명 | 예시 |
|------|------|------|
| 상태 비저장 함수 변환 | 여러 이벤트에 걸쳐 상태를 유지하지 않는 단일 연산 변환. 이벤트가 수신되면 개별 연산을 수행하고 즉시 반환 | remap 변환 |
| 태스크 변환 | 여러 이벤트에 걸쳐 선택적으로 상태를 유지할 수 있음. 따라서 별도의 태스크로 실행되며 동시성을 위해 소스 수준에서 인라인될 수 없음 | dedupe 변환 |

#### 싱크 태스크

싱크는 입력 채널이 있는 태스크입니다. 싱크는 스트리밍, 배칭, 파티셔닝, 네트워킹, 재시도, 버퍼 등 구축을 쉽고 유연하게 만드는 많은 인프라를 공유합니다.

### 스케줄러

Vector는 태스크 스케줄링을 위해 Tokio 런타임 을 사용합니다. Vector의 동시성 모델은 모든 vCPU를 활용하도록 자동으로 확장됩니다. 설정 변경이 필요하지 않습니다.

### 데이터 플레인

Vector의 DAG 토폴로지의 노드는 채널을 통해 통신합니다. 엣지 노드는 동적 출력 제어가 있는 맞춤형 채널입니다.

- 백프레셔 가 기본값이지만, 싱크별로 부하를 줄이거나 디스크에 저장하도록 사용자 정의할 수 있습니다.

---

## 버퍼링 모델 (Buffering Model)

Vector는 싱크가 처리할 수 있는 것 이상의 초과 이벤트를 처리할 때 성능 또는 내구성을 우선시할지 운영자가 선택할 수 있는 버퍼링 모델을 구현합니다.

### 백프레셔

백프레셔 는 컴포넌트가 수신하는 것만큼 빠르게 이벤트를 처리할 수 없음을 나타내는 신호입니다. 이는 싱크에서 변환을 거쳐 소스로 전파되며, 최종적으로 업스트림 클라이언트에 도달합니다.

### 기본 버퍼

Vector 토폴로지의 모든 컴포넌트는 그 사이에 작은 인메모리 버퍼를 가집니다. 이 버퍼의 주요 목적은 두 컴포넌트가 통신하는 채널 역할을 하는 것이지만, 수신 측 컴포넌트가 현재 바쁜 경우에도 이벤트를 보낼 수 있는 작은 공간(일반적으로 100개 이벤트)이 있습니다. 이를 통해 워크로드가 완전히 균일하지 않을 때 처리량을 최대화할 수 있습니다.

기본적으로 싱크는 다른 모든 컴포넌트와 같은 인메모리 버퍼를 사용하지만, 기본 버퍼 크기는 500개 이벤트로 약간 증가합니다. 싱크는 일반적으로 모든 Vector 토폴로지에서 백프레셔의 주요 원인이므로 버퍼 용량이 특별히 증가합니다.

### 버퍼 유형

#### 인메모리 버퍼

인메모리 버퍼는 가장 빠른 버퍼 유형 이지만 두 가지 주요 단점이 있습니다:

1. 크기에 비례하여 메모리를 소비할 수 있음
2. 내구성이 없음 - Vector가 충돌하면 인메모리 버퍼에 있는 모든 이벤트가 손실됨

```toml
[sinks.my_sink_id]
  [sinks.my_sink_id.buffer]
    type = "memory"
    max_events = 500
```

> 참고: 인메모리 버퍼는 보유할 수 있는 바이트 수가 아닌 버퍼링할 수 있는 이벤트 수로 구성됩니다. 예를 들어, 최대 이벤트 수가 100,000으로 구성된 인메모리 버퍼는 이벤트가 작은 경우 몇 메가바이트만 소비할 수 있지만, 이벤트가 킬로바이트 크기인 경우 수백 메가바이트로 늘어날 수 있습니다.

#### 디스크 버퍼

디스크 버퍼는 재시작에 걸쳐 내구성 을 제공합니다.

- 선행 기록 로그(write-ahead log)로 작동
- 기본적으로 500밀리초마다 동기화
- 일관된 성능 유지
- 최소 약 256MiB 크기 필요
- 로그당 최대 파일 크기: 128MiB
- 자동 체크섬 및 손상 복구 포함

```toml
[sinks.my_sink_id]
  [sinks.my_sink_id.buffer]
    type = "disk"
    max_size = 268435488  # 256MiB
```

> 중요 요구 사항: Vector에 구성된 데이터 디렉토리가 충분한 여유 공간이 있는 저장소 볼륨에 있는지 반드시 확인해야 합니다.

### 버퍼가 가득 찼을 때의 동작

| 동작 | 설명 |
|------|------|
| block (기본값) | 무기한 대기; 업스트림으로 백프레셔 유도 |
| drop_newest | 버퍼가 가득 차면 이벤트 삭제; 버스트성 워크로드에 부적합 |
| overflow | 보조 버퍼로 라우팅 (실험적, 프로덕션 준비되지 않음); 이벤트 순서 보장 없음 |

#### 백프레셔 전파

`buffer.when_full = block`(기본값)인 경우, 버퍼가 가득 차면 그래프의 이전 컴포넌트에 백프레셔가 적용됩니다.

싱크의 버퍼가 가득 차고 백프레셔를 제공하도록 구성된 경우, 해당 백프레셔는 연결된 모든 변환으로 전파되고, 이는 소스로도 전파됩니다. 소스는 데이터를 제공하는 시스템으로 백프레셔를 전파하려고 시도합니다.

정확한 메커니즘은 소스에 따라 다릅니다:
- HTTP 소스: HTTP 429 오류(Too Many Requests)로 요청을 거부할 수 있음
- 풀 기반 소스 (예: Kafka): 새 이벤트 가져오기 속도를 늦출 수 있음

### 권장 구성

| 우선순위 | 권장 구성 |
|----------|----------|
| 성능 중심 | 인메모리 버퍼와 증가된 `max_events` |
| 내구성 중심 | 디스크 버퍼와 block 또는 drop 동작 |
| 제한된 저장소 | 인메모리 버퍼를 사용해야 함 |

---

## 동시성 모델 (Concurrency Model)

각 Vector 소스는 동시성 단위를 정의하고 그에 따라 구현할 책임이 있습니다.

이 설계를 통해 수동 튜닝 없이 데이터 볼륨에 따라 자연스럽게 확장할 수 있습니다.

### 소스별 동시성

다른 소스 유형은 동시성을 다르게 구현합니다:

| 소스 유형 | 동시성 구현 |
|----------|------------|
| 파일 기반 소스 (예: file 소스) | 모니터링되는 파일 수에 걸쳐 병렬화 |
| 연결 기반 소스 (예: socket 소스) | 활성 열린 연결에 걸쳐 병렬화 |

```
┌─────────────────────────────────────────────────────────────────┐
│                           Vector                                 │
├─────────────────────────────────────────────────────────────────┤
│  Socket 소스          File 소스                                  │
│  ┌──────────┐        ┌──────────┐                               │
│  │ 연결 1   │        │ 파일 1   │                               │
│  │ 연결 2   │        │ 파일 2   │                               │
│  │ 연결 3   │        │ 파일 3   │                               │
│  └────┬─────┘        └────┬─────┘                               │
│       │                   │                                      │
│       └───────┬───────────┘                                      │
│               ▼                                                  │
│        ┌──────────────┐                                          │
│        │   Transform  │                                          │
│        │   (Dedupe)   │                                          │
│        └──────┬───────┘                                          │
│               ▼                                                  │
│        ┌──────────────┐                                          │
│        │     Sink     │                                          │
│        └──────────────┘                                          │
└─────────────────────────────────────────────────────────────────┘
```

### 상태 비저장 함수 변환

Vector의 동시성은 병렬화될 수 있는 상태 비저장 함수 변환에 의존합니다. 태스크 변환은 현재 병렬화될 수 없으며 병목 현상을 유발할 수 있습니다.

> 참고: 팀은 이를 향후 잠재적인 개선 사항으로 표시했습니다.

### 핵심 요점

Vector는 각 소스 유형이 자체 동시성 단위를 자연스럽게 구현하도록 하여 번거로운 동시성 구성을 피합니다. 이는 들어오는 데이터 볼륨에 따라 확장되는 적응형 모델 을 생성합니다.

---

## 적응형 요청 동시성 (Adaptive Request Concurrency)

적응형 요청 동시성(ARC) 은 정적 동시성 제한을 없애고 다운스트림 서비스 응답을 기반으로 HTTP 동시성을 자동으로 최적화하는 Vector의 네트워킹 기능입니다.

### 작동 원리

기본 메커니즘은 TCP 혼잡 제어 알고리즘에서 영감을 받은 피드백 루프 입니다.

#### AIMD 알고리즘

ARC는 과거 RTT 측정의 지수 가중 이동 평균(EWMA) 을 현재 RTT와 비교하기 위한 참조로 사용합니다.

```
                    ┌──────────────────────────────────────┐
                    │          ARC 피드백 루프              │
                    ├──────────────────────────────────────┤
                    │                                      │
                    │  요청 전송 ──► 응답 수신             │
                    │       │              │               │
                    │       ▼              ▼               │
                    │   RTT 측정    ◄── 상태 확인          │
                    │       │                              │
                    │       ▼                              │
                    │   EWMA 업데이트                      │
                    │       │                              │
                    │       ▼                              │
                    │   동시성 조정                        │
                    │   (증가/감소)                        │
                    │                                      │
                    └──────────────────────────────────────┘
```

#### 동시성 제한

적응형 요청 동시성 제한은 구성 가능한 최대 한계 를 초과하지 않습니다. 이는 안전장치로 마련되어 있습니다.

### 주요 이점

- 향상된 성능: 다운스트림 서비스의 용량에 따라 자동으로 최적화
- 향상된 신뢰성: 서비스 과부하 방지
- 제로 구성: 기본값으로 활성화되어 있으며 추가 구성이 필요하지 않음

### 구성

ARC는 기본값으로 설정되어 있으며, 추가 구성이 필요하지 않습니다. 전체 옵저버빌리티 인프라에 걸쳐 향상된 성능과 신뢰성 을 제공합니다.

---

## 보장 (Guarantees)

Vector는 사용자가 정보에 입각한 트레이드오프 결정을 내릴 수 있도록 컴포넌트에 대한 전달 및 안정성 보장을 개략적으로 설명합니다.

### 전달 보장

#### 최소 한 번 전달 (At-Least-Once)

수신된 이벤트가 최소 한 번 전달되도록 보장합니다. 드문 상황에서 중복이 여전히 가능합니다.

재시작 보호를 위해 디스크 기반 싱크 버퍼가 필요합니다:

```toml
[sinks.my_sink_id]
  [sinks.my_sink_id.buffer]
    type = "disk"
    when_full = "block"
    max_size = 104900000
```

#### 최선 노력 전달 (Best-Effort)

컴포넌트는 이벤트를 전달하기 위해 최선을 다하지만 기본 프로토콜 제한으로 인해 전달을 보장할 수 없습니다. 중복이 여전히 가능하므로 최대 한 번 전달과 다릅니다.

### 안정성 보장

| 상태 | 설명 |
|------|------|
| Stable (안정) | 4개월 이상 50명 이상의 프로덕션 사용자, 안정적인 API, 주요 오픈 버그 없음 |
| Beta (베타) | 안정성 기준을 충족하지 않는 기능; 프로덕션에서 주의해서 사용 |
| Alpha (알파) | 초기 테스트를 위한 실험적 기능, 프로덕션 준비되지 않음 |
| Deprecated (지원 종료) | 다음 메이저 버전에서 제거되는 기능으로 전환 시간 제공 |

### FAQ

#### 최소 한 번 전달이 필요한가요?

메트릭과 로깅은 일반적으로 진단 목적으로 사용되며, 가끔 데이터 손실은 비즈니스에 미치는 영향이 미미합니다. 그러나 비즈니스에 중요한 운영은 최소 한 번 보장이 필요합니다.

#### Vector는 정확히 한 번 전달을 지원하나요?

아니요. Kafka와 같은 호환 소스/싱크에 대한 부분적 지원은 향후 고려 중이지만 확실하지 않습니다.

#### 보장을 충족하는 컴포넌트를 어떻게 찾나요?

컴포넌트 페이지의 필터를 사용하세요.

---

## 엔드투엔드 확인 (End-to-end Acknowledgements)

Vector는 클라이언트가 데이터가 목적지 싱크에 전달되었는지 확인할 수 있는 기능을 제공합니다. 이를 엔드투엔드 확인이라고 합니다.

### 작동 방식

엔드투엔드 확인은 소스가 이벤트가 완전히 처리될 때까지 기다릴지 여부를 제어합니다. 싱크에서 활성화되면, 엔드투엔드 확인을 지원하는 모든 소스는 소스에서 확인하기 전에 연결된 모든 싱크에서 이벤트가 확인될 때까지 기다립니다.

#### 배치 알림기

참여하는 소스가 이벤트 또는 이벤트 배치를 수신하면, 해당 이벤트에 대한 배치 알림기 를 선택적으로 생성할 수 있습니다.

배치 알림기는 두 부분으로 구성됩니다:
1. 한 부분은 소스에 남아 있음
2. 다른 부분은 이벤트에 첨부됨

이벤트가 목적지 싱크에 도달하고 싱크에 의해 처리되면, Vector는 다운스트림 서비스의 응답 상태를 캡처하고 이를 사용하여 배치 알림기를 업데이트합니다. 이를 통해 이벤트가 성공적으로 처리되었는지 여부를 표시할 수 있습니다.

```
┌──────────────────────────────────────────────────────────────────┐
│                    엔드투엔드 확인 흐름                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│   소스                변환               싱크                    │
│  ┌─────┐            ┌─────┐           ┌─────┐                   │
│  │     │ ──이벤트─► │     │ ──이벤트─► │     │ ──► 다운스트림    │
│  │     │            │     │           │     │      서비스        │
│  │     │            │     │           │     │ ◄── 응답 상태     │
│  │     │            │     │           │     │                   │
│  │     │ ◄─────────────────────────── 확인 │                    │
│  └─────┘                              └─────┘                   │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

#### 이벤트 드롭 처리

Vector는 이벤트가 싱크에 도달했는지 여부와 관계없이 이벤트의 배치 알림기가 항상 업데이트되도록 보장합니다. 이를 통해 이벤트가 의도적으로 삭제되거나(예: 필터 변환 사용) 의도치 않게 삭제되더라도 배치 알림기가 여전히 업데이트됩니다.

### 여러 목적지 처리

이벤트는 여러 싱크로 전송 될 수 있습니다. 이 경우 Vector는 모든 목적지에 걸쳐 전달 상태를 추적합니다.

이벤트의 상태는 이벤트의 모든 복사본에서 공유되는 데이터 조각에 저장됩니다. 이를 통해:
- Vector는 이벤트의 모든 복사본이 싱크에 의해 처리된 후에만 소스에 알림
- "최악의" 상태가 소스에 보고되는 상태

예시: 이벤트가 세 개의 싱크로 전송되고 그 중 두 개만 성공적으로 처리한 경우, Vector는 해당 이벤트를 실패한 것으로 표시합니다. 이를 통해 세 개의 싱크 모두가 성공적으로 처리할 수 있도록 다시 전송할 수 있습니다.

### 이벤트 병합 처리

`aggregate` 또는 `reduce`와 같은 변환이 여러 이벤트를 결합하는 경우, 각각은 원래 소스 배치 목록을 포함합니다. 전달 시 모든 소스 배치가 동시에 업데이트됩니다.

### 구성

싱크 수준에서 확인을 활성화하거나 비활성화하면 모든 전역 확인 구성보다 우선합니다.

```yaml
# 전역 확인 설정
acknowledgements:
  enabled: true

sinks:
  my_sink:
    type: "http"
    # 싱크 수준 설정이 전역 설정보다 우선
    acknowledgements:
      enabled: true
```

### 소스/싱크 호환성

모든 소스가 이벤트를 확인할 수 있는 것은 아닙니다. 예를 들어, socket 소스는 단순히 소켓을 통해 수신하는 바이트를 디코딩하기만 하고 "방금 보낸 이벤트가 올바르게 처리되지 않았습니다. 다시 보내주시겠습니까?"라는 메시지를 다시 보낼 방법이 없기 때문에 이벤트를 확인할 수 없습니다.

#### 시작 시 검증

Vector가 시작되고 설정을 로드할 때, 엔드투엔드 확인이 활성화된 모든 싱크에 대해 소비하는 이벤트가 확인을 지원하는 소스에서 오는지 확인합니다.

소스가 확인 지원이 없는 경우, 엔드투엔드 확인이 일반적인 내구성 있는 처리 약속을 제공할 수 없으며 자동 데이터 손실이 발생할 수 있음을 알리는 경고 메시지 가 표시됩니다.

### 확인을 지원하는 소스

다음 소스는 네이티브 메시지 확인 기능을 지원하여 엔드투엔드 내구성 보장을 가능하게 합니다:

- Kafka: 메시지 오프셋 커밋
- AWS SQS: 메시지 삭제 확인

### 아키텍처 권장 사항

- Vector pub-sub 소스(예: kafka 소스)에 대해 엔드투엔드 확인을 활성화 하여 pub-sub 시스템에서 데이터를 제거하기 전에 데이터가 다운스트림에 유지되도록 보장
- 데이터 수신 실패를 완화하기 위해 엔드투엔드 확인을 활성화
- 데이터 처리 실패를 완화하기 위해 삭제된 이벤트를 라우팅

---

## 참고 자료

- [Vector 공식 문서 - Architecture](https://vector.dev/docs/architecture/)
- [Vector 공식 문서 - Data Model](https://vector.dev/docs/architecture/data-model/)
- [Vector 공식 문서 - Pipeline Model](https://vector.dev/docs/architecture/pipeline-model/)
- [Vector 공식 문서 - Runtime Model](https://vector.dev/docs/architecture/runtime-model/)
- [Vector 공식 문서 - Buffering Model](https://vector.dev/docs/architecture/buffering-model/)
- [Vector 공식 문서 - Concurrency Model](https://vector.dev/docs/architecture/concurrency-model/)
- [Vector 공식 문서 - Adaptive Request Concurrency](https://vector.dev/docs/architecture/arc/)
- [Vector 공식 문서 - Guarantees](https://vector.dev/docs/architecture/guarantees/)
- [Vector 공식 문서 - End-to-end Acknowledgements](https://vector.dev/docs/architecture/end-to-end-acknowledgements/)
- [Vector GitHub](https://github.com/vectordotdev/vector)
