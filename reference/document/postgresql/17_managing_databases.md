# Chapter 22. 데이터베이스 관리 (Managing Databases)

PostgreSQL 서버는 하나 이상의 데이터베이스를 관리할 수 있습니다. 일반적으로 각 프로젝트나 각 사용자에 대해 별도의 데이터베이스를 사용합니다.

목차
- [22.1. 개요](#221-개요)
- [22.2. 데이터베이스 생성](#222-데이터베이스-생성)
- [22.3. 템플릿 데이터베이스](#223-템플릿-데이터베이스)
- [22.4. 데이터베이스 구성](#224-데이터베이스-구성)
- [22.5. 데이터베이스 삭제](#225-데이터베이스-삭제)
- [22.6. 테이블스페이스](#226-테이블스페이스)

---

## 22.1. 개요

데이터베이스 객체의 작은 집합인 역할(role), 데이터베이스, 테이블스페이스는 클러스터 수준에서 정의되며 `pg_global` 테이블스페이스에 저장됩니다. 클러스터 내부에는 여러 데이터베이스가 존재하며, 이들은 서로 격리되어 있지만 클러스터 수준 객체에는 접근할 수 있습니다. 각 데이터베이스 내부에는 여러 스키마가 있으며, 스키마에는 테이블이나 함수 같은 객체가 포함됩니다. 따라서 전체 계층 구조는 클러스터, 데이터베이스, 스키마, 테이블(또는 함수 같은 다른 종류의 객체) 순서입니다.

서버에 연결할 때, 연결 요청은 클러스터 내의 정확히 하나의 데이터베이스를 지정해야 합니다. 연결당 여러 데이터베이스에 접근하는 것은 허용되지 않습니다. 그러나 애플리케이션이 동일한 데이터베이스 또는 다른 데이터베이스에 대해 동시에 여러 연결을 열지 못하도록 하는 제한은 없습니다. 데이터베이스는 물리적으로 분리되어 있으며 접근 제어는 연결 수준에서 관리됩니다. 하나의 클러스터 내에 여러 데이터베이스가 있고 단일 연결로 여러 데이터베이스의 데이터에 동시 접근이 필요한 경우, PostgreSQL의 Foreign Data Wrapper 기능(`postgres_fdw`)을 사용할 수 있습니다. 자세한 내용은 [postgres_fdw](https://www.postgresql.org/docs/18/postgres-fdw.html)를 참조하세요. 다른 접근법으로 `dblink` 모듈을 사용할 수도 있습니다. 자세한 내용은 [dblink](https://www.postgresql.org/docs/18/dblink.html)를 참조하세요. `postgres_fdw`는 다른 클러스터의 데이터베이스에서 객체에 대한 프록시를 생성하는 데도 사용할 수 있습니다.

만약 동일한 PostgreSQL 서버 인스턴스가 서로 독립적인 프로젝트나 사용자를 호스팅하는 경우, 이들을 별도의 데이터베이스에 넣고 그에 맞게 접근 제어 및 권한 부여를 구성하는 것이 권장됩니다. 프로젝트나 사용자들이 상호 관련되어 있고 서로의 리소스를 사용할 수 있어야 하는 경우, 동일한 데이터베이스에 넣되 네임스페이스 격리 및 권한 부여를 통한 모듈화 구조를 위해 별도의 스키마에 넣을 수 있습니다.

클러스터 내에서 여러 데이터베이스를 사용하면 공유 WAL(Write-Ahead Log)로 인해 백업 및 복구에 대한 유연성이 감소합니다. 클러스터에 포함된 여러 데이터베이스가 사용자 관점에서는 격리되어 있어도 관리자 관점에서는 밀접하게 결합되어 있습니다.

데이터베이스는 `CREATE DATABASE` 명령(Section 22.2 참조)으로 생성되고 `DROP DATABASE` 명령(Section 22.5 참조)으로 삭제됩니다. 기존 데이터베이스 집합을 확인하려면 다음과 같이 `pg_database` 시스템 카탈로그를 조회합니다:

```sql
SELECT datname FROM pg_database;
```

`psql` 프로그램의 `\l` 메타 명령과 `-l` 명령줄 옵션도 기존 데이터베이스를 나열하는 데 유용합니다.

> 참고: SQL 표준에서는 데이터베이스를 "카탈로그(catalog)"라고 부르지만, 실제로는 차이가 없습니다.

---

## 22.2. 데이터베이스 생성

데이터베이스를 생성하려면 PostgreSQL 서버가 실행 중이어야 합니다(Section 18.3 참조).

데이터베이스는 SQL 명령 `CREATE DATABASE`로 생성됩니다:

```sql
CREATE DATABASE name;
```

여기서 `name`은 SQL 식별자의 일반적인 규칙을 따릅니다. 현재 역할(role)이 자동으로 새 데이터베이스의 소유자가 됩니다. 나중에 데이터베이스를 삭제하는 것은 소유자의 특권입니다(이는 데이터베이스에 포함된 모든 객체도 삭제하며, 소유자가 아닌 경우에도 삭제됩니다).

데이터베이스 생성은 제한된 작업입니다. 권한을 부여하는 방법은 Section 21.2를 참조하세요.

데이터베이스를 생성하려면 데이터베이스 서버에 연결되어 있어야 하므로, 주어진 클러스터에서 첫 번째 데이터베이스를 어떻게 만들 수 있는지에 대한 질문이 있습니다. 첫 번째 데이터베이스는 항상 `initdb` 명령으로 데이터 저장 영역을 초기화할 때 생성됩니다(Section 18.2 참조). 이 데이터베이스는 `postgres`라고 합니다. 따라서 첫 번째 "일반" 데이터베이스를 생성하려면 `postgres`에 연결할 수 있습니다.

데이터베이스 클러스터 초기화 중에 `template1`(Section 22.3 참조)과 `template0`이라는 두 개의 추가 데이터베이스도 생성됩니다. 클러스터 내에서 새 데이터베이스가 생성될 때마다 `template1`이 본질적으로 복제됩니다. 이는 `template1`에서 수행한 모든 수정 사항이 이후에 생성되는 모든 데이터베이스에 나타난다는 것을 의미합니다. 이 때문에 `template1`에 객체를 추가하는 것은 적절한 고려 없이 수행하지 마세요. `template0`은 `template1`의 원시 복사본으로, 사용자가 추가한 어떠한 사이트 지역 사항도 포함하지 않는 순수한 데이터베이스가 필요할 때 복제할 수 있습니다. 자세한 내용은 Section 22.3을 참조하세요.

편의상, 셸에서 실행할 수 있는 `createdb` 프로그램도 있습니다:

```bash
createdb dbname
```

`createdb`는 마법이 아닙니다. `postgres` 데이터베이스에 연결하고 `CREATE DATABASE` 명령을 실행합니다(위에서 설명한 것과 정확히 같습니다). [createdb](https://www.postgresql.org/docs/18/app-createdb.html) 참조 페이지에 호출 세부 정보가 포함되어 있습니다. 인자 없이 호출된 `createdb`는 현재 사용자 이름으로 데이터베이스를 생성합니다.

> 팁: Chapter 20에서는 특정 데이터베이스에 연결할 수 있는 사람을 제한하는 방법에 대한 정보를 제공합니다.

때때로 다른 사람을 위해 데이터베이스를 생성하고 그 새 데이터베이스의 소유자로 만들어 스스로 구성하고 관리할 수 있도록 하고 싶을 때가 있습니다. 이를 수행하려면 SQL 환경에서 다음 명령 중 하나를 사용하세요:

```sql
CREATE DATABASE dbname OWNER rolename;
```

또는 셸에서:

```bash
createdb -O rolename dbname
```

슈퍼유저만 자신이 멤버가 아닌 역할을 위해 데이터베이스를 생성할 수 있습니다.

---

## 22.3. 템플릿 데이터베이스

`CREATE DATABASE`는 실제로 기존 데이터베이스를 복사하여 작동합니다. 기본적으로 `template1`이라는 표준 시스템 데이터베이스를 복사합니다. 따라서 해당 데이터베이스는 새 데이터베이스를 만드는 "템플릿"입니다. `template1`에 객체를 추가하면 이러한 객체는 이후에 생성되는 사용자 데이터베이스로 복사됩니다. 이 동작은 데이터베이스에 대한 표준 객체 집합의 사이트 지역 수정을 허용합니다. 예를 들어, `template1`에 절차적 언어 PL/Perl을 설치하면 추가 조치 없이 사용자 데이터베이스에서 자동으로 사용 가능해집니다.

그러나 `template1`에서 데이터베이스 수준의 `GRANT` 권한은 새 데이터베이스에 복사되지 않습니다. 새 데이터베이스는 해당 데이터베이스 수준 권한에 대한 기본 설정을 가집니다.

클러스터 초기화 중에 `template0`이라는 두 번째 표준 시스템 데이터베이스가 생성됩니다. 이 데이터베이스는 `template1`의 초기 내용과 동일한 데이터를 포함하며, 즉 PostgreSQL 버전에서 미리 정의한 표준 객체만 포함합니다. `template0`은 데이터베이스 클러스터 초기화 후에 변경해서는 안 됩니다. `CREATE DATABASE`가 `template1` 대신 `template0`을 복사하도록 지시함으로써, `template1`에 추가된 사이트 지역 추가 사항이 포함되지 않은 "순수한" 사용자 데이터베이스(어떤 사용자 정의 객체도 존재하지 않고 시스템 객체가 변경되지 않은 상태)를 생성할 수 있습니다.

`template0`을 템플릿으로 사용해야 하는 또 다른 일반적인 이유는 `template0`을 복사할 때 `template1`과 달리 새로운 인코딩 및 로케일 설정을 지정할 수 있기 때문입니다. 왜냐하면 `template0`에는 인코딩 또는 로케일에 종속되는 데이터가 포함되지 않은 것으로 알려져 있기 때문입니다.

`template0`을 템플릿 데이터베이스로 사용하여 데이터베이스를 생성하려면 다음을 사용합니다:

```sql
CREATE DATABASE dbname TEMPLATE template0;
```

셸에서:

```bash
createdb -T template0 dbname
```

이름을 지정하여 다른 데이터베이스를 템플릿으로 복사하는 추가적인 데이터베이스 템플릿을 생성할 수 있습니다. 그러나 이것은 (아직) 범용 "COPY DATABASE" 기능으로 의도되지 않았음을 이해하는 것이 중요합니다. 주요 제한 사항은 소스 데이터베이스가 복사되는 동안 다른 세션이 연결되어 있으면 안 된다는 것입니다. 시작할 때 다른 연결이 있으면 `CREATE DATABASE`는 실패합니다.

`pg_database`의 각 데이터베이스에 대해 두 가지 유용한 플래그가 있습니다: `datistemplate` 및 `datallowconn` 열입니다. `datistemplate`은 데이터베이스가 `CREATE DATABASE`의 템플릿으로 의도되었음을 나타내기 위해 설정할 수 있습니다. 이 플래그가 설정되면 `CREATEDB` 권한이 있는 모든 사용자가 데이터베이스를 복제할 수 있습니다. 설정되지 않은 경우 슈퍼유저와 데이터베이스 소유자만 복제할 수 있습니다. `datallowconn`이 false이면 데이터베이스에 대한 새 연결이 허용되지 않습니다(그러나 단순히 플래그를 false로 설정해도 기존 세션은 종료되지 않습니다). `template0` 데이터베이스는 일반적으로 수정을 방지하기 위해 `datallowconn = false`로 표시됩니다. `template0`과 `template1` 모두 항상 `datistemplate = true`로 표시되어야 합니다.

> 참고: `template1`과 `template0`에는 특별한 하드코딩된 상태가 없으며, 이름이 다릅니다. 예를 들어, `template1`을 삭제하고 `template0`에서 다시 생성할 수 있습니다. 신중하지 않게 `template1`에 쓰레기를 추가한 경우 이 작업 과정이 권장될 수 있습니다. (`template1`을 삭제하려면 `pg_database.datistemplate = false`가 있어야 합니다.)

`postgres` 데이터베이스도 데이터베이스 클러스터 초기화 중에 생성됩니다. 이 데이터베이스는 사용자와 애플리케이션이 연결하기 위한 기본 데이터베이스로 의도됩니다. 이것은 단순히 `template1`의 복사본이며 필요한 경우 삭제하고 다시 생성할 수 있습니다.

---

## 22.4. 데이터베이스 구성

Chapter 19에서 설명한 것처럼 PostgreSQL 서버는 런타임 구성 매개변수를 상당수 제공합니다. 이러한 설정 중 많은 것에 대해 데이터베이스별 기본값을 설정할 수 있습니다.

예를 들어, 어떤 이유로 특정 데이터베이스에 대해 GEQO 옵티마이저를 비활성화하려면 일반적으로 모든 데이터베이스에 대해 비활성화하거나 모든 연결 클라이언트가 `SET geqo TO off;`를 실행하도록 해야 합니다. 해당 데이터베이스 내에서 이 설정을 기본값으로 만들려면 다음 명령을 실행할 수 있습니다:

```sql
ALTER DATABASE mydb SET geqo TO off;
```

이렇게 하면 설정이 저장됩니다(그러나 즉시 설정되지는 않습니다). 이후 이 데이터베이스에 대한 연결에서 세션이 시작되기 직전에 `SET geqo TO off;`가 실행된 것처럼 나타납니다. 이것은 여전히 기본값일 뿐이므로 세션 내에서 설정을 변경할 수 있습니다. 이 설정을 실행 취소하려면 `ALTER DATABASE dbname RESET varname`을 사용합니다.

데이터베이스별 기본 설정을 취소하려면 다음을 사용합니다:

```sql
ALTER DATABASE dbname RESET varname;
```

---

## 22.5. 데이터베이스 삭제

데이터베이스는 `DROP DATABASE` 명령으로 삭제됩니다:

```sql
DROP DATABASE name;
```

데이터베이스의 소유자 또는 슈퍼유저만 데이터베이스를 삭제할 수 있습니다. 데이터베이스를 삭제하면 데이터베이스에 포함된 모든 객체가 제거됩니다. 데이터베이스 삭제는 취소할 수 없습니다.

삭제할 데이터베이스에 연결되어 있는 동안에는 `DROP DATABASE`를 실행할 수 없습니다. 그러나 클러스터의 다른 데이터베이스를 포함한 다른 데이터베이스에 연결할 수 있습니다. `template1`은 클러스터의 마지막 사용자 데이터베이스를 삭제하는 경우 유일한 옵션이 될 것입니다.

편의상, 셸에서 데이터베이스를 삭제하기 위한 셸 프로그램 `dropdb`도 있습니다:

```bash
dropdb dbname
```

(`createdb`와 달리 현재 사용자 이름의 데이터베이스를 삭제하는 것은 기본 동작이 아닙니다.)

---

## 22.6. 테이블스페이스

PostgreSQL의 테이블스페이스를 사용하면 데이터베이스 관리자가 데이터베이스 객체를 나타내는 파일이 저장될 수 있는 파일 시스템의 위치를 정의할 수 있습니다. 한 번 생성되면 테이블스페이스는 데이터베이스 객체를 생성할 때 이름으로 참조될 수 있습니다.

테이블스페이스를 사용하면 관리자는 PostgreSQL 설치의 디스크 레이아웃을 제어할 수 있습니다. 이는 적어도 두 가지 이유로 유용합니다. 첫째, 클러스터가 초기화된 파티션 또는 볼륨의 공간이 부족하고 확장할 수 없는 경우, 다른 파티션에 테이블스페이스를 생성하고 시스템이 재구성될 때까지 사용할 수 있습니다. 둘째, 테이블스페이스를 사용하면 관리자가 데이터베이스 객체의 사용 패턴에 대한 지식을 사용하여 성능을 최적화할 수 있습니다. 예를 들어, 매우 많이 사용되는 인덱스는 매우 빠르고 가용성이 높은 SSD와 같은 솔리드 스테이트 드라이브에 배치할 수 있습니다. 동시에 거의 사용되지 않거나 성능이 중요하지 않은 아카이브 데이터를 저장하는 테이블은 더 저렴하고 느린 디스크 시스템에 저장할 수 있습니다.

> 경고: 테이블스페이스가 메인 PostgreSQL 데이터 디렉토리 외부에 있더라도 데이터베이스 클러스터의 필수적인 부분이며 데이터 파일의 자율적인 컬렉션으로 취급될 수 없습니다. 테이블스페이스는 메인 데이터 디렉토리에 포함된 메타데이터에 종속되므로 다른 데이터베이스 클러스터에 연결하거나 개별적으로 백업할 수 없습니다. 마찬가지로 테이블스페이스를 잃으면(파일 삭제, 디스크 장애 등) 데이터베이스 클러스터가 읽을 수 없거나 시작할 수 없게 될 수 있습니다. 램 디스크와 같은 임시 파일 시스템에 테이블스페이스를 배치하면 전체 클러스터의 신뢰성이 위험에 처할 수 있습니다.

테이블스페이스를 정의하려면 `CREATE TABLESPACE` 명령을 사용합니다. 예:

```sql
CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';
```

위치는 빈 기존 디렉토리여야 하며 PostgreSQL 운영 체제 사용자가 소유해야 합니다. 이후 테이블스페이스 내에서 생성된 모든 객체는 이 디렉토리 아래의 파일에 저장됩니다. 위치는 제거 가능하거나 일시적인 저장소에 있어서는 안 됩니다. 그렇지 않으면 테이블스페이스가 누락되거나 손실되어 클러스터가 작동하지 않을 수 있습니다.

> 참고: 논리적으로 클러스터당 하나의 테이블스페이스에 있는 여러 논리적 파일 시스템을 사용하는 것을 방해하는 것은 일반적으로 없습니다. 그러나 관리자는 그러한 설정에서 복잡성을 인식하고 있어야 합니다.

테이블스페이스 생성 자체는 데이터베이스 슈퍼유저로 수행해야 하지만, 그 후에 의도된 일반 데이터베이스 사용자에게 사용 권한을 부여할 수 있습니다. 이를 수행하려면 테이블스페이스에 대한 `CREATE` 권한을 부여합니다.

테이블, 인덱스 및 전체 데이터베이스를 특정 테이블스페이스에 할당할 수 있습니다. 이를 수행하려면 주어진 테이블스페이스에 대한 `CREATE` 권한이 있는 사용자가 테이블스페이스 이름을 관련 명령에 매개변수로 전달해야 합니다. 예를 들어, 다음은 `space1` 테이블스페이스에 테이블을 생성합니다:

```sql
CREATE TABLE foo(i int) TABLESPACE space1;
```

또는 `default_tablespace` 매개변수를 사용합니다:

```sql
SET default_tablespace = space1;
CREATE TABLE foo(i int);
```

`default_tablespace`가 빈 문자열이 아닌 다른 값으로 설정되면, 명시적인 `TABLESPACE` 절을 지정하지 않는 `CREATE TABLE` 및 `CREATE INDEX` 명령에 대해 암시적인 `TABLESPACE` 절을 제공합니다.

임시 테이블 및 인덱스의 배치와 대규모 데이터 집합을 정렬하는 것과 같은 목적으로 내부적으로 생성되는 임시 파일에 대해 지정된 테이블스페이스 집합을 결정하는 `temp_tablespaces`라는 매개변수도 있습니다. 이것은 하나의 테이블스페이스 이름이 아닌 테이블스페이스 이름 목록이 될 수 있으므로, 임시 객체와 관련된 로드가 여러 테이블스페이스에 분산될 수 있습니다. 임시 객체가 생성될 때마다 목록의 무작위 멤버가 선택됩니다.

데이터베이스와 연관된 테이블스페이스는 데이터베이스의 시스템 카탈로그를 저장하는 데 사용됩니다. 또한, `TABLESPACE` 절이 주어지지 않고 `default_tablespace` 또는 `temp_tablespaces`(해당되는 대로)에 의해 다른 선택이 지정되지 않은 경우 데이터베이스 내에서 생성된 테이블, 인덱스 및 임시 파일에 사용되는 기본 테이블스페이스입니다. 테이블스페이스를 지정하지 않고 생성된 데이터베이스는 복사된 템플릿 데이터베이스와 동일한 테이블스페이스를 사용합니다.

데이터베이스 클러스터가 초기화될 때 두 개의 테이블스페이스가 자동으로 생성됩니다. `pg_global` 테이블스페이스는 공유 시스템 카탈로그에 사용됩니다. `pg_default` 테이블스페이스는 `template1` 및 `template0` 데이터베이스의 기본 테이블스페이스입니다(따라서 `TABLESPACE` 절로 재정의되지 않는 한 다른 데이터베이스의 기본 테이블스페이스이기도 합니다).

테이블스페이스가 생성되면 원하는 사용자에게 권한이 부여된 경우 모든 데이터베이스에서 사용할 수 있습니다. 이는 테이블스페이스를 사용하는 모든 데이터베이스에서 모든 객체가 제거될 때까지 테이블스페이스를 삭제할 수 없음을 의미합니다.

빈 테이블스페이스를 제거하려면 `DROP TABLESPACE` 명령을 사용합니다:

```sql
DROP TABLESPACE tablespace_name;
```

기존 테이블스페이스 집합을 검사하려면 `pg_tablespace` 시스템 카탈로그를 사용합니다. 예:

```sql
SELECT spcname FROM pg_tablespace;
```

`psql` 프로그램의 `\db` 메타 명령도 기존 테이블스페이스를 나열하는 데 유용합니다.

테이블스페이스의 파일 시스템 위치를 포함한 더 자세한 정보를 보려면:

```sql
SELECT spcname, spcowner::regrole, pg_tablespace_location(oid)
FROM pg_tablespace;
```

PostgreSQL은 `TABLESPACE` 구문 외에 `pg_tablespace_location` 함수를 사용하여 테이블스페이스의 파일 시스템 경로를 가져올 수 있도록 합니다.

테이블스페이스의 구현을 단순화하기 위해 심볼릭 링크를 사용하여 `$PGDATA/pg_tblspc` 디렉토리에 클러스터에 정의된 비기본 테이블스페이스를 가리킵니다. 심볼릭 링크를 지원하지 않는 시스템에서는 권장되지 않지만 실제로 `pg_tblspc` 링크가 가리키는 위치에 직접 디렉토리를 사용할 수 있습니다.

> 경고: 서버가 실행 중일 때 이러한 링크를 수동으로 이동하거나 수정하면 데이터 무결성 오류가 발생할 수 있습니다.

---

## 참고 문서

- [PostgreSQL 18 공식 문서 - Managing Databases](https://www.postgresql.org/docs/18/managing-databases.html)
- [CREATE DATABASE](https://www.postgresql.org/docs/18/sql-createdatabase.html)
- [DROP DATABASE](https://www.postgresql.org/docs/18/sql-dropdatabase.html)
- [CREATE TABLESPACE](https://www.postgresql.org/docs/18/sql-createtablespace.html)
- [DROP TABLESPACE](https://www.postgresql.org/docs/18/sql-droptablespace.html)
- [ALTER DATABASE](https://www.postgresql.org/docs/18/sql-alterdatabase.html)
