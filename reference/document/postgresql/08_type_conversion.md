# Chapter 10. 타입 변환 (Type Conversion)

SQL 문은 의도적이든 아니든 동일한 표현식 내에서 서로 다른 데이터 타입을 혼합해야 할 수 있습니다. PostgreSQL은 혼합 타입 표현식을 평가하기 위한 광범위한 기능을 제공합니다.

대부분의 경우 사용자는 타입 변환 메커니즘의 세부 사항을 이해할 필요가 없습니다. 그러나 PostgreSQL에 의해 수행되는 암시적 변환은 쿼리 결과에 영향을 미칠 수 있습니다. 필요한 경우, 이러한 결과는 명시적(explicit) 타입 변환 을 사용하여 조정할 수 있습니다.

이 장에서는 PostgreSQL 타입 변환 메커니즘과 규칙을 소개합니다. 특정 데이터 타입과 허용되는 함수 및 연산자에 대한 자세한 내용은 데이터 타입 및 함수와 연산자에 대한 관련 섹션을 참조하세요.

---

## 10.1. 개요 (Overview)

SQL은 강력한 타입 언어입니다. 즉, 모든 데이터 항목은 연관된 데이터 타입을 가지며, 이는 동작과 허용되는 사용을 결정합니다. PostgreSQL은 다른 SQL 구현보다 더 일반적이고 유연한 확장 가능한 타입 시스템을 가지고 있습니다. 따라서 PostgreSQL의 대부분의 타입 변환 동작은 임의적인 휴리스틱이 아닌 일반 규칙에 의해 관리됩니다. 이를 통해 사용자 정의 타입을 포함한 혼합 타입 표현식의 사용이 허용됩니다.

PostgreSQL 스캐너/파서는 어휘 요소를 다섯 가지 기본 범주로만 분류합니다:

- 정수 (integers)
- 비정수 숫자 (non-integer numbers)
- 문자열 (strings)
- 식별자 (identifiers)
- 키워드 (keywords)

대부분의 비숫자 타입 상수는 먼저 문자열로 분류됩니다. SQL 언어 정의는 타입 이름을 문자열과 함께 지정할 수 있게 하며, 이 메커니즘은 파서가 올바른 타입으로 문자열을 전달하는 데 사용될 수 있습니다. 예를 들어, 다음 쿼리는:

```sql
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)
```

이 예제에는 두 개의 리터럴이 있습니다. 하나는 `text` 타입이고 다른 하나는 `point` 타입입니다. 문자열 리터럴에 타입이 지정되지 않으면, 아래 설명된 대로 이후 단계에서 해결될 플레이스홀더 타입 `unknown`이 초기에 할당됩니다.

SQL 파서에서 별도의 타입 변환이 필요한 네 가지 기본 SQL 구문이 있습니다:

### 함수 호출 (Function calls)

PostgreSQL 타입 시스템의 대부분은 풍부한 함수 집합을 기반으로 구축됩니다. 함수는 하나 이상의 인수를 가질 수 있습니다. PostgreSQL은 함수 오버로딩을 허용하므로, 함수 이름만으로는 호출할 함수를 고유하게 식별할 수 없습니다; 파서는 제공된 인수의 데이터 타입을 기반으로 올바른 함수를 선택해야 합니다.

### 연산자 (Operators)

PostgreSQL은 전위(prefix) 연산자(단항)와 중위(infix) 연산자(이항)를 가진 표현식을 허용합니다. 함수와 마찬가지로 연산자도 오버로드될 수 있으므로 올바른 연산자를 선택하는 데 동일한 문제가 존재합니다.

### 값 저장 (Value Storage)

SQL `INSERT` 및 `UPDATE` 문은 표현식의 결과를 테이블에 저장합니다. 문의 표현식은 대상 열의 타입과 일치하거나 변환되어야 합니다.

### UNION, CASE 및 관련 구문

`UNION`으로 결합된 `SELECT` 문의 모든 쿼리 결과는 단일 열 집합에 나타나야 하므로, 각 `SELECT` 절의 결과 타입이 일치하고 균일한 집합으로 변환되어야 합니다. 마찬가지로, `CASE` 구문의 결과 표현식은 공통 타입으로 변환되어야 CASE 표현식 전체가 알려진 출력 타입을 갖게 됩니다. `ARRAY[]` 구문과 `GREATEST` 및 `LEAST` 함수도 마찬가지입니다.

시스템 카탈로그는 데이터 타입 간에 존재하는 변환(캐스트)과 수행 방법에 대한 정보를 저장합니다. 추가 캐스트는 `CREATE CAST` 명령으로 사용자가 추가할 수 있습니다(이는 일반적으로 새로운 데이터 타입 정의와 함께 수행됩니다. 내장 타입 간의 캐스트 집합은 신중하게 제작되었으며 변경하지 않는 것이 가장 좋습니다).

파서에 의해 제공되는 추가 휴리스틱은 적절한 캐스팅 동작을 결정하기 위해 암시적 캐스트가 있는 타입 그룹 중에서 선택할 수 있게 합니다. 데이터 타입은 여러 기본 *타입 카테고리*로 나뉩니다:

- `boolean`
- `numeric`
- `string`
- `bitstring`
- `datetime`
- `timespan`
- `geometric`
- `network`
- 사용자 정의 카테고리

(전체 목록은 Table 53.65를 참조; 그러나 사용자 정의 카테고리를 생성하는 것도 가능합니다.)

각 카테고리에는 하나 이상의 *선호 타입(preferred types)*이 있을 수 있으며, 이는 타입 선택의 여지가 있을 때 선호됩니다. 주의 깊게 선택된 선호 타입과 사용 가능한 암시적 캐스트를 통해, 모호한 표현식(여러 가지 다른 해결책이 있는 표현식)이 유용한 방식으로 해결될 수 있습니다.

모든 타입 변환 규칙은 다음 몇 가지 원칙을 염두에 두고 설계되었습니다:

- 암시적 변환은 절대로 놀랍거나 예측할 수 없는 결과를 초래해서는 안 됩니다.
- 쿼리에 암시적 타입 변환이 필요하지 않으면 파서나 실행기에서 추가 오버헤드가 발생하지 않아야 합니다. 즉, 쿼리가 잘 구성되어 있고 타입이 이미 일치하면 쿼리는 파서에서 추가 시간을 소비하지 않고 실행되어야 하며 쿼리에 불필요한 암시적 타입 변환 호출이 도입되지 않아야 합니다.
- 또한, 쿼리가 일반적으로 함수에 대해 암시적 변환을 필요로 하고 사용자가 올바른 인수 타입으로 새 함수를 정의하면, 파서는 이 새 함수를 사용해야 하며 이전 함수를 사용하기 위해 더 이상 암시적 변환을 수행하지 않아야 합니다.

---

## 10.2. 연산자 (Operators)

연산자 표현식에서 참조되는 특정 연산자는 다음 절차를 사용하여 결정됩니다. 입력 인수 타입은 알 수 없을 수 있으며, 연산자는 전위(prefix) 연산자(왼쪽 인수가 없음) 또는 중위(infix) 연산자일 수 있습니다. 중위 연산자는 예전에는 접미(postfix) 연산자(오른쪽 인수가 없음)로도 작동할 수 있었지만, 이 가능성은 PostgreSQL 14부터 제거되었습니다.

### 연산자 타입 해석 절차

1. `pg_operator` 시스템 카탈로그에서 고려할 연산자를 선택합니다. 스키마로 한정되지 않은 연산자 이름이 사용된 경우(일반적인 경우), 고려되는 연산자는 현재 검색 경로에서 보이는 이름 및 인수 개수와 일치하는 연산자입니다. 한정된 연산자 이름이 주어진 경우, 해당 스키마의 연산자만 고려됩니다.

   a. 검색 경로에서 동일한 인수 타입을 가진 여러 연산자가 발견되면, 경로에서 가장 먼저 나타나는 연산자만 고려됩니다. 그러나 다른 인수 타입을 가진 연산자는 경로에서의 위치와 관계없이 동등하게 고려됩니다.

2. 입력 인수 타입을 정확히 받아들이는 연산자가 있는지 확인합니다. 존재하면(고려되는 연산자 집합에서 정확히 하나의 일치만 있을 수 있음) 사용합니다. (알 수 없는 타입의) 바이너리 연산자 호출에서 한 인수가 `unknown` 타입이면, 이 검사에서 다른 인수와 동일한 것으로 가정됩니다. 중위 연산자 호출에서 양쪽 인수가 모두 `unknown` 타입인 경우를 포함하여 이 단계에서 일치하는 것은 없습니다.

   a. 중위 연산자의 한 인수가 `unknown` 타입이고 다른 인수가 도메인 타입인 경우, 다음으로 양쪽 인수가 도메인의 기본 타입인 연산자가 있는지 확인합니다. 있으면 그것을 사용합니다.

3. 최적의 일치를 찾습니다.

   a. 입력 타입이 일치하지 않고 암시적 변환으로 일치하도록 변환할 수 없는 후보 연산자를 모두 버립니다. 이 목적을 위해 `unknown` 리터럴은 어떤 것으로든 변환 가능한 것으로 가정됩니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   b. 모든 후보를 검토하고 도메인 타입인 입력 인수가 있는 경우 해당 인수 위치에서 도메인의 기본 타입을 허용하는 것으로 간주합니다. 이 식별을 통해 정확히 일치하는 후보가 발견되면 사용합니다. 그렇지 않으면 도메인 인수가 있는 후보를 이 목적 및 후속 단계에서 도메인의 기본 타입을 허용하는 것으로 계속 간주합니다.

   c. 모든 후보를 검토하고 입력 타입에서 가장 많은 위치에서 정확한 일치를 허용하는 것만 유지합니다. 정확한 일치가 없으면 모든 후보를 유지합니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   d. 모든 후보를 검토하고 타입 변환이 필요한 위치에서 선호 타입(입력 데이터 타입의 타입 카테고리)을 허용하는 것이 가장 많은 위치에 있는 것만 유지합니다. 선호 타입을 허용하는 것이 없으면 모든 후보를 유지합니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   e. 입력 인수 중 `unknown` 타입인 것이 있으면, 해당 위치에서 남은 후보가 허용하는 타입 카테고리를 확인합니다. 각 위치에서 `string` 카테고리를 허용하는 후보가 있으면 해당 카테고리를 선택합니다(`unknown` 타입 리터럴이 문자열처럼 보이기 때문에 이 편향이 적절합니다). 그렇지 않으면 모든 남은 후보가 동일한 타입 카테고리를 허용하면 해당 카테고리를 선택합니다; 그렇지 않으면 올바른 선택을 추론할 추가 단서 없이 실패합니다. 이제 선택된 타입 카테고리를 허용하지 않는 후보를 버립니다. 또한, 해당 인수에서 선호 타입을 허용하는 후보가 있으면 해당 인수 위치에서 비선호 타입을 허용하는 후보를 버립니다. 후보가 없으면 원래 집합을 유지하고 다음 단계로 계속합니다. (이러한 테스트의 전체 집합을 통과하는 후보가 없으면 원래 집합을 유지하여 이후 단계에서 의미 있는 오류를 발행할 수 있습니다.)

   f. `unknown`과 알려진 타입 인수가 모두 있고, 알려진 타입 인수가 모두 동일한 타입인 경우, `unknown` 인수도 해당 타입인 것으로 가정합니다. 그런 다음 입력 타입과 어떤 후보가 일치하는지 또는 해당 위치에서 암시적으로 해당 타입으로 변환될 수 있는지 확인합니다. 정확히 하나의 후보가 그 테스트를 통과하면 사용합니다. 그렇지 않으면 실패합니다.

### 예제

#### 예제 10.1. 제곱근 연산자 타입 해석

표준 카탈로그에는 `double precision` 인수를 받는 제곱근 연산자(`|/`)가 하나만 정의되어 있습니다. 스캐너는 다음 쿼리 표현식의 입력에 초기 타입 `integer`를 할당합니다:

```sql
SELECT |/ 40 AS "square root of 40";
 square root of 40
-------------------
 6.324555320336759
(1 row)
```

따라서 파서는 피연산자에 대해 타입 변환을 수행하고 쿼리는 다음과 동등합니다:

```sql
SELECT |/ CAST(40 AS double precision) AS "square root of 40";
```

#### 예제 10.2. 문자열 연결 연산자 타입 해석

문자열과 같은 구문은 문자열 타입뿐만 아니라 복잡한 확장 타입에도 사용됩니다. 지정되지 않은 타입의 문자열은 가능한 연산자 후보와 일치됩니다.

지정되지 않은 인수가 하나인 예:

```sql
SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)
```

이 경우 파서는 `text` 타입을 양쪽에서 받아들이는 연산자가 있는지 확인합니다. 있으므로 두 번째 인수가 `text` 타입으로 해석된다고 가정합니다.

다음은 지정되지 않은 타입의 두 값의 연결입니다:

```sql
SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)
```

이 경우 사용할 타입에 대한 초기 힌트가 없습니다. 파서는 시스템 카탈로그에서 연결 연산자(`||`)의 모든 후보 연산자를 찾습니다. 문자열 카테고리와 비트 문자열 카테고리 둘 다 허용하는 후보가 있으므로 문자열 카테고리가 선호됩니다. 문자열 카테고리의 선호 타입인 `text`가 인수의 가정 타입으로 사용되어 연산자가 해석됩니다.

#### 예제 10.3. 절댓값 및 부정 연산자 타입 해석

PostgreSQL 연산자 카탈로그에는 전위 연산자 `@`에 대한 여러 항목이 있으며, 다양한 숫자 데이터 타입에 대한 절댓값 연산을 구현합니다. 그 중 하나는 `float8` 타입이며, 숫자 카테고리의 선호 타입입니다. 따라서 PostgreSQL은 `unknown` 입력에 직면했을 때 그것을 사용합니다:

```sql
SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)
```

여기서 시스템은 `text` 타입 상수에서 `float8`로의 암시적 변환을 적용한 후 `float8` `@` 연산자를 적용합니다. 실제로 `float8`이 사용되었고 다른 타입이 아님을 확인할 수 있습니다:

```sql
SELECT @ '-4.5e500' AS "abs";

ERROR:  "-4.5e500" is out of range for type double precision
```

반면에, 전위 연산자 `~`(비트 부정)는 정수 데이터 타입에 대해서만 정의되어 있으며, `float8`에 대해서는 정의되어 있지 않습니다. 따라서 `~`로 유사한 경우를 시도하면 다음과 같습니다:

```sql
SELECT ~ '20' AS "negation";

ERROR:  operator is not unique: ~ "unknown"
HINT:  Could not choose a best candidate operator. You might need to add
explicit type casts.
```

이는 시스템이 여러 가능한 `~` 연산자 중에서 어떤 것을 선호해야 할지 결정할 수 없기 때문에 발생합니다. 명시적 캐스트를 사용하여 도움을 줄 수 있습니다:

```sql
SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)
```

#### 예제 10.4. 배열 포함 연산자 타입 해석

다음은 도메인 타입의 배열과 관련된 예제입니다:

```sql
SELECT array[1,2] <@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)
```

PostgreSQL 연산자 카탈로그에는 `<@`에 대한 여러 중위 연산자가 있지만, 왼쪽에 정수 배열을 허용하는 관련 연산자는 `anyarray <@ anyarray`(배열 포함)와 `anyelement <@ anyrange`(범위 포함)뿐입니다. 정수가 아닌 정수 배열이 있으므로, 범위 연산자에 대한 정확한 일치가 없습니다. 따라서 배열 포함 연산자가 해결됩니다. (3.f 단계가 `unknown` 리터럴이 정수 배열로 해석되도록 하지 않았다면, 위 쿼리는 실패했을 것입니다.)

#### 예제 10.5. 도메인 타입에 대한 사용자 정의 연산자

사용자는 때때로 기존 연산자를 확장하는 것이 아니라 도메인 타입에만 적용되는 연산자를 정의하려고 합니다. 한 가지 예는 `=`와 같은 도메인의 `text` 기반 값에서 대소문자를 무시하는 비교 연산자를 정의하는 것입니다. 이렇게 하는 것은 가능하지만, 예상대로 작동하지 않는 경우가 있습니다. 다음과 같은 스키마가 있다고 가정합니다:

```sql
CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);
```

그런 다음 다음과 같은 쿼리를 수행합니다:

```sql
SELECT * FROM mytable WHERE val = 'foo';
```

이 쿼리는 사용자 정의 연산자를 사용하지 않습니다. 파서는 먼저 `mytext = mytext` 연산자가 있는지 확인합니다(2단계). 없으므로 도메인의 기본 타입 `text`를 고려하여 `text = text` 연산자가 있는지 확인합니다(2.a단계). 있으므로 `unknown` 타입 리터럴을 `text`로 해석하고 `text = text` 연산자를 사용합니다. 사용자 정의 연산자가 사용되도록 하는 유일한 방법은 리터럴을 명시적으로 캐스팅하는 것입니다:

```sql
SELECT * FROM mytable WHERE val = text 'foo';
```

그러면 2단계에서 즉시 `mytext = text` 연산자가 정확히 일치합니다. 대신 `mytext = mytext` 연산자가 있었다면, 2단계는 실패하지만 파서가 3.c단계에서 연산자를 찾아 오른쪽 인수를 `mytext`로 변환합니다.

도메인의 `text = text` 비교가 중요하지 않다면, 일반적으로 도메인이 동등 비교를 지원해야 하는 경우가 있으므로 특별히 해결할 필요가 없을 수 있습니다. 그러나 연산자가 대소문자 무시인 경우, 비교를 수행하기 전에 시스템이 비교되는 다른 피연산자를 `mytext`로 변환하도록 하려면 3.c단계를 트리거하려고 할 가능성이 높습니다. 그러나 사용자가 혼합 타입 비교를 시작하면 다시 위험에 처하게 됩니다:

```sql
SELECT * FROM mytable WHERE val = 'foo'::text;
```

이는 다시 3.b단계에서 `text = text` 연산자를 찾습니다. 그것이 작동하도록 하는 유일한 방법은 `text = mytext` 연산자를 정의하는 것입니다. 그래야 일치하기 전에 시스템이 `mytext` 연산자를 찾을 수 있습니다.

---

## 10.3. 함수 (Functions)

함수 호출에서 참조되는 특정 함수는 다음 절차를 사용하여 결정됩니다.

### 함수 타입 해석 절차

1. `pg_proc` 시스템 카탈로그에서 고려할 함수를 선택합니다. 스키마로 한정되지 않은 함수 이름이 사용된 경우, 고려되는 함수는 현재 검색 경로에서 보이는 이름 및 인수 개수와 일치하는 함수입니다. 한정된 함수 이름이 주어진 경우, 해당 스키마의 함수만 고려됩니다.

   a. 검색 경로에서 동일한 인수 타입을 가진 여러 함수가 발견되면, 경로에서 가장 먼저 나타나는 함수만 고려됩니다. 그러나 다른 인수 타입을 가진 함수는 경로에서의 위치와 관계없이 동등하게 고려됩니다.

   b. `VARIADIC` 배열 매개변수가 있는 함수가 발견되고 호출에 `VARIADIC` 키워드가 사용되지 않은 경우, 함수는 배열 매개변수를 해당 요소 타입의 하나 이상의 발생으로 대체한 것처럼 처리됩니다. 이러한 확장 후 함수가 비VARIADIC 함수와 동일한 인수 타입을 가지면, 검색 경로에서 가장 먼저 나타나는 함수가 사용됩니다. 동일한 스키마에 있으면 비VARIADIC 함수가 선호됩니다.

      > 참고: 함수 호출에서 `VARIADIC` 키워드를 사용하면 이 단계의 확장이 수행되지 않습니다. 인수가 이미 형성된 배열 값과 일치합니다. VARIADIC 함수가 신뢰할 수 없는 사용자가 객체를 생성할 수 있는 스키마에서 호출되면 위험할 수 있습니다. VARIADIC 키워드를 사용하여 위험을 우회할 수 있습니다.

   c. 기본 매개변수 표현식이 있는 함수가 발견되면, 0개 이상의 기본 가능한 매개변수 위치가 누락된 호출과 일치하는 것으로 간주됩니다. 둘 이상의 함수가 호출과 일치하면 검색 경로에서 가장 먼저 나타나는 함수가 사용됩니다. 동일한 스키마에서 비기본 위치의 인수 타입이 동일한 함수가 둘 이상 있으면(기본값이 있는 일부 위치가 다를 수 있음), 시스템은 호출되어야 하는 함수를 결정할 수 없으며 "모호한 함수 호출" 오류가 발생합니다.

      > 참고: 기본값에 대한 검사는 인수 타입과 관계없이 수행됩니다. 따라서 예를 들어, `foo(int, int)`와 `foo(int, int, text DEFAULT ...)`를 모두 갖는 것은 불가능합니다. 두 함수 중 어느 것이 둘 이상의 인수로 호출해야 하는지 모호하기 때문입니다.

2. 입력 인수 타입을 정확히 받아들이는 함수가 있는지 확인합니다. 존재하면(고려되는 함수 집합에서 정확히 하나의 일치만 있을 수 있음) 사용합니다. 정확한 일치가 없고 신뢰할 수 없는 사용자가 객체를 생성할 수 있는 스키마의 함수를 스키마 한정 이름으로 호출하면 위험할 수 있습니다. 그런 경우 인수를 캐스팅하여 정확한 일치를 강제하세요.

   a. 함수의 한 인수가 `unknown` 타입이고 다른 인수가 도메인 타입인 경우, 다음으로 양쪽 인수가 도메인의 기본 타입인 함수가 있는지 확인합니다. 있으면 그것을 사용합니다.

3. 함수 호출이 단일 인수로 나타나고 함수 이름이 데이터 타입의 (스키마 한정된) 이름과 동일한 경우, 호출이 타입 캐스트 요청인지 확인합니다. 함수 인수가 `unknown` 타입 리터럴이거나, 명명된 데이터 타입과 이진 호환되거나, 타입의 I/O 함수를 적용하여(즉, 캐스트가 to 또는 from `text`이거나) 변환될 수 있는 경우, 호출은 캐스트로 처리됩니다. 이 예외는 함수 유사 구문을 사용하여 캐스트를 호출할 수 있도록 합니다.

4. 최적의 일치를 찾습니다.

   a. 입력 타입이 일치하지 않고 암시적 변환으로 일치하도록 변환할 수 없는 후보 함수를 모두 버립니다. 이 목적을 위해 `unknown` 리터럴은 어떤 것으로든 변환 가능한 것으로 가정됩니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   b. 모든 후보를 검토하고 도메인 타입인 입력 인수가 있는 경우 해당 인수 위치에서 도메인의 기본 타입을 허용하는 것으로 간주합니다. 이 식별을 통해 정확히 일치하는 후보가 발견되면 사용합니다. 그렇지 않으면 도메인 인수가 있는 후보를 이 목적 및 후속 단계에서 도메인의 기본 타입을 허용하는 것으로 계속 간주합니다.

   c. 모든 후보를 검토하고 입력 타입에서 가장 많은 위치에서 정확한 일치를 허용하는 것만 유지합니다. 정확한 일치가 없으면 모든 후보를 유지합니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   d. 모든 후보를 검토하고 타입 변환이 필요한 위치에서 선호 타입(입력 데이터 타입의 타입 카테고리)을 허용하는 것이 가장 많은 위치에 있는 것만 유지합니다. 선호 타입을 허용하는 것이 없으면 모든 후보를 유지합니다. 하나의 후보만 남으면 사용합니다; 그렇지 않으면 다음 단계로 계속합니다.

   e. 입력 인수 중 `unknown` 타입인 것이 있으면, 해당 위치에서 남은 후보가 허용하는 타입 카테고리를 확인합니다. 각 위치에서 `string` 카테고리를 허용하는 후보가 있으면 해당 카테고리를 선택합니다(`unknown` 타입 리터럴이 문자열처럼 보이기 때문에 이 편향이 적절합니다). 그렇지 않으면 모든 남은 후보가 동일한 타입 카테고리를 허용하면 해당 카테고리를 선택합니다; 그렇지 않으면 올바른 선택을 추론할 추가 단서 없이 실패합니다. 이제 선택된 타입 카테고리를 허용하지 않는 후보를 버립니다. 또한, 해당 인수에서 선호 타입을 허용하는 후보가 있으면 해당 인수 위치에서 비선호 타입을 허용하는 후보를 버립니다. 후보가 없으면 원래 집합을 유지하고 다음 단계로 계속합니다.

   f. `unknown`과 알려진 타입 인수가 모두 있고, 알려진 타입 인수가 모두 동일한 타입인 경우, `unknown` 인수도 해당 타입인 것으로 가정합니다. 그런 다음 입력 타입과 어떤 후보가 일치하는지 또는 해당 위치에서 암시적으로 해당 타입으로 변환될 수 있는지 확인합니다. 정확히 하나의 후보가 그 테스트를 통과하면 사용합니다. 그렇지 않으면 실패합니다.

### 예제

#### 예제 10.6. 반올림 함수 인수 타입 해석

`round` 함수는 두 인수를 받습니다. 첫 번째 인수는 `numeric` 타입이고 두 번째 인수는 `integer` 타입입니다. 따라서 다음 쿼리는 첫 번째 인수를 `numeric`으로 자동 변환합니다:

```sql
SELECT round(4, 4);

 round
-------
4.0000
(1 row)
```

이 쿼리는 실제로 파서에 의해 다음과 같이 변환됩니다:

```sql
SELECT round(CAST (4 AS numeric), 4);
```

소수점이 있는 숫자 상수는 초기에 `numeric` 타입으로 지정되므로, 다음 쿼리는 타입 변환이 필요 없어 약간 더 효율적일 수 있습니다:

```sql
SELECT round(4.0, 4);
```

#### 예제 10.7. 가변 인수 함수 해석

```sql
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION
```

이 함수는 `VARIADIC` 키워드를 받아들이지만 필수는 아닙니다. 정수와 숫자 인수를 모두 허용합니다:

```sql
SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                1 |                1 |                1
(1 row)
```

그러나 더 구체적인 함수가 있으면 첫 번째와 두 번째 호출이 그것을 선호합니다:

```sql
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                3 |                2 |                1
(1 row)
```

기본 설정과 첫 번째 함수만 존재하는 경우, 첫 번째와 두 번째 호출은 안전하지 않습니다. 모든 사용자가 두 번째 또는 세 번째 함수를 생성하여 이를 가로챌 수 있습니다. 인수 타입을 정확히 일치시키고 `VARIADIC` 키워드를 사용하여 세 번째 호출은 안전합니다.

#### 예제 10.8. 부분 문자열 함수 타입 해석

여러 `substr` 함수가 있으며, 그 중 하나는 `text`와 `integer` 타입을 받습니다. 지정되지 않은 타입의 문자열 상수로 호출하면, 시스템은 `string` 카테고리의 선호 타입(즉, `text` 타입)의 인수를 받아들이는 후보 함수를 선택합니다:

```sql
SELECT substr('1234', 3);

 substr
--------
     34
(1 row)
```

`varchar` 타입으로 선언된 문자열로 호출하면 파서가 변환을 시도합니다:

```sql
SELECT substr(varchar '1234', 3);

 substr
--------
     34
(1 row)
```

이것은 파서에 의해 효과적으로 다음과 같이 변환됩니다:

```sql
SELECT substr(CAST (varchar '1234' AS text), 3);
```

> 참고: 파서는 `pg_cast` 카탈로그에서 `text`와 `varchar`가 이진 호환됨을 알게 됩니다. 즉, 하나를 다른 것으로 전달하여 물리적 표현의 변환 없이 받아들일 수 있습니다. 따라서 이 경우 실제로 타입 변환 호출이 삽입되지 않습니다.

반면에, `integer` 타입의 인수로 호출하면, 파서가 `text`로 변환하려고 시도합니다:

```sql
SELECT substr(1234, 3);
ERROR:  function substr(integer, integer) does not exist
HINT:  No function matches the given name and argument types. You might need
to add explicit type casts.
```

`integer`에서 `text`로의 암시적 캐스트가 없기 때문에 작동하지 않습니다. 그러나 명시적 캐스트는 작동합니다:

```sql
SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)
```

---

## 10.4. 값 저장 (Value Storage)

테이블에 삽입되는 값은 다음 단계에 따라 대상 열의 데이터 타입으로 변환됩니다.

### 값 저장 타입 변환 절차

1. 대상과의 정확한 일치를 확인합니다.

2. 그렇지 않으면 표현식을 대상 타입으로 변환하려고 시도합니다. 두 타입 간에 *할당 캐스트(assignment cast)*가 `pg_cast` 카탈로그에 등록되어 있으면(CREATE CAST 참조) 가능합니다. 또는 표현식이 `unknown` 타입 리터럴인 경우, 리터럴 문자열의 내용이 대상 타입의 입력 변환 루틴에 전달됩니다.

3. 대상에 대한 크기 조정 캐스트(sizing cast)가 있는지 확인합니다. 크기 조정 캐스트는 동일한 타입에서의 캐스트입니다. `pg_cast` 카탈로그에서 찾으면 표현식에 적용한 후 대상 열에 저장합니다. 이러한 캐스트의 구현 함수는 항상 `integer` 타입의 추가 매개변수를 받습니다. 이 매개변수는 대상 열의 `atttypmod` 값을 수신합니다(일반적으로 선언된 길이이지만 `atttypmod`의 해석은 다른 데이터 타입에 따라 다릅니다). 또한 선택적으로 `boolean` 타입의 세 번째 매개변수를 받아 캐스트가 명시적인지 암시적인지를 나타낼 수 있습니다. 캐스트 함수는 길이 제약에 맞지 않는 값에 대해 오류를 발생시키거나 길이 자르기 등 필요한 길이 종속 의미를 적용할 책임이 있습니다.

### 예제

#### 예제 10.9. `character` 저장 타입 변환

`character(20)` 타입으로 선언된 대상 열의 경우 다음 문은 저장된 값이 올바른 크기임을 보여줍니다:

```sql
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
----------------------+--------------
 abcdef               |           20
(1 row)
```

실제로 일어나는 일은 다음과 같습니다: 두 개의 `unknown` 리터럴은 기본적으로 `text`로 해석되어 `||` 연산자가 `text` 연결로 해석됩니다. 그런 다음 연산자의 `text` 결과가 대상 열 타입인 `bpchar`("blank-padded char", `character` 데이터 타입의 내부 이름)로 변환됩니다. `text`에서 `bpchar`로의 변환은 이진 호환되므로 이 변환은 함수 호출을 삽입하지 않습니다. 마지막으로, 시스템 카탈로그에서 크기 조정 함수 `bpchar(bpchar, integer, boolean)`을 찾아 연산자 결과와 저장된 열 길이에 적용합니다. 이 타입별 함수는 필요한 길이 검사와 패딩 공백 추가를 수행합니다.

---

## 10.5. UNION, CASE 및 관련 구문

SQL `UNION` 구문은 서로 다른 타입을 단일 결과 집합으로 일치시켜야 합니다. 해결 알고리즘은 UNION 쿼리의 각 출력 열에 개별적으로 적용됩니다. `INTERSECT` 및 `EXCEPT` 구문도 `UNION`과 동일한 방식으로 다른 타입을 해결합니다. 일부 `CASE`, `ARRAY`, `VALUES`, `GREATEST` 및 `LEAST` 구문도 동일한 알고리즘을 사용하여 구성 표현식을 일치시키고 결과 데이터 타입을 선택합니다.

### UNION, CASE 및 관련 구문의 타입 해결 절차

1. 모든 입력이 동일한 타입이고 `unknown`이 아니면 해당 타입으로 해결합니다.

2. 모든 입력의 타입이 도메인 타입인 경우, 모든 후속 단계에서 해당 입력을 도메인의 기본 타입으로 취급합니다.

   > 참고: 연산자 및 함수 해결과 마찬가지로, 이를 통해 도메인 타입이 도메인 친화적 연산이 있는 한 균일한 혼합 도메인 및 기본 타입 사례에서 보존될 수 있습니다.

3. 모든 입력이 `unknown` 타입이면 `text`(문자열 카테고리의 선호 타입) 타입으로 해결합니다. 그렇지 않으면 `unknown` 입력은 이 규칙과 후속 규칙을 위해 무시됩니다.

4. 비`unknown` 입력이 모두 동일한 타입 카테고리가 아니면 실패합니다.

5. 후보 타입을 선택합니다. 이는 첫 번째 비`unknown` 입력 타입입니다. 그런 다음 왼쪽에서 오른쪽으로 다른 비`unknown` 입력 타입을 고려합니다. 후보 타입이 다른 타입으로 암시적으로 변환될 수 있지만 그 반대는 아닌 경우, 다른 타입을 새 후보로 선택합니다. 선호 타입이 선택되면 다른 입력 고려를 중단합니다.

6. 모든 입력을 최종 후보 타입으로 변환합니다. 주어진 입력에서 해당 타입으로의 암시적 변환이 없으면 실패합니다.

몇 가지 예가 뒤따릅니다.

### 예제

#### 예제 10.10. 미지정 타입을 포함한 Union의 타입 해결

```sql
SELECT text 'a' AS "text" UNION SELECT 'b';

 text
------
 a
 b
(2 rows)
```

여기서 `unknown` 타입 리터럴 `'b'`는 `text` 타입으로 해결됩니다.

#### 예제 10.11. 간단한 Union의 타입 해결

```sql
SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
---------
       1
     1.2
(2 rows)
```

리터럴 `1.2`는 `numeric` 타입이고, `integer` 값 `1`은 암시적으로 `numeric`으로 캐스트될 수 있으므로, 해당 타입이 사용됩니다.

#### 예제 10.12. 전치된 Union의 타입 해결

```sql
SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
------
    1
  2.2
(2 rows)
```

여기서 `real`은 `integer`로 암시적으로 캐스트될 수 없지만, `integer`는 `real`로 암시적으로 캐스트될 수 있으므로, union 결과 타입은 `real`로 해결됩니다.

#### 예제 10.13. 중첩된 Union의 타입 해결

```sql
SELECT NULL UNION SELECT NULL UNION SELECT 1;

ERROR:  UNION types text and integer cannot be matched
```

이 실패는 PostgreSQL이 다중 `UNION`을 쌍 단위 연산으로 취급하기 때문에 발생합니다. 즉, 이 입력은 다음과 동일합니다:

```sql
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
```

내부 `UNION`은 위의 규칙 3에 따라 `text` 타입으로 해결됩니다. 그런 다음 외부 `UNION`은 `text` 및 `integer` 타입의 입력을 가지며, 이 충돌을 야기합니다. 가장 왼쪽 `UNION`이 원하는 결과 타입의 입력을 적어도 하나 포함하도록 하면 문제를 해결할 수 있습니다.

`INTERSECT` 및 `EXCEPT` 연산도 쌍 단위로 해결됩니다. 그러나 이 섹션에서 설명하는 다른 구문은 모든 입력을 한 번에 고려합니다. 예를 들어, `CASE`의 경우 `ELSE` 절이 "첫 번째" 입력으로 간주되고, `THEN` 절이 그 이후로 고려됩니다.

---

## 10.6. SELECT 출력 열 (SELECT Output Columns)

앞의 섹션에서 설명한 규칙은 모든 표현식에 알려지지 않은 타입 리터럴을 포함하여 비`unknown` 데이터 타입을 할당합니다. `SELECT` 명령의 단순 출력 열로만 나타나는 지정되지 않은 타입의 리터럴에는 예외가 있습니다. 예를 들어, 다음에서:

```sql
SELECT 'Hello World';
```

문자열 리터럴의 타입을 식별할 방법이 없습니다. 이 상황에서 PostgreSQL은 리터럴의 타입을 `text`로 기본 해석합니다.

지정되지 않은 타입의 리터럴이 `UNION`(또는 `INTERSECT` 또는 `EXCEPT`) 구문의 일부이거나 `INSERT ... SELECT` 내에 나타나는 경우, 이 규칙이 적용되지 않습니다. 이러한 경우에는 앞의 섹션의 규칙이 우선되며, 다른 `UNION` arm 또는 대상 열에서 타입이 결정됩니다.

`RETURNING` 목록은 이 목적상 `SELECT` 출력 목록과 동일하게 취급됩니다.

> 참고: PostgreSQL 10 이전에는 이 규칙이 존재하지 않았으며, `SELECT` 출력 목록의 지정되지 않은 타입 리터럴은 `unknown` 타입으로 남았습니다. 이는 다양한 문제를 야기했기 때문에 변경되었습니다.
