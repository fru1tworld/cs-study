# 제4장. SQL 구문 (SQL Syntax)

> PostgreSQL 18 공식 문서 번역
> 원문: https://www.postgresql.org/docs/18/sql-syntax.html

이 장에서는 SQL 구문의 기본 요소들을 설명합니다. 이 지식은 후속 장에서 데이터 정의와 조작을 위한 SQL 명령을 적용하는 방법을 상세히 설명할 때 기초가 됩니다.

SQL 경험이 있는 사용자도 이 장을 주의 깊게 읽어야 합니다. PostgreSQL은 다른 SQL 데이터베이스와 일관되지 않게 구현된 규칙과 개념이 있거나 PostgreSQL 고유의 기능을 사용하기 때문입니다.

---

## 4.1. 어휘 구조 (Lexical Structure)

SQL 입력은 명령(command) 시퀀스로 구성됩니다. 명령은 세미콜론(`;`)으로 종료되는 토큰(token) 시퀀스로 구성됩니다. 입력 스트림의 끝도 명령을 종료합니다. 어떤 토큰이 유효한지는 특정 명령의 구문에 따라 다릅니다.

토큰은 키워드(keyword), 식별자(identifier), 따옴표로 묶인 식별자(quoted identifier), 리터럴(literal) 또는 상수, 또는 특수 문자 기호일 수 있습니다. 토큰은 일반적으로 공백(스페이스, 탭, 줄바꿈)으로 구분되지만, 모호함이 없는 경우(일반적으로 특수 문자가 다른 토큰 유형에 인접한 경우에만)에는 구분할 필요가 없습니다.

추가로, SQL 입력에는 주석(comment) 이 나타날 수 있습니다. 주석은 토큰이 아니며 실질적으로 공백과 동일합니다.

예를 들어, 다음은 (구문적으로) 유효한 SQL 입력입니다:

```sql
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
```

이것은 세미콜론으로 구분된 세 개의 명령 시퀀스입니다(한 줄에 하나의 명령이지만 필수 사항은 아닙니다. 한 줄에 여러 명령이 있을 수 있고, 명령은 여러 줄에 걸쳐 나뉠 수 있습니다).

토큰이 어떤 것인지는 사용되는 컨텍스트에 따라 다릅니다. 다음 하위 섹션에서는 어휘 구조의 구성 요소들을 개별적으로 설명합니다.

### 4.1.1. 식별자와 키워드 (Identifiers and Key Words)

위 예제에서 `SELECT`, `UPDATE`, `INSERT`와 같은 토큰은 키워드 의 예입니다. 즉, SQL 언어에서 고정된 의미를 가지는 단어입니다. `MY_TABLE`과 `A` 토큰은 식별자 의 예입니다. 사용되는 명령에 따라 테이블, 열 또는 다른 데이터베이스 객체의 이름을 식별합니다. 따라서 때때로 간단히 "이름"이라고 부릅니다. 키워드와 식별자는 동일한 어휘 구조를 가지므로, 언어를 알지 못하면 토큰이 식별자인지 키워드인지 알 수 없습니다. 키워드의 전체 목록은 부록 C에서 찾을 수 있습니다.

SQL 식별자와 키워드는 문자 (a-z, 발음 구별 부호가 있는 문자, 비라틴 문자 포함) 또는 밑줄 (`_`)로 시작해야 합니다. 식별자나 키워드의 후속 문자는 문자, 밑줄, 숫자(0-9), 또는 달러 기호(`$`)일 수 있습니다. SQL 표준에 따르면 달러 기호는 식별자에 허용되지 않으므로, 이를 사용하면 애플리케이션의 이식성이 떨어질 수 있습니다. SQL 표준은 숫자를 포함하거나 밑줄로 시작하거나 끝나는 키워드를 정의하지 않으므로, 이 형식의 식별자는 표준의 가능한 향후 확장과 충돌하지 않습니다.

시스템은 식별자에 `NAMEDATALEN-1` 바이트 이상을 사용하지 않습니다. 명령에서 더 긴 이름을 작성할 수 있지만 잘립니다. 기본적으로 `NAMEDATALEN`은 64이므로 최대 식별자 길이는 63바이트 입니다. 이 제한이 문제가 되면 `src/include/pg_config_manual.h`에서 `NAMEDATALEN` 상수를 변경하여 늘릴 수 있습니다.

키워드와 따옴표가 없는 식별자는 대소문자를 구분하지 않습니다. 따라서:

```sql
UPDATE MY_TABLE SET A = 5;
```

는 다음과 동일하게 작성될 수 있습니다:

```sql
uPDaTE my_teleE SeT a = 5;
```

자주 사용되는 관례는 키워드를 대문자로, 이름을 소문자로 작성하는 것입니다. 예:

```sql
UPDATE my_table SET a = 5;
```

두 번째 종류의 식별자가 있습니다: 구분된 식별자(delimited identifier) 또는 따옴표로 묶인 식별자(quoted identifier) . 이것은 임의의 문자 시퀀스를 큰따옴표(`"`)로 묶어서 만듭니다. 구분된 식별자는 항상 식별자이며 절대 키워드가 아닙니다. 따라서 `"select"`는 `select`라는 이름의 열이나 테이블을 참조하는 데 사용될 수 있는 반면, 따옴표 없는 `select`는 키워드로 취급되어 테이블이나 열 이름이 예상되는 곳에 사용되면 구문 분석 오류가 발생합니다. 이 예제는 따옴표로 묶인 식별자와 함께 작성될 수 있습니다:

```sql
UPDATE "my_table" SET "a" = 5;
```

따옴표로 묶인 식별자는 코드 0의 문자를 제외한 모든 문자를 포함할 수 있습니다. (리터럴 큰따옴표를 포함하려면 큰따옴표 두 개를 작성하세요.) 이렇게 하면 공백이나 앰퍼샌드를 포함하는 테이블이나 열 이름을 구성할 수 있습니다. 길이 제한은 여전히 적용됩니다.

따옴표로 묶인 식별자도 대소문자를 구분합니다. 식별자를 따옴표로 묶으면 대소문자가 구분되고, 따옴표로 묶지 않으면 소문자로 변환됩니다. 예를 들어, 식별자 `FOO`, `foo`, `"foo"`는 PostgreSQL에서 동일한 것으로 간주되지만, `"Foo"`와 `"FOO"`는 이 세 가지 및 서로 다릅니다. (PostgreSQL에서 따옴표가 없는 이름을 소문자로 변환하는 것은 SQL 표준과 호환되지 않습니다. SQL 표준에서는 따옴표가 없는 이름을 대문자로 변환해야 합니다. 따라서 표준에 따르면 `foo`는 `"FOO"`와 동일해야 하며 `"foo"`와는 다릅니다. 이식 가능한 애플리케이션을 작성하려면 특정 이름을 항상 따옴표로 묶거나 절대 묶지 않는 것이 좋습니다.)

식별자를 형성하기 위한 변형이 있습니다: 유니코드 이스케이프가 있는 식별자입니다. 이 변형은 `U&`(대문자 또는 소문자 U 다음에 앰퍼샌드)로 시작하고 바로 뒤에 분리 공백 없이 큰따옴표가 옵니다. 예: `U&"foo"`. (이것은 `&` 연산자와 모호함을 만들므로, 해당 연산자 주위에 공백을 사용하세요.) 큰따옴표 안에 유니코드 문자는 백슬래시 다음에 4자리 16진수 코드 포인트 번호 또는 백슬래시와 더하기 기호 다음에 6자리 16진수 코드 포인트 번호를 작성하는 이스케이프 형식으로 지정할 수 있습니다. 예를 들어, 식별자 `"data"`는 다음과 같이 작성할 수 있습니다:

```sql
U&"d\0061t\+000061"
```

다음의 더 흥미로운 예제는 러시아어 단어 "slon"(코끼리)을 키릴 문자로 작성합니다:

```sql
U&"\0441\043B\043E\043D"
```

백슬래시 이외의 다른 이스케이프 문자를 원하면 문자열 뒤에 `UESCAPE` 절을 사용하여 지정할 수 있습니다. 예:

```sql
U&"d!0061t!+000061" UESCAPE '!'
```

이스케이프 문자는 16진수, 더하기 기호, 작은따옴표, 큰따옴표 또는 공백 문자 이외의 단일 문자일 수 있습니다. 이스케이프 문자는 `UESCAPE` 뒤에 작은따옴표로 작성되며, 큰따옴표가 아닙니다.

결과 문자열에 리터럴 백슬래시를 포함하려면 두 번 작성하세요.

4자리 또는 6자리 이스케이프 형식은 UTF-16 대리 쌍을 사용하여 코드 포인트가 `U+FFFF`보다 큰 문자를 구성하는 데 사용할 수 있지만, 6자리 형식의 사용 가능성으로 인해 이는 불필요합니다. (대리 쌍은 직접 저장되지 않고 단일 코드 포인트로 결합됩니다.)

서버 인코딩이 UTF-8이 아닌 경우, 이러한 이스케이프 시퀀스 중 하나로 식별된 유니코드 코드 포인트가 실제 서버 인코딩으로 변환됩니다. 가능하지 않으면 오류가 보고됩니다.

### 4.1.2. 상수 (Constants)

PostgreSQL에는 세 종류의 암묵적으로 타입이 지정된 상수가 있습니다: 문자열, 비트 문자열, 숫자. 상수는 명시적 타입으로도 지정될 수 있으며, 이를 통해 시스템에서 더 정확하게 표현하고 더 효율적으로 처리할 수 있습니다. 이러한 대안들은 다음 하위 섹션에서 논의됩니다.

#### 4.1.2.1. 문자열 상수 (String Constants)

SQL의 문자열 상수는 작은따옴표(`'`)로 묶인 임의의 문자 시퀀스입니다. 예: `'This is a string'`. 문자열 상수에 작은따옴표를 포함하려면 인접한 작은따옴표 두 개를 작성합니다. 예: `'Dianne''s horse'`. 이것은 이스케이프 문자가 아닌 작은따옴표 두 개입니다.

하나 이상의 줄바꿈만으로 구분된 두 문자열 상수는 연결되어 상수가 한 줄에 작성된 것처럼 처리됩니다. 예:

```sql
SELECT 'foo'
'bar';
```

는 다음과 동일합니다:

```sql
SELECT 'foobar';
```

하지만:

```sql
SELECT 'foo'      'bar';
```

는 유효한 구문이 아닙니다. (이 약간 이상한 동작은 SQL에서 지정된 것이며 PostgreSQL은 표준을 따릅니다.)

#### 4.1.2.2. C 스타일 이스케이프가 있는 문자열 상수 (String Constants with C-Style Escapes)

PostgreSQL은 SQL 표준의 확장인 "이스케이프" 문자열 상수도 허용합니다. 이스케이프 문자열 상수는 여는 작은따옴표 바로 앞에(사이에 공백 없이) 문자 `E`(대문자 또는 소문자)를 작성하여 지정합니다. 예: `E'foo'`. (여러 줄에 걸친 이스케이프 문자열 상수를 계속할 때, 첫 번째 여는 따옴표 전에만 `E`를 작성하세요.) 이스케이프 문자열 내에서 백슬래시 문자(`\`)는 C와 같은 백슬래시 이스케이프 시퀀스를 시작하며, 백슬래시와 다음 문자의 조합은 특별한 바이트 값을 나타냅니다. 아래 표 4.1에 표시됩니다.

표 4.1. 백슬래시 이스케이프 시퀀스

| 백슬래시 이스케이프 시퀀스 | 해석 |
|--------------------------|------|
| `\b` | 백스페이스 |
| `\f` | 폼 피드 |
| `\n` | 줄바꿈 |
| `\r` | 캐리지 리턴 |
| `\t` | 탭 |
| `\o`, `\oo`, `\ooo` (o = 0–7) | 8진수 바이트 값 |
| `\xh`, `\xhh` (h = 0–9, A–F) | 16진수 바이트 값 |
| `\uxxxx`, `\Uxxxxxxxx` (x = 0–9, A–F) | 16비트 또는 32비트 유니코드 문자 값 |

백슬래시 뒤에 나오는 다른 문자는 문자 그대로 취급됩니다. 따라서 리터럴 백슬래시 문자를 포함하려면 백슬래시 두 개(`\\`)를 작성합니다. 또한 이스케이프 문자열에서 일반적인 방법(작은따옴표 두 개) 외에도 `\'`로 작은따옴표를 포함할 수 있습니다.

백슬래시 뒤에 8진수 이스케이프 시퀀스를 만드는 것은 사용자의 책임입니다. 서버 인코딩이 UTF-8인 경우 유니코드 이스케이프 또는 대체 유니코드 이스케이프 구문(4.1.2.3절에서 설명)을 대신 사용해야 합니다. 다른 서버 인코딩의 경우 8진수 이스케이프가 서버 인코딩에서 유효한 바이트 시퀀스를 만들지 않는 한 입력 오류가 발생합니다.

`\x` 16진수 이스케이프 시퀀스는 설정된 숫자 수가 없기 때문에 사용하기 어려울 수 있습니다. 예를 들어, `'\x7'`은 단일 바이트이고 `'\x07'`도 마찬가지이지만 `'\x007'`은 두 바이트입니다. 명시적인 길이 제한을 원하면 8진수 형식이나 후행 문자가 유효한 16진수 숫자가 아닌 짧은 16진수 형식을 사용하세요.

16진수 바이트 값이 서버 인코딩 문자 집합의 유효한 문자를 인코딩하지 않으면 8진수 이스케이프와 마찬가지로 입력 오류가 발생합니다.

유니코드 이스케이프 시퀀스는 UTF-8 인코딩일 때만 작동합니다. 다른 서버 인코딩이 사용되면 4.1.2.3절에서 설명하는 이스케이프 문자열 구문을 대신 사용해야 합니다. 기술적인 이유로 유니코드 이스케이프 형식은 대리 쌍을 지원하지 않습니다.

> 주의
>
> 구성 매개변수 `standard_conforming_strings`가 `off`인 경우, PostgreSQL은 일반 및 이스케이프 문자열 상수 모두에서 백슬래시 이스케이프를 인식합니다. 그러나 PostgreSQL 9.1부터 기본값은 `on`이며, 이는 백슬래시 이스케이프가 이스케이프 문자열 상수에서만 인식됨을 의미합니다. 이 동작은 표준을 더 잘 준수하지만, 역사적 동작에 의존하는 애플리케이션을 깨뜨릴 수 있습니다. 여기서 백슬래시 이스케이프는 항상 인식되었습니다. 해결 방법으로, 이 매개변수를 `off`로 설정할 수 있지만, 이스케이프 문자열을 사용하는 것이 더 좋습니다.
>
> `standard_conforming_strings` 외에도 구성 매개변수 `escape_string_warning` 및 `backslash_quote`가 문자열 상수에서 백슬래시 처리를 제어합니다.

코드 포인트 0의 문자는 문자열 상수에 나타날 수 없습니다.

#### 4.1.2.3. 유니코드 이스케이프가 있는 문자열 상수 (String Constants with Unicode Escapes)

PostgreSQL은 유니코드 코드 포인트로 임의의 유니코드 문자를 지정할 수 있는 다른 유형의 이스케이프 구문도 지원합니다. 유니코드 이스케이프 문자열 상수는 `U&`(대문자 또는 소문자 U 다음에 앰퍼샌드)로 시작하고 바로 뒤에 분리 공백 없이 여는 따옴표가 옵니다. 예: `U&'foo'`. (이것은 `&` 연산자와 모호함을 만들므로, 해당 연산자 주위에 공백을 사용하세요.) 따옴표 안에 유니코드 문자는 백슬래시 다음에 4자리 16진수 코드 포인트 번호 또는 백슬래시와 더하기 기호 다음에 6자리 16진수 코드 포인트 번호를 작성하는 이스케이프 형식으로 지정할 수 있습니다. 예를 들어, 문자열 `'data'`는 다음과 같이 작성할 수 있습니다:

```sql
U&'d\0061t\+000061'
```

다음의 더 흥미로운 예제는 러시아어 단어 "slon"(코끼리)을 키릴 문자로 작성합니다:

```sql
U&'\0441\043B\043E\043D'
```

백슬래시 이외의 다른 이스케이프 문자를 원하면 문자열 뒤에 `UESCAPE` 절을 사용하여 지정할 수 있습니다. 예:

```sql
U&'d!0061t!+000061' UESCAPE '!'
```

이스케이프 문자는 16진수, 더하기 기호, 작은따옴표, 큰따옴표 또는 공백 문자 이외의 단일 문자일 수 있습니다.

유니코드 이스케이프 구문은 서버 인코딩이 UTF-8일 때만 작동합니다. 다른 서버 인코딩이 사용되면 UTF-16 범위(`\0001`–`\007F`) 내의 코드 포인트만 지정할 수 있습니다. 4자리 및 6자리 형식 모두 UTF-16 대리 쌍을 사용하여 코드 포인트가 `U+FFFF`보다 큰 문자를 구성하는 데 사용할 수 있지만, 6자리 형식의 사용 가능성으로 인해 이는 불필요합니다. (대리 쌍은 직접 저장되지 않고 단일 코드 포인트로 결합됩니다.)

또한 유니코드 이스케이프 구문이 문자열 상수에 대해 작동하려면 구성 매개변수 `standard_conforming_strings`가 켜져 있어야 합니다. 그렇지 않으면 백슬래시가 있는 클라이언트가 이를 해석하려고 시도하여 혼란스러운 결과를 초래합니다. 이 매개변수의 기본 설정은 `on`입니다.

결과 문자열에 리터럴 백슬래시를 포함하려면 두 번 작성하세요.

#### 4.1.2.4. 달러 인용 문자열 상수 (Dollar-Quoted String Constants)

표준 구문이 문자열 상수를 지정하는 데 일반적으로 편리하지만, 원하는 문자열에 많은 작은따옴표나 백슬래시가 포함되어 있으면 이해하기 어려울 수 있습니다. 이러한 상황에서 쿼리를 더 읽기 쉽게 만들기 위해 PostgreSQL은 달러 인용(dollar quoting) 이라고 하는 문자열 상수를 작성하는 다른 방법을 제공합니다. 달러 인용 문자열 상수는 달러 기호(`$`), 0개 이상의 문자로 구성된 선택적 "태그", 또 다른 달러 기호, 문자열 내용을 구성하는 임의의 문자 시퀀스, 달러 기호, 이 상수를 시작한 것과 동일한 태그, 그리고 달러 기호로 구성됩니다. 예를 들어, 달러 인용으로 문자열 "Dianne's horse"를 지정하는 두 가지 다른 방법이 있습니다:

```sql
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
```

달러 인용 문자열 내부에서 작은따옴표는 이스케이프할 필요 없이 사용할 수 있습니다. 실제로 달러 인용 문자열 내부에서는 문자가 이스케이프되지 않습니다: 문자열 내용은 항상 문자 그대로 작성됩니다. 백슬래시는 특별하지 않으며 달러 기호도 시작하는 달러 인용의 일부가 아닌 한 마찬가지입니다.

달러 인용 문자열 상수를 중첩할 수 있으며, 각 중첩 수준에서 다른 태그를 선택하면 됩니다. 이것은 프로시저 함수 정의를 작성할 때 가장 일반적으로 사용됩니다. 예:

```sql
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
```

여기서 시퀀스 `$q$[\t\r\n\v\\]$q$`는 함수 본문이 PostgreSQL에 의해 구문 분석될 때 달러 인용 리터럴 문자열 `[\t\r\n\v\\]`를 나타냅니다. 그러나 쿼리 실행 중에 함수가 호출될 때 문자열의 내용이 정규 표현식 함수에 대한 패턴이 되므로 백슬래시는 정규 표현식 연산자로 처리됩니다.

달러 인용 문자열의 태그(있는 경우)는 따옴표 없는 식별자와 동일한 규칙을 따르지만, 달러 기호를 포함할 수 없습니다. 태그는 대소문자를 구분하므로 `$tag$String content$tag$`는 정확하지만 `$TAG$String content$tag$`는 그렇지 않습니다.

키워드나 식별자 바로 뒤에 오는 달러 인용 문자열은 공백으로 구분해야 합니다. 그렇지 않으면 달러 인용 구분자가 앞의 식별자의 일부로 취급됩니다.

달러 인용은 SQL 표준의 일부가 아니지만, 복잡한 문자열 리터럴을 작성하는 데 표준 준수 작은따옴표 구문보다 훨씬 더 편리한 방법인 경우가 많습니다. 문자열 상수가 다른 상수 내에 포함되어야 하는 상황에서 특히 유용합니다. 프로시저 함수 정의에서 자주 필요합니다. 작은따옴표 구문을 사용하면 위 예제에서 각 백슬래시는 4개의 백슬래시로 작성해야 하며, 이는 원래 문자열 상수 구문 분석 시 두 개로 줄어들고 함수 실행 중에 내부 문자열 상수가 다시 구문 분석될 때 다시 하나로 줄어듭니다.

#### 4.1.2.5. 비트 문자열 상수 (Bit-String Constants)

비트 문자열 상수는 일반 문자열 상수처럼 보이지만 여는 따옴표 바로 앞에(사이에 공백 없이) `B`(대문자 또는 소문자)가 붙습니다. 예: `B'1001'`. 비트 문자열 상수에서 허용되는 문자는 `0`과 `1`뿐입니다.

또는 비트 문자열 상수는 선행 `X`(대문자 또는 소문자)를 사용하여 16진수 표기법으로 지정할 수 있습니다. 예: `X'1FF'`. 이 표기법은 각 16진수 숫자를 4개의 이진 숫자로 대체한 비트 문자열과 동일합니다.

두 형식의 비트 문자열 상수는 일반 문자열 상수처럼 여러 줄에 걸쳐 계속될 수 있습니다. 달러 인용은 비트 문자열 상수에 사용할 수 없습니다.

#### 4.1.2.6. 숫자 상수 (Numeric Constants)

숫자 상수는 다음의 일반적인 형식으로 허용됩니다:

```
digits
digits.[digits][e[+-]digits]
[digits].digits[e[+-]digits]
digitse[+-]digits
```

여기서 `digits`는 하나 이상의 10진수(0에서 9까지)입니다. 소수점이 사용되면 소수점 앞이나 뒤에 적어도 하나의 숫자가 있어야 합니다. 지수 표시(e)가 있으면 적어도 하나의 숫자가 뒤따라야 합니다. 상수 내에 공백이나 다른 문자가 포함될 수 없습니다. 선행 더하기 또는 빼기 기호는 실제로 상수의 일부로 간주되지 않습니다. 상수에 적용되는 연산자입니다.

유효한 숫자 상수의 몇 가지 예입니다:

```
42
3.5
4.
.001
5e2
1.925e-3
```

정수가 아닌 숫자 상수는 소수점 또는 지수를 포함하거나 둘 다 포함합니다.

추가로, 비십진수 정수 상수도 다음 형식으로 허용됩니다:

```
0xhexdigits
0ooctdigits
0bbindigits
```

여기서 `hexdigits`는 하나 이상의 16진수(0-9, A-F), `octdigits`는 하나 이상의 8진수(0-7), `bindigits`는 하나 이상의 이진 숫자(0 또는 1)입니다. 16진수와 기수 접두사는 대문자 또는 소문자일 수 있습니다. 비십진수 형식은 정수에만 지원되며 부동 소수점 숫자에는 지원되지 않습니다.

몇 가지 예입니다:

```
0x42f
0XFFFF
0o273
0O755
0b100101
0B10011001
```

가독성을 위해 숫자 상수의 숫자 사이에 밑줄을 삽입할 수 있습니다. 이것은 값에 영향을 미치지 않습니다. 예:

```
1_500_000_000
0b10001000_00000000
0o_1_755
0xFFFF_FFFF
1.618_034
```

밑줄은 상수의 시작이나 끝에 올 수 없으며, 기수 접두사 바로 뒤에 올 수 없고, 소수점이나 지수 표시에 인접하여 올 수 없으며, 연속으로 두 개 이상의 밑줄을 사용할 수 없습니다.

기본적으로 소수점이나 지수가 없는 숫자 상수는 처음에 `integer` 타입(32비트)으로 가정됩니다. 값이 맞지 않으면 `bigint` 타입(64비트)으로 가정됩니다. 그래도 맞지 않으면 `numeric` 타입으로 취급됩니다. 소수점 및/또는 지수를 포함하는 상수도 처음에 `numeric` 타입으로 가정됩니다.

숫자 상수의 처음에 할당된 데이터 타입은 타입 해결 알고리즘의 시작점일 뿐입니다. 대부분의 경우 상수는 컨텍스트에 따라 가장 적절한 타입으로 자동 강제 변환됩니다. 필요한 경우 숫자 값을 캐스팅하여 특정 데이터 타입으로 해석하도록 강제할 수 있습니다. 예를 들어, 숫자 값을 `real`(`float4`) 타입으로 처리하도록 강제할 수 있습니다:

```sql
REAL '1.23'  -- 문자열 스타일
1.23::REAL   -- PostgreSQL (역사적) 스타일
```

실제로 이것들은 다음 섹션에서 설명하는 일반 캐스팅 표기법의 특수한 경우입니다.

#### 4.1.2.7. 다른 타입의 상수 (Constants of Other Types)

임의의 타입의 상수는 다음 표기법 중 하나를 사용하여 입력할 수 있습니다:

```sql
type 'string'
'string'::type
CAST ( 'string' AS type )
```

문자열 상수의 텍스트는 `type`이라는 타입에 대한 입력 변환 루틴으로 전달됩니다. 결과는 표시된 타입의 상수입니다. 상수의 타입에 대한 모호함이 없으면(예: 테이블 열에 직접 할당될 때) 명시적 타입 캐스트를 생략할 수 있으며, 이 경우 자동으로 강제 변환됩니다.

문자열 상수는 일반 SQL 표기법 또는 달러 인용을 사용하여 작성할 수 있습니다.

함수와 유사한 구문을 사용하여 타입 강제 변환을 작성할 수도 있습니다:

```sql
typename ( 'string' )
```

그러나 모든 타입 이름이 이 방식으로 사용될 수 있는 것은 아닙니다. 자세한 내용은 4.2.9절을 참조하세요.

`::`, `CAST()`, 함수 호출 구문은 4.2.9절에서 설명하는 것처럼 임의의 표현식의 런타임 타입 변환을 지정하는 데에도 사용할 수 있습니다. 구문적 모호함을 피하기 위해 `type 'string'` 구문은 단순 리터럴 상수를 지정하는 데에만 사용할 수 있습니다. `type 'string'` 구문의 또 다른 제한은 배열 타입에 대해 작동하지 않는다는 것입니다. 배열 상수의 타입을 지정하려면 `::` 또는 `CAST()`를 사용하세요.

`CAST()` 구문은 SQL을 준수합니다. `type 'string'` 구문은 표준의 일반화입니다: SQL은 이 구문을 몇 가지 데이터 타입에만 지정하지만 PostgreSQL은 모든 타입에 허용합니다. `::` 구문은 역사적인 PostgreSQL 사용법이며, 함수 호출 구문도 마찬가지입니다.

### 4.1.3. 연산자 (Operators)

연산자 이름은 다음 목록의 최대 `NAMEDATALEN-1` (기본적으로 63) 문자 시퀀스입니다:

```
+ - * / < > = ~ ! @ # % ^ & | ` ?
```

그러나 연산자 이름에 몇 가지 제한이 있습니다:

- `--`와 `/*`는 주석의 시작으로 인식되므로 연산자 이름의 어디에도 나타날 수 없습니다.

- 여러 문자 연산자 이름은 SQL 주석의 시작으로 해석될 수 있으므로 `+` 또는 `-`로 끝날 수 없습니다. 단, 이름에 다음 문자 중 하나 이상이 포함된 경우는 예외입니다:
  ```
  ~ ! @ # % ^ & | ` ?
  ```
  예를 들어, `@-`는 허용되는 연산자 이름이지만 `*-`는 아닙니다. 이 제한으로 인해 PostgreSQL은 토큰 사이에 공백 없이 SQL 호환 쿼리를 구문 분석할 수 있습니다.

SQL에서 표준 연산자가 아닌 연산자를 사용할 때는 일반적으로 인접한 연산자를 공백으로 구분하여 모호함을 피해야 합니다. 예를 들어, `@`라는 접두사 연산자를 정의한 경우 `X*@Y`를 작성할 수 없습니다. 이것이 `X* @Y`인지 `X *@ Y`인지 명확하게 해야 합니다.

### 4.1.4. 특수 문자 (Special Characters)

일부 비알파뉴메릭 문자는 연산자로 사용되지 않고 특별한 구문적 의미를 가집니다. 사용법에 대한 자세한 내용은 해당 구문 요소가 설명되는 곳에서 찾을 수 있습니다. 이 섹션은 단순히 존재와 목적을 요약하기 위해 존재합니다.

- 숫자가 뒤따르는 달러 기호(`$`)는 함수 정의 본문 또는 준비된 문의 위치 매개변수를 나타내는 데 사용됩니다. 다른 컨텍스트에서 달러 기호는 식별자의 일부이거나 달러 인용 문자열 상수일 수 있습니다.

- 괄호(`()`)는 표현식을 그룹화하고 우선순위를 강제하는 일반적인 의미를 가집니다. 어떤 경우에는 괄호가 특정 SQL 명령의 고정 구문의 일부로 필요합니다.

- 대괄호(`[]`)는 배열의 요소를 선택하는 데 사용됩니다. 배열에 대한 자세한 내용은 8.15절을 참조하세요.

- 쉼표(`,`)는 일부 구문 구성에서 목록의 요소를 구분하는 데 사용됩니다.

- 세미콜론(`;`)은 SQL 명령을 종료합니다. 문자열 상수나 따옴표로 묶인 식별자 내부를 제외하고는 명령 내의 어디에도 나타날 수 없습니다.

- 콜론(`:`)은 배열에서 "슬라이스"를 선택하는 데 사용됩니다. (8.15절 참조.) 특정 SQL 방언(예: Embedded SQL)에서는 콜론이 변수 이름 앞에 붙는 데 사용됩니다.

- 별표(`*`)는 일부 컨텍스트에서 테이블 행 또는 복합 값의 모든 필드를 나타내는 데 사용됩니다. 또한 명시적 매개변수 없이 호출되는 집계 함수의 인수로 사용될 때 특별한 의미를 가집니다.

- 마침표(`.`)는 숫자 상수에서 사용되며, 스키마, 테이블, 열 이름을 구분하는 데 사용됩니다.

### 4.1.5. 주석 (Comments)

주석은 두 개의 대시로 시작하여 줄 끝까지 확장되는 문자 시퀀스입니다. 예:

```sql
-- This is a standard SQL comment
```

또는 C 스타일 블록 주석을 사용할 수 있습니다:

```sql
/* multiline comment
 * with nesting: /* nested block comment */
 */
```

여기서 주석은 `/*`로 시작하여 일치하는 `*/`까지 확장됩니다. 이러한 블록 주석은 SQL 표준에서 지정한 대로 중첩됩니다. 이는 전체 코드 블록을 주석 처리할 수 있게 하며, 해당 블록에 기존 블록 주석이 포함되어 있어도 가능합니다.

주석은 추가 구문 분석 전에 입력 스트림에서 제거되고 공백으로 효과적으로 대체됩니다.

### 4.1.6. 연산자 우선순위 (Operator Precedence)

표 4.2는 PostgreSQL에서 연산자의 우선순위와 결합성을 보여줍니다. 대부분의 연산자는 동일한 우선순위를 가지며 왼쪽에서 오른쪽으로 결합합니다. 연산자의 우선순위와 결합성은 파서에 하드 코딩되어 있습니다. 이로 인해 위의 표가 제안하는 것과 다른 구문 분석 동작을 원하면 `BETWEEN`과 그 변형, `NOT`(비교를 제외한), `AND`, `OR` 구문에서 괄호를 추가해야 할 수 있습니다.

표 4.2. 연산자 우선순위 (높은 것부터 낮은 것 순)

| 연산자/요소 | 결합성 | 설명 |
|------------|--------|------|
| `.` | 왼쪽 | 테이블/열 이름 구분자 |
| `::` | 왼쪽 | PostgreSQL 스타일 타입캐스트 |
| `[ ]` | 왼쪽 | 배열 요소 선택 |
| `+` `-` | 오른쪽 | 단항 더하기, 단항 빼기 |
| `COLLATE` | 왼쪽 | 콜레이션 선택 |
| `AT` | 왼쪽 | `AT TIME ZONE`, `AT LOCAL` |
| `^` | 왼쪽 | 거듭제곱 |
| `*` `/` `%` | 왼쪽 | 곱셈, 나눗셈, 나머지 |
| `+` `-` | 왼쪽 | 덧셈, 뺄셈 |
| (기타 모든 연산자) | 왼쪽 | 다른 모든 네이티브 및 사용자 정의 연산자 |
| `BETWEEN` `IN` `LIKE` `ILIKE` `SIMILAR` | | 범위 포함, 집합 멤버십, 문자열 매칭 |
| `<` `>` `=` `<=` `>=` `<>` | | 비교 연산자 |
| `IS` `ISNULL` `NOTNULL` | | IS TRUE, IS FALSE, IS NULL, IS DISTINCT FROM 등 |
| `NOT` | 오른쪽 | 논리 부정 |
| `AND` | 왼쪽 | 논리 곱 |
| `OR` | 왼쪽 | 논리 합 |

위의 우선순위 규칙은 다음 확장을 사용하여 스키마 한정 연산자 이름이 있는 사용자 정의 연산자에도 적용됩니다:

```sql
OPERATOR(schema.operatorname)
```

`OPERATOR()` 구문이 사용될 때, 위의 표에서 명시적으로 언급되지 않은 내장 연산자(예: 사용자 정의 연산자와 동일한 이름을 가진)도 기본 "기타 모든 연산자" 우선순위를 갖습니다. 예를 들어, 이름 `+`와 `-`를 가진 사용자 정의 접두사 연산자를 정의하면 해당 내장 연산자와 동일한 우선순위를 갖지만, `OPERATOR()` 구문으로 스키마 한정하면 "기타 모든 연산자" 우선순위를 얻습니다.

> 주의
>
> PostgreSQL 버전 9.5 이전에는 일부 다른 연산자 우선순위 규칙을 사용했습니다. 특히 `<=`, `>=`, `<>`가 일반 연산자로 취급되었고, `IS` 테스트는 더 높은 우선순위를 가졌으며, `NOT BETWEEN`과 관련 구문이 일관되지 않게 작동하여 일부 경우 `NOT`이 `BETWEEN`보다 먼저 바인딩되었습니다. 이러한 규칙은 SQL 표준에 더 잘 부합하고 `NOT`과 동일한 구문 우선순위를 가진 연산자의 논리적으로 일관되지 않은 처리를 줄이기 위해 변경되었습니다. 대부분의 경우 이러한 변경은 동작에 변화를 초래하지 않거나 "연산자가 고유하지 않습니다"라는 실패를 생성할 수 있으며, 이는 괄호를 추가하여 해결할 수 있습니다. 그러나 경고나 오류 없이 동작이 변경될 수 있는 코너 케이스가 있습니다.

---

## 4.2. 값 표현식 (Value Expressions)

값 표현식은 다양한 컨텍스트에서 사용됩니다. 예를 들어 `SELECT` 명령의 대상 목록, `INSERT` 또는 `UPDATE`의 새 열 값, 또는 많은 명령의 검색 조건에서 사용됩니다. 값 표현식의 결과는 때때로 스칼라(scalar) 라고 불리며, 테이블 표현식(테이블)의 결과와 구별됩니다. 따라서 값 표현식은 스칼라 표현식(scalar expressions) (또는 더 간단히 표현식(expressions) )이라고도 합니다. 표현식 구문은 산술, 논리, 집합 및 기타 연산을 사용하여 기본 부분에서 값을 계산할 수 있게 합니다.

값 표현식은 다음 중 하나입니다:

- 상수 또는 리터럴 값
- 열 참조
- 함수 정의 본문 또는 준비된 문의 위치 매개변수 참조
- 첨자 표현식
- 필드 선택 표현식
- 연산자 호출
- 함수 호출
- 집계 표현식
- 윈도우 함수 호출
- 타입 캐스트
- 콜레이션 표현식
- 스칼라 서브쿼리
- 배열 생성자
- 행 생성자
- 괄호로 묶인 또 다른 값 표현식(하위 표현식을 그룹화하고 우선순위를 재정의하는 데 사용)

이 목록 외에도 표현식으로 분류되지만 이 섹션에서 논의하는 일반 구문 규칙을 따르지 않는 여러 구문이 있습니다. 이것들은 일반적으로 함수 또는 연산자의 의미를 가지며 9장의 적절한 위치에서 설명됩니다. 예로는 `IS NULL` 절이 있습니다.

4.1.2절에서 이미 상수에 대해 논의했습니다. 다음 섹션에서는 나머지 옵션을 설명합니다.

### 4.2.1. 열 참조 (Column References)

열은 다음 형식으로 참조할 수 있습니다:

```
correlation.columnname
```

`correlation`은 테이블 이름(스키마 이름으로 한정될 수 있음) 또는 `FROM` 절에서 정의된 테이블의 별칭입니다. 열 이름이 현재 쿼리에서 사용되는 모든 테이블에서 고유한 경우 상관 이름과 구분 점은 생략할 수 있습니다. (또한 7장 참조.)

### 4.2.2. 위치 매개변수 (Positional Parameters)

위치 매개변수 참조는 SQL 문에 외부에서 제공된 값을 나타내는 데 사용됩니다. 매개변수는 SQL 함수 정의 및 준비된 쿼리에서 사용됩니다. 일부 클라이언트 라이브러리는 SQL 명령 문자열과 별도로 데이터 값을 지정하는 것도 지원하며, 이 경우 매개변수는 대역 외 데이터 값을 참조하는 데 사용됩니다. 매개변수 참조의 형식은 다음과 같습니다:

```
$number
```

예를 들어, `dept` 함수의 정의를 고려하세요:

```sql
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
```

여기서 `$1`은 함수가 호출될 때 첫 번째 함수 인수의 값을 참조합니다.

### 4.2.3. 첨자 (Subscripts)

표현식이 배열 타입의 값을 생성하면 배열 값의 특정 요소는 다음과 같이 추출할 수 있습니다:

```
expression[subscript]
```

또는 연속된 여러 요소("배열 슬라이스")는 다음과 같이 추출할 수 있습니다:

```
expression[lower_subscript:upper_subscript]
```

(여기서 대괄호 `[ ]`는 문자 그대로 나타나도록 의도됩니다.) 각 `subscript`는 그 자체로 표현식이며 정수 값으로 반올림됩니다.

일반적으로 배열 `expression`은 괄호로 묶어야 하지만, 첨자할 표현식이 열 참조 또는 위치 매개변수만 있는 경우에는 괄호를 생략할 수 있습니다. 또한 원래 배열이 다차원인 경우 여러 첨자를 연결할 수 있습니다. 예:

```sql
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
```

마지막 예에서 괄호가 필요합니다. 배열에 대한 자세한 내용은 8.15절을 참조하세요.

### 4.2.4. 필드 선택 (Field Selection)

표현식이 복합 타입(행 타입)의 값을 생성하면 행의 특정 필드는 다음과 같이 추출할 수 있습니다:

```
expression.fieldname
```

일반적으로 행 `expression`은 괄호로 묶어야 하지만, 선택할 표현식이 테이블 참조 또는 위치 매개변수만 있는 경우에는 괄호를 생략할 수 있습니다. 예:

```sql
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
```

(따라서 한정된 열 참조는 실제로 필드 선택 구문의 특수한 경우입니다.) 중요한 특수 케이스는 복합 타입인 테이블 열에서 필드를 추출하는 것입니다:

```sql
(compositecol).somefield
(mytable.compositecol).somefield
```

여기서 괄호가 필요합니다. 괄호가 없으면 `compositecol`이 테이블 이름으로 취급되거나, 두 번째 경우에는 `mytable.compositecol`이 테이블 이름으로 취급됩니다.

복합 값의 모든 필드를 요청하려면 `.*`를 작성할 수 있습니다:

```sql
(compositecol).*
```

이 표기법은 컨텍스트에 따라 다르게 동작합니다. 자세한 내용은 8.16.5절을 참조하세요.

### 4.2.5. 연산자 호출 (Operator Invocations)

연산자 호출에는 다음 표에서 보여주는 구문이 있습니다.

| 구문 | 설명 |
|------|------|
| `expression operator expression` | 이항 중위 연산자 |
| `operator expression` | 단항 접두사 연산자 |

여기서 `operator` 토큰은 4.1.3절의 구문 규칙을 따르거나 키워드 `AND`, `OR`, `NOT`이거나 다음 형식의 한정된 연산자 이름입니다:

```sql
OPERATOR(schema.operatorname)
```

어떤 특정 연산자가 존재하고 이항인지 단항인지는 시스템 또는 사용자가 정의한 연산자에 따라 다릅니다. 9장에서 내장 연산자를 설명합니다.

### 4.2.6. 함수 호출 (Function Calls)

함수 호출의 구문은 함수 이름(스키마 이름으로 한정될 수 있음) 다음에 괄호로 묶인 인수 목록이 옵니다:

```sql
function_name ([expression [, expression ... ]] )
```

예를 들어, 다음은 2의 제곱근을 계산합니다:

```sql
sqrt(2)
```

내장 함수 목록은 9장에 있습니다. 다른 함수는 사용자가 추가할 수 있습니다.

인수에는 선택적으로 이름을 붙일 수 있습니다. 자세한 내용은 4.3절을 참조하세요.

> 참고
>
> 단일 복합 타입 인수를 취하는 함수는 선택적으로 필드 선택 구문을 사용하여 호출할 수 있으며, 반대로 필드 선택은 함수 형식으로 작성될 수 있습니다. 즉, `col(table)`과 `table.col`은 서로 바꿔서 사용할 수 있습니다. 이것은 표준 SQL 구문이 아니지만 PostgreSQL에서 제공됩니다. 이것은 "계산된 필드"를 에뮬레이트하는 함수 사용을 허용하기 때문입니다. 자세한 내용은 8.16.5절을 참조하세요.

### 4.2.7. 집계 표현식 (Aggregate Expressions)

집계 표현식은 쿼리에서 선택한 행에 걸쳐 집계 함수의 적용을 나타냅니다. 집계 함수는 여러 입력을 단일 출력 값(예: 입력의 합계 또는 평균)으로 줄입니다. 집계 표현식의 구문은 다음 중 하나입니다:

```sql
aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]
aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]
```

여기서 `aggregate_name`은 이전에 정의된 집계(`AGGREGATE`)이며, `expression`은 집계 표현식이나 윈도우 함수 호출을 포함하지 않는 값 표현식입니다. 선택적 `order_by_clause`와 `filter_clause`는 아래에서 설명합니다.

첫 번째 형식의 집계 표현식은 각 입력 행에 대해 집계를 한 번 호출합니다. 두 번째 형식은 `ALL`이 기본값이므로 첫 번째와 동일합니다. 세 번째 형식은 입력 행에서 찾은 각 고유 값(또는 여러 표현식의 경우 고유 값 집합)에 대해 집계를 호출합니다. 네 번째 형식은 특정 입력 값 없이 각 입력 행에 대해 집계를 한 번 호출합니다. 일반적으로 `count(*)` 집계 함수에 유용합니다. 마지막 형식은 순서 집합(ordered-set) 집계 함수와 함께 사용되며, 아래에서 설명합니다.

대부분의 집계 함수는 `NULL` 입력을 무시하므로 하나 이상의 표현식이 `NULL`을 생성하는 행은 버려집니다. 다르게 지정하지 않는 한 모든 내장 집계에 대해 이것이 사실이라고 가정할 수 있습니다.

예를 들어, `count(*)`는 입력 행의 총 개수를 생성합니다. `count(f1)`은 `f1`이 널이 아닌 입력 행의 개수를 생성합니다(`count`는 `NULL` 입력을 무시하기 때문입니다). `count(distinct f1)`은 `f1`의 고유한 널이 아닌 값의 개수를 생성합니다.

일반적으로 입력 행은 지정되지 않은 순서로 집계 함수에 전달됩니다. 많은 경우 이것은 중요하지 않습니다. 예를 들어, `min`은 어떤 순서로 입력을 받든 동일한 결과를 생성합니다. 그러나 일부 집계 함수(`array_agg`, `string_agg` 등)는 입력 행의 순서에 따라 다른 결과를 생성합니다. 이러한 집계를 사용할 때 선택적 `order_by_clause`를 사용하여 원하는 순서를 지정할 수 있습니다. `order_by_clause`는 7.5절에서 설명하는 쿼리 수준 `ORDER BY` 절과 동일한 구문을 가지지만, 해당 표현식은 항상 단순 표현식이며 출력 열 이름이나 번호가 될 수 없습니다. 예:

```sql
SELECT array_agg(a ORDER BY b DESC) FROM table;
```

다중 인수 집계 함수를 다룰 때, `ORDER BY` 절이 모든 집계 인수 뒤에 온다는 점에 유의하세요. 예:

```sql
SELECT string_agg(a, ',' ORDER BY a) FROM table;
```

위는 맞지만 다음은 틀립니다:

```sql
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- 잘못됨
```

후자는 구문적으로 유효하지만 두 개의 `ORDER BY` 키로 단일 인수 집계 함수 호출을 나타내며(두 번째는 상수이므로 다소 쓸모없지만) 두 인수의 집계 호출을 나타내지 않습니다.

`order_by_clause` 앞에 `DISTINCT`를 추가로 지정하면 모든 `ORDER BY` 표현식이 집계의 일반 인수 목록과 일치해야 합니다. 즉, `DISTINCT` 목록에 포함되지 않은 표현식으로 정렬할 수 없습니다.

> 참고
>
> 집계 함수에서 `DISTINCT`와 `ORDER BY`를 모두 지정하는 기능은 PostgreSQL 확장입니다.

`FILTER` 절을 추가하면 필터 표현식이 `true`로 평가되는 입력 행만 집계 함수에 전달됩니다. 다른 행은 버려집니다. 예:

```sql
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i < 5) AS filtered
FROM generate_series(1,10) AS s(i);

 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
```

사전 정의된 집계 함수는 9.21절에서 설명합니다. 다른 집계 함수는 사용자가 추가할 수 있습니다.

집계 표현식은 `SELECT` 명령의 결과 목록 또는 `HAVING` 절에만 나타날 수 있습니다. `WHERE`와 같은 다른 절에서는 허용되지 않습니다. 이러한 절은 집계 결과가 형성되기 전에 논리적으로 평가되기 때문입니다.

집계 표현식이 서브쿼리에 나타나는 경우(4.2.11절 및 9.23절 참조), 집계는 일반적으로 서브쿼리의 행에 대해 평가됩니다. 그러나 집계의 인수(및 `filter_clause`가 있는 경우)가 외부 쿼리의 변수만 포함하면 예외가 발생합니다: 집계는 그 가장 가까운 외부 쿼리에 속하며 해당 쿼리의 행에 대해 평가됩니다. 그러면 집계 표현식 전체가 포함된 서브쿼리에 대한 외부 참조이며, 해당 서브쿼리의 모든 평가에서 상수로 작동합니다. 결과 목록 또는 `HAVING` 절에만 나타나야 한다는 제한은 집계가 속하는 쿼리 수준에 대한 것입니다.

### 4.2.8. 윈도우 함수 호출 (Window Function Calls)

윈도우 함수 호출은 쿼리에서 선택한 행의 일부 부분에 걸쳐 집계와 유사한 함수의 적용을 나타냅니다. 일반적인(비윈도우) 집계 호출과 달리 이것은 선택한 행을 단일 출력 행으로 묶는 것과 관련이 없습니다. 대신 행은 별도의 ID를 유지합니다. 배후에서 윈도우 함수는 쿼리 결과의 현재 행뿐만 아니라 그 이상에 접근할 수 있습니다. 윈도우 함수 호출의 구문은 다음 중 하나입니다:

```sql
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
```

여기서 `window_definition`의 구문은 다음과 같습니다:

```sql
[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ frame_clause ]
```

선택적 `frame_clause`는 다음 중 하나일 수 있습니다:

```sql
{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]
```

여기서 `frame_start`와 `frame_end`는 다음 중 하나일 수 있습니다:

```sql
UNBOUNDED PRECEDING
offset PRECEDING
CURRENT ROW
offset FOLLOWING
UNBOUNDED FOLLOWING
```

그리고 `frame_exclusion`은 다음 중 하나일 수 있습니다:

```sql
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
```

여기서 `expression`은 윈도우 함수 호출을 포함하지 않는 값 표현식을 나타냅니다.

`window_name`은 쿼리의 `WINDOW` 절에서 정의된 명명된 윈도우 사양에 대한 참조입니다. 또는 전체 `window_definition`이 괄호 안에 주어질 수 있으며, 명명된 윈도우와 동일한 구문을 사용합니다. 자세한 내용은 `SELECT` 참조 페이지를 참조하세요. `OVER wname`이 `OVER (wname ...)`과 정확히 동일하지 않다는 점에 주목할 가치가 있습니다. 후자는 윈도우 정의 복사 및 수정을 의미하며, 윈도우 사양에 프레임 절이 포함된 경우 거부됩니다.

`PARTITION BY` 절은 `PARTITION BY` 표현식의 값이 같은 행들끼리 쿼리 행을 파티션(partition) 으로 그룹화합니다. 윈도우 함수의 경우 계산은 현재 행과 동일한 파티션에 있는 행에 대해 수행됩니다.

`ORDER BY` 절은 윈도우 함수에 의해 처리되는 각 파티션 내 행의 순서를 결정합니다. 이것은 쿼리의 출력 순서와 별개입니다. `ORDER BY` 절이 없으면 행은 지정되지 않은 순서로 처리됩니다.

`frame_clause`는 프레임을 구성하는 행 집합을 지정합니다. 프레임은 현재 파티션의 부분 집합이며, 프레임 관련 윈도우 함수는 전체 파티션이 아닌 해당 프레임의 행에 대해 작동합니다. 프레임의 행 집합은 현재 행에 따라 달라질 수 있습니다. 프레임은 `RANGE`, `ROWS`, `GROUPS` 모드로 지정할 수 있습니다. 이 모드들은 `frame_start`와 `frame_end` 오프셋이 측정되는 방식에 영향을 줍니다.

`ROWS` 모드에서 `offset`은 현재 행 앞이나 뒤의 행 수를 나타내는 정수여야 합니다.

`GROUPS` 모드에서 `offset`은 현재 행의 피어 그룹 앞이나 뒤의 피어 그룹 수를 나타내는 정수여야 합니다. 여기서 피어 그룹은 윈도우의 `ORDER BY` 절에서 동등한 값을 가진 행 집합입니다. `GROUPS` 모드를 사용하려면 `ORDER BY` 절이 있어야 합니다.

`RANGE` 모드에서는 이러한 옵션을 사용하려면 `ORDER BY` 절이 정확히 하나의 열을 지정해야 합니다. `offset`은 그 열 값과 현재 행의 열 값의 최대 차이를 지정합니다. `offset` 표현식의 데이터 타입은 정렬 열의 데이터 타입에 따라 다릅니다. 숫자 정렬 열의 경우 일반적으로 동일한 타입이지만, datetime 정렬 열의 경우 `interval`입니다. 예를 들어, 정렬 열이 `date` 또는 `timestamp` 타입인 경우, `RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING`을 작성할 수 있습니다. `offset`은 널이 아닌 음수가 아니어야 합니다. "음수"의 의미는 정렬 열의 데이터 타입에 따라 다릅니다.

어떤 경우든 프레임의 끝까지의 거리는 파티션의 끝까지의 거리로 제한됩니다. `frame_start`에 `UNBOUNDED PRECEDING`을 사용하면 프레임이 파티션의 첫 번째 행에서 시작하고, 마찬가지로 `frame_end`에 `UNBOUNDED FOLLOWING`을 사용하면 프레임이 파티션의 마지막 행에서 끝납니다.

모든 경우에서 `CURRENT ROW`는 프레임이 현재 행 또는 현재 피어 그룹에서 시작하거나 끝남을 의미합니다.

`frame_exclusion` 옵션은 프레임에서 시작과 끝 위치 사이에 있는 행도 프레임에서 제외할 수 있게 합니다. `EXCLUDE CURRENT ROW`는 현재 행을 프레임에서 제외합니다. `EXCLUDE GROUP`은 현재 행과 정렬 피어를 프레임에서 제외합니다. `EXCLUDE TIES`는 현재 행의 정렬 피어를 프레임에서 제외하지만 현재 행 자체는 제외하지 않습니다. `EXCLUDE NO OTHERS`는 현재 행이나 그 피어를 제외하지 않음을 명시적으로 지정합니다.

기본 프레이밍 옵션은 `RANGE UNBOUNDED PRECEDING`이며, 이는 `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`와 같습니다. `ORDER BY`가 있으면 파티션 시작부터 현재 행의 마지막 `ORDER BY` 피어까지 모든 행을 포함하도록 프레임이 설정됩니다. `ORDER BY`가 없으면 파티션의 모든 행이 윈도우 프레임에 포함됩니다. 왜냐하면 모든 행이 현재 행의 피어가 되기 때문입니다.

`frame_start`에 적용되는 제한은 `frame_end`보다 앞에 있을 수 없으며, 예를 들어 `frame_start`에는 `UNBOUNDED FOLLOWING`을 사용할 수 없고 `frame_end`에는 `UNBOUNDED PRECEDING`을 사용할 수 없습니다.

`FILTER` 절을 추가하면 필터 표현식이 `true`로 평가되는 입력 행만 윈도우 함수에 의해 처리됩니다. 다른 행은 버려집니다. 집계에서 파생된 윈도우 함수만 `FILTER` 절을 허용합니다.

내장 윈도우 함수는 표 9.67에서 설명합니다. 다른 윈도우 함수는 사용자가 추가할 수 있습니다. 또한 모든 내장 또는 사용자 정의 범용 또는 통계 집계를 윈도우 함수로 사용할 수 있습니다. (순서 집합 및 가설 집합 집계는 현재 윈도우 함수로 사용할 수 없습니다.)

`*`를 사용하는 구문은 매개변수 없는 집계 함수를 윈도우 함수로 호출하는 데 사용됩니다. 예: `count(*) OVER (PARTITION BY x ORDER BY y)`. 별표(`*`)는 일반적으로 윈도우 전용 함수에는 사용되지 않습니다. 윈도우 전용 함수는 빈 인수 목록을 작성하면 되기 때문입니다. 예: `row_number() OVER (PARTITION BY x ORDER BY y)`.

윈도우 함수 호출은 `SELECT` 목록과 쿼리의 `ORDER BY` 절에서만 허용됩니다.

윈도우 함수에 대한 자세한 내용은 3.5절, 9.22절 및 7.2.5절에서 찾을 수 있습니다.

### 4.2.9. 타입 캐스트 (Type Casts)

타입 캐스트는 한 데이터 타입에서 다른 데이터 타입으로의 변환을 지정합니다. PostgreSQL은 타입 캐스트를 위한 두 가지 동등한 구문을 허용합니다:

```sql
CAST ( expression AS type )
expression::type
```

`CAST` 구문은 SQL을 준수합니다. `::` 구문은 역사적인 PostgreSQL 사용법입니다.

캐스트가 알려진 타입의 값 표현식에 적용될 때, 이것은 런타임 타입 변환을 나타냅니다. 변환은 적절한 타입 변환 함수가 정의되어 있는 경우에만 성공합니다. 이것은 4.1.2.7절에서 설명한 상수에 대한 캐스트 사용과 미묘하게 다릅니다. "데코레이트되지 않은" 문자열 리터럴에 적용된 캐스트는 리터럴 상수 값에 타입의 초기 할당을 나타내므로 모든 타입에 대해 성공합니다(문자열 리터럴의 내용이 해당 데이터 타입의 유효한 입력 구문인 경우).

값 표현식이 생성해야 하는 타입에 대한 모호함이 없는 경우(예: 테이블 열에 할당될 때) 명시적 타입 캐스트를 일반적으로 생략할 수 있습니다. 시스템은 그러한 경우에 자동으로 타입 캐스트를 적용합니다. 그러나 자동 캐스팅은 시스템 카탈로그에서 "암묵적으로 적용해도 됨"으로 표시된 캐스트에 대해서만 수행됩니다. 다른 캐스트는 명시적 캐스팅 구문으로 호출해야 합니다. 이 제한은 자동 캐스팅의 놀라운 적용을 방지하기 위한 것입니다.

함수와 같은 구문을 사용하여 타입 캐스트를 지정할 수도 있습니다:

```sql
typename ( expression )
```

그러나 이것은 `typename`이 함수 이름으로도 유효한 타입 이름에 대해서만 작동합니다. 예를 들어, `double precision`은 이 방식으로 사용할 수 없지만, 동등한 `float8`은 사용할 수 있습니다. 또한 표준 SQL에서 구문이 유사하지만 의미가 다른 이름 `interval`, `time`, `timestamp`는 함수 구문 캐스트에서 큰따옴표로 묶여야만 사용할 수 있습니다. 따라서 함수와 같은 캐스트 구문은 일관성이 없어서 새 애플리케이션에서는 사용을 권장하지 않습니다.

> 참고
>
> 함수와 같은 구문은 사실 그냥 함수 호출입니다. 런타임 변환을 수행하기 위해 두 가지 표준 SQL 캐스트 구문 중 하나가 사용될 때, 이것은 내부적으로 등록된 함수를 호출하여 변환을 수행합니다. 관례적으로 이러한 변환 함수는 출력 타입과 동일한 이름을 가지므로 "함수와 같은 구문"은 단지 기본 변환 함수의 직접 호출입니다. 분명히 이식 가능한 애플리케이션이 의존해서는 안 됩니다. 자세한 내용은 `CREATE CAST`를 참조하세요.

### 4.2.10. 콜레이션 표현식 (Collation Expressions)

`COLLATE` 절은 표현식의 콜레이션을 재정의합니다. 이것은 적용되는 표현식에 추가됩니다:

```sql
expr COLLATE collation
```

여기서 `collation`은 스키마 한정 가능한 식별자입니다. `COLLATE` 절은 연산자보다 더 강하게 바인딩됩니다. 필요한 경우 괄호를 사용할 수 있습니다.

콜레이션이 명시적으로 지정되지 않으면 데이터베이스 시스템은 열에서 표현식에 관련된 콜레이션을 파생하거나 열이 표현식에 관련되지 않은 경우 기본 콜레이션을 사용합니다.

`COLLATE` 절의 두 가지 일반적인 용도는 `ORDER BY` 절에서 정렬 순서를 재정의하는 것입니다. 예:

```sql
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
```

그리고 콜레이션에 민감한 결과를 가진 함수 또는 연산자 호출의 콜레이션을 재정의하는 것입니다. 예:

```sql
SELECT * FROM tbl WHERE a > 'foo' COLLATE "C";
```

후자의 경우 `COLLATE` 절은 영향을 미치고자 하는 연산자에 입력되는 인수에 붙습니다. `COLLATE` 절이 연산자나 함수 호출의 어느 인수에 붙는지는 중요하지 않습니다. 연산자나 함수에 의해 적용되는 콜레이션은 명시적인 `COLLATE` 절이 있는지 여부와 관계없이 모든 인수를 고려하여 파생되기 때문입니다. 따라서 이것은 위의 예와 동일한 결과를 제공합니다:

```sql
SELECT * FROM tbl WHERE a COLLATE "C" > 'foo';
```

그러나 이것은 오류입니다:

```sql
SELECT * FROM tbl WHERE (a > 'foo') COLLATE "C";
```

부울 데이터 타입의 `>` 연산자 결과에 콜레이션을 적용하려고 시도하기 때문입니다. 이는 의미가 없습니다.

### 4.2.11. 스칼라 서브쿼리 (Scalar Subqueries)

스칼라 서브쿼리는 정확히 한 행과 한 열을 반환하는 괄호로 묶인 일반 `SELECT` 쿼리입니다. (서브쿼리 작성에 대한 정보는 7장을 참조하세요.) `SELECT` 쿼리가 실행되고 단일 반환 값이 주변 값 표현식에서 사용됩니다. 한 행 이상 또는 한 열 이상을 반환하는 쿼리를 스칼라 서브쿼리로 사용하는 것은 오류입니다. (그러나 특정 실행 중에 서브쿼리가 행을 반환하지 않으면 오류가 없습니다. 스칼라 결과는 널로 취급됩니다.) 서브쿼리는 주변 쿼리의 변수를 참조할 수 있으며, 이것은 서브쿼리의 각 평가 중에 상수로 작동합니다. 서브쿼리와 관련된 다른 표현식에 대해서는 9.23절도 참조하세요.

예를 들어, 다음은 각 주에서 가장 큰 도시 인구를 찾습니다:

```sql
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
```

### 4.2.12. 배열 생성자 (Array Constructors)

배열 생성자는 멤버 요소의 값을 사용하여 배열 값을 구축하는 표현식입니다. 간단한 배열 생성자는 키워드 `ARRAY`, 왼쪽 대괄호 `[`, 배열 요소 값에 대한 표현식 목록(쉼표로 구분), 오른쪽 대괄호 `]`로 구성됩니다. 예:

```sql
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
```

기본적으로 배열 요소 타입은 멤버 표현식의 공통 타입이며, `UNION` 또는 `CASE` 구문에서 사용되는 것과 동일한 규칙을 사용하여 결정됩니다(10.5절 참조). 배열 생성자를 원하는 타입으로 명시적 캐스트하여 이를 재정의할 수 있습니다. 예:

```sql
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
```

이것은 개별 요소를 정수 타입으로 캐스트하는 것과 동일한 효과가 있습니다.

다차원 배열 값은 배열 생성자를 중첩하여 구축할 수 있습니다. 내부 생성자에서 키워드 `ARRAY`는 생략할 수 있습니다. 예를 들어, 다음은 동일한 결과를 생성합니다:

```sql
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
```

다차원 배열은 직사각형이어야 하므로 동일한 수준의 내부 생성자는 동일한 차원의 하위 배열을 생성해야 합니다. 외부 `ARRAY` 생성자에 적용된 캐스트는 자동으로 모든 내부 생성자로 전파됩니다.

다차원 배열 생성자 요소는 적절한 타입의 배열을 생성하는 것이면 무엇이든 될 수 있으며, 하위 `ARRAY` 구문만이 아닙니다. 예:

```sql
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
```

`ARRAY` 생성자를 사용하여 빈 배열을 구축할 수 있지만, 요소 없이 타입 시스템이 배열의 타입을 추론할 방법이 없으므로 원하는 타입을 명시적으로 캐스트해야 합니다. 예:

```sql
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
```

서브쿼리의 결과에서 배열을 구축할 수도 있습니다. 이 형태에서 배열 생성자는 키워드 `ARRAY` 다음에 괄호로 묶인(대괄호가 아님) 서브쿼리로 작성됩니다. 예:

```sql
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                              array
------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
```

서브쿼리는 정확히 한 열을 반환해야 합니다. 서브쿼리의 출력 열이 비배열 타입인 경우, 결과 1차원 배열은 서브쿼리 결과의 각 행에 대해 하나의 요소를 가지며, 요소 타입은 서브쿼리의 출력 열 타입과 일치합니다. 서브쿼리의 출력 열이 배열 타입인 경우, 결과는 하나 더 높은 차원의 동일한 타입 배열이 됩니다. 이 경우 서브쿼리의 모든 행은 동일한 차원의 배열을 생성해야 합니다. 그렇지 않으면 결과는 직사각형이 아닙니다.

`ARRAY`로 구축된 배열 값의 첨자는 항상 1로 시작합니다. 배열에 대한 자세한 내용은 8.15절을 참조하세요.

### 4.2.13. 행 생성자 (Row Constructors)

행 생성자는 멤버 필드의 값을 사용하여 행 값(복합 값이라고도 함)을 구축하는 표현식입니다. 행 생성자는 키워드 `ROW`, 왼쪽 괄호, 행 필드 값에 대한 0개 이상의 표현식(쉼표로 구분), 오른쪽 괄호로 구성됩니다. 예:

```sql
SELECT ROW(1,2.5,'this is a test');
```

키워드 `ROW`는 목록에 두 개 이상의 표현식이 있을 때 선택 사항입니다.

행 생성자는 복합 값으로 저장할 값을 구축하기 위해 복합 타입 테이블 열에 저장되거나 복합 매개변수를 허용하는 함수에 전달될 수 있습니다. 또한 9.24절에서 논의하는 것처럼 두 행 값을 비교하거나 `IS NULL` 또는 `IS NOT NULL`로 행을 테스트할 수 있습니다.

복합 타입 요구 사항에 맞게 제공되는 필드 수가 일치하는 경우에만 행 생성자를 사용할 수 있습니다. 기본적으로 `ROW` 표현식으로 생성된 값은 익명 레코드 타입입니다. 필요한 경우 명명된 복합 타입(테이블의 행 타입 또는 `CREATE TYPE AS`로 생성된 복합 타입)으로 캐스트할 수 있습니다. 모호성을 방지하기 위해 명시적 캐스트가 필요할 수 있습니다. 예:

```sql
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- getf1()이 하나만 있으므로 캐스트 불필요:
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 이제 모호성을 방지하기 위해 캐스트 필요:
SELECT getf1(ROW(1,2.5,'this is a test'));  -- 오류
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
```

행 생성자는 복합 타입 테이블 열에 저장하거나 복합 매개변수를 허용하는 함수에 전달할 복합 값을 구축하는 데 사용할 수 있습니다.

### 4.2.14. 표현식 평가 규칙 (Expression Evaluation Rules)

하위 표현식의 평가 순서는 정의되지 않았습니다. 특히 연산자나 함수의 입력이 반드시 왼쪽에서 오른쪽 또는 다른 고정된 순서로 평가되는 것은 아닙니다.

또한 표현식의 결과가 일부만 평가하여 결정될 수 있는 경우, 다른 하위 표현식은 전혀 평가되지 않을 수 있습니다. 예를 들어, 다음과 같이 작성하면:

```sql
SELECT true OR somefunc();
```

`somefunc()`는 (아마도) 전혀 호출되지 않습니다. 다음과 같이 작성해도 마찬가지입니다:

```sql
SELECT somefunc() OR true;
```

이것은 다른 프로그래밍 언어에서 찾을 수 있는 부울 연산자의 왼쪽에서 오른쪽 "단락(short-circuiting)"과 다릅니다.

결과적으로 부작용이 있는 함수를 복잡한 표현식의 일부로 사용하는 것은 현명하지 않습니다. `WHERE`와 `HAVING` 절에서 부작용이나 평가 순서에 의존하는 것은 특히 위험합니다. 이러한 절은 실행 계획을 개발하는 과정에서 광범위하게 재처리되기 때문입니다. 해당 절의 부울 표현식(`AND`/`OR`/`NOT` 조합)은 부울 대수가 허용하는 모든 방식으로 재구성될 수 있습니다.

평가 순서를 강제해야 할 때는 `CASE` 구문(9.18절 참조)을 사용할 수 있습니다. 예를 들어, 다음은 `WHERE` 절에서 0으로 나누기를 피하는 신뢰할 수 없는 방법입니다:

```sql
SELECT ... WHERE x > 0 AND y/x > 1.5;
```

다음은 안전합니다:

```sql
SELECT ... WHERE CASE WHEN x > 0 THEN y/x > 1.5 ELSE false END;
```

이 방식으로 사용되는 `CASE` 구문은 최적화 시도를 방해하므로 필요할 때만 수행해야 합니다. (이 특정 예에서는 의심스러운 나눗셈을 피하기 위해 `y > 1.5*x`로 작성하는 것이 더 좋습니다.)

그러나 `CASE`는 그러한 모든 문제에 대한 만병통치약이 아닙니다. 위에서 설명한 기술의 한 가지 한계는 상수 하위 표현식의 조기 평가를 방지하지 않는다는 것입니다. 10.3절에서 설명한 대로, `IMMUTABLE`로 표시된 함수와 연산자는 계획 시간이 아닌 쿼리 실행 시 호출되면 평가될 수 있습니다. 따라서 예를 들어:

```sql
SELECT CASE WHEN x > 0 THEN x ELSE 1/0 END FROM tab;
```

`tab`의 모든 행에 대해 `x > 0`이 참이더라도 계획자가 상수 하위 표현식을 단순화하려고 시도할 때 1/0 표현식이 평가될 수 있어 0으로 나누기 오류가 발생할 수 있습니다.

`CASE`가 중첩된 집계 하위 표현식이 평가되는 것을 방지하지 않는다는 더 중요한 한계가 있습니다. 집계 표현식은 다른 표현식 전에 계산되기 때문입니다. 예를 들어, 다음 쿼리는 직원이 0인 부서가 있는 경우에도 0으로 나누기 오류를 생성할 수 있습니다:

```sql
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
```

`min()` 및 `avg()` 집계는 모든 입력 행에 대해 동시에 계산되므로, 직원이 0인 행이 있으면 `CASE` 표현식의 테스트 결과 전에 0으로 나누기 오류가 발생합니다. 대신 `WHERE` 또는 `FILTER` 절을 사용하여 문제가 되는 입력 행이 집계 함수에 도달하는 것을 처음부터 방지할 수 있습니다:

```sql
SELECT avg(expenses / employees)
FROM departments
WHERE employees > 0;
```

`WHERE`는 `HAVING`과 달리 집계 계산 전에 적용됩니다. 또는 집계 함수의 `FILTER` 절을 사용하세요:

```sql
SELECT avg(expenses / employees) FILTER (WHERE employees > 0)
FROM departments;
```

---

## 4.3. 함수 호출 (Calling Functions)

PostgreSQL은 명명된 매개변수가 있는 함수를 위치 표기법(positional notation) 또는 명명된 표기법(named notation) 으로 호출할 수 있습니다. 명명된 표기법은 많은 매개변수가 있는 함수에 특히 유용합니다. 매개변수와 실제 인수 간의 연결을 더 명시적이고 신뢰할 수 있게 만들기 때문입니다. 위치 표기법에서 함수 호출은 함수 선언에서 정의된 순서와 동일한 순서로 인수 값과 함께 작성됩니다. 명명된 표기법에서 인수는 이름으로 함수 매개변수와 일치되며, 어떤 순서로든 작성할 수 있습니다. 각 표기법에 대해 10장에서 설명하는 함수 인수 타입의 효과도 고려하세요.

어느 표기법에서든 기본값을 가진 매개변수가 있는 함수는 해당 매개변수를 호출에서 생략하여 기본값이 삽입되도록 호출할 수 있습니다. 그러나 이것은 명명된 표기법에서 특히 유용합니다. 매개변수의 어떤 조합이든 생략할 수 있기 때문입니다. 위치 표기법에서는 매개변수가 오른쪽에서 왼쪽으로만 생략할 수 있습니다.

PostgreSQL은 함수가 인수 이름 없이 선언된 경우에도 명명된 표기법을 지원합니다. 매개변수에 함수 정의에서 사용된 이름이 자동으로 할당됩니다.

> 참고
>
> 명명된 및 혼합 호출 표기법은 현재 집계 함수 호출에 사용할 수 없습니다(그러나 집계 함수가 윈도우 함수로 사용될 때는 작동합니다).

### 4.3.1. 위치 표기법 사용 (Using Positional Notation)

위치 표기법은 PostgreSQL에서 함수에 인수를 전달하는 전통적인 메커니즘입니다. 예:

```sql
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
```

모든 인수가 순서대로 지정됩니다. 세 번째 인수 `uppercase`가 `true`로 지정되어 있으므로 결과는 대문자입니다. 다른 예:

```sql
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
```

여기서 `uppercase` 매개변수는 기본값 `false`를 가지므로 생략되었습니다. 위치 표기법에서 기본값을 가진 인수는 오른쪽에서 왼쪽으로만 생략할 수 있습니다.

### 4.3.2. 명명된 표기법 사용 (Using Named Notation)

명명된 표기법에서 각 인수의 이름은 `=>`를 사용하여 인수 표현식과 구분하여 지정됩니다. 예:

```sql
SELECT concat_lower_or_upper(a => 'Hello', b => 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
```

다시, 인수 `uppercase`가 생략되었으므로 암묵적으로 `false`로 설정됩니다. 명명된 표기법을 사용하면 인수를 어떤 순서로든 지정할 수 있습니다. 예:

```sql
SELECT concat_lower_or_upper(a => 'Hello', b => 'World', uppercase => true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a => 'Hello', uppercase => true, b => 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
```

이전 버전과의 호환성을 위해 이전 구문 `:=`도 지원됩니다:

```sql
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
```

### 4.3.3. 혼합 표기법 사용 (Using Mixed Notation)

혼합 표기법은 위치 표기법과 명명된 표기법을 결합합니다. 그러나 이미 언급했듯이 명명된 인수는 위치 인수 앞에 올 수 없습니다. 예:

```sql
SELECT concat_lower_or_upper('Hello', 'World', uppercase => true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
```

위 쿼리에서 인수 `a`와 `b`는 위치로 지정되고 `uppercase`는 이름으로 지정됩니다.

이 형식에서 기본값을 가진 매개변수는 출력 위치에서만 생략할 수 있습니다. 예를 들어:

```sql
SELECT concat_lower_or_upper('Hello', uppercase => true, b => 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
```

---

## 요약

이 장에서는 PostgreSQL의 SQL 구문 기초를 다루었습니다:

1. 어휘 구조: 식별자, 키워드, 상수(문자열, 숫자, 비트 문자열), 연산자, 특수 문자, 주석, 연산자 우선순위

2. 값 표현식: 열 참조, 위치 매개변수, 첨자, 필드 선택, 연산자 호출, 함수 호출, 집계 표현식, 윈도우 함수, 타입 캐스트, 콜레이션 표현식, 스칼라 서브쿼리, 배열 및 행 생성자, 표현식 평가 규칙

3. 함수 호출: 위치 표기법, 명명된 표기법, 혼합 표기법

이러한 SQL 구문 요소를 이해하면 PostgreSQL에서 효과적인 쿼리를 작성하는 데 필요한 기초가 마련됩니다.
