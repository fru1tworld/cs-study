# PostgreSQL 18 백업 및 복원 (Backup and Restore)

이 장에서는 PostgreSQL 데이터베이스의 백업 및 복원 절차를 다룹니다. 중요한 데이터의 정기적인 백업은 필수적이며, 이 문서에서는 기본 기술과 가정에 대한 지침을 제공합니다.

## 세 가지 기본 백업 방식

PostgreSQL에서는 세 가지 기본적인 백업 방식을 제공합니다:

1. SQL 덤프 (SQL Dump)
2. 파일 시스템 레벨 백업 (File System Level Backup)
3. 연속 아카이빙 (Continuous Archiving)

각 방식에는 고유한 장단점이 있으며, 이후 섹션에서 자세히 설명합니다.

---

## 25.1. SQL 덤프

### 목차
- 25.1.1. 덤프 복원
- 25.1.2. pg_dumpall 사용
- 25.1.3. 대용량 데이터베이스 처리

### 개요

덤프 방식은 데이터베이스를 이전 상태로 재생성하는 SQL 명령이 포함된 파일을 생성합니다. PostgreSQL은 이를 위해 `pg_dump` 유틸리티를 제공합니다.

기본 사용법:
```bash
pg_dump dbname > dumpfile
```

주요 특징:
- `pg_dump`는 표준 출력으로 결과를 출력합니다
- 여러 파일 형식을 생성할 수 있습니다 (병렬 처리 및 세밀한 객체 복원 허용)
- 일반적인 PostgreSQL 클라이언트 애플리케이션입니다 (원격 호스트에서 실행 가능)
- 백업하려는 모든 테이블에 대한 읽기 접근 권한이 필요합니다
- 전체 데이터베이스 백업을 위해서는 일반적으로 슈퍼유저 권한이 필요합니다
- 선택적으로 `-n schema` 또는 `-t table` 옵션으로 부분 백업 가능

연결 옵션:
```
-h host       (기본값: PGHOST 환경 변수 또는 로컬 호스트)
-p port       (기본값: PGPORT 환경 변수 또는 컴파일 시 설정된 기본값)
-U username   (기본값: 현재 OS 사용자 또는 PGUSER 환경 변수)
```

장점:
- 출력 결과는 최신 PostgreSQL 버전으로 다시 로드할 수 있습니다
- 다른 머신 아키텍처로의 데이터베이스 전송에 사용할 수 있습니다 (예: 32비트에서 64비트로)
- 아키텍처 전송에 사용할 수 있는 유일한 방식입니다
- 내부적으로 일관성이 있습니다 (덤프 시작 시점의 스냅샷)
- 다른 데이터베이스 작업을 차단하지 않습니다 (대부분의 `ALTER TABLE`과 같이 배타적 잠금이 필요한 작업 제외)

---

### 25.1.1. 덤프 복원

텍스트 덤프 복원:
```bash
psql -X dbname < dumpfile
```

중요 참고사항:
- `dbname` 데이터베이스는 미리 `template0`에서 생성되어 있어야 합니다
- 명령 예시:
```bash
createdb -T template0 dbname
```
- `-X` (`--no-psqlrc`) 옵션을 사용하여 psql이 기본 설정으로 실행되도록 합니다
- `psql`은 `pg_dump`와 동일한 서버 및 사용자 옵션을 지원합니다

비텍스트 형식 복원:
```bash
pg_restore
```
(커스텀 및 디렉토리 형식 덤프에 사용)

복원 전 요구사항:
- 객체를 소유하거나 권한이 부여된 모든 사용자가 이미 존재해야 합니다
- 그렇지 않으면 복원 시 원래 소유권/권한으로 객체를 재생성하는 데 실패합니다

오류 처리 - 옵션 1 (오류 발생 시 계속):
기본 동작 - `psql`은 SQL 오류 발생 후에도 계속 진행하며, 부분 복원이 됩니다

오류 처리 - 옵션 2 (오류 발생 시 중지):
```bash
psql -X --set ON_ERROR_STOP=on dbname < dumpfile
```
- psql은 SQL 오류 시 종료 코드 3으로 종료합니다
- 여전히 부분 복원 상태가 됩니다

오류 처리 - 옵션 3 (단일 트랜잭션):
```bash
psql -X -1 dbname < dumpfile
```
또는
```bash
psql -X --single-transaction dbname < dumpfile
```

특징:
- 전체 덤프가 단일 트랜잭션으로 복원됩니다
- 전체 완료 또는 전체 롤백 (all-or-nothing) 복원
- 주의: 사소한 오류로 인해 여러 시간의 복원이 롤백될 수 있습니다
- 복잡한 데이터베이스의 수동 정리보다 나을 수 있습니다

서버 간 직접 전송:
```bash
pg_dump -h host1 dbname | psql -X -h host2 dbname
```

### template0 요구사항에 대한 중요 참고

덤프는 `template0`을 기준으로 합니다. `template1`을 통해 추가된 언어, 프로시저 등도 함께 덤프됩니다. 사용자 정의된 `template1`로 복원할 때는 `template0`에서 빈 데이터베이스를 생성해야 합니다:
```bash
createdb -T template0 dbname
```

복원 후 단계:
- 각 데이터베이스에서 `ANALYZE` 실행 (쿼리 최적화기가 유용한 통계를 수집할 수 있도록)
- 참조: 섹션 24.1.3 (플래너 통계 업데이트) 및 섹션 24.1.6 (Autovacuum 데몬)
- 대용량 데이터 로드의 경우: 섹션 14.4 (데이터베이스 채우기) 참조

---

### 25.1.2. pg_dumpall 사용

특징:
- `pg_dump`는 한 번에 하나의 데이터베이스만 백업합니다
- 역할(role)이나 테이블스페이스를 덤프하지 않습니다 (클러스터 전역 객체, 데이터베이스별이 아님)
- `pg_dumpall`은 전체 데이터베이스 클러스터를 백업합니다
- 클러스터 전역 데이터(역할 및 테이블스페이스 정의)를 보존합니다

기본 사용법:
```bash
pg_dumpall > dumpfile
```

복원:
```bash
psql -X -f dumpfile postgres
```

참고:
- 기존 데이터베이스 이름을 지정할 수 있습니다 (빈 클러스터의 경우 `postgres` 사용)
- 복원을 위해 데이터베이스 슈퍼유저 접근 권한이 필요합니다
- 테이블스페이스 경로가 새 설치에 적합한지 확인해야 합니다
- 각 데이터베이스는 내부적으로 일관성이 있지만, 서로 다른 데이터베이스의 스냅샷은 동기화되지 않습니다

전역 객체만 백업:
```bash
pg_dumpall --globals-only
```
- 개별 데이터베이스에 `pg_dump`를 실행할 때 전체 클러스터 백업에 필요합니다

---

### 25.1.3. 대용량 데이터베이스 처리

일부 운영 체제의 파일 크기 제한 문제를 `pg_dump`의 파이프 기능으로 해결합니다.

방법 1: 압축된 덤프 (gzip)

```bash
pg_dump dbname | gzip > filename.gz
```

복원 옵션:
```bash
gunzip -c filename.gz | psql dbname
```
또는
```bash
cat filename.gz | gunzip | psql dbname
```

방법 2: `split` 명령 사용

2 기가바이트 청크로 생성:
```bash
pg_dump dbname | split -b 2G - filename
```

복원:
```bash
cat filename* | psql dbname
```

GNU split과 gzip 함께 사용:
```bash
pg_dump dbname | split -b 2G --filter='gzip > $FILE.gz'
```

`zcat`으로 복원

방법 3: 커스텀 덤프 형식

요구사항: zlib 압축 라이브러리로 빌드된 PostgreSQL

```bash
pg_dump -Fc dbname > filename
```

특징:
- 작성 시 자동으로 데이터를 압축합니다
- gzip과 유사한 크기의 덤프를 생성합니다
- 선택적 테이블 복원을 허용합니다
- psql 스크립트가 아닙니다

복원:
```bash
pg_restore -d dbname filename
```

방법 4: 병렬 덤프 기능

대용량 데이터베이스의 경우 병렬 처리로 덤프 속도 향상:

```bash
pg_dump -j num -F d -f out.dir dbname
```

매개변수:
- `-j num` - 병렬 처리 정도를 제어합니다
- `-F d` - 디렉토리 아카이브 형식 (병렬 덤프를 지원하는 유일한 형식)
- `-f out.dir` - 출력 디렉토리

병렬 복원:
```bash
pg_restore -j num -d dbname out.dir
```

참고:
- 커스텀 또는 디렉토리 아카이브 모드에서 작동합니다
- `pg_dump -j`로 생성되었는지와 관계없이 작동합니다

복합 접근 방식:
- 매우 대용량 데이터베이스의 경우 `split`과 압축 또는 커스텀 형식을 결합해야 할 수 있습니다

---

## 25.2. 파일 시스템 레벨 백업

### 개요
PostgreSQL이 데이터베이스 데이터를 저장하는 데 사용하는 파일을 직접 복사하는 대안적인 백업 전략입니다. 위치 정보는 섹션 18.2 (데이터베이스 클러스터 생성)에서 찾을 수 있습니다.

### 예시 명령
```bash
tar -cf backup.tar /usr/local/pgsql/data
```

### 두 가지 중요한 제한사항

#### 1. 서버가 종료되어 있어야 함
- 사용 가능한 백업을 얻으려면 데이터베이스 서버가 반드시 종료되어 있어야 합니다
- 모든 연결을 금지하는 것과 같은 절반의 조치는 작동하지 않습니다
- 이유: `tar` 및 유사 도구는 파일 시스템 상태의 원자적 스냅샷을 찍지 않으며, 서버 내부 버퍼링도 있습니다
- 서버 종료 정보: 섹션 18.5 (서버 종료)
- 데이터 복원 전에도 서버가 종료되어 있어야 합니다

#### 2. 개별 테이블이나 데이터베이스를 백업할 수 없음
- 특정 개별 테이블이나 데이터베이스만 백업하거나 복원하는 것은 작동하지 않습니다
- 이유: 파일은 커밋 로그 파일(`pg_xact/*`) 없이는 사용할 수 없습니다
- `pg_xact/*` 파일에는 모든 트랜잭션의 커밋 상태가 포함되어 있습니다
- 테이블 파일은 이 정보가 있어야만 사용할 수 있습니다
- 테이블과 관련된 `pg_xact` 데이터만 복원하면 데이터베이스 클러스터의 다른 모든 테이블이 사용 불가능해집니다
- 파일 시스템 백업은 전체 데이터베이스 클러스터의 완전한 백업 및 복원에서만 작동합니다

### 대안: 일관된 스냅샷 접근 방식

#### 절차
- 데이터베이스를 포함하는 볼륨의 "고정된 스냅샷"을 만듭니다 (파일 시스템이 지원하는 경우)
- 스냅샷에서 전체 데이터 디렉토리를 백업 장치로 복사합니다
- 고정된 스냅샷을 해제합니다
- 데이터베이스 서버가 실행 중일 때도 작동합니다

#### 중요 고려사항
- 백업은 서버가 제대로 종료되지 않은 상태의 데이터베이스 파일을 저장합니다
- 서버를 재시작하면 이전 인스턴스가 충돌한 것으로 생각하고 WAL 로그를 재생합니다
- 이것은 문제가 아닙니다 - 단지 인식하고 있으면 됩니다
- 백업에 WAL 파일을 포함해야 합니다
- 스냅샷을 찍기 전에 `CHECKPOINT`를 수행하여 복구 시간을 줄일 수 있습니다

#### 다중 파일 시스템 제한
- 데이터베이스가 여러 파일 시스템에 분산된 경우 정확히 동시적인 고정 스냅샷을 얻지 못할 수 있습니다
- 다음 경우 스냅샷이 동시에 이루어져야 합니다:
  - 데이터 파일과 WAL 로그가 다른 디스크에 있는 경우
  - 테이블스페이스가 다른 파일 시스템에 있는 경우
- 이러한 상황에서 스냅샷 백업을 신뢰하기 전에 파일 시스템 문서를 주의 깊게 읽으세요

### 다중 파일 시스템 문제 해결책

#### 옵션 1: 스냅샷 중 종료
- 모든 고정 스냅샷을 설정하기에 충분한 시간 동안 데이터베이스 서버를 종료합니다

#### 옵션 2: 연속 아카이빙 베이스 백업
- 연속 아카이빙 베이스 백업을 수행합니다 (섹션 25.3.2)
- 백업 중 파일 시스템 변경에 영향을 받지 않습니다
- 백업 프로세스 중 연속 아카이빙을 활성화해야 합니다
- 연속 아카이브 복구를 사용하여 복원합니다 (섹션 25.3.5)

#### 옵션 3: rsync 방법
- 데이터베이스 서버가 실행 중일 때 `rsync` 실행 (첫 번째 실행)
- `rsync --checksum`을 수행하기에 충분한 시간 동안 데이터베이스 서버 종료
- 참고: `rsync`는 파일 수정 시간 정밀도가 1초뿐이므로 `--checksum`이 필요합니다
- 두 번째 rsync는 더 빠를 것입니다 (전송할 데이터가 상대적으로 적음)
- 서버가 다운되어 있었으므로 결과가 일관됩니다
- 최소한의 다운타임 으로 파일 시스템 백업이 가능합니다

### 성능 비교

#### 크기
- 파일 시스템 백업은 일반적으로 SQL 덤프보다 큽니다
- `pg_dump`는 인덱스 내용을 덤프하지 않고 재생성 명령만 덤프합니다

#### 속도
- 파일 시스템 백업을 수행하는 것이 더 빠를 수 있습니다

---

## 25.3. 연속 아카이빙 및 특정 시점 복구 (PITR)

### 개요

PostgreSQL은 항상 클러스터 데이터 디렉토리의 `pg_wal/` 하위 디렉토리에 _Write Ahead Log_ (WAL)를 유지합니다. 로그는 데이터베이스 데이터 파일에 대한 모든 변경 사항을 기록합니다. 이 로그는 주로 충돌 안전성을 위해 존재합니다: 시스템이 충돌하면 마지막 체크포인트 이후에 만들어진 로그 항목을 "재생"하여 데이터베이스를 일관성 있는 상태로 복원할 수 있습니다. 그러나 로그의 존재는 데이터베이스 백업을 위한 세 번째 전략을 사용할 수 있게 합니다: 파일 시스템 수준 백업과 WAL 파일의 백업을 결합할 수 있습니다. 복구가 필요한 경우 파일 시스템 백업을 복원한 다음 백업된 WAL 파일에서 재생하여 시스템을 현재 상태로 가져옵니다. 이 접근 방식은 이전 접근 방식보다 관리가 더 복잡하지만 몇 가지 중요한 이점이 있습니다:

- 시작점으로 완벽하게 일관된 파일 시스템 백업이 필요하지 않습니다. 백업의 내부 불일치는 로그 재생으로 수정됩니다 (이는 충돌 복구 중에 일어나는 것과 크게 다르지 않습니다). 따라서 파일 시스템 스냅샷 기능이 필요 없고 tar 또는 유사한 아카이빙 도구만 있으면 됩니다.

- 무한히 긴 WAL 파일 시퀀스를 재생용으로 결합할 수 있으므로 WAL 파일을 계속 아카이빙하기만 하면 연속 백업을 달성할 수 있습니다. 이는 전체 백업을 자주 수행하기 불편할 수 있는 대용량 데이터베이스에 특히 유용합니다.

- WAL 항목을 끝까지 모두 재생할 필요가 없습니다. 어느 시점에서든 재생을 중지하고 해당 시점의 데이터베이스 일관된 스냅샷을 가질 수 있습니다. 따라서 이 기술은 _특정 시점 복구(point-in-time recovery)_를 지원합니다: 베이스 백업이 수행된 이후 어느 시점으로든 데이터베이스를 복원할 수 있습니다.

- 동일한 베이스 백업 파일이 로드된 다른 머신에 WAL 파일 시리즈를 지속적으로 공급하면 _웜 스탠바이(warm standby)_ 시스템을 갖게 됩니다: 언제든지 두 번째 머신을 가동하면 거의 최신 복사본의 데이터베이스를 갖게 됩니다.

### 참고

pg_dump와 pg_dumpall은 파일 시스템 수준 백업을 생성하지 않으며 연속 아카이빙 솔루션의 일부로 사용할 수 없습니다. 이러한 덤프는 _논리적_이며 WAL 재생에 사용될 수 있는 충분한 정보를 포함하지 않습니다.

일반 파일 시스템 백업 기술과 마찬가지로 이 방법은 전체 데이터베이스 클러스터의 복원만 지원할 수 있으며 하위 집합은 지원하지 않습니다. 또한 많은 아카이브 저장소가 필요합니다: 베이스 백업이 방대할 수 있고 바쁜 시스템은 아카이빙해야 할 많은 메가바이트의 WAL 트래픽을 생성합니다. 그럼에도 불구하고 높은 신뢰성이 필요한 많은 상황에서 선호되는 백업 기술입니다.

연속 아카이빙(많은 데이터베이스 벤더가 "온라인 백업"이라고도 함)을 사용하여 성공적으로 복구하려면 적어도 백업 시작 시간까지 거슬러 올라가는 연속적인 아카이브된 WAL 파일 시퀀스가 필요합니다. 따라서 시작하려면 첫 번째 베이스 백업을 수행하기 _전에_ WAL 파일 아카이빙 절차를 설정하고 테스트해야 합니다. 따라서 먼저 WAL 파일 아카이빙의 메커니즘에 대해 설명합니다.

---

### 25.3.1. WAL 아카이빙 설정

추상적인 의미에서 실행 중인 PostgreSQL 시스템은 무한히 긴 WAL 레코드 시퀀스를 생성합니다. 시스템은 이 시퀀스를 WAL _세그먼트 파일_로 물리적으로 나눕니다. 세그먼트 파일은 일반적으로 각각 16MB입니다 (세그먼트 크기는 initdb 중에 변경할 수 있음). 세그먼트 파일에는 추상적인 WAL 시퀀스에서의 위치를 반영하는 숫자 이름이 지정됩니다. WAL 아카이빙을 사용하지 않을 때 시스템은 일반적으로 몇 개의 세그먼트 파일만 생성한 다음 더 이상 필요하지 않은 세그먼트 파일의 이름을 더 높은 세그먼트 번호로 변경하여 "재활용"합니다. 마지막 체크포인트 이전의 내용을 가진 세그먼트 파일은 더 이상 관심이 없으며 재활용할 수 있다고 가정합니다.

WAL 데이터를 아카이빙할 때 각 세그먼트 파일이 채워지면 해당 내용을 캡처하고 세그먼트 파일이 재사용을 위해 재활용되기 전에 해당 데이터를 어딘가에 저장해야 합니다. 애플리케이션 및 사용 가능한 하드웨어에 따라 "데이터를 어딘가에 저장"하는 많은 다른 방법이 있을 수 있습니다: 세그먼트 파일을 다른 머신의 NFS 마운트 디렉토리로 복사하거나, 테이프 드라이브에 기록하거나 (각 파일의 원래 이름을 식별하는 방법이 있는지 확인), 함께 묶어 CD에 굽거나, 완전히 다른 것을 할 수 있습니다. 데이터베이스 관리자에게 유연성을 제공하기 위해 PostgreSQL은 아카이빙 방법에 대해 어떤 가정도 하지 않으려고 합니다. 대신 PostgreSQL을 사용하면 관리자가 완료된 세그먼트 파일을 필요한 곳으로 복사하기 위해 실행할 셸 명령 또는 아카이브 라이브러리를 지정할 수 있습니다. 이것은 `cp`를 사용하는 셸 명령처럼 간단할 수도 있고 복잡한 C 함수를 호출할 수도 있습니다 - 모두 사용자에게 달려 있습니다.

WAL 아카이빙을 활성화하려면 [wal_level](runtime-config-wal.html#GUC-WAL-LEVEL) 구성 매개변수를 `replica` 이상으로 설정하고 [archive_mode](runtime-config-wal.html#GUC-ARCHIVE-MODE)를 `on`으로 설정한 다음 [archive_command](runtime-config-wal.html#GUC-ARCHIVE-COMMAND) 구성 매개변수에 사용할 셸 명령을 지정하거나 [archive_library](runtime-config-wal.html#GUC-ARCHIVE-LIBRARY) 구성 매개변수에 사용할 라이브러리를 지정합니다. 실제로 이러한 설정은 항상 `postgresql.conf` 파일에 배치됩니다.

`archive_command`에서 `%p`는 아카이빙할 파일의 경로 이름으로 대체되고 `%f`는 파일 이름만으로 대체됩니다. (경로 이름은 현재 작업 디렉토리, 즉 클러스터의 데이터 디렉토리를 기준으로 합니다.) 명령에 실제 `%` 문자를 포함해야 하는 경우 `%%`를 사용하세요. 가장 간단한 유용한 명령은 다음과 같습니다:

```bash
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
```

이것은 아카이빙 가능한 WAL 세그먼트를 `/mnt/server/archivedir` 디렉토리로 복사합니다. (이것은 예시이며 권장 사항이 아니며 모든 플랫폼에서 작동하지 않을 수 있습니다.) `%p` 및 `%f` 매개변수가 대체된 후 실제로 실행되는 명령은 다음과 같을 수 있습니다:

```bash
test ! -f /mnt/server/archivedir/00000001000000A900000065 && cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
```

아카이빙할 각 새 파일에 대해 유사한 명령이 생성됩니다.

아카이브 명령은 PostgreSQL 서버가 실행되는 것과 동일한 사용자의 소유권으로 실행됩니다. 아카이빙되는 WAL 파일 시리즈에는 데이터베이스의 모든 것이 효과적으로 포함되어 있으므로 아카이브된 데이터가 엿보는 눈으로부터 보호되도록 해야 합니다. 예를 들어 그룹 또는 월드 읽기 액세스가 없는 디렉토리에 아카이브합니다.

아카이브 명령이 성공한 경우에만 0 종료 상태를 반환하는 것이 중요합니다. 0 결과를 받으면 PostgreSQL은 파일이 성공적으로 아카이브되었다고 가정하고 이를 제거하거나 재활용합니다. 그러나 0이 아닌 상태는 PostgreSQL에게 파일이 아카이브되지 않았음을 알립니다. 성공할 때까지 주기적으로 다시 시도합니다.

아카이빙하는 또 다른 방법은 `archive_library`로 사용자 정의 아카이브 모듈을 사용하는 것입니다. 이러한 모듈은 `C`로 작성되므로 직접 만드는 것은 셸 명령을 작성하는 것보다 상당히 더 많은 노력이 필요할 수 있습니다. 그러나 아카이브 모듈은 셸을 통한 아카이빙보다 성능이 더 좋을 수 있으며 많은 유용한 서버 리소스에 액세스할 수 있습니다. 아카이브 모듈에 대한 자세한 내용은 [49장](archive-modules.html "49장. 아카이브 모듈")을 참조하세요.

아카이브 명령이 신호(서버 종료의 일부로 사용되는 SIGTERM 제외)에 의해 종료되거나 125보다 큰 종료 상태로 셸에 의해 오류가 발생하거나(예: 명령을 찾을 수 없음), 아카이브 함수가 `ERROR` 또는 `FATAL`을 발생시키면 아카이버 프로세스가 중단되고 postmaster에 의해 다시 시작됩니다. 이러한 경우 실패는 [pg_stat_archiver](monitoring-stats.html#PG-STAT-ARCHIVER-VIEW "표 27.22. pg_stat_archiver 뷰")에 보고되지 않습니다.

아카이브 명령과 라이브러리는 일반적으로 기존 아카이브 파일을 덮어쓰지 않도록 설계해야 합니다. 이것은 관리자 오류(예: 두 개의 다른 서버의 출력을 동일한 아카이브 디렉토리로 보내는 것)의 경우 아카이브의 무결성을 보존하기 위한 중요한 안전 기능입니다. 제안된 아카이브 라이브러리가 기존 파일을 덮어쓰지 않는지 테스트하는 것이 좋습니다.

드문 경우에 PostgreSQL은 이전에 아카이브된 WAL 파일을 다시 아카이브하려고 시도할 수 있습니다. 예를 들어 서버가 아카이빙 성공에 대한 지속적인 기록을 만들기 전에 시스템이 충돌하면 서버는 재시작 후 파일을 다시 아카이브하려고 시도합니다 (아카이빙이 여전히 활성화되어 있는 경우). 아카이브 명령이나 라이브러리가 기존 파일을 만나면 WAL 파일이 기존 아카이브와 동일한 내용을 가지고 있고 기존 아카이브가 스토리지에 완전히 지속된 경우 각각 0 상태 또는 `true`를 반환해야 합니다. 기존 파일이 아카이빙 중인 WAL 파일과 다른 내용을 포함하면 아카이브 명령이나 라이브러리는 _반드시_ 각각 0이 아닌 상태 또는 `false`를 반환해야 합니다.

위의 Unix용 예제 명령은 별도의 `test` 단계를 포함하여 기존 아카이브 덮어쓰기를 피합니다. 일부 Unix 플랫폼에서는 `cp`에 `-i`와 같은 스위치가 있어 같은 작업을 덜 장황하게 수행할 수 있지만 올바른 종료 상태가 반환되는지 확인하지 않고 이에 의존해서는 안 됩니다. (특히 GNU `cp`는 `-i`를 사용하고 대상 파일이 이미 존재하면 상태 0을 반환하는데, 이것은 원하는 동작이 _아닙니다_.)

아카이빙 설정을 설계할 때 일부 측면에서 운영자 개입이 필요하거나 아카이브 공간이 부족하여 아카이브 명령이나 라이브러리가 반복적으로 실패하면 어떻게 될지 고려하세요. 예를 들어 오토체인저 없이 테이프에 쓰는 경우 이런 일이 발생할 수 있습니다. 테이프가 가득 차면 테이프를 교체할 때까지 더 이상 아카이브할 수 없습니다. 상황을 합리적으로 빠르게 해결할 수 있도록 모든 오류 조건이나 운영자에 대한 요청이 적절하게 보고되도록 해야 합니다. `pg_wal/` 디렉토리는 상황이 해결될 때까지 WAL 세그먼트 파일로 계속 채워집니다. (`pg_wal/`을 포함하는 파일 시스템이 가득 차면 PostgreSQL은 PANIC 종료를 수행합니다. 커밋된 트랜잭션은 손실되지 않지만 공간을 확보할 때까지 데이터베이스는 오프라인 상태로 유지됩니다.)

아카이브 명령이나 라이브러리의 속도는 서버가 WAL 데이터를 생성하는 평균 속도를 따라갈 수 있는 한 중요하지 않습니다. 아카이빙 프로세스가 약간 뒤처지더라도 정상 작업은 계속됩니다. 아카이빙이 크게 뒤처지면 재해 발생 시 손실될 데이터의 양이 증가합니다. 또한 `pg_wal/` 디렉토리에 아직 아카이브되지 않은 많은 수의 세그먼트 파일이 포함되어 결국 사용 가능한 디스크 공간을 초과할 수 있습니다. 아카이빙 프로세스가 의도한 대로 작동하는지 모니터링하는 것이 좋습니다.

아카이브 명령이나 라이브러리를 작성할 때 아카이빙할 파일 이름이 최대 64자 길이이고 ASCII 문자, 숫자 및 점의 조합을 포함할 수 있다고 가정해야 합니다. 원래 상대 경로(`%p`)를 보존할 필요는 없지만 파일 이름(`%f`)은 보존해야 합니다.

WAL 아카이빙을 통해 PostgreSQL 데이터베이스의 데이터에 대한 모든 수정 사항을 복원할 수 있지만 구성 파일(즉, `postgresql.conf`, `pg_hba.conf` 및 `pg_ident.conf`)에 대한 변경 사항은 복원되지 않습니다. 이러한 파일은 SQL 작업이 아닌 수동으로 편집되기 때문입니다. 정기적인 파일 시스템 백업 절차로 백업될 위치에 구성 파일을 보관하는 것이 좋습니다. 구성 파일을 재배치하는 방법은 [섹션 19.2](runtime-config-file-locations.html "19.2. 파일 위치")를 참조하세요.

아카이브 명령이나 함수는 완료된 WAL 세그먼트에서만 호출됩니다. 따라서 서버가 WAL 트래픽을 거의 생성하지 않거나 (또는 그렇게 하는 여유 기간이 있는 경우) 트랜잭션 완료와 아카이브 스토리지에 안전하게 기록되는 사이에 긴 지연이 있을 수 있습니다. 아카이브되지 않은 데이터가 얼마나 오래된 것인지에 대한 제한을 두려면 [archive_timeout](runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT)을 설정하여 서버가 최소한 그 정도 자주 새 WAL 세그먼트 파일로 전환하도록 강제할 수 있습니다. 강제 전환으로 인해 조기에 아카이브된 파일은 여전히 완전히 채워진 파일과 동일한 길이입니다. 따라서 매우 짧은 `archive_timeout`을 설정하는 것은 현명하지 않습니다 - 아카이브 스토리지가 팽창합니다. 1분 정도의 `archive_timeout` 설정이 일반적으로 합리적입니다.

또한 방금 완료된 트랜잭션이 가능한 빨리 아카이브되도록 하려면 `pg_switch_wal`을 사용하여 수동으로 세그먼트 전환을 강제할 수 있습니다. WAL 관리와 관련된 다른 유틸리티 함수는 [표 9.97](functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE "표 9.97. 백업 제어 함수")에 나열되어 있습니다.

`wal_level`이 `minimal`이면 [섹션 14.4.7](populate.html#POPULATE-PITR "14.4.7. WAL 아카이빙 및 스트리밍 복제 비활성화")에 설명된 대로 일부 SQL 명령이 WAL 로깅을 피하도록 최적화됩니다. 이러한 문 중 하나를 실행하는 동안 아카이빙이나 스트리밍 복제가 켜져 있으면 WAL에 아카이브 복구에 충분한 정보가 포함되지 않습니다. (충돌 복구는 영향을 받지 않습니다.) 이러한 이유로 `wal_level`은 서버 시작 시에만 변경할 수 있습니다. 그러나 `archive_command`와 `archive_library`는 구성 파일 다시 로드로 변경할 수 있습니다. 셸을 통해 아카이빙하고 일시적으로 아카이빙을 중지하려면 한 가지 방법은 `archive_command`를 빈 문자열(`''`)로 설정하는 것입니다. 이렇게 하면 작동하는 `archive_command`가 다시 설정될 때까지 WAL 파일이 `pg_wal/`에 축적됩니다.

---

### 25.3.2. 베이스 백업 만들기

베이스 백업을 수행하는 가장 쉬운 방법은 [pg_basebackup](app-pgbasebackup.html "pg_basebackup") 도구를 사용하는 것입니다. 일반 파일 또는 tar 아카이브로 베이스 백업을 생성할 수 있습니다. [pg_basebackup](app-pgbasebackup.html "pg_basebackup")이 제공할 수 있는 것보다 더 많은 유연성이 필요한 경우 저수준 API를 사용하여 베이스 백업을 만들 수도 있습니다 ([섹션 25.3.4](continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP "25.3.4. 저수준 API를 사용하여 베이스 백업 만들기") 참조).

베이스 백업을 수행하는 데 걸리는 시간에 대해 걱정할 필요는 없습니다. 그러나 일반적으로 `full_page_writes`를 비활성화한 상태로 서버를 실행하는 경우 백업 모드 중에 `full_page_writes`가 효과적으로 강제 적용되므로 백업 실행 중 성능 저하를 느낄 수 있습니다.

백업을 사용하려면 파일 시스템 백업 중 및 이후에 생성된 모든 WAL 세그먼트 파일을 보관해야 합니다. 이를 지원하기 위해 베이스 백업 프로세스는 WAL 아카이브 영역에 즉시 저장되는 _백업 이력 파일_을 생성합니다. 이 파일은 파일 시스템 백업에 필요한 첫 번째 WAL 세그먼트 파일의 이름을 따서 명명됩니다. 예를 들어 시작 WAL 파일이 `0000000100001234000055CD`이면 백업 이력 파일은 `0000000100001234000055CD.007C9330.backup`과 같은 이름이 됩니다. (파일 이름의 두 번째 부분은 WAL 파일 내의 정확한 위치를 나타내며 일반적으로 무시할 수 있습니다.) 파일 시스템 백업과 백업 중 사용된 WAL 세그먼트 파일(백업 이력 파일에 지정된 대로)을 안전하게 아카이브하면 숫자상으로 더 작은 이름을 가진 모든 아카이브된 WAL 세그먼트는 파일 시스템 백업을 복구하는 데 더 이상 필요하지 않으며 삭제할 수 있습니다. 그러나 데이터를 복구할 수 있음을 절대적으로 확신하기 위해 여러 백업 세트를 유지하는 것을 고려해야 합니다.

백업 이력 파일은 작은 텍스트 파일일 뿐입니다. [pg_basebackup](app-pgbasebackup.html "pg_basebackup")에 지정한 레이블 문자열과 백업의 시작 및 종료 시간 및 WAL 세그먼트가 포함되어 있습니다. 레이블을 사용하여 연관된 덤프 파일을 식별했다면 아카이브된 이력 파일만으로도 어떤 덤프 파일을 복원해야 하는지 알 수 있습니다.

마지막 베이스 백업까지 모든 아카이브된 WAL 파일을 보관해야 하므로 베이스 백업 간의 간격은 일반적으로 아카이브된 WAL 파일에 사용할 스토리지 양을 기준으로 선택해야 합니다. 복구가 필요한 경우 복구에 얼마나 많은 시간을 할애할 수 있는지도 고려해야 합니다 - 시스템은 모든 WAL 세그먼트를 재생해야 하며 마지막 베이스 백업 이후 오랜 시간이 경과했다면 상당한 시간이 걸릴 수 있습니다.

---

### 25.3.3. 증분 백업 만들기

`--incremental` 옵션을 지정하여 [pg_basebackup](app-pgbasebackup.html "pg_basebackup")을 사용하여 증분 백업을 수행할 수 있습니다. `--incremental`에 대한 인수로 동일한 서버의 이전 백업에 대한 백업 매니페스트를 제공해야 합니다. 결과 백업에서 비관계 파일은 전체적으로 포함되지만 일부 관계 파일은 이전 백업 이후 변경된 블록과 파일의 현재 버전을 재구성하기에 충분한 메타데이터만 포함하는 더 작은 증분 파일로 대체될 수 있습니다.

어떤 블록을 백업해야 하는지 파악하기 위해 서버는 데이터 디렉토리의 `pg_wal/summaries` 디렉토리에 저장된 WAL 요약을 사용합니다. 필요한 요약 파일이 없으면 증분 백업 시도가 실패합니다. 이 디렉토리에 있는 요약은 이전 백업의 시작 LSN부터 현재 백업의 시작 LSN까지 모든 LSN을 포함해야 합니다. 서버가 현재 백업의 시작 LSN을 설정한 직후 WAL 요약을 찾기 때문에 필요한 요약 파일이 디스크에 즉시 존재하지 않을 수 있지만 서버는 누락된 파일이 나타날 때까지 기다립니다. 이것은 WAL 요약 프로세스가 뒤처진 경우에도 도움이 됩니다. 그러나 필요한 파일이 이미 제거되었거나 WAL 요약기가 충분히 빨리 따라잡지 못하면 증분 백업이 실패합니다.

증분 백업을 복원할 때 증분 백업 자체뿐만 아니라 증분 백업에서 생략된 블록을 제공하는 데 필요한 모든 이전 백업도 필요합니다. 이 요구 사항에 대한 자세한 내용은 [pg_combinebackup](app-pgcombinebackup.html "pg_combinebackup")을 참조하세요. 클러스터의 체크섬 상태가 변경된 경우 `pg_combinebackup` 사용에 제한이 있습니다. [pg_combinebackup 제한 사항](app-pgcombinebackup.html#APP-PGCOMBINEBACKUP-LIMITATIONS "제한 사항")을 참조하세요.

전체 백업을 사용하기 위한 모든 요구 사항은 증분 백업에도 적용됩니다. 예를 들어 파일 시스템 백업 중 및 이후에 생성된 모든 WAL 세그먼트 파일과 관련 WAL 이력 파일이 여전히 필요합니다. 그리고 [섹션 25.3.5](continuous-archiving.html#BACKUP-PITR-RECOVERY "25.3.5. 연속 아카이브 백업을 사용한 복구")에 설명된 대로 `recovery.signal`(또는 `standby.signal`)을 생성하고 복구를 수행해야 합니다. 복원 시 이전 백업을 사용할 수 있어야 하고 `pg_combinebackup`을 사용해야 하는 요구 사항은 다른 모든 것 위에 추가되는 요구 사항입니다. PostgreSQL에는 나중에 증분 백업을 복원하기 위한 기초로 어떤 백업이 여전히 필요한지 파악하는 내장 메커니즘이 없습니다. 전체 및 증분 백업 간의 관계를 직접 추적하고 나중에 증분 백업을 복원할 때 필요할 수 있는 이전 백업을 제거하지 않도록 해야 합니다.

증분 백업은 일반적으로 데이터의 상당 부분이 변경되지 않거나 천천히 변경되는 비교적 대용량 데이터베이스에만 의미가 있습니다. 소규모 데이터베이스의 경우 증분 백업의 존재를 무시하고 관리하기 더 간단한 전체 백업을 수행하는 것이 더 간단합니다. 모두 크게 수정되는 대용량 데이터베이스의 경우 증분 백업은 전체 백업보다 훨씬 작지 않습니다.

증분 백업은 재생이 이전 백업보다 나중 체크포인트에서 시작하는 경우에만 가능합니다. 프라이머리에서 증분 백업을 수행하면 각 백업이 새 체크포인트를 트리거하므로 이 조건은 항상 충족됩니다. 스탠바이에서는 가장 최근의 재시작 지점에서 재생이 시작됩니다. 따라서 이전 백업 이후 활동이 거의 없었다면 새 재시작 지점이 생성되지 않았을 수 있으므로 스탠바이 서버의 증분 백업이 실패할 수 있습니다.

---

### 25.3.4. 저수준 API를 사용하여 베이스 백업 만들기

[pg_basebackup](app-pgbasebackup.html "pg_basebackup")을 사용하여 전체 또는 증분 베이스 백업을 수행하는 대신 저수준 API를 사용하여 베이스 백업을 수행할 수 있습니다. 이 절차는 pg_basebackup 방법보다 몇 단계가 더 있지만 비교적 간단합니다. 이러한 단계가 순서대로 실행되고 다음 단계로 진행하기 전에 단계의 성공 여부가 확인되는 것이 매우 중요합니다.

여러 백업을 동시에 실행할 수 있습니다 (이 백업 API를 사용하여 시작된 것과 [pg_basebackup](app-pgbasebackup.html "pg_basebackup")을 사용하여 시작된 것 모두).

#### 단계별 절차

1. WAL 아카이빙이 활성화되어 있고 작동하는지 확인합니다.

2. 서버에 연결합니다 (어떤 데이터베이스인지는 중요하지 않음) `pg_backup_start`를 실행할 권한이 있는 사용자(슈퍼유저 또는 함수에 대한 `EXECUTE` 권한이 부여된 사용자)로 다음 명령을 실행합니다:

```sql
SELECT pg_backup_start(label => 'label', fast => false);
```

여기서 `label`은 이 백업 작업을 고유하게 식별하는 데 사용할 문자열입니다. `pg_backup_start`를 호출하는 연결은 백업 끝까지 유지되어야 하며, 그렇지 않으면 백업이 자동으로 중단됩니다.

온라인 백업은 항상 체크포인트 시작 시 시작됩니다. 기본적으로 `pg_backup_start`는 다음 정기 예약된 체크포인트가 완료될 때까지 기다리며 오랜 시간이 걸릴 수 있습니다 (구성 매개변수 [checkpoint_timeout](runtime-config-wal.html#GUC-CHECKPOINT-TIMEOUT) 및 [checkpoint_completion_target](runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET) 참조). 이것은 일반적으로 실행 중인 시스템에 미치는 영향을 최소화하므로 선호됩니다. 가능한 빨리 백업을 시작하려면 두 번째 매개변수로 `true`를 `pg_backup_start`에 전달하면 가능한 한 많은 I/O를 사용하여 가능한 빨리 완료되는 즉시 체크포인트를 요청합니다.

3. 백업을 수행합니다, tar 또는 cpio와 같은 편리한 파일 시스템 백업 도구를 사용합니다 (pg_dump나 pg_dumpall이 아님). 이 작업을 수행하는 동안 데이터베이스의 정상 작업을 중지할 필요도 없고 바람직하지도 않습니다. 이 백업 중에 고려해야 할 사항은 [섹션 25.3.4.1](continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA "25.3.4.1. 데이터 디렉토리 백업")을 참조하세요.

4. 이전과 동일한 연결에서 다음 명령을 실행합니다:

```sql
SELECT * FROM pg_backup_stop(wait_for_archive => true);
```

이것은 백업 모드를 종료합니다. 프라이머리에서는 다음 WAL 세그먼트로 자동 전환도 수행합니다. 스탠바이에서는 WAL 세그먼트를 자동으로 전환할 수 없으므로 수동 전환을 수행하기 위해 프라이머리에서 `pg_switch_wal`을 실행할 수 있습니다. 전환의 이유는 백업 간격 동안 작성된 마지막 WAL 세그먼트 파일이 아카이브될 준비가 되도록 정리하기 위함입니다.

`pg_backup_stop`은 세 가지 값이 있는 하나의 행을 반환합니다. 이러한 필드 중 두 번째는 백업 루트 디렉토리의 `backup_label`이라는 파일에 작성되어야 합니다. 세 번째 필드는 필드가 비어 있지 않은 한 `tablespace_map`이라는 파일에 작성되어야 합니다. 이러한 파일은 백업이 작동하는 데 필수적이며 수정 없이 바이트 단위로 작성되어야 하며 바이너리 모드로 파일을 열어야 할 수 있습니다.

5. 백업 중에 활성화된 WAL 세그먼트 파일이 아카이브되면 완료됩니다. `pg_backup_stop`의 첫 번째 반환 값으로 식별된 파일은 완전한 백업 파일 세트를 구성하는 데 필요한 마지막 세그먼트입니다. 프라이머리에서 `archive_mode`가 활성화되어 있고 `wait_for_archive` 매개변수가 `true`이면 `pg_backup_stop`은 마지막 세그먼트가 아카이브될 때까지 반환하지 않습니다. 스탠바이에서는 `pg_backup_stop`이 대기하려면 `archive_mode`가 `always`여야 합니다. `archive_command` 또는 `archive_library`를 이미 구성했으므로 이러한 파일의 아카이빙은 자동으로 발생합니다. 대부분의 경우 이것은 빠르게 발생하지만 지연이 없는지 확인하기 위해 아카이브 시스템을 모니터링하는 것이 좋습니다. 아카이브 명령이나 라이브러리의 실패로 인해 아카이브 프로세스가 뒤처진 경우 아카이브가 성공하고 백업이 완료될 때까지 계속 재시도합니다. `pg_backup_stop` 실행에 시간 제한을 두려면 적절한 `statement_timeout` 값을 설정하되 이로 인해 `pg_backup_stop`이 종료되면 백업이 유효하지 않을 수 있습니다.

백업 프로세스가 백업에 필요한 모든 WAL 세그먼트 파일이 성공적으로 아카이브되었는지 모니터링하고 확인하는 경우 `wait_for_archive` 매개변수(기본값 true)를 false로 설정하여 `pg_backup_stop`이 중지 백업 레코드가 WAL에 작성되자마자 반환되도록 할 수 있습니다. 기본적으로 `pg_backup_stop`은 모든 WAL이 아카이브될 때까지 기다리며 시간이 걸릴 수 있습니다. 이 옵션은 주의해서 사용해야 합니다: WAL 아카이빙이 올바르게 모니터링되지 않으면 백업에 모든 WAL 파일이 포함되지 않아 불완전하여 복원할 수 없습니다.

#### 25.3.4.1. 데이터 디렉토리 백업

일부 파일 시스템 백업 도구는 복사 중에 파일이 변경되면 경고나 오류를 발생시킵니다. 활성 데이터베이스의 베이스 백업을 수행할 때 이 상황은 정상이며 오류가 아닙니다. 그러나 이러한 종류의 불만을 실제 오류와 구별할 수 있어야 합니다. 예를 들어 일부 버전의 rsync는 "사라진 소스 파일"에 대해 별도의 종료 코드를 반환하며 이 종료 코드를 비오류 사례로 허용하는 드라이버 스크립트를 작성할 수 있습니다. 또한 일부 버전의 GNU tar는 tar가 파일을 복사하는 동안 파일이 잘린 경우 치명적인 오류와 구별할 수 없는 오류 코드를 반환합니다. 다행히 GNU tar 버전 1.16 이상에서는 백업 중에 파일이 변경되면 1로 종료하고 다른 오류의 경우 2로 종료합니다. GNU tar 버전 1.23 이상에서는 경고 옵션 `--warning=no-file-changed --warning=no-file-removed`를 사용하여 관련 경고 메시지를 숨길 수 있습니다.

백업에 데이터베이스 클러스터 디렉토리(예: `/usr/local/pgsql/data`) 아래의 모든 파일이 포함되어 있는지 확인하세요. 이 디렉토리 아래에 있지 않은 테이블스페이스를 사용하는 경우 해당 테이블스페이스도 포함하도록 주의하세요 (그리고 백업 아카이브가 심볼릭 링크를 링크로 아카이브하는지 확인하세요. 그렇지 않으면 복원 시 테이블스페이스가 손상됩니다).

그러나 클러스터의 `pg_wal/` 하위 디렉토리 내의 파일은 백업에서 제외해야 합니다. 이 약간의 조정은 복원 시 실수의 위험을 줄이기 때문에 가치가 있습니다. `pg_wal/`이 클러스터 디렉토리 외부 어딘가를 가리키는 심볼릭 링크인 경우 정리하기 쉬우며 이것은 어차피 성능상의 이유로 일반적인 설정입니다. 또한 실행 중인 postmaster에 대한 정보를 기록하는 `postmaster.pid` 및 `postmaster.opts`를 제외할 수도 있습니다. 이 백업을 결국 사용할 postmaster가 아닙니다. (이러한 파일은 pg_ctl을 혼란스럽게 할 수 있습니다.)

프라이머리에 존재하는 복제 슬롯이 백업의 일부가 되지 않도록 클러스터의 `pg_replslot/` 디렉토리 내의 파일도 백업에서 제외하는 것이 좋습니다. 그렇지 않으면 백업을 사용하여 스탠바이를 생성하면 스탠바이에서 WAL 파일이 무기한 보존될 수 있으며 핫 스탠바이 피드백이 활성화된 경우 프라이머리에서 팽창이 발생할 수 있습니다. 이러한 복제 슬롯을 사용하는 클라이언트가 여전히 스탠바이가 아닌 프라이머리에 연결하고 슬롯을 업데이트하기 때문입니다. 백업이 새 프라이머리 생성에만 사용되는 경우에도 해당 슬롯의 내용은 새 프라이머리가 온라인 상태가 될 때까지 심하게 구식이 될 가능성이 높으므로 복제 슬롯을 복사하는 것은 특히 유용하지 않습니다.

`pg_dynshmem/`, `pg_notify/`, `pg_serial/`, `pg_snapshots/`, `pg_stat_tmp/` 및 `pg_subtrans/` 디렉토리의 내용(디렉토리 자체는 아님)은 postmaster 시작 시 초기화되므로 백업에서 생략할 수 있습니다.

`pgsql_tmp`로 시작하는 모든 파일이나 디렉토리는 백업에서 생략할 수 있습니다. 이러한 파일은 postmaster 시작 시 제거되고 필요에 따라 디렉토리가 다시 생성됩니다.

`pg_internal.init` 파일은 해당 이름의 파일이 발견될 때마다 백업에서 생략할 수 있습니다. 이러한 파일에는 복구 시 항상 다시 빌드되는 관계 캐시 데이터가 포함되어 있습니다.

백업 레이블 파일에는 `pg_backup_start`에 지정한 레이블 문자열과 `pg_backup_start`가 실행된 시간 및 시작 WAL 파일의 이름이 포함되어 있습니다. 혼란이 있는 경우 백업 파일 내부를 살펴보고 덤프 파일이 어떤 백업 세션에서 온 것인지 정확히 확인할 수 있습니다. 테이블스페이스 맵 파일에는 `pg_tblspc/` 디렉토리에 존재하는 심볼릭 링크 이름과 각 심볼릭 링크의 전체 경로가 포함되어 있습니다. 이러한 파일은 단순히 정보용이 아니라 시스템의 복구 프로세스가 올바르게 작동하는 데 필수적입니다.

서버가 중지된 상태에서 백업을 수행할 수도 있습니다. 이 경우 당연히 `pg_backup_start` 또는 `pg_backup_stop`을 사용할 수 없으며 따라서 어떤 백업이 무엇인지 그리고 연관된 WAL 파일이 얼마나 뒤로 가는지 추적하는 것은 사용자에게 달려 있습니다. 일반적으로 위의 연속 아카이빙 절차를 따르는 것이 좋습니다.

---

### 25.3.5. 연속 아카이브 백업을 사용한 복구

좋습니다, 최악의 상황이 발생했고 백업에서 복구해야 합니다. 절차는 다음과 같습니다:

1. 서버가 실행 중이면 중지합니다.

2. 공간이 있다면, 나중에 필요할 경우를 대비하여 전체 클러스터 데이터 디렉토리와 테이블스페이스를 임시 위치에 복사합니다. 이 예방 조치를 위해서는 시스템에 기존 데이터베이스의 두 복사본을 보관할 충분한 여유 공간이 있어야 합니다. 충분한 공간이 없으면 시스템이 다운되기 전에 아카이브되지 않은 WAL 파일을 포함할 수 있으므로 최소한 클러스터의 `pg_wal` 하위 디렉토리의 내용을 저장해야 합니다.

3. 클러스터 데이터 디렉토리 아래의 모든 기존 파일과 하위 디렉토리 및 사용 중인 테이블스페이스의 루트 디렉토리 아래의 모든 파일과 하위 디렉토리를 제거합니다.

4. 전체 백업을 복원하는 경우 데이터베이스 파일을 대상 디렉토리로 직접 복원할 수 있습니다. 올바른 소유권(`root`가 아닌 데이터베이스 시스템 사용자!)과 올바른 권한으로 복원되었는지 확인하세요. 테이블스페이스를 사용하는 경우 `pg_tblspc/`의 심볼릭 링크가 올바르게 복원되었는지 확인해야 합니다.

5. 증분 백업을 복원하는 경우 복원을 수행하는 머신으로 증분 백업과 직접 또는 간접적으로 의존하는 모든 이전 백업을 복원해야 합니다. 이러한 백업은 실행 중인 서버가 결국 위치할 대상 디렉토리가 아닌 별도의 디렉토리에 배치해야 합니다. 이 작업이 완료되면 [pg_combinebackup](app-pgcombinebackup.html "pg_combinebackup")을 사용하여 전체 백업과 모든 후속 증분 백업에서 데이터를 가져와 대상 디렉토리에 합성 전체 백업을 작성합니다. 위와 같이 권한과 테이블스페이스 링크가 올바른지 확인합니다.

6. `pg_wal/`에 있는 모든 파일을 제거합니다; 이것들은 파일 시스템 백업에서 가져온 것이므로 현재보다는 아마도 구식일 것입니다. `pg_wal/`을 전혀 아카이브하지 않았다면 적절한 권한으로 다시 만드세요. 이전에 심볼릭 링크로 설정했다면 다시 심볼릭 링크로 설정하도록 주의하세요.

7. 2단계에서 저장한 아카이브되지 않은 WAL 세그먼트 파일 이 있으면 `pg_wal/`에 복사합니다. (문제가 발생하여 다시 시작해야 하는 경우 수정되지 않은 파일이 있도록 이동하는 것보다 복사하는 것이 좋습니다.)

8. `postgresql.conf`에 복구 구성 설정 을 설정하고 ([섹션 19.5.5](runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY "19.5.5. 아카이브 복구") 참조) 클러스터 데이터 디렉토리에 `recovery.signal` 파일을 생성합니다. 복구가 성공했는지 확신할 때까지 일반 사용자가 연결하지 못하도록 `pg_hba.conf`를 일시적으로 수정할 수도 있습니다.

9. 서버를 시작합니다. 서버는 복구 모드로 들어가 필요한 아카이브된 WAL 파일을 읽기 시작합니다. 외부 오류로 인해 복구가 종료되면 서버를 다시 시작하기만 하면 복구가 계속됩니다. 복구 프로세스가 완료되면 서버는 `recovery.signal`을 제거하고 (나중에 실수로 복구 모드로 다시 들어가는 것을 방지) 정상 데이터베이스 작업을 시작합니다.

10. 데이터베이스의 내용을 검사하여 원하는 상태로 복구되었는지 확인합니다. 그렇지 않으면 1단계로 돌아갑니다. 모든 것이 정상이면 `pg_hba.conf`를 정상으로 복원하여 사용자가 연결할 수 있도록 합니다.

#### 복구 구성

이 모든 것의 핵심 부분은 복구 방법과 복구가 얼마나 진행되어야 하는지 설명하는 복구 구성을 설정하는 것입니다. 반드시 지정해야 하는 것은 `restore_command`로, PostgreSQL에게 아카이브된 WAL 파일 세그먼트를 검색하는 방법을 알려줍니다. `archive_command`와 마찬가지로 이것은 셸 명령 문자열입니다. `%f`는 원하는 WAL 파일의 이름으로 대체되고 `%p`는 WAL 파일을 복사할 경로 이름으로 대체됩니다. (경로 이름은 현재 작업 디렉토리, 즉 클러스터의 데이터 디렉토리를 기준으로 합니다.) 명령에 실제 `%` 문자를 포함해야 하는 경우 `%%`를 작성하세요. 가장 간단한 유용한 명령은 다음과 같습니다:

```bash
restore_command = 'cp /mnt/server/archivedir/%f %p'
```

이것은 `/mnt/server/archivedir` 디렉토리에서 이전에 아카이브된 WAL 세그먼트를 복사합니다. 물론 훨씬 더 복잡한 것을 사용할 수 있으며 운영자에게 적절한 테이프를 마운트하도록 요청하는 셸 스크립트일 수도 있습니다.

명령이 실패 시 0이 아닌 종료 상태를 반환하는 것이 중요합니다. 명령은 아카이브에 없는 파일을 요청하면서 _호출될 것입니다_; 그렇게 요청받으면 0이 아닌 값을 반환해야 합니다. 이것은 오류 조건이 아닙니다. 예외적으로 명령이 신호(데이터베이스 서버 종료의 일부로 사용되는 SIGTERM 제외)에 의해 종료되거나 셸에 의한 오류(예: 명령을 찾을 수 없음)가 발생하면 복구가 중단되고 서버가 시작되지 않습니다.

요청된 파일 중 일부는 WAL 세그먼트 파일이 아닙니다; `.history` 접미사가 있는 파일에 대한 요청도 예상해야 합니다. 또한 `%p` 경로의 기본 이름이 `%f`와 다를 것이라는 점에 유의하세요. 서로 바꿔서 사용할 수 있다고 기대하지 마세요.

아카이브에서 찾을 수 없는 WAL 세그먼트는 `pg_wal/`에서 검색됩니다; 이를 통해 최근에 아카이브되지 않은 세그먼트를 사용할 수 있습니다. 그러나 아카이브에서 사용할 수 있는 세그먼트는 `pg_wal/`의 파일보다 우선적으로 사용됩니다.

일반적으로 복구는 사용 가능한 모든 WAL 세그먼트를 통해 진행되어 데이터베이스를 현재 시점(또는 사용 가능한 WAL 세그먼트가 허용하는 한 가까운 시점)으로 복원합니다. 따라서 정상적인 복구는 "파일을 찾을 수 없음" 메시지로 끝나며 `restore_command` 선택에 따라 정확한 오류 메시지 텍스트가 달라집니다. 복구 시작 시 `00000001.history`와 같은 이름의 파일에 대한 오류 메시지도 볼 수 있습니다. 이것도 정상이며 단순한 복구 상황에서 문제를 나타내지 않습니다; 논의는 [섹션 25.3.6](continuous-archiving.html#BACKUP-TIMELINES "25.3.6. 타임라인")을 참조하세요.

이전 시점으로 복구하려면 (예: 후배 DBA가 메인 트랜잭션 테이블을 삭제하기 직전) 필요한 [중지 지점](runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET "19.5.6. 복구 대상")을 지정하면 됩니다. "복구 대상"으로 알려진 중지 지점을 날짜/시간, 명명된 복원 지점 또는 특정 트랜잭션 ID의 완료로 지정할 수 있습니다. 이 글을 쓰는 시점에서 어떤 트랜잭션 ID를 사용해야 하는지 정확하게 식별하는 데 도움이 되는 도구가 없으므로 날짜/시간 및 명명된 복원 지점 옵션만 매우 사용 가능합니다.

### 참고

중지 지점은 베이스 백업의 종료 시간 이후여야 합니다. 즉, `pg_backup_stop`의 종료 시간입니다. 베이스 백업을 사용하여 해당 백업이 진행 중이던 시간으로 복구할 수 없습니다. (그러한 시간으로 복구하려면 이전 베이스 백업으로 돌아가서 거기에서 앞으로 롤링해야 합니다.)

복구가 손상된 WAL 데이터를 발견하면 해당 지점에서 복구가 중단되고 서버가 시작되지 않습니다. 이 경우 복구가 정상적으로 완료될 수 있도록 손상 지점 이전의 "복구 대상"을 지정하여 복구 프로세스를 처음부터 다시 실행할 수 있습니다. 시스템 충돌이나 WAL 아카이브에 액세스할 수 없게 되는 것과 같은 외부 이유로 복구가 실패하면 복구를 다시 시작하기만 하면 실패한 곳에서 거의 다시 시작됩니다. 복구 다시 시작은 정상 작업에서의 체크포인팅과 매우 유사하게 작동합니다: 서버는 주기적으로 모든 상태를 디스크에 강제하고 `pg_control` 파일을 업데이트하여 이미 처리된 WAL 데이터를 다시 스캔할 필요가 없음을 나타냅니다.

---

### 25.3.6. 타임라인

데이터베이스를 이전 시점으로 복원하는 기능은 시간 여행 및 평행 우주에 관한 공상 과학 이야기와 유사한 몇 가지 복잡성을 만듭니다. 예를 들어 데이터베이스의 원래 이력에서 화요일 저녁 5시 15분에 중요한 테이블을 삭제했지만 수요일 정오까지 실수를 깨닫지 못했다고 가정합니다. 당황하지 않고 백업을 꺼내 화요일 저녁 5시 14분 시점으로 복원하고 다시 가동합니다. 데이터베이스 우주의 _이_ 이력에서는 테이블을 삭제하지 않았습니다. 그러나 나중에 이것이 그다지 좋은 생각이 아니었음을 깨닫고 원래 이력의 수요일 아침 어느 시점으로 돌아가고 싶다고 가정합니다. 데이터베이스가 가동되는 동안 지금 돌아가고 싶은 시간까지 이어지는 일부 WAL 세그먼트 파일을 덮어썼다면 돌아갈 수 없습니다. 따라서 이를 피하려면 특정 시점 복구 후 생성된 WAL 레코드 시리즈를 원래 데이터베이스 이력에서 생성된 것과 구별해야 합니다.

이 문제를 처리하기 위해 PostgreSQL에는 _타임라인_이라는 개념이 있습니다. 아카이브 복구가 완료될 때마다 해당 복구 후 생성된 WAL 레코드 시리즈를 식별하기 위해 새 타임라인이 생성됩니다. 타임라인 ID 번호는 WAL 세그먼트 파일 이름의 일부이므로 새 타임라인은 이전 타임라인에서 생성된 WAL 데이터를 덮어쓰지 않습니다. 예를 들어 WAL 파일 이름 `0000000100001234000055CD`에서 앞의 `00000001`은 16진수의 타임라인 ID입니다. (서버 로그 메시지와 같은 다른 컨텍스트에서는 타임라인 ID가 일반적으로 10진수로 인쇄됩니다.)

실제로 많은 다른 타임라인을 아카이브할 수 있습니다. 이것이 쓸모없는 기능처럼 보일 수 있지만 종종 생명의 은인입니다. 어느 시점으로 복구해야 하는지 정확히 확실하지 않아 여러 번 시행착오로 특정 시점 복구를 수행하여 이전 이력에서 분기할 최적의 위치를 찾아야 하는 상황을 고려하세요. 타임라인이 없으면 이 프로세스는 곧 관리할 수 없는 혼란을 만들어냅니다. 타임라인을 사용하면 이전에 포기한 타임라인 분기의 상태를 포함하여 _이전의 모든_ 상태로 복구할 수 있습니다.

새 타임라인이 생성될 때마다 PostgreSQL은 어떤 타임라인에서 분기되었는지와 언제 분기되었는지를 보여주는 "타임라인 이력" 파일을 생성합니다. 이러한 이력 파일은 여러 타임라인이 포함된 아카이브에서 복구할 때 시스템이 올바른 WAL 세그먼트 파일을 선택할 수 있도록 하는 데 필요합니다. 따라서 WAL 세그먼트 파일과 마찬가지로 WAL 아카이브 영역에 아카이브됩니다. 이력 파일은 작은 텍스트 파일일 뿐이므로 (크기가 큰 세그먼트 파일과 달리) 무기한 보관하는 것이 저렴하고 적절합니다. 원하는 경우 이력 파일에 특정 타임라인이 어떻게 그리고 왜 생성되었는지에 대한 자신의 메모를 기록하는 주석을 추가할 수 있습니다. 이러한 주석은 실험의 결과로 서로 다른 타임라인의 덤불이 있을 때 특히 유용합니다.

복구의 기본 동작은 아카이브에서 찾은 최신 타임라인으로 복구하는 것입니다. 베이스 백업이 수행되었을 때 현재였던 타임라인이나 특정 자식 타임라인으로 복구하려면 (즉, 복구 시도 후 자체적으로 생성된 일부 상태로 돌아가려면) [recovery_target_timeline](runtime-config-wal.html#GUC-RECOVERY-TARGET-TIMELINE)에 `current` 또는 대상 타임라인 ID를 지정해야 합니다. 베이스 백업보다 더 일찍 분기된 타임라인으로는 복구할 수 없습니다.

---

### 25.3.7. 팁과 예제

연속 아카이빙 구성에 대한 몇 가지 팁이 여기에 제공됩니다.

#### 25.3.7.1. 독립형 핫 백업

PostgreSQL의 백업 기능을 사용하여 독립형 핫 백업을 생성할 수 있습니다. 이러한 백업은 특정 시점 복구에 사용할 수 없지만 일반적으로 pg_dump 덤프보다 백업 및 복원이 훨씬 빠릅니다. (또한 pg_dump 덤프보다 훨씬 크므로 일부 경우 속도 이점이 상쇄될 수 있습니다.)

베이스 백업과 마찬가지로 독립형 핫 백업을 생성하는 가장 쉬운 방법은 [pg_basebackup](app-pgbasebackup.html "pg_basebackup") 도구를 사용하는 것입니다. 호출할 때 `-X` 매개변수를 포함하면 백업을 사용하는 데 필요한 모든 write-ahead 로그가 백업에 자동으로 포함되며 백업을 복원하기 위해 특별한 조치가 필요하지 않습니다.

#### 25.3.7.2. 압축된 아카이브 로그

아카이브 스토리지 크기가 우려되는 경우 gzip을 사용하여 아카이브 파일을 압축할 수 있습니다:

```bash
archive_command = 'gzip < %p > /mnt/server/archivedir/%f.gz'
```

그런 다음 복구 중에 gunzip을 사용해야 합니다:

```bash
restore_command = 'gunzip < /mnt/server/archivedir/%f.gz > %p'
```

#### 25.3.7.3. `archive_command` 스크립트

많은 사람들이 `archive_command`를 정의하기 위해 스크립트를 사용하므로 `postgresql.conf` 항목이 매우 간단해 보입니다:

```bash
archive_command = 'local_backup_script.sh "%p" "%f"'
```

아카이빙 프로세스에서 둘 이상의 명령을 사용하려는 경우 별도의 스크립트 파일을 사용하는 것이 좋습니다. 이를 통해 bash나 perl과 같은 인기 있는 스크립팅 언어로 작성된 스크립트 내에서 모든 복잡성을 관리할 수 있습니다.

스크립트 내에서 해결될 수 있는 요구 사항의 예:

- 안전한 원격 데이터 스토리지에 데이터 복사
- 한 번에 하나씩이 아닌 3시간마다 전송되도록 WAL 파일 일괄 처리
- 다른 백업 및 복구 소프트웨어와 인터페이스
- 오류를 보고하기 위해 모니터링 소프트웨어와 인터페이스

#### 팁

`archive_command` 스크립트를 사용할 때 [logging_collector](runtime-config-logging.html#GUC-LOGGING-COLLECTOR)를 활성화하는 것이 바람직합니다. 그러면 스크립트에서 stderr에 작성된 모든 메시지가 데이터베이스 서버 로그에 나타나므로 복잡한 구성이 실패할 경우 쉽게 진단할 수 있습니다.

---

### 25.3.8. 주의사항

이 글을 쓰는 시점에서 연속 아카이빙 기술에는 몇 가지 제한 사항이 있습니다. 이러한 것들은 향후 릴리스에서 수정될 수 있습니다:

- 베이스 백업이 수행되는 동안 [`CREATE DATABASE`](sql-createdatabase.html "CREATE DATABASE") 명령이 실행되고 `CREATE DATABASE`가 복사한 템플릿 데이터베이스가 베이스 백업이 아직 진행 중인 동안 수정되면 해당 수정 사항이 생성된 데이터베이스에도 전파될 수 있습니다. 이것은 물론 바람직하지 않습니다. 이 위험을 피하려면 베이스 백업을 수행하는 동안 템플릿 데이터베이스를 수정하지 않는 것이 좋습니다.

- [`CREATE TABLESPACE`](sql-createtablespace.html "CREATE TABLESPACE") 명령은 리터럴 절대 경로로 WAL 로깅되므로 동일한 절대 경로로 테이블스페이스 생성으로 재생됩니다. WAL이 다른 머신에서 재생되는 경우 이것은 바람직하지 않을 수 있습니다. WAL이 동일한 머신에서 재생되지만 새 데이터 디렉토리로 재생되는 경우에도 위험할 수 있습니다: 재생이 여전히 원래 테이블스페이스의 내용을 덮어씁니다. 이러한 종류의 잠재적 문제를 피하기 위한 가장 좋은 방법은 테이블스페이스를 생성하거나 삭제한 후 새 베이스 백업을 수행하는 것입니다.

기본 WAL 형식은 많은 디스크 페이지 스냅샷을 포함하므로 상당히 방대합니다. 이러한 페이지 스냅샷은 부분적으로 작성된 디스크 페이지를 수정해야 할 수 있으므로 충돌 복구를 지원하도록 설계되었습니다. 시스템 하드웨어 및 소프트웨어에 따라 부분 쓰기의 위험이 무시할 수 있을 정도로 작을 수 있으며, 이 경우 [full_page_writes](runtime-config-wal.html#GUC-FULL-PAGE-WRITES) 매개변수를 사용하여 페이지 스냅샷을 끄면 아카이브된 WAL 파일의 총 볼륨을 크게 줄일 수 있습니다. (그렇게 하기 전에 [28장](wal.html "28장. 신뢰성 및 Write-Ahead 로그")의 참고 사항과 경고를 읽으세요.) 페이지 스냅샷을 끄는 것은 PITR 작업에 WAL 사용을 방해하지 않습니다. 향후 개발 영역은 `full_page_writes`가 켜져 있는 경우에도 불필요한 페이지 복사를 제거하여 아카이브된 WAL 데이터를 압축하는 것입니다. 그동안 관리자는 체크포인트 간격 매개변수를 가능한 한 늘려 WAL에 포함된 페이지 스냅샷 수를 줄일 수 있습니다.

---

## 요약

이 종합적인 문서는 다음을 다룹니다:

1. 개요 - 연속 아카이빙 및 PITR의 목적과 이점
2. WAL 아카이빙 설정 - 구성 매개변수, 아카이브 명령 및 모범 사례
3. 베이스 백업 - 전체 및 증분 백업 생성
4. 저수준 API - pg_backup_start 및 pg_backup_stop을 사용한 수동 백업 절차
5. 복구 절차 - 백업에서 단계별 복구
6. 타임라인 - 여러 복구 시나리오 관리
7. 팁과 예제 - 실용적인 구현 전략
8. 주의사항 - 알려진 제한 사항 및 고려 사항
