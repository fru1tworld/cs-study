# 제28장. 안정성과 Write-Ahead Log (Reliability and the Write-Ahead Log)

> PostgreSQL 18 공식 문서 번역

원문: https://www.postgresql.org/docs/current/wal.html

이 장에서는 Write-Ahead Log에 대한 세부 사항을 포함하여 PostgreSQL의 안정성을 제어하는 방법을 설명합니다.

---

## 목차

- [28.1. 안정성 (Reliability)](#281-안정성-reliability)
- [28.2. 데이터 체크섬 (Data Checksums)](#282-데이터-체크섬-data-checksums)
  - [28.2.1. 오프라인 체크섬 활성화](#2821-오프라인-체크섬-활성화)
- [28.3. Write-Ahead Logging (WAL)](#283-write-ahead-logging-wal)
- [28.4. 비동기 커밋 (Asynchronous Commit)](#284-비동기-커밋-asynchronous-commit)
- [28.5. WAL 구성 (WAL Configuration)](#285-wal-구성-wal-configuration)
- [28.6. WAL 내부 구조 (WAL Internals)](#286-wal-내부-구조-wal-internals)

---

## 28.1. 안정성 (Reliability)

안정성은 모든 심각한 데이터베이스 시스템의 중요한 속성이며, PostgreSQL은 모든 커밋된 트랜잭션의 데이터가 정전, 운영 체제 장애, 하드웨어 장애(물론 저장 영역 자체의 장애 제외)로부터 안전한 비휘발성 영역에 저장되도록 보장합니다. 이 보장을 위해 데이터를 영구적으로 저장하기 위한 컴퓨터의 영구 저장소(디스크 드라이브 또는 동등한 장치)에 쓰기가 성공적으로 수행되어야 합니다.

### 캐싱 아키텍처의 도전

PostgreSQL은 메인 메모리와 디스크 플래터 사이의 여러 캐시 레이어를 탐색해야 합니다:

#### 운영 체제 버퍼 캐시

- 자주 요청되는 디스크 블록을 캐시하고 쓰기를 결합합니다.
- PostgreSQL은 운영 체제 기능을 사용하여 버퍼 캐시에서 디스크로 쓰기를 강제합니다.
- `wal_sync_method` 파라미터로 제어됩니다.

#### 디스크 컨트롤러 캐시

RAID 컨트롤러에서 일반적입니다:

- Write-through: 쓰기를 즉시 드라이브로 전송합니다.
- Write-back: 나중에 데이터를 드라이브로 전송합니다 (휘발성 메모리의 안정성 위험).
- 배터리 백업 장치(BBU): 시스템 장애 시 캐시 전원을 유지하여 데이터 손실을 방지합니다.

#### 디스크 드라이브 캐시

- 일부는 write-through, 다른 일부는 write-back입니다.
- 소비자용 IDE 및 SATA 드라이브는 정전 시 생존하지 못하는 write-back 캐시를 가지는 경향이 있습니다.
- 많은 SSD는 휘발성 write-back 캐시를 가지고 있습니다.

### 운영 체제별 쓰기 캐시 비활성화

#### Linux

```bash
# IDE/SATA 드라이브 - 쓰기 캐싱 상태 확인
hdparm -I /dev/sdX

# 쓰기 캐싱 비활성화
hdparm -W 0 /dev/sdX

# SCSI 드라이브 - 상태 확인
sdparm --get=WCE /dev/sdX

# SCSI에서 쓰기 캐시 비활성화
sdparm --clear=WCE /dev/sdX
```

#### FreeBSD

- IDE: `camcontrol identify` (쿼리); `/boot/loader.conf`에서 `hw.ata.wc=0` (비활성화)
- SCSI: `camcontrol identify` (쿼리); 사용 가능한 경우 `sdparm` (쿼리/변경)

#### Solaris

```bash
format -e
```

참고: ZFS 파일 시스템은 자체 캐시 플러시 명령을 사용하므로 디스크 쓰기 캐시가 활성화되어도 안전합니다.

#### Windows

- `wal_sync_method`가 `open_datasync`(기본값)인 경우: `내 컴퓨터\디스크 드라이브 열기\속성\하드웨어\속성\정책\디스크에 쓰기 캐싱 사용` 체크 해제
- 또는 `wal_sync_method`를 `fdatasync`(NTFS 전용) 또는 `fsync`로 설정하여 쓰기 캐싱 방지

#### macOS

```
wal_sync_method를 fsync_writethrough로 설정
```

### 드라이브 캐시 플러시 명령

- SATA 드라이브 (ATAPI-6 이상): `FLUSH CACHE EXT` 명령 지원
- SCSI 드라이브: `SYNCHRONIZE CACHE` 명령 지원
- 이러한 명령은 PostgreSQL에서 직접 접근할 수 없지만 일부 파일 시스템(ZFS, ext4)에서 사용합니다.
- 주의: BBU 컨트롤러와의 비최적 동작 - 동기화 명령이 컨트롤러 캐시의 모든 데이터를 디스크로 강제하여 BBU의 이점을 제거합니다.

#### 테스트 도구

```bash
pg_test_fsync
```

이 프로그램을 사용하여 시스템이 BBU/쓰기 장벽 문제의 영향을 받는지 확인하세요.

### 관리자의 책임

1. 모든 저장 구성 요소가 데이터 및 파일 시스템 메타데이터의 무결성을 보장하는지 확인
2. 배터리 백업이 없는 쓰기 캐시가 있는 디스크 컨트롤러 사용 자제
3. 드라이브 수준에서: 드라이브가 종료 전 쓰기를 보장할 수 없는 경우 write-back 캐싱 비활성화
4. SSD의 경우: 많은 SSD가 기본적으로 캐시 플러시 명령을 준수하지 않음
5. I/O 서브시스템 안정성을 테스트: [`diskchecker.pl`](https://brad.livejournal.com/2116715.html)

### 부분 페이지 쓰기 보호

#### 문제점

- 디스크 플래터는 512바이트 섹터로 나뉩니다.
- 쓰기 요청은 여러 섹터에 걸칠 수 있습니다 (PostgreSQL은 일반적으로 8192바이트 = 16섹터 쓰기).
- 쓰기 중 정전으로 작업이 부분적으로 완료될 수 있습니다.

#### PostgreSQL 솔루션

- 실제 디스크 페이지를 수정하기 전에 주기적으로 전체 페이지 이미지를 WAL에 씁니다.
- 충돌 복구 중 부분적으로 쓰여진 페이지는 WAL에서 복원됩니다.
- `full_page_writes` 파라미터로 제어됩니다.

참고: ZFS 또는 부분 페이지 쓰기를 방지하는 유사한 파일 시스템에서는 비활성화할 수 있습니다. BBU 컨트롤러는 데이터가 전체 8kB 페이지로 쓰여지도록 보장하지 않는 한 부분 페이지 쓰기를 방지하지 않습니다.

### 데이터 손상 보호

#### WAL 레코드 보호

- 각 WAL 파일 레코드는 CRC-32C (32비트) 체크섬으로 보호됩니다.
- CRC는 충돌 복구, 아카이브 복구, 복제 중에 검증됩니다.

#### 데이터 페이지 보호

- 데이터 페이지는 기본적으로 체크섬됩니다.
- WAL 레코드의 전체 페이지 이미지는 항상 체크섬으로 보호됩니다.

#### 내부 데이터 구조 커버리지

- 직접 체크섬되지 않음: `pg_xact`, `pg_subtrans`, `pg_multixact`, `pg_serial`, `pg_notify`, `pg_stat`, `pg_snapshots`
- 전체 페이지 쓰기로 보호되지 않음: 동일한 내부 구조
- 보호 방법: WAL 레코드를 통해 충돌 복구 시 정확한 재구축 허용 (WAL 레코드 자체는 보호됨)

#### 2단계 커밋 파일

- `pg_twophase`의 개별 상태 파일은 CRC-32C 로 보호됩니다.

#### 임시 데이터 파일

- 대규모 SQL 쿼리 (정렬, 구체화, 중간 결과)
- 현재 체크섬되지 않으며 WAL 레코드도 쓰여지지 않습니다.

### 메모리 오류 보호

PostgreSQL은 수정 가능한 메모리 오류에 대해 보호하지 않습니다. 시스템이 다음을 사용할 것으로 가정합니다:
- 산업 표준 오류 수정 코드(ECC) RAM
- 또는 더 나은 보호 표준

---

## 28.2. 데이터 체크섬 (Data Checksums)

기본적으로 데이터 페이지는 체크섬으로 보호되지만, 이 보호는 클러스터에 대해 선택적으로 비활성화할 수 있습니다. 활성화된 경우:

- 각 데이터 페이지에는 페이지가 쓰여질 때 업데이트되는 체크섬이 포함됩니다.
- 페이지가 읽힐 때마다 체크섬이 검증됩니다.
- 데이터 페이지만 보호됩니다; 내부 데이터 구조와 임시 파일은 보호되지 않습니다.

### 체크섬 활성화/비활성화

#### 클러스터 초기화 중

`--data-checksums` 플래그와 함께 [`initdb`](https://www.postgresql.org/docs/current/app-initdb.html#APP-INITDB-DATA-CHECKSUMS) 명령을 사용하여 클러스터 초기화 시 체크섬을 비활성화할 수 있습니다.

#### 오프라인 작업

나중에 [`pg_checksums`](https://www.postgresql.org/docs/current/app-pgchecksums.html) 애플리케이션을 사용하여 오프라인 작업으로 체크섬을 활성화하거나 비활성화할 수 있습니다.

중요한 제한 사항:

- 데이터 체크섬은 전체 클러스터 수준 에서 활성화 또는 비활성화됩니다.
- 개별 데이터베이스나 테이블에 대해 지정할 수 없습니다.

### 체크섬 상태 확인

읽기 전용 구성 변수를 확인하여 클러스터의 현재 체크섬 상태를 볼 수 있습니다:

```sql
SHOW data_checksums;
```

### 구성 파라미터

#### `data_checksums`

- 타입: 읽기 전용 부울 구성 변수
- 목적: 클러스터에 대해 데이터 체크섬이 활성화되어 있는지 표시

#### `ignore_checksum_failure`

- 타입: 구성 파라미터
- 목적: 페이지 손상에서 복구를 시도할 때 체크섬 보호를 우회하기 위해 임시로 이 파라미터를 설정

### 28.2.1. 오프라인 체크섬 활성화

`pg_checksums` 도구를 사용하여 오프라인 클러스터에서 체크섬을 활성화, 비활성화 또는 검증할 수 있습니다.

```bash
# 체크섬 활성화
pg_checksums --enable -D /path/to/data

# 체크섬 비활성화
pg_checksums --disable -D /path/to/data

# 체크섬 검증
pg_checksums --check -D /path/to/data
```

---

## 28.3. Write-Ahead Logging (WAL)

Write-Ahead Logging (WAL) 은 데이터 무결성을 보장하기 위한 표준 방법입니다. 자세한 설명은 대부분의 데이터베이스 시스템에 대한 거의 모든 책(또는 소스)에서 찾을 수 있습니다.

### 핵심 개념

WAL의 핵심 원칙은 데이터 파일에 대한 변경은 해당 변경 사항이 로그된 후에만 쓰여져야 한다 는 것입니다. 구체적으로:

- 변경 사항을 설명하는 WAL 레코드가 먼저 영구 저장소로 플러시되어야 합니다.
- 모든 트랜잭션 커밋 시 데이터 페이지를 디스크로 플러시할 필요가 없습니다.
- 충돌 시 로그를 사용하여 데이터베이스를 복구할 수 있습니다.
- 커밋되지 않은 변경 사항은 WAL 레코드에서 다시 실행됩니다 (롤포워드 복구, REDO 라고도 함).

### 주요 이점

#### 1. 디스크 I/O 감소

- 트랜잭션 커밋을 보장하기 위해 WAL 파일만 디스크로 플러시하면 됩니다.
- WAL 파일은 순차적으로 쓰여지므로 동기화 작업이 여러 데이터 페이지를 플러시하는 것보다 훨씬 저렴합니다.
- 여러 개의 작은 동시 트랜잭션이 WAL 파일의 단일 `fsync`로 커밋될 수 있습니다.

#### 2. 온라인 백업 및 특정 시점 복구 (PITR)

- 온라인 백업 기능을 활성화합니다.
- 사용 가능한 WAL 데이터가 커버하는 모든 시간 순간으로 되돌리기를 지원합니다.
- 물리적 백업은 일정 기간에 걸쳐 수행할 수 있으며; WAL 재생으로 내부 불일치를 수정합니다.
- 프로세스: 이전 물리적 백업 설치 + 원하는 시간까지 WAL 재생

### 파일 시스템 고려 사항

#### 중요한 팁

- 저널링 파일 시스템은 필요하지 않습니다 안정적인 WAL/데이터 파일 저장소에
- 저널링 오버헤드는 성능을 저하시킬 수 있습니다 (특히 데이터 플러싱)
- 저널링 중 데이터 플러싱은 종종 마운트 옵션으로 비활성화할 수 있습니다
  - 예: Linux ext3에서 `data=writeback`
- 저널링 파일 시스템은 충돌 후 부팅 속도를 향상시킵니다.

---

## 28.4. 비동기 커밋 (Asynchronous Commit)

비동기 커밋 은 WAL(Write-Ahead Log) 레코드가 디스크로 플러시되기 전에 성공을 반환하여 트랜잭션이 더 빨리 완료될 수 있게 하는 선택적 모드입니다. 데이터베이스가 충돌할 경우 잠재적인 데이터 손실이 발생할 수 있습니다.

### 주요 특성

#### 일반(동기) 커밋

- 서버는 WAL 레코드가 영구 저장소로 플러시될 때까지 대기합니다.
- 클라이언트는 데이터가 내구적으로 쓰여진 후에만 성공 확인을 받습니다.
- 즉시 서버 충돌이 발생해도 트랜잭션 보존을 보장합니다.
- 특히 짧은 트랜잭션의 경우 지연 시간이 발생합니다.

#### 비동기 커밋

- 서버는 논리적 트랜잭션 완료 직후 성공을 반환합니다.
- WAL 레코드가 아직 디스크에 도달하지 않았습니다.
- 작은 트랜잭션에 대해 상당한 처리량 향상을 제공합니다.
- 데이터 손실에 대한 위험 창을 만듭니다.

### 데이터 손실 vs 손상

- 위험: 데이터 손실 (손상이 아님)
- 데이터베이스 복구는 마지막으로 플러시된 레코드까지 WAL을 재생합니다.
- 자체 일관성 있는 상태로 복원되지만, 플러시되지 않은 트랜잭션은 손실됩니다.
- 트랜잭션은 커밋 순서대로 재생됩니다 - 불일치가 발생하지 않습니다.

### 구성

#### 기본 파라미터

`synchronous_commit` - 커밋 모드를 제어하는 사용자 설정 가능 파라미터

- 다른 구성 파라미터처럼 변경할 수 있습니다.
- 변경 후 시작된 트랜잭션에 적용됩니다.
- 동시에 동기 및 비동기 트랜잭션을 혼합할 수 있습니다.

```sql
-- 현재 세션에서 비동기 커밋 활성화
SET synchronous_commit = off;

-- 기본 동기 커밋으로 되돌리기
SET synchronous_commit = on;
```

#### 위험 창 기간

- 백그라운드 WAL 작성자 프로세스에 의해 제한됩니다.
- `wal_writer_delay` 밀리초마다 쓰여지지 않은 레코드를 플러시합니다.
- 최대 위험 창: 3 x `wal_writer_delay` (바쁜 기간 동안 일괄 페이지 쓰기)

### 중요한 예외

`synchronous_commit` 설정과 관계없이 다음 명령은 항상 동기적으로 커밋 됩니다:

- 유틸리티 명령 (예: `DROP TABLE`)
- 2단계 커밋 명령 (예: `PREPARE TRANSACTION`)

이는 파일 시스템과 데이터베이스 논리적 상태 간의 일관성을 보장합니다.

### 경고

> 주의: 즉시 모드 종료는 서버 충돌과 동일하며 플러시되지 않은 비동기 커밋의 손실을 초래합니다.

### 다른 설정과의 비교

#### vs `fsync = off`

| 특성 | `synchronous_commit = off` | `fsync = off` |
|------|---------------------------|---------------|
| 범위 | 트랜잭션별 | 서버 전체 |
| 손상 위험 | 없음 | 있음 |
| 데이터 손실 위험 | 최근 트랜잭션 | 전체 데이터베이스 |
| 복구 | 자체 일관성 상태 | 임의의 손상 가능 |

#### vs `commit_delay`

- `commit_delay`는 동기 커밋 방법 입니다 (비동기 커밋 중 무시됨).
- 트랜잭션이 WAL을 플러시하기 전에 지연을 추가하여 여러 트랜잭션을 일괄 처리하기를 희망합니다.
- 플러시 비용을 상각하기 위해 단일 플러시에서 트랜잭션을 그룹화합니다.

### 사용 사례

#### 비동기 커밋에 적합한 경우:

- 이벤트 로깅
- 중요하지 않은 데이터
- 최근 트랜잭션 손실을 허용하는 애플리케이션

#### 적합하지 않은 경우:

- 금융 트랜잭션 (예: ATM 현금 인출)
- 강력한 내구성 보장이 필요한 모든 시나리오
- 클라이언트가 커밋 확인을 기반으로 외부 작업을 수행하는 경우

---

## 28.5. WAL 구성 (WAL Configuration)

WAL(Write-Ahead Log) 구성은 데이터베이스 성능과 안정성에 영향을 미치는 파라미터를 제공합니다. 이 섹션에서는 체크포인트 관리, WAL 버퍼 처리 및 복구 최적화를 다룹니다.

### 핵심 개념

#### 체크포인트

정의: 힙 및 인덱스 데이터 파일이 해당 체크포인트 이전에 쓰여진 모든 정보로 업데이트됨이 보장되는 트랜잭션 시퀀스의 지점.

체크포인트 프로세스:

1. 모든 더티 데이터 페이지가 디스크로 플러시됩니다.
2. 특수 체크포인트 레코드가 WAL 파일에 쓰여집니다.
3. 충돌 후 복구는 최신 체크포인트 레코드(redo 레코드)에서 시작됩니다.
4. redo 레코드 이전의 WAL 세그먼트는 재활용되거나 제거될 수 있습니다.

성능 영향: 모든 더티 데이터 페이지를 플러시하면 상당한 I/O 부하가 발생합니다; 체크포인트 활동은 체크포인트 간격에 걸쳐 I/O를 분산하도록 조절됩니다.

### 구성 파라미터

#### 체크포인트 타이밍 파라미터

| 파라미터 | 기본값 | 설명 |
|---------|--------|------|
| `checkpoint_timeout` | 5분 | N초마다 체크포인트 시작 |
| `max_wal_size` | 1 GB | 초과할 것 같으면 체크포인트 시작 |
| `checkpoint_warning` | (설정 안 됨) | 체크포인트가 N초보다 가깝게 발생하면 경고 로깅 |
| `checkpoint_completion_target` | 0.9 | I/O를 분산할 체크포인트 간격의 비율 (0-1.0) |
| `checkpoint_flush_after` | (다양) | N바이트 후 OS 페이지 플러시 강제 (Linux/POSIX 전용) |

참고: 이전 체크포인트 이후 WAL이 쓰여지지 않았다면 `checkpoint_timeout`이 지나도 체크포인트가 건너뛰어집니다.

#### 체크포인트 로직

체크포인트는 다음 중 먼저 발생하는 것에 의해 트리거됩니다:

- `checkpoint_timeout` 초가 경과
- `max_wal_size`를 초과할 것 같음
- 수동 `CHECKPOINT` SQL 명령

#### WAL 파일 관리 파라미터

| 파라미터 | 설명 |
|---------|------|
| `min_wal_size` | 향후 사용을 위해 재활용되는 최소 WAL 파일 양 |
| `max_wal_size` | 이전 세그먼트가 제거되기 전 최대 WAL 크기 |
| `wal_keep_size` | 최근 WAL 파일을 최소 N 메가바이트와 하나의 추가 파일 유지 |

WAL 세그먼트 재활용 로직:

- 시스템은 다음 체크포인트까지 예상 필요량을 커버할 충분한 WAL 파일을 재활용합니다.
- 이전 체크포인트 사이클에서 사용된 WAL 파일의 이동 평균을 기반으로 합니다.
- `max_wal_size`를 초과하면 불필요한 세그먼트가 제거됩니다.
- `min_wal_size`는 유휴 상태에서도 최소 재활용 WAL을 보장합니다.

#### WAL 버퍼 파라미터

| 파라미터 | 기본값 | 설명 |
|---------|--------|------|
| `wal_buffers` | ~16 MB | 공유 메모리의 WAL 버퍼용 디스크 페이지 수 |
| `full_page_writes` | on | 체크포인트 후 첫 번째 수정 시 전체 페이지 내용 로깅 |

튜닝 권장 사항: 높은 WAL 출력 시스템에서 `wal_buffers`를 증가시켜 배타적 잠금을 유지하면서 `XLogInsertRecord`가 버퍼 쓰기를 강제하는 것을 방지하세요.

#### 그룹 커밋 파라미터

| 파라미터 | 기본값 | 설명 |
|---------|--------|------|
| `commit_delay` | 0 마이크로초 | XLogFlush에서 잠금 획득 후 리더 대기 시간, 팔로워가 큐에 들어갈 수 있도록 함 |
| `commit_siblings` | 5 | commit_delay 대기를 트리거하는 데 필요한 최소 동시 트랜잭션 |
| `fsync` | on | WAL 플러싱을 위한 fsync 활성화 |

최적화 참고:

- `commit_delay`는 `pg_test_fsync`가 8kB 쓰기에 대해 보고하는 평균 시간의 약 절반이어야 합니다.
- 고지연 회전 디스크에서 유용하며 SSD/RAID 어레이에도 이점이 있을 수 있습니다.
- 너무 높게 설정하면 트랜잭션 지연 시간이 증가합니다.
- 0에서도 더 높은 클라이언트 수에서 자연스럽게 그룹 커밋이 발생합니다.

#### WAL 동기화 파라미터

| 파라미터 | 설명 |
|---------|------|
| `wal_sync_method` | PostgreSQL이 WAL 업데이트를 디스크에 강제하는 방법 (fsync, fdatasync, open_sync, open_datasync, fsync_writethrough) |
| `track_wal_io_timing` | pg_stat_io에서 쓰기 및 fsync 시간 추적 |

테스트: `pg_test_fsync` 프로그램을 사용하여 플러시 작업 속도를 측정하고 다른 `wal_sync_method` 옵션을 비교하세요.

#### 복구 파라미터

| 파라미터 | 기본값 | 설명 |
|---------|--------|------|
| `recovery_prefetch` | try | 복구 중 디스크 블록 미리 읽기 활성화 |
| `maintenance_io_concurrency` | (다양) | 프리페치 동시성 제한 |
| `wal_decode_buffer_size` | (다양) | 프리페치 거리 제한 |
| `wal_debug` | off | 각 XLogInsertRecord 및 XLogFlush 호출 로깅 (개발 빌드 전용) |

### 재시작점 (아카이브/대기 모드)

정의: 체크포인트와 유사하지만 아카이브 복구 또는 대기 모드 중에 발생합니다.

특성:

- 모든 상태를 디스크에 강제합니다.
- `pg_control` 파일을 업데이트합니다.
- 이전 WAL 세그먼트 파일을 재활용합니다.
- 체크포인트 레코드에서만 수행할 수 있습니다.
- 한 체크포인트 사이클 분량의 WAL만큼 `max_wal_size`를 초과할 수 있습니다.

모니터링 뷰: `pg_stat_checkpointer` 뷰 카운터:

- `restartpoints_timed`: 스케줄 트리거된 재시작점
- `restartpoints_req`: 요청 트리거된 재시작점
- `restartpoints_done`: 실제로 수행된 재시작점

### 성능 권장 사항

#### 체크포인트 간격 튜닝

- 빠른 복구: `checkpoint_timeout` 및/또는 `max_wal_size` 감소 (더 자주 체크포인트 발생)
- 트레이드오프: 더 자주 체크포인트는 전체 페이지 쓰기로 인해 I/O 및 WAL 볼륨 증가
- 건전성 확인: `checkpoint_warning`을 사용하여 체크포인트가 너무 자주 발생하는지 확인

#### 체크포인트 I/O 분산

- 모범 사례: `checkpoint_completion_target`을 0.9(기본값)로 유지
- 권장하지 않음: 1.0으로 설정하면 체크포인트가 늦게 완료되고 가변적인 WAL 세그먼트 필요
- 대안: 복구 시간이 우려된다면 더 자주 체크포인트를 위해 `checkpoint_timeout` 감소

#### 고지연 저장소

- `commit_delay`를 `pg_test_fsync`가 보고하는 시간의 약 절반으로 설정
- 더 높은 `commit_siblings` 값 사용
- 두 명의 클라이언트만으로도 상당한 처리량 이점 가능

#### 디스크 공간 관리

- 항상 여유 공간 유지; `max_wal_size`는 하드 리밋이 아님
- WAL 아카이빙 또는 복제 슬롯이 따라가지 못하는지 모니터링
- WAL 쓰기 및 fsync 통계를 위해 `pg_stat_io` 확인

### WAL 아카이빙 고려 사항

WAL 아카이빙이 활성화된 경우:

- 이전 세그먼트는 아카이빙될 때까지 제거되거나 재활용될 수 없습니다.
- 아카이빙이 뒤처지면 WAL 파일이 `pg_wal`에 축적됩니다.
- 복제 슬롯을 사용하는 느리거나 실패한 대기 서버도 비슷한 영향을 미칩니다.
- WAL 요약화(활성화된 경우)도 요약될 때까지 이전 세그먼트를 유지합니다.
- 아카이브 빈도에 하한을 두려면 `archive_timeout` 사용 (체크포인트 파라미터가 아님)

---

## 28.6. WAL 내부 구조 (WAL Internals)

WAL은 PostgreSQL에서 자동으로 활성화됩니다. 관리자는 WAL 파일을 위한 적절한 디스크 공간을 확보하고 필요한 튜닝만 수행하면 됩니다 (Section 28.5 참조).

### 핵심 개념

#### 로그 시퀀스 번호 (LSN)

- WAL 레코드는 WAL 파일에 순차적으로 추가됩니다.
- 삽입 위치는 로그 시퀀스 번호(LSN) 로 설명됩니다 - WAL로의 바이트 오프셋
- LSN은 새 레코드마다 단조 증가합니다.
- 데이터 타입: `pg_lsn`
- 용도: 복제 및 복구 진행 측정, 지점 간 WAL 데이터 볼륨 비교

### WAL 파일 저장 구조

위치: 데이터 디렉토리 아래 `pg_wal` 디렉토리

세그먼트 구성:

- 세그먼트 파일: 일반적으로 각 16 MB (`initdb`의 `--wal-segsize` 옵션으로 구성 가능)
- 각 세그먼트는 페이지로 나뉨: 일반적으로 각 8 kB (`--with-wal-blocksize` configure 옵션으로 구성 가능)
- 명명: `000000010000000000000001`부터 시작하는 계속 증가하는 숫자
- 숫자는 순환하지 않음; 사용 가능한 숫자를 소진하는 데 극도로 오랜 시간이 걸림

레코드 헤더:

- `access/xlogrecord.h`에 설명됨
- 내용은 로깅되는 이벤트 유형에 따라 다름

### 성능 최적화

디스크 배치:

WAL은 이상적으로 메인 데이터베이스 파일과 다른 디스크에 위치해야 합니다. 다음과 같이 달성할 수 있습니다:

1. 서버 종료
2. `pg_wal` 디렉토리를 다른 위치로 이동
3. 원래 위치에서 새 위치로 심볼릭 링크 생성

```bash
# 예시
pg_ctl stop -D /path/to/data
mv /path/to/data/pg_wal /new/disk/pg_wal
ln -s /new/disk/pg_wal /path/to/data/pg_wal
pg_ctl start -D /path/to/data
```

### 안정성 고려 사항

#### 데이터 무결성 위험

- WAL은 데이터베이스 레코드가 변경되기 전에 로그가 쓰여지도록 하는 것을 목표로 합니다.
- 위험: 디스크 드라이브가 데이터가 캐시에만 있고 아직 지속되지 않았을 때 성공적인 쓰기를 거짓으로 보고할 수 있음
- 이러한 경우 정전은 복구 불가능한 데이터 손상을 유발할 수 있음
- 권장 사항: PostgreSQL WAL 파일을 보유하는 디스크가 거짓 쓰기 보고를 하지 않도록 보장 (Section 28.1 참조)

#### 복구 프로세스

1. 서버가 시작 시 `pg_control` 파일을 읽음
2. `pg_control`에서 체크포인트 레코드를 읽음
3. 체크포인트 레코드의 WAL 위치에서 앞으로 스캔하여 REDO 작업 수행
4. 체크포인트 이후 변경된 모든 페이지를 일관된 상태로 복원 (`full_page_writes`가 활성화되었다고 가정)

#### pg_control 보호 장치

- 체크포인트 위치는 체크포인트 및 WAL 플러시 후 `pg_control`에 저장됨
- 파일 크기: 하나의 디스크 페이지 미만 (부분 쓰기 문제의 대상이 아님)
- 참고: `pg_control` 손상 시 최신 체크포인트를 찾기 위한 WAL 세그먼트 역방향 스캔은 구현되지 않음
- 실제로: `pg_control` 자체를 읽을 수 없어서 발생한 데이터베이스 장애 보고 없음
- 상태: 이론적으로 약점이지만 실제 문제로 보이지 않음

### 내부 WAL 함수

- `XLogInsertRecord`: WAL 버퍼에 새 레코드 배치 (배타적 잠금을 가진 모든 저수준 수정에서)
- `XLogFlush`: WAL 버퍼 쓰기 및 플러시 (일반적으로 트랜잭션 커밋 시)
- `XLogWrite`: WAL 버퍼를 디스크에 쓰기
- `issue_xlog_fsync`: WAL 파일을 디스크에 동기화

---

## 요약

### WAL의 핵심 이점

1. 데이터 무결성: 충돌 시에도 커밋된 트랜잭션 보존
2. 성능 향상: 순차적 WAL 쓰기로 랜덤 I/O 감소
3. 복구 능력: 특정 시점 복구 (PITR) 지원
4. 복제 기반: 스트리밍 복제 및 논리적 복제의 기초

### 주요 구성 고려 사항

| 목표 | 권장 설정 |
|------|----------|
| 빠른 복구 | 낮은 `checkpoint_timeout`, 낮은 `max_wal_size` |
| 높은 처리량 | 높은 `wal_buffers`, 적절한 `commit_delay` |
| 데이터 안정성 | `synchronous_commit = on`, `fsync = on` |
| 성능 우선 | `synchronous_commit = off` (중요하지 않은 데이터) |

### 모니터링 뷰

```sql
-- 체크포인트 통계
SELECT * FROM pg_stat_checkpointer;

-- WAL I/O 통계
SELECT * FROM pg_stat_io WHERE backend_type = 'walwriter';

-- 복제 상태
SELECT * FROM pg_stat_replication;
```

---

## 참고

- Section 25.3: 연속 아카이빙 및 특정 시점 복구
- Section 26.2.5: 스트리밍 복제
- Section 28.1: 안정성
- Section 28.5: WAL 구성
- pg_test_fsync: WAL 동기화 성능 테스트 도구
- pg_checksums: 오프라인 체크섬 관리 도구
