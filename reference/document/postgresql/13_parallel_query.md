# Chapter 15. 병렬 쿼리 (Parallel Query)

PostgreSQL은 여러 CPU를 활용하여 쿼리에 더 빠르게 응답하는 쿼리 계획을 수립할 수 있습니다. 이 기능을 병렬 쿼리(parallel query) 라고 합니다.

많은 쿼리는 병렬 쿼리의 이점을 얻을 수 없습니다. 이는 현재 구현의 제한 사항이거나 쿼리를 순차적으로 실행하는 것보다 병렬 쿼리 계획을 생성하는 것이 더 빠를 것으로 예상되는 쿼리 계획이 없기 때문입니다. 그러나 이 기능의 이점을 얻을 수 있는 쿼리의 경우, 병렬 쿼리로 인한 속도 향상은 상당합니다. 많은 쿼리가 2배 이상 빨라지며, 일부는 4배 이상 빨라집니다. 대량의 데이터를 처리하지만 사용자에게 적은 수의 행만 반환하는 쿼리가 일반적으로 가장 큰 이점을 얻습니다. 이 장에서는 병렬 쿼리가 언제 사용될 수 있는지 이해하고 최대한 효과적으로 활용하는 방법을 설명합니다.

## 목차

- [15.1. 병렬 쿼리의 작동 방식](#151-병렬-쿼리의-작동-방식)
- [15.2. 병렬 쿼리를 사용할 수 있는 경우](#152-병렬-쿼리를-사용할-수-있는-경우)
- [15.3. 병렬 계획](#153-병렬-계획)
  - [15.3.1. 병렬 스캔](#1531-병렬-스캔)
  - [15.3.2. 병렬 조인](#1532-병렬-조인)
  - [15.3.3. 병렬 집계](#1533-병렬-집계)
  - [15.3.4. Parallel Append](#1534-parallel-append)
  - [15.3.5. 병렬 계획 팁](#1535-병렬-계획-팁)
- [15.4. 병렬 안전성](#154-병렬-안전성)
  - [15.4.1. 함수 및 집계에 대한 병렬 라벨링](#1541-함수-및-집계에-대한-병렬-라벨링)

---

## 15.1. 병렬 쿼리의 작동 방식

옵티마이저가 특정 쿼리에 대해 병렬 쿼리가 가장 빠른 실행 전략이라고 판단하면, Gather 또는 Gather Merge 노드를 포함하는 쿼리 계획을 생성합니다. 다음은 간단한 예제입니다:

```sql
EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN
-------------------------------------------------------------------
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   ->  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)
```

### Gather 및 Gather Merge 노드

모든 경우에 `Gather` 또는 `Gather Merge` 노드는 정확히 하나의 자식 계획을 가지며, 이 계획은 병렬로 실행되는 계획의 일부입니다. `Gather` 또는 `Gather Merge` 노드가 계획 트리의 최상위에 있으면 전체 쿼리가 병렬로 실행됩니다. 다른 곳에 있으면 해당 노드 아래 부분만 병렬로 실행됩니다.

### 워커 프로세스 관리

위의 예제에서 `Gather` 노드 아래에는 정확히 하나의 자식 계획이 있으므로, 쿼리의 병렬 부분을 실행하는 프로세스당 하나의 실행 계획만 있습니다. `EXPLAIN` 출력에 표시된 대로 `Workers Planned: 2`는 쿼리에 2개의 워커가 사용됨을 나타냅니다. 따라서 이 쿼리의 병렬 부분은 총 3개의 프로세스(워커 2개 + 리더 1개)에서 실행됩니다.

쿼리 실행 중 `Gather` 노드에 도달하면, 쿼리를 실행하는 프로세스(리더 프로세스)가 해당 계획에서 구성된 워커 수만큼의 백그라운드 워커 프로세스를 요청합니다. 사용되는 워커 수는 다음에 의해 제한됩니다:

- `max_parallel_workers_per_gather`: 쿼리당 최대 워커 수
- `max_worker_processes`: 시스템 전체 백그라운드 워커 최대 수
- `max_parallel_workers`: 병렬 작업을 위한 워커 최대 수

중요: 병렬 쿼리는 계획된 것보다 적은 수의 워커로 실행되거나, 리소스가 부족한 경우 워커 없이 실행될 수도 있습니다.

### 실행 모델

쿼리의 병렬 부분을 시작하는 모든 백그라운드 워커 프로세스는 리더의 계획 복사본을 실행합니다. 이러한 워커들이 생성하는 모든 튜플은 `Gather` 노드로 전송됩니다.

리더 프로세스의 역할:

리더 프로세스도 계획의 해당 부분을 실행합니다. 단, 워커로부터 튜플을 읽고, `Gather` 또는 `Gather Merge` 노드 위의 계획 노드에 필요한 추가 처리를 수행해야 합니다.

- 리더가 적은 튜플을 생성할 때: 추가 워커처럼 동작하여 쿼리 실행을 가속화합니다.
- 리더가 많은 튜플을 생성할 때: 튜플을 읽고 추가 처리하는 작업에 거의 전적으로 점유되어 추가 워커로서의 역할을 하지 못할 수 있습니다.

### Gather vs. Gather Merge

- Gather: 워커로부터 튜플을 편리한 순서대로 읽습니다. 이는 정렬 순서를 파괴합니다.
- Gather Merge: 각 워커가 정렬된 튜플을 생성하면, 리더가 순서를 유지하는 병합을 수행합니다.

### 성능 최적화

병렬 쿼리가 계획된 것보다 적은 워커로 자주 실행된다면 다음을 고려하세요:

- `max_worker_processes` 증가
- `max_parallel_workers` 증가
- `max_parallel_workers_per_gather` 감소 (더 적은 워커를 요청하도록)

---

## 15.2. 병렬 쿼리를 사용할 수 있는 경우

병렬 쿼리 계획이 생성되려면 여러 조건이 충족되어야 합니다.

### 필수 구성 설정

병렬 쿼리 계획이 생성되려면 다음이 참이어야 합니다:

- `max_parallel_workers_per_gather` 가 0보다 큰 값 으로 설정되어야 합니다. 이는 단일 Gather 작업에 사용할 수 있는 최대 워커 수를 제어합니다.

- 시스템이 단일 사용자 모드로 실행 중이 아니어야 합니다. 단일 사용자 모드에서는 백그라운드 워커를 사용할 수 없습니다.

### 병렬 계획 생성을 방해하는 조건

다음 조건 중 하나라도 해당되면 플래너는 쿼리에 대한 병렬 쿼리 계획을 생성하지 않습니다:

#### 1. 데이터 수정 또는 행 잠금

데이터를 쓰거나 데이터베이스 행을 잠그는 쿼리는 병렬 계획을 사용할 수 없습니다.

예외: 다음 명령은 기본 `SELECT`를 병렬화할 수 있습니다:
- `CREATE TABLE ... AS`
- `SELECT INTO`
- `CREATE MATERIALIZED VIEW`
- `REFRESH MATERIALIZED VIEW`

#### 2. 실행 중 쿼리 일시 중단

- `DECLARE CURSOR`로 생성된 커서는 병렬 계획을 사용할 수 없습니다.
- `FOR x IN query LOOP .. END LOOP`과 같은 PL/pgSQL 루프는 병렬 계획을 사용할 수 없습니다. 시스템이 병렬 실행 중에 루프 코드가 안전한지 확인할 수 없기 때문입니다.

#### 3. 안전하지 않은 함수

`PARALLEL UNSAFE`로 표시된 함수를 사용하는 쿼리는 병렬화할 수 없습니다.

- 사용자 정의 함수는 기본적으로 `PARALLEL UNSAFE`입니다 (섹션 15.4 참조).
- 대부분의 시스템 정의 함수는 `PARALLEL SAFE`입니다.

#### 4. 중첩된 병렬 쿼리

이미 병렬로 실행 중인 쿼리 내부에서 실행되는 쿼리는 병렬 계획을 사용할 수 없습니다.

병렬 쿼리에서 호출되는 함수가 자체 SQL 쿼리를 실행하면, 해당 중첩 쿼리는 병렬화되지 않습니다.

### 런타임 실행 제한

병렬 계획이 생성되더라도 다음 경우에는 순차적으로 실행될 수 있습니다:

- 백그라운드 워커 부족: `max_worker_processes` 제한 초과
- 병렬 워커 부족: `max_parallel_workers` 제한 초과
- 확장 쿼리 프로토콜에서 0이 아닌 페치 횟수: 순차 실행으로 대체

이러한 경우, 리더 프로세스가 `Gather` 노드 아래의 계획을 단독으로 실행합니다.

---

## 15.3. 병렬 계획

PostgreSQL에서 병렬 계획을 사용하려면 "부분 계획(partial plan)" 구조가 필요합니다. 각 워커 프로세스는 출력 행의 일부만 생성하며, 필요한 각 출력 행이 정확히 하나의 프로세스에 의해 생성됩니다. 드라이빙 테이블의 스캔은 병렬 인식 스캔이어야 합니다.

### 15.3.1. 병렬 스캔

세 가지 유형의 병렬 인식 테이블 스캔이 지원됩니다:

#### 1. Parallel Sequential Scan (병렬 순차 스캔)

- 테이블 블록이 범위로 나뉘어 협력하는 프로세스 간에 공유됩니다.
- 각 워커는 자신의 범위 스캔을 완료한 후 추가 블록을 요청합니다.

#### 2. Parallel Bitmap Heap Scan (병렬 비트맵 힙 스캔)

- 하나의 프로세스가 리더 역할을 하여 하나 이상의 인덱스를 스캔합니다.
- 방문해야 할 테이블 블록을 나타내는 비트맵을 구축합니다.
- 블록이 협력하는 프로세스 간에 나뉩니다 (힙 스캔은 병렬화되지만, 인덱스 스캔은 병렬화되지 않습니다).

#### 3. Parallel Index Scan / Parallel Index-Only Scan (병렬 인덱스 스캔 / 병렬 인덱스 전용 스캔)

- 협력하는 프로세스가 번갈아가며 인덱스에서 읽습니다.
- 현재 btree 인덱스 에서만 지원됩니다.
- 각 프로세스는 단일 인덱스 블록을 요청하고 참조된 모든 튜플을 스캔합니다.
- 결과는 각 워커 프로세스 내에서 정렬된 순서로 반환됩니다.

### 15.3.2. 병렬 조인

드라이빙 테이블은 중첩 루프, 해시 조인 또는 병합 조인을 사용하여 다른 테이블과 조인될 수 있습니다:

#### 1. Nested Loop Join (중첩 루프 조인)

- 내부 측은 항상 비병렬입니다.
- 내부 측이 인덱스 스캔인 경우 효율적입니다 (외부 튜플/루프가 프로세스 간에 분할됨).

#### 2. Merge Join (병합 조인)

- 내부 측은 항상 비병렬입니다 (전체적으로 실행됨).
- 정렬이 필요한 경우 비효율적일 수 있습니다 (작업이 프로세스 간에 중복됨).

#### 3. Hash Join (해시 조인)

- 표준 해시 조인: 내부 측이 모든 프로세스에서 전체적으로 실행됩니다 (해시 테이블이 중복됨).
- Parallel Hash Join: 내부 측이 병렬 해시로, 공유 해시 테이블 구축 작업을 분할합니다.

### 15.3.3. 병렬 집계

PostgreSQL은 두 단계로 병렬 집계를 지원합니다:

1. 부분 집계 (Partial Aggregation): 각 워커가 집계 단계를 수행하여 그룹당 부분 결과를 생성합니다 (`Partial Aggregate` 노드).

2. 데이터 전송: 부분 결과가 `Gather` 또는 `Gather Merge`를 통해 리더로 전송됩니다.

3. 최종 집계 (Finalize Aggregation): 리더가 결과를 다시 집계하여 최종 결과를 생성합니다 (`Finalize Aggregate` 노드).

#### 제한 사항

- 모든 상황에서 지원되지 않습니다.
- 각 집계는 병렬 처리에 안전해야 하며 결합 함수(combine function)가 있어야 합니다.
- `internal` 전이 상태를 가진 집계는 직렬화/역직렬화 함수가 필요합니다.
- 집계에 `DISTINCT` 또는 `ORDER BY` 절이 포함된 경우 지원되지 않습니다.
- 순서 집합 집계(ordered set aggregates)나 `GROUPING SETS`에는 지원되지 않습니다.
- 모든 조인이 병렬 부분의 일부인 경우에만 사용할 수 있습니다.

### 15.3.4. Parallel Append

여러 소스의 행을 단일 결과 집합으로 결합할 때 사용됩니다 (예: `UNION ALL`, 파티션된 테이블):

- 일반 Append: 모든 프로세스가 자식 계획을 순서대로 순차적으로 실행합니다.
- Parallel Append: 프로세스가 자식 계획에 고르게 분산되어 동시에 여러 개를 실행합니다.
  - 경합 및 시작 비용을 피합니다.
  - 부분(partial) 및 비부분(non-partial) 자식 계획을 모두 가질 수 있습니다.
  - 비부분 자식은 단일 프로세스에서만 스캔됩니다.

기능 제어: `enable_parallel_append`를 사용하여 이 기능을 비활성화할 수 있습니다.

### 15.3.5. 병렬 계획 팁

#### 쿼리가 병렬 계획을 생성하지 않는 경우

- `parallel_setup_cost` 또는 `parallel_tuple_cost` 구성 매개변수를 줄이세요.
- 둘 다 0으로 설정하면 문제 진단에 도움이 될 수 있습니다.
- 제한 사항에 대해서는 섹션 15.2 (병렬 쿼리를 사용할 수 있는 경우)와 섹션 15.4 (병렬 안전성)를 참조하세요.

#### 성능 분석

다음 명령을 사용하여 각 계획 노드에 대한 워커별 통계를 표시하고 작업이 고르게 분산되는지 확인하세요:

```sql
EXPLAIN (ANALYZE, VERBOSE)
```

---

## 15.4. 병렬 안전성

PostgreSQL 플래너는 쿼리의 작업을 세 가지 병렬 안전성 범주로 분류합니다:

### 병렬 안전성 범주

1. Parallel Safe (병렬 안전): 병렬 쿼리 실행과 충돌하지 않는 작업

2. Parallel Restricted (병렬 제한): 병렬 워커에서는 실행할 수 없지만 병렬 쿼리 실행 중 리더 프로세스에서는 실행할 수 있는 작업

3. Parallel Unsafe (병렬 안전하지 않음): 병렬 쿼리 실행 중에 전혀 실행할 수 없는 작업으로, 전체 쿼리에 대해 병렬 쿼리를 완전히 비활성화합니다.

### 항상 병렬 제한되는 작업

- 공통 테이블 표현식(CTE)의 스캔
- 임시 테이블의 스캔
- 외부 테이블의 스캔 (외부 데이터 래퍼가 `IsForeignScanParallelSafe` API를 통해 다르게 표시하지 않는 한)
- 상관 `SubPlan`을 참조하는 계획 노드

### 15.4.1. 함수 및 집계에 대한 병렬 라벨링

#### 자동 분류의 한계

플래너는 사용자 정의 함수나 집계의 병렬 안전성을 자동으로 결정할 수 없습니다. 이 결정은 함수가 수행할 수 있는 모든 가능한 작업을 예측해야 하며, 이는 정지 문제(Halting Problem)와 동등합니다.

기본 동작: 모든 사용자 정의 함수는 명시적으로 표시하지 않는 한 `PARALLEL UNSAFE`로 간주됩니다.

#### CREATE/ALTER FUNCTION을 사용한 수동 표시

함수를 생성하거나 변경할 때 다음 절을 사용합니다:

```sql
CREATE FUNCTION ... PARALLEL SAFE | PARALLEL RESTRICTED | PARALLEL UNSAFE
ALTER FUNCTION ... PARALLEL SAFE | PARALLEL RESTRICTED | PARALLEL UNSAFE
```

#### CREATE AGGREGATE를 사용한 수동 표시

```sql
CREATE AGGREGATE ... PARALLEL (SAFE | RESTRICTED | UNSAFE)
```

### 함수 표시 요구 사항

#### PARALLEL UNSAFE로 표시해야 하는 경우

함수가 다음을 수행하는 경우:
- 데이터베이스에 쓰기
- 트랜잭션 상태 변경 (오류 복구를 위한 서브트랜잭션 제외)
- 시퀀스에 액세스
- 설정에 영구적인 변경을 가함

#### PARALLEL RESTRICTED로 표시해야 하는 경우

함수가 다음에 액세스하는 경우:
- 임시 테이블
- 클라이언트 연결 상태
- 커서 또는 준비된 문
- 워커 간에 동기화할 수 없는 기타 백엔드 로컬 상태
- 예: `setseed` 및 `random`

### 중요 참고 사항

- 잘못된 라벨링의 위험: 잘못 라벨링된 함수는 병렬 쿼리에서 오류를 발생시키거나 잘못된 결과를 생성할 수 있습니다.

- 잠금 동작: 병렬 워커가 획득한 잠금(리더가 보유하지 않은)은 트랜잭션 종료 시가 아니라 워커 종료 시 해제됩니다.

- 플래너 제한 사항: 쿼리 플래너는 우수한 계획을 달성하기 위해 병렬 제한 함수의 평가를 연기하지 않습니다. 예를 들어, `WHERE` 절이 병렬 제한되면 테이블 스캔이 계획의 병렬 부분에 포함되지 않습니다. 비록 그렇게 하는 것이 효율적일 수 있더라도 말입니다.

- 확실하지 않을 때: 안전을 위해 함수를 `UNSAFE`로 라벨링하세요.

---

## 참고 자료

- [PostgreSQL 18 공식 문서 - Parallel Query](https://www.postgresql.org/docs/18/parallel-query.html)
- [15.1. How Parallel Query Works](https://www.postgresql.org/docs/18/how-parallel-query-works.html)
- [15.2. When Can Parallel Query Be Used?](https://www.postgresql.org/docs/18/when-can-parallel-query-be-used.html)
- [15.3. Parallel Plans](https://www.postgresql.org/docs/18/parallel-plans.html)
- [15.4. Parallel Safety](https://www.postgresql.org/docs/18/parallel-safety.html)
