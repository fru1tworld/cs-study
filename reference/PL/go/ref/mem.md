# Go 메모리 모델

**버전:** 2022년 6월 6일

## 소개

Go 메모리 모델은 한 고루틴에서 변수를 읽을 때 다른 고루틴에서 동일한 변수에 쓴 값을 관찰할 수 있도록 보장하는 조건을 명시합니다.

### 핵심 조언

- 여러 고루틴이 동시에 접근하는 데이터를 수정하는 프로그램은 반드시 그러한 접근을 직렬화해야 합니다
- 채널 연산이나 `sync` 및 `sync/atomic` 패키지의 동기화 기본 요소를 사용하세요
- **"프로그램의 동작을 이해하기 위해 이 문서의 나머지 부분을 읽어야 한다면, 당신은 너무 영리하게 굴고 있는 것입니다. 영리하게 굴지 마세요."**

### 비형식적 개요

**데이터 경합 정의:** 한 메모리 위치에 대한 쓰기가 동일한 위치에 대한 다른 읽기 또는 쓰기와 동시에 발생하는 것 (모든 접근이 원자적인 경우 제외).

**DRF-SC 속성:** 데이터 경합이 없는 경우, Go 프로그램은 마치 모든 고루틴이 단일 프로세서에서 멀티플렉싱된 것처럼 동작합니다 (데이터 경합이 없는 프로그램은 순차적 일관성으로 실행됩니다).

Go의 접근 방식은 C/C++와 비교하여 잘못된 프로그램을 더 신뢰할 수 있고 디버깅하기 쉽게 만들면서도, 여전히 경합을 도구가 진단할 수 있는 오류로 취급합니다.

---

## 메모리 모델 - 형식적 정의

### 핵심 개념

**메모리 연산:** 네 가지 세부 사항으로 모델링됩니다:
1. 종류 (일반 읽기/쓰기 또는 동기화 연산)
2. 프로그램 내 위치
3. 접근되는 메모리 위치 또는 변수
4. 읽거나 쓰는 값

**메모리 연산 분류:**
- **읽기류:** 읽기, 원자적 읽기, 뮤텍스 잠금, 채널 수신
- **쓰기류:** 쓰기, 원자적 쓰기, 뮤텍스 해제, 채널 송신, 채널 닫기
- **둘 다:** 원자적 비교 및 교환

### 세 가지 핵심 요구사항

**요구사항 1:** 각 고루틴의 메모리 연산은 _순서 지정 전_ 관계와 일관된 올바른 순차적 실행에 해당해야 합니다.

**요구사항 2:** 읽기에서 쓰기로의 매핑(동기화 연산의 경우)은 순서 지정 및 값과 일관된 암시적 전체 순서로 설명될 수 있어야 합니다.

**요구사항 3:** 메모리 위치 _x_에 대한 일반 데이터 읽기의 경우, 관찰되는 쓰기는 _가시적_이어야 합니다. 즉:
1. 쓰기가 읽기 전에 발생합니다
2. 쓰기가 읽기 전에 발생하는 다른 쓰기 전에 발생하지 않습니다

### 경합 정의

- **읽기-쓰기 데이터 경합:** 동일한 위치에 대한 읽기류 연산과 쓰기류 연산이 happens-before로 순서화되지 않음 (적어도 하나가 비동기화)
- **쓰기-쓰기 데이터 경합:** 동일한 위치에 대한 두 쓰기류 연산이 happens-before로 순서화되지 않음 (적어도 하나가 비동기화)

### DRF-SC 보장

데이터 경합이 없는 모든 Go 프로그램은 고루틴 실행의 일부 순차적으로 일관된 인터리빙으로만 결과를 설명할 수 있습니다.

---

## 데이터 경합이 있는 프로그램의 구현 제한

### 감지 및 종료
- 구현체는 경합을 감지하고 보고하여 실행을 중단할 수 있습니다
- ThreadSanitizer (`go build -race`를 통해)가 이를 수행합니다

### 복합 타입 처리
- 배열, 구조체, 또는 복소수 읽기는 개별 하위 값의 읽기로 임의의 순서로 구현될 수 있습니다
- 쓰기에도 동일하게 적용됩니다

### 워드 크기 읽기
단일 워드 크기 또는 하위 워드 크기 값을 보유하는 메모리 위치 _x_의 읽기 _r_은 다음과 같은 일부 쓰기 _w_를 관찰해야 합니다:
- _r_이 _w_ 전에 발생하지 않음
- _w_가 _w'_ 전에 발생하고 _w'_가 _r_ 전에 발생하는 쓰기 _w'_가 존재하지 않음

**금지됨:** 인과 관계 없는 쓰기 및 "허공에서 나온" 쓰기

### 다중 워드 연산
다중 워드 데이터 구조에 대한 경합은 일관성 없는 값과 임의의 메모리 손상을 초래할 수 있으며, 특히 인터페이스 값, 맵, 슬라이스, 문자열에 영향을 미칩니다.

---

## 동기화

### 초기화

```go
// 프로그램 초기화는 단일 고루틴에서 실행됩니다
// 패키지 q의 init 함수들은 패키지 p의 것들 전에 완료됩니다
// 모든 init 함수들은 main.main 시작 전에 완료됩니다
```

### 고루틴 생성

`go` 문은 고루틴 실행 시작 전에 동기화됩니다.

**예제:**
```go
var a string

func f() {
	print(a)
}

func hello() {
	a = "hello, world"
	go f()  // 결국 "hello, world"를 출력하는 것이 보장됨
}
```

### 고루틴 소멸

고루틴의 종료는 어떤 이벤트 전에 동기화되는 것이 **보장되지 않습니다**.

**예제:**
```go
var a string

func hello() {
	go func() { a = "hello" }()
	print(a)  // "hello"를 출력하는 것이 보장되지 않음
}
```

**해결책:** 잠금이나 채널을 사용하여 순서를 확립하세요.

### 채널 통신

고루틴 간의 **주요 동기화 방법**입니다.

**규칙 1:** 채널에 대한 송신은 해당 수신 완료 전에 동기화됩니다.

**예제:**
```go
var c = make(chan int, 10)
var a string

func f() {
	a = "hello, world"
	c <- 0
}

func main() {
	go f()
	<-c
	print(a)  // "hello, world"를 출력하는 것이 보장됨
}
```

**규칙 2:** 채널 닫기는 영값을 반환하는 수신 전에 동기화됩니다.

**규칙 3:** **버퍼 없는** 채널에서의 수신은 해당 송신 완료 전에 동기화됩니다.

**예제:**
```go
var c = make(chan int)  // 버퍼 없음
var a string

func f() {
	a = "hello, world"
	<-c
}

func main() {
	go f()
	c <- 0
	print(a)  // "hello, world"를 출력하는 것이 보장됨
}
```

**규칙 4:** 용량 _C_인 채널에서의 _k_번째 수신은 _k_+_C_번째 송신 완료 전에 동기화됩니다.

**세마포어 예제:**
```go
var limit = make(chan int, 3)

func main() {
	for _, w := range work {
		go func(w func()) {
			limit <- 1
			w()
			<-limit
		}(w)
	}
	select{}
}
```

### 잠금 (sync.Mutex 및 sync.RWMutex)

**뮤텍스 규칙:** 모든 `sync.Mutex` 변수 `l`과 _n_ < _m_에 대해, `l.Unlock()`의 호출 _n_은 `l.Lock()`의 호출 _m_ 반환 전에 동기화됩니다.

**예제:**
```go
var l sync.Mutex
var a string

func f() {
	a = "hello, world"
	l.Unlock()
}

func main() {
	l.Lock()
	go f()
	l.Lock()
	print(a)  // "hello, world"를 출력하는 것이 보장됨
}
```

**RWMutex 규칙:** 각 `l.RLock` 호출에 대해, _n_번째 `l.Unlock`이 반환 전에 동기화되고, 일치하는 `l.RUnlock`이 _n_+1번째 `l.Lock` 전에 동기화되는 _n_이 존재합니다.

**TryLock 동작:**
- 성공적인 `TryLock`/`TryRLock` = `Lock`/`RLock`과 동등
- 실패한 호출 = 동기화 효과 없음
- 메모리 모델 관점에서, 잠금 해제 상태에서도 false를 반환할 수 있음

### Once (sync.Once)

여러 고루틴으로 초기화를 위한 안전한 메커니즘입니다.

**규칙:** `once.Do(f)`에서 `f()`의 단일 호출 완료는 모든 `once.Do(f)` 호출 반환 전에 동기화됩니다.

**예제:**
```go
var a string
var once sync.Once

func setup() {
	a = "hello, world"
}

func doprint() {
	once.Do(setup)
	print(a)
}

func twoprint() {
	go doprint()
	go doprint()
	// setup은 정확히 한 번 호출되고, "hello, world"를 두 번 출력
}
```

### 원자적 값 (sync/atomic)

원자적 연산은 실행을 동기화하는 데 집합적으로 사용됩니다.

**규칙:** 원자적 연산 _A_의 효과가 원자적 연산 _B_에 의해 관찰되면, _A_는 _B_ 전에 동기화됩니다. 모든 원자적 연산은 마치 일부 순차적으로 일관된 순서로 실행된 것처럼 동작합니다.

**의미적으로 동등:** C++ 순차적 일관성 원자적 연산 및 Java의 `volatile` 변수.

### 파이널라이저 (runtime.SetFinalizer)

`SetFinalizer(x, f)` 호출은 파이널라이저 호출 `f(x)` 전에 동기화됩니다.

### 추가 메커니즘

`sync` 패키지는 다음을 제공합니다:
- 조건 변수 (`Cond`)
- 잠금 없는 맵 (`Map`)
- 할당 풀 (`Pool`)
- 대기 그룹 (`WaitGroup`)

각각은 자체 동기화 보장을 명시합니다.

---

## 잘못된 동기화

### 예제 1: 비순차적으로 일관된 실행과의 경합

```go
var a, b int

func f() {
	a = 1
	b = 2
}

func g() {
	print(b)
	print(a)
}

func main() {
	go f()
	g()
	// 출력할 수 있음: 2 다음 0 (2, 1이 아님)
}
```

### 잘못된 관용구 1: 이중 검사 잠금

```go
var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
}

func doprint() {
	if !done {  // 안전하지 않음: done=true를 관찰하는 것이
		once.Do(setup)  // a="hello, world"를 관찰한다는 보장이 없음
	}
	print(a)  // 빈 문자열을 출력할 수 있음
}
```

### 잘못된 관용구 2: 바쁜 대기

```go
var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
}

func main() {
	go setup()
	for !done {  // 안전하지 않음: done 쓰기가 관찰된다는 보장이 없음
	}
	print(a)  // 빈 문자열을 출력하거나 영원히 반복할 수 있음
}
```

### 잘못된 관용구 3: 포인터 초기화 경합

```go
type T struct {
	msg string
}

var g *T

func setup() {
	t := new(T)
	t.msg = "hello, world"
	g = t
}

func main() {
	go setup()
	for g == nil {
	}
	print(g.msg)  // g != nil이어도, msg가 초기화되지 않았을 수 있음
}
```

**모든 경우의 해결책:** 채널, 뮤텍스, 또는 원자적 연산으로 명시적 동기화를 사용하세요.

---

## 잘못된 컴파일

메모리 모델은 동시성 프로그램에 대한 컴파일러 최적화를 제한합니다.

### 제한 1: 쓰기를 도입할 수 없음

**잘못된 최적화:**
```go
// 원본
*p = 1
if cond {
	*p = 2
}

// 잘못된 재작성
*p = 2
if !cond {
	*p = 1
}
```
경합하는 스레드가 재작성된 버전에서 값 `2`를 관찰할 수 있지만 원본에서는 그렇지 않습니다.

### 제한 2: 루프를 지나 접근을 이동할 수 없음

**잘못된 최적화:**
```go
// 원본 - list가 순환이면, *p나 *q에 절대 접근하지 않음
n := 0
for e := list; e != nil; e = e.next {
	n++
}
i := *p
*q = 1

// 잘못됨: *p나 *q를 루프 전으로 이동할 수 없음
```

### 제한 3: 함수 호출을 지나 이동할 수 없음

**잘못된 최적화:**
```go
// 원본
f()
i := *p
*q = 1

// 잘못됨: *p나 *q를 f() 전으로 이동할 수 없음
// f()가 반환하지 않거나 동기화를 포함할 수 있음
```

### 제한 4: 지역 변수를 다시 로드할 수 없음

**잘못된 최적화:**
```go
i := *p
if i < 0 || i >= len(funcs) {
	panic("invalid function index")
}
// ... 복잡한 코드 ...
// 잘못됨: 여기서 i = *p를 다시 로드할 수 없음
funcs[i]()
```

경합하는 스레드가 `*p`가 변경되면 범위를 벗어난 접근을 유발할 수 있습니다.

### 제한 5: 공유 메모리를 임시로 사용할 수 없음

**잘못된 최적화:**
```go
// 원본
*p = i + *p/2

// 잘못된 재작성
*p /= 2
*p += i
```

`i`와 `*p`가 2로 시작하면:
- 원본: `*p = 3` (경합하는 스레드가 2 또는 3을 봄)
- 재작성: `*p = 1` 그 다음 `*p = 3` (경합하는 스레드가 1, 2, 또는 3을 볼 수 있음)

### 예외: 입증 가능하게 안전한 최적화

```go
// 유효: 컴파일러가 *shared가 오류를 일으키지 않고 재작성이 안전하다고 증명할 수 있음
n := 0
for i := 0; i < m; i++ {
	n += *shared
}

// 다음으로 재작성할 수 있음:
n := 0
local := *shared
for i := 0; i < m; i++ {
	n += local
}
```

**참고:** 경합 도입 금지는 컴파일러가 경합이 대상 플랫폼에서 올바른 실행에 영향을 미치지 않는다고 증명하면 적용되지 않습니다.

---

## 결론

**데이터 경합이 없는 프로그램의 경우:**
Go 프로그래머는 다른 현대 프로그래밍 언어에서와 마찬가지로 순차적으로 일관된 실행에 의존할 수 있습니다.

**경합이 있는 프로그램의 경우:**
프로그래머와 컴파일러 모두 다음을 기억해야 합니다:

> **"영리하게 굴지 마세요."**

---

이 문서는 올바른 동시성 프로그램을 작성하는 데 필수적인 Go 메모리 모델의 완전한 형식적 및 비형식적 명세를 제공합니다.
