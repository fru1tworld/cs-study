# Go 가비지 컬렉터 가이드

## 소개

이 가이드는 Go 가비지 컬렉터에 대한 통찰력을 통해 고급 Go 사용자가 애플리케이션 비용을 이해하고 리소스 활용도를 개선하기 위한 지침을 제공합니다. Go 프로그래밍에 익숙하지만 가비지 컬렉션 지식은 필요하지 않다고 가정합니다.

### 핵심 개념

**가비지 컬렉션**: 더 이상 필요하지 않은 부분을 식별하여 자동으로 메모리를 재활용합니다.

**메모리 관리**: Go 런타임은 Go 값의 저장을 정렬합니다. 물리적 메모리는 유한하므로 자동 재활용을 통해 주의 깊게 관리해야 합니다.

**범위**: 이 가이드는 표준 Go 툴체인(`gc` 컴파일러)에 특별히 적용됩니다. Gccgo와 Gollvm은 유사한 구현을 사용하지만 세부 사항이 다를 수 있습니다. 현재 버전은 Go 1.19 GC 동작을 설명합니다.

---

## Go 값이 사는 곳

### 스택 할당
- 지역 변수의 비포인터 Go 값은 일반적으로 GC에 의해 관리되지 않습니다
- 메모리는 생성된 렉시컬 스코프에 연결되어 할당됩니다
- 컴파일러가 메모리를 해제할 수 있는 시점을 미리 결정하므로 힙 할당보다 효율적
- "스택 할당"이라고 합니다

### 힙 할당
- 컴파일러가 수명을 결정할 수 없는 Go 값은 "힙으로 이스케이프"합니다
- 힙은 동적 메모리 할당을 위한 포괄적인 장소입니다
- GC는 동적 메모리 할당을 식별하고 정리합니다
- 힙 이스케이프 이유:
  - 동적으로 결정되는 크기(예: 변수 초기 크기의 슬라이스)
  - 전이적 이스케이프: 참조가 이미 이스케이프된 값에 작성되면 함께 이스케이프해야 함

---

## 추적 가비지 컬렉션

Go는 **추적 가비지 컬렉션**을 사용하여 포인터를 전이적으로 따라가며 라이브 객체를 식별합니다.

### 정의

**객체**: 하나 이상의 Go 값을 포함하는 동적으로 할당된 메모리 조각.

**포인터**: 객체 내의 어떤 값을 참조하는 메모리 주소. `*T` 타입과 문자열, 슬라이스, 채널, 맵, 인터페이스에 내장된 주소를 포함합니다.

**객체 그래프**: 객체와 다른 객체에 대한 포인터가 객체 그래프를 형성합니다.

**루트**: 프로그램에서 확실히 사용 중인 객체를 식별하는 포인터(예: 지역 및 전역 변수).

**스캔**: 프로그램 루트에서 시작하여 객체 그래프를 탐색합니다.

**도달 가능**: 스캔 프로세스에서 발견할 수 있는 객체.

### 마크-스윕 기법

1. **마킹 단계**: GC가 객체 그래프를 탐색하고 만나는 값을 라이브로 마킹
2. **스위핑 단계**: GC가 모든 힙 메모리를 탐색하고 마킹되지 않은 메모리를 할당 가능하게 만듦
3. **비이동 GC**: Go는 객체를 이동하지 않음; 이동 컬렉터 접근 방식 대신 마크-스윕 사용

---

## GC 사이클

Go GC는 세 단계를 지속적으로 순환합니다:

1. **스위핑**: 마킹되지 않은 메모리를 할당 가능하게 만듦
2. **오프**: GC 관련 작업 없음
3. **마킹**: 라이브 메모리 추적 및 마킹

스캔되지 않은 포인터가 객체를 유지할 수 있으므로 모든 메모리가 추적될 때까지 메모리를 해제할 수 없습니다.

---

## 비용 이해

### GC 비용 모델을 위한 세 가지 공리

1. **두 가지 리소스**: 물리적 메모리와 CPU 시간
2. **메모리 비용**:
   ```
   사이클 N의 GC 메모리 비용 = 사이클 N-1의 라이브 힙 + 새 힙
   ```
   - 라이브 힙: 이전 GC 사이클에서 라이브로 결정된 메모리
   - 새 힙: 현재 사이클에서 할당된 메모리(라이브일 수도 아닐 수도 있음)

3. **CPU 비용**:
   ```
   사이클 N의 GC CPU 시간 = 사이클당 고정 CPU 비용 +
                          (바이트당 비용 * 사이클 N에서 발견된 라이브 힙 메모리)
   ```
   - 고정 비용: 초기화 및 사이클당 연산
   - 한계 비용: 마킹 및 스캔(라이브 힙 크기에 비례)

**핵심 통찰**: 총 GC CPU 비용은 GC 사이클 빈도에 따라 달라집니다.

### 기본 시간/공간 트레이드오프

**정상 상태** (일정한 할당률, 일정한 한계 비용):

10 MiB/s 할당률, 100 MiB/cpu-second 스캔율, 10 MiB 라이브 힙 예제:

- **1 cpu-second 사이클**: 20 MiB 힙, 10% GC 오버헤드
- **2 cpu-second 사이클**: 30 MiB 힙, 5% GC 오버헤드

**GC 빈도**가 이 트레이드오프의 중심입니다: 더 자주 GC는 더 적은 메모리를 사용하지만 더 많은 CPU를 사용합니다.

---

## GOGC

### 개요

GOGC는 각 GC 사이클 후 대상 힙 크기를 설정하여 GC CPU와 메모리 간의 트레이드오프를 결정합니다.

### 공식

```
대상 힙 메모리 = 라이브 힙 + (라이브 힙 + GC 루트) x GOGC / 100
```

### 예제

프로그램:
- 라이브 힙: 8 MiB
- 고루틴 스택: 1 MiB
- 전역 변수 포인터: 1 MiB
- 총 작업: 10 MiB

| GOGC 값 | 새 메모리 | 총 힙 |
|---------|----------|-------|
| 100     | 10 MiB   | 18 MiB|
| 50      | 5 MiB    | 13 MiB|
| 200     | 20 MiB   | 28 MiB|

### 핵심 원칙

**GOGC를 두 배로 늘리면 힙 메모리 오버헤드가 두 배로 늘고 GC CPU 비용이 대략 절반으로 줄어들며**, 그 반대도 마찬가지입니다.

### 구성

```bash
# 환경 변수
export GOGC=100

# API
runtime/debug.SetGCPercent(100)

# GC 끄기
export GOGC=off
# 또는
runtime/debug.SetGCPercent(-1)
```

### Go 1.18+ 참고사항

GOGC는 이제 계산에 고루틴 스택과 전역 변수 포인터를 포함합니다(이전에는 라이브 힙만 계산).

---

## 메모리 제한 (Go 1.19+)

### 해결된 문제

GOGC만으로는 사용 가능한 유한 메모리를 고려하지 않습니다. 일시적인 힙 스파이크는 피크 메모리에 대한 GOGC 구성을 강제하여 일반적인 경우에 대한 최적화를 제한합니다.

### 구성

```bash
# 환경 변수
export GOMEMLIMIT=500MiB

# API
runtime/debug.SetMemoryLimit(500 * 1024 * 1024)
```

### 정의

메모리 제한은 Go 런타임이 사용할 수 있는 최대 총 메모리를 설정합니다:

```
Sys - HeapReleased
```

또는 메트릭 용어로:

```
/memory/classes/total:bytes - /memory/classes/heap/released:bytes
```

### 주요 특성

- **소프트 제한**: Go는 합리적인 노력을 하지만 모든 상황에서 보장하지 않음
- **CPU 제한**: GC는 `2 * GOMAXPROCS` CPU-second 윈도우에서 ~50% CPU 시간으로 제한
- **스래싱 방지**: 소프트 제한은 불가능한 메모리 제한으로 인한 무한 지연 방지

### 제안된 용도

**사용할 때:**
- 실행 환경이 완전히 제어 하에 있을 때
- Go 프로그램이 리소스의 유일한 사용자일 때(예: 컨테이너 메모리 제한)
- 알 수 없는 메모리 소스를 위해 5-10% 여유 공간을 남길 수 있을 때
- 변화하는 조건에 실시간으로 조정할 때

**사용하지 말 때:**
- 제어되지 않는 환경에 배포할 때
- 프로그램 메모리 사용량이 입력에 비례할 때(CLI 도구, 데스크톱 앱)
- 환경의 메모리 제한에 이미 근접했을 때
- 프로그램이 분리된 공동 테넌트 프로그램과 메모리를 공유할 때

---

## 지연 시간

### 동시성 GC 설계

Go의 GC는 완전한 stop-the-world가 아닙니다; 지연 시간을 줄이기 위해 애플리케이션과 동시에 대부분의 작업을 수행합니다.

**지연 시간**: 단일 계산 단위의 종단 간 지속 시간(예: 웹 요청)
**처리량**: 초당 전체 요청 수

### 핵심 원칙

**GC 빈도를 줄이면 처리량과 지연 시간 모두 개선됩니다.**

### 지연 시간 원인

1. 마크/스윕 단계 전환 중 짧은 stop-the-world 일시 중지
2. 스케줄링 지연(GC는 마크 단계에서 25% CPU 사용)
3. 높은 할당률로 GC를 지원하는 사용자 고루틴
4. 마크 단계 중 포인터 쓰기 배리어
5. 루트 스캔을 위해 실행 중인 고루틴 일시 중지

이는 `runtime/trace` 패키지를 통한 실행 추적에서 볼 수 있습니다(포인터 쓰기 배리어 작업 제외).

---

## 파이널라이저, 정리, 약한 포인터

### 개요

세 가지 기능이 객체 죽음을 관찰하고 대응할 수 있게 합니다:
- **정리** (`runtime.AddCleanup`)
- **약한 포인터** (`weak.Pointer`)
- **파이널라이저** (`runtime.SetFinalizer`)

### 일반 조언

1. **단위 테스트 작성**: 타이밍을 예측하기 어려움; 테스트가 중요
2. **직접 사용 피하기**: 미묘한 제한이 있는 저수준
3. **패키지 내 캡슐화**: 공개 API에서 숨김
4. **객체 접근 제한**: 생성 패키지에만 유지
5. **결정적 정리 선호**: 비메모리 리소스에 명시적 `Close()` 메서드 사용
6. **파이널라이저보다 정리 선호**: 더 유연하고, 오류가 적고, 더 효율적

### 정리 문제

```go
// 실수: 정리가 f를 참조하여 정리 방지
f := new(myFile)
f.fd = syscall.Open(...)
runtime.AddCleanup(f, func(fd int) {
    syscall.Close(f.fd) // f를 참조!
}, f.fd)

// 올바른 접근
f := new(myFile)
f.fd = syscall.Open(...)
runtime.AddCleanup(f, func(fd int) {
    syscall.Close(fd) // 매개변수 사용
}, f.fd)
```

### 약한 포인터 문제

- 예기치 않게 `nil`을 반환할 수 있음; 항상 nil 검사로 보호
- 맵 키로서 값의 도달 가능성에 영향을 주지 않음

### 파이널라이저 문제

```go
// 실수: 참조 순환의 객체
f := new(myCycle)
f.self = f // 순환 참조가 파이널라이제이션 방지
runtime.SetFinalizer(f, func(f *myCycle) { ... })

// 실수: 파이널라이저를 통한 참조 순환
f := new(myFile)
runtime.SetFinalizer(f, func(_ *myFile) {
    syscall.Close(f.fd) // 외부 f 참조
})
```

- 참조 순환에 있을 수 없음
- 참조 체인은 N개 객체에 대해 N개 GC 사이클 소요(체인을 얕게 유지)
- 오래 실행되는 파이널라이저는 고루틴을 생성해야 함
- `runtime.GC()`는 실행이 아닌 큐잉만 대기

### 객체 죽음 테스트

1. 다른 테스트와 병렬로 실행하지 않음
2. 기준선 설정을 위해 `runtime.GC()` 사용
3. `runtime.GC()`는 큐잉하지만 실행을 기다리지 않음
4. 강력한 테스트를 위해 차단 메커니즘(채널) 주입
5. 동시 정리 경합을 감지하기 위해 경합 모드 사용
6. 파이널라이저 체인의 경우 깊이 N 체인에 대해 최소 N번 `runtime.GC()` 호출

---

## 최적화 가이드

### 1단계: 비용 식별

#### CPU 프로파일링

`runtime/pprof`를 사용하여 CPU 시간이 소비되는 곳을 식별합니다.

**핵심 런타임 함수**:

- **`runtime.gcBgMarkWorker`**: 백그라운드 마크 워커 고루틴. 시간은 GC 빈도와 객체 그래프 복잡성에 비례.
  - 서브콜: `gcDrainMarkWorkerDedicated`, `gcDrainMarkWorkerFractional`, `gcDrainMarkWorkerIdle`
  - `Idle` 워커는 유휴 CPU 용량 사용

- **`runtime.mallocgc`**: 메모리 할당자 진입점. 높은 누적 시간(>15%)은 무거운 할당을 나타냄.

- **`runtime.gcAssistAlloc`**: 스캔/마킹으로 GC를 지원하는 애플리케이션. 높은 시간(>5%)은 애플리케이션이 GC를 앞서감을 나타냄. `mallocgc` 트리에 포함됨.

#### 실행 추적

짧은 실행 윈도우의 자세한 뷰를 위해 `runtime/trace`를 사용합니다:
- GC 이벤트의 풍부한 뷰
- 특정 실행 경로 관찰
- 지연 시간 관련 비용 식별

#### GC 추적

`GODEBUG`를 통해 구성:

```bash
# 코어 GC 추적
GODEBUG=gctrace=1

# 페이서 추적(더 깊은 통찰)
GODEBUG=gcpacertrace=1
```

출력은 `runtime` 패키지 환경 변수 섹션에 문서화되어 있습니다.

### 2단계: 힙 할당 제거

#### 힙 프로파일링

메모리 프로파일은 스택 추적별 힙 할당 소스를 설명합니다.

**뷰**:
- `inuse_objects`: 라이브 객체 수
- `inuse_space`: 사용된 바이트별 라이브 객체
- `alloc_objects`: 시작 이후 할당된 총 객체
- `alloc_space`: 시작 이후 할당된 총 바이트(GC 비용에 가장 유용)

```bash
go tool pprof -sample_index=alloc_space profile.prof
```

#### 이스케이프 분석

힙 대신 스택을 사용하기 위해 컴파일러의 이스케이프 분석을 활용합니다.

```bash
# 이스케이프 분석 세부 정보 보기
go build -gcflags=-m=3 [package]
```

**gopls가 있는 VS Code**:
- "Go: Toggle compiler optimization details" 실행
- `escape`를 포함하도록 `ui.diagnostic.annotations` 활성화

컴파일러 소스 코드를 통해 기계 판독 가능한 JSON 출력에 접근합니다.

### 3단계: 구현 특정 최적화

1. **포인터 없는 값**: 다른 값에서 분리됨
   - 포인터를 제거하면 GC 캐시 압력 감소
   - 인덱스 기반 구조가 포인터 기반보다 더 잘 수행될 수 있음

2. **포인터 필드 순서 지정**: GC는 마지막 포인터에서 스캔 중지
   - 포인터 필드를 구조체 시작 부분에 그룹화
   - 스캔 오버헤드 감소(아직 자동화되지 않음)

3. **포인터 대신 인덱스**: 모든 포인터와의 GC 상호 작용 감소

---

## Linux 투명 대형 페이지 (THP)

### 개요

투명 대형 페이지는 표준 페이지를 더 큰 블록으로 투명하게 대체하여 페이지 테이블 조회 시간을 개선하지만 잠재적으로 메모리를 낭비합니다.

### Go 프로그램에 대한 영향

- **작은 힙** (< 1 GiB): 50% 추가 메모리 사용, 처리량 이점 거의 없음
- **큰 힙** (>= 1 GiB): 최대 10% 처리량 개선, 1-2% 메모리 오버헤드

### 권장 설정

```bash
# 조각 모음을 느리게 활성화
echo defer > /sys/kernel/mm/transparent_hugepage/defrag
# 또는
echo defer+madvise > /sys/kernel/mm/transparent_hugepage/defrag

# 공격적인 대형 페이지 할당 방지
echo 0 > /sys/kernel/mm/transparent_hugepage/khugepaged/max_ptes_none
```

### Go 1.21+ 해결 방법

```bash
# 프로세스별 대형 페이지 비활성화
golang.org/x/sys/unix.Prctl(unix.PR_SET_THP_DISABLE, ...)

# 환경 변수 (Go 1.21.6+, 1.22+)
export GODEBUG=disablethp=1
```

---

## 가상 메모리 vs. 물리적 메모리

### 핵심 구분

- **물리적 메모리**: 실제 RAM
- **가상 메모리**: OS 추상화, 물리적 지원 없이 예약 가능
- **가상 메모리는 저렴**: 물리적 메모리 없이 큰 가상 예약 허용

### Go 런타임 사용

1. 가상 메모리를 삭제하지 않음; OS 연산을 사용하여 물리적 리소스 해제
2. 32비트: 단편화 제한을 위해 미리 128-512 MiB 예약
3. 64비트: 내부 데이터 구조가 최소 ~700 MiB 가상 메모리 예약

### 실용적 함의

가상 메모리 메트릭(`top`의 "VSS")은 유용하지 않습니다. 물리적 메모리 사용량에 대해 "RSS" 및 유사 항목에 집중하세요.

---

## 추가 리소스

- **[GC 핸드북](https://gchandbook.org/)**: 일반 GC 설계 참조
- **[TCMalloc 설계](https://google.github.io/tcmalloc/design.html)**: 메모리 할당자(Go의 것은 이에 기반)
- **[Go 1.5 GC 발표](/blog/go15gc)**: 동시성 GC 세부사항
- **[Getting to Go](/blog/ismmkeynote)**: 2018년까지의 GC 진화
- **[Go 1.5 동시성 GC 페이싱](https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit)**: 마크 단계 타이밍
- **[더 스마트한 스캐빈징](/issue/30333)**: OS에 메모리 반환
- **[확장 가능한 페이지 할당자](/issue/35112)**: OS 메모리 관리
- **[GC 페이서 재설계 (Go 1.18)](/issue/44167)**: 마크 단계 알고리즘
- **[소프트 메모리 제한 (Go 1.19)](/issue/48409)**: 메모리 제한 설계

---

## 부록: GOGC에 대한 추가 참고사항

### 두 배 속성의 수학적 증명

**새 힙 메모리 공식**:
```
새 힙 메모리 = (라이브 힙 + GC 루트) x GOGC / 100
```

GOGC를 두 배로 늘리면 사이클당 새 힙 메모리가 두 배가 됩니다.

**사이클당 GC CPU 비용**:
```
사이클당 GC CPU 비용 = (라이브 힙 + GC 루트) x (바이트당 비용) + 고정 비용
```

**정상 상태 GC 빈도**:
```
GC 빈도 = (할당률) / (새 힙 메모리)
        = (할당률) / ((라이브 힙 + GC 루트) x GOGC / 100)
```

**총 GC CPU 비용**:
```
총 GC CPU 비용 = GC 빈도 x 사이클당 GC 비용 x T
```

큰 힙(한계 비용 지배)의 경우:
```
총 GC CPU 비용 = (할당률 / (GOGC / 100)) x (바이트당 비용) x T
```

**결과**: GOGC를 두 배로 늘리면 총 GC CPU 비용이 절반으로 줄어듭니다(역관계).

### 힙 구조 고려사항

불일치 존재: 구조가 다른 동일 크기의 라이브 힙은 다른 CPU 비용을 산출합니다. GC는 포인터 밀도와 구조에 따라 다른 양을 스캔해야 합니다.

---

이 포괄적인 가이드는 고급 Go 개발자에게 애플리케이션에서 가비지 컬렉션 동작을 이해, 측정, 최적화하는 도구를 제공합니다.
