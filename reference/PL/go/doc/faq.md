# Go 프로그래밍 언어 - 자주 묻는 질문 (FAQ)

## 기원

### 프로젝트의 목적은 무엇인가요?

Go는 Google에서 대규모 소프트웨어 개발을 위한 기존 언어 및 환경에 대한 불만을 해결하기 위해 만들어졌습니다. 이 언어는 다음을 결합하는 것을 목표로 했습니다:
- 동적 타입 언어(Python, JavaScript)의 **프로그래밍 용이성**
- 정적 타입, 컴파일 언어(C++, Java)의 **효율성과 안전성**
- 네트워크 및 멀티코어 컴퓨팅 지원으로 **현대 하드웨어에 대한 더 나은 적응**
- **빠른 컴파일** - 대형 실행 파일이 단일 컴퓨터에서 몇 초 내에 빌드되어야 함

핵심 설계 고려사항에는 대규모 동시성 프로그램에서 리소스 관리를 처리하기 위한 동시성/병렬성 및 가비지 컬렉션 지원이 포함되었습니다.

### 프로젝트의 역사는 무엇인가요?

- **2007년 9월 21일**: Robert Griesemer, Rob Pike, Ken Thompson이 Go 설계 시작
- **2008년 1월**: Ken Thompson이 컴파일러 구축 시작
- **2008년 5월**: 프로덕션 컴파일러 개발과 함께 풀타임 프로젝트 시작
- **2008년 5월**: Ian Taylor가 독자적으로 Go를 위한 GCC 프론트엔드 시작
- **2008년 후반**: Russ Cox가 합류하여 언어를 프로토타입에서 프로덕션으로 이동
- **2009년 11월 10일**: Go가 공개 오픈 소스 프로젝트가 됨

### 고퍼 마스코트의 기원은?

**Renée French**(Plan 9의 Glenda도 디자인함)가 디자인했습니다. 마스코트는 Creative Commons Attribution 4.0 라이선스로 보호됩니다. French는 고퍼의 특성을 설명하는 모델 시트를 만들었으며, 2016년 Gophercon 발표에서 처음 공개되었습니다.

### 언어 이름이 Go인가요, Golang인가요?

언어 이름은 **Go**입니다. "Golang"은 원래 웹사이트가 golang.org였기 때문에 생겼습니다. "golang"이 널리 사용되지만(특히 #golang과 같은 소셜 미디어 태그에서), 공식 언어 이름은 단순히 **Go**입니다.

### 왜 새로운 언어를 만들었나요?

Go는 핵심 문제를 해결했습니다: 프로그래머들은 다음 중에서 선택해야 했습니다:
1. 효율적인 컴파일
2. 효율적인 실행
3. 프로그래밍 용이성

주류 언어에서는 세 가지 모두 사용할 수 없었습니다. Go는 현재 하드웨어(네트워크, 멀티코어 컴퓨팅)에 더 잘 적응하면서 세 가지를 모두 결합하려고 시도했습니다.

### Go의 조상은 무엇인가요?

- **C 계열**: 기본 구문
- **Pascal/Modula/Oberon 계열**: 선언 및 패키지
- **CSP에서 영감을 받은 언어들** (Newsqueak, Limbo): 동시성 기능

### 설계 지침 원칙은?

1. **타이핑 줄이기** - 리터럴 타이핑과 타입 복잡성 모두
2. **혼란 제거** - 단일 선언, 전방 선언 없음, 자동 초기화
3. **개념을 직교적으로 유지** - 모든 타입에 대한 메서드, 데이터를 위한 구조체, 추상화를 위한 인터페이스
4. **도구 지원 활성화** - 코드 포맷팅 자동화, 의존성 관리
5. **동시성 지원** - 일급 동시성 기본 요소
6. **효율적인 컴파일** - 빠른 빌드 시간

## 사용

### Google은 내부적으로 Go를 사용하나요?

예. Go는 Google에서 프로덕션에 널리 사용됩니다. 포함:
- Google의 다운로드 서버(dl.google.com) - Chrome 및 패키지용
- 사이트 신뢰성 엔지니어링(SRE)
- 대규모 데이터 처리
- Google Cloud 인프라

### 다른 회사들은 Go를 사용하나요?

Go를 사용하는 주요 프로젝트:
- **Docker** - 컨테이너화 플랫폼
- **Kubernetes** - 컨테이너 오케스트레이션
- **클라우드 컴퓨팅 프로젝트** - 광범위한 채택

광범위한 성공 사례와 회사 목록은 go.dev 웹사이트와 Go Wiki를 참조하세요.

### Go 프로그램이 C/C++와 링크되나요?

가능하지만 자연스럽지 않습니다. C와 Go를 링크하면 메모리 안전성 및 스택 관리 보장이 희생됩니다. 안전한 C 라이브러리 통합을 위해 **cgo**를 사용하세요:

```go
// cgo는 C를 위한 외부 함수 인터페이스를 제공합니다
import "C"
```

**SWIG**는 이를 C++ 라이브러리로 확장합니다. GCC 기반(gccgo) 및 LLVM 기반(gollvm) 컴파일러는 C/C++와 더 직접적으로 링크할 수 있지만 큰 주의가 필요합니다.

### Go는 어떤 IDE를 지원하나요?

Go 프로젝트에는 사용자 정의 IDE가 포함되어 있지 않지만, 잘 알려진 편집기를 지원합니다:
- **Emacs, Vim, VSCode, Atom**
- **Eclipse, Sublime Text**
- **IntelliJ/GoLand**
- LSP 호환 도구를 위한 gopls를 통한 **LSP 지원**

### Go는 Google의 프로토콜 버퍼를 지원하나요?

예, **github.com/golang/protobuf/**의 별도 오픈 소스 프로젝트를 통해 지원합니다.

## 설계

### Go에 런타임이 있나요?

예. Go에는 다음을 구현하는 광범위한 런타임 라이브러리가 포함되어 있습니다:
- 가비지 컬렉션
- 동시성
- 스택 관리
- 중요한 언어 기능

Java와 달리 Go는 네이티브 머신 코드(또는 JavaScript/WebAssembly)로 미리 컴파일됩니다. 런타임은 가상 머신이 아니라 C의 libc와 유사합니다.

### 유니코드 식별자는 어떻게 되나요?

Go의 간단한 규칙: **식별자 문자는 유니코드에 의해 정의된 문자 또는 숫자여야 합니다**

제한사항:
- 설계상 결합 문자 제외
- 일부 언어 제외(예: 데바나가리)
- 내보낸 식별자는 대문자로 시작해야 함 - 일부 언어는 정의상 식별자를 내보낼 수 없음

### Go에 기능 X가 없는 이유는 무엇인가요?

Go는 특정 목표를 가지고 설계되었습니다: 프로그래밍의 편의성, 컴파일 속도, 직교성, 동시성, 가비지 컬렉션. 좋아하는 기능이 없을 수 있는 이유:
- 설계 철학에 맞지 않음
- 컴파일 속도에 영향
- 설계 명확성 위반
- 기본 시스템 모델을 복잡하게 만듦

### Go는 언제 제네릭 타입을 얻었나요?

**Go 1.18**에서 타입 매개변수가 추가되어 다형성/제네릭 프로그래밍이 가능해졌습니다.

### 처음에 제네릭 없이 출시된 이유는?

Go는 단순성을 우선시했고 유지 관리하기 쉬운 것을 목표로 했습니다. 제네릭은 타입 시스템과 런타임에 복잡성 비용을 가져옵니다. 복잡성에 비례하는 가치를 제공하는 설계를 개발하는 데 시간이 걸렸습니다.

### 왜 예외가 없나요?

Go는 try-catch-finally와 다른 접근 방식을 취합니다:
- 예외를 제어 구조에 결합하면 복잡한 코드가 됨
- 일반적인 오류(예: 파일 열기 실패)를 예외적인 것으로 잘못 라벨링하도록 권장
- 다중 값 반환은 반환 값을 오버로딩하지 않고 오류 보고를 쉽게 만듦

```go
// Go의 접근 방식
result, err := someFunction()
if err != nil {
    // 오류 처리
}
```

내장 함수 `panic`과 `recover`는 진정으로 예외적인 조건을 처리합니다.

### 왜 어설션이 없나요?

어설션은 편리하지만 프로그래머들이 적절한 오류 처리를 피하기 위한 보조 수단으로 사용합니다. 적절한 오류 처리는 서버를 충돌시키는 대신 계속 실행하게 합니다.

### 왜 CSP(Communicating Sequential Processes)를 기반으로 구축했나요?

CSP는 동시성을 위한 고수준 언어적 지원을 제공합니다. Go의 동시성 기본 요소는 CSP의 계보에서 비롯되며, 특히 **일급 객체로서의 채널**이라는 강력한 개념이 있습니다. 이 접근 방식은 절차적 언어 프레임워크에서 성공적임이 입증되었습니다.

### 왜 스레드 대신 고루틴인가요?

고루틴은 독립적으로 실행되는 코루틴을 스레드 집합에 멀티플렉싱합니다. 고루틴이 차단되면(예: 시스템 호출), 런타임은 자동으로 다른 고루틴을 실행 가능한 스레드로 이동시켜 차단을 방지합니다.

**주요 장점:**
- 경량 - 스택 메모리 외 오버헤드가 낮음(몇 킬로바이트)
- 크기 조절 가능, 제한된 스택 - 자동으로 증가/축소
- 함수 호출당 약 3개의 저렴한 명령어의 CPU 오버헤드
- 동일한 주소 공간에서 수십만 개 생성 가능
- 스레드였다면 시스템 리소스가 훨씬 빨리 고갈될 것

### 왜 맵 연산이 원자적이지 않나요?

대부분의 맵 사용은 안전한 동시 접근이 필요하지 않습니다. 필요한 경우 데이터는 일반적으로 더 큰 동기화된 구조의 일부입니다. 모든 맵 연산이 뮤텍스를 잡게 만들면:
- 대부분의 프로그램이 느려짐
- 소수의 경우에만 안전성 추가

**안전 지침:**
- 동시 읽기만 안전
- 어떤 고루틴이라도 맵을 수정하면 안전하지 않음
- 일부 구현에는 동시 수정 감지가 있음
- 특정 패턴(예: 정적 캐시)에는 `sync.Map` 사용 가능

### 제 언어 변경을 받아들이시겠어요?

매우 가능성이 낮습니다. 언어는 기존 프로그램을 깨는 변경을 방지하는 **호환성 약속**으로 보호됩니다. 향후 메이저 릴리스에서 비호환성이 도입될 수 있지만 매우 드뭅니다.

호환 가능한 제안조차도 Go의 설계 목표에 맞지 않을 수 있습니다. 설계 동기에 대해서는 "[Go at Google: Language Design in the Service of Software Engineering](/talks/2012/splash.article)"을 참조하세요.

## 타입

### Go는 객체 지향인가요?

**예이기도 하고 아니기도 합니다.** Go에는 OO 스타일 프로그래밍을 허용하는 타입과 메서드가 있지만:
- **타입 계층 없음** - "인터페이스" 개념이 다른 접근 방식 제공
- **타입 임베딩** - 서브클래싱과 유사하지만 동일하지 않음
- **범용 메서드** - 모든 타입(내장 타입 포함)에 정의 가능
- **경량 객체** - C++나 Java 동등물보다 더 가벼움

### 메서드의 동적 디스패치를 어떻게 얻나요?

**인터페이스를 통해서만.** 구조체나 구체적인 타입의 메서드는 항상 정적으로 해결됩니다.

### 왜 타입 상속이 없나요?

전통적인 OO는 타입 간 관계를 선언해야 하며, 종종 자동으로 도출할 수 있습니다. Go의 접근 방식:

```go
// 타입은 메서드와 일치하는 모든 인터페이스를 자동으로 만족합니다
type Reader interface {
    Read(p []byte) (n int, err error)
}

type File struct { ... }
func (f *File) Read(p []byte) (n int, err error) { ... }
// File은 자동으로 Reader를 구현합니다 - 선언 불필요
```

**장점:**
- 기록 관리 감소
- 타입이 복잡성 없이 여러 인터페이스 만족 가능
- 경량 인터페이스(0개 메서드 인터페이스도 유용)
- 원래 타입에 주석 없이 소급하여 인터페이스 추가 가능
- 관리할 타입 계층 없음

### 왜 `len`은 메서드가 아니라 함수인가요?

`len`과 친구들을 함수로 구현하면 기본 타입의 인터페이스가 단순화되고 타입 시스템이 복잡해지지 않습니다.

### 왜 메서드/연산자 오버로딩이 없나요?

이름만으로 일치시키고 타입 일관성을 요구하는 것은 Go의 타입 시스템에서 주요 단순화 결정이었습니다. 타입 일치 요구사항을 제거하여 메서드 디스패치를 단순화합니다.

### 왜 "implements" 선언이 없나요?

Go 타입은 메서드를 구현하여 인터페이스를 구현합니다 - 그 이상 없습니다. 이것은 다음을 가능하게 합니다:
- 기존 코드를 수정하지 않고 정의되고 사용되는 인터페이스
- 관심사 분리를 촉진하는 구조적 타이핑
- 향상된 코드 재사용
- 코드가 발전함에 따라 더 쉬운 패턴 구축

### 타입이 인터페이스를 만족하는지 어떻게 보장하나요?

컴파일 시간 검사와 함께 빈 식별자를 사용하세요:

```go
type T struct{}
var _ I = T{}       // T가 I를 구현하는지 확인
var _ I = (*T)(nil) // *T가 I를 구현하는지 확인

// 또는 명시적 마커 메서드 추가
type Fooer interface {
    Foo()
    ImplementsFooer()
}

type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
```

### 왜 타입 T는 Equal 인터페이스를 만족하지 않나요?

```go
type Equaler interface {
    Equal(Equaler) bool
}

type T int
func (t T) Equal(u T) bool { return t == u } // Equaler를 만족하지 않음
// 인자 타입이 Equaler가 아니라 T이기 때문

type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) } // Equaler 만족
```

일부 다형성 시스템과 달리 Go는 인자를 자동으로 승격하지 않습니다. 이것은 타입 시스템 규칙을 간단하고 효율적으로 구현하기 쉽게 유지합니다.

### []T를 []interface{}로 변환할 수 있나요?

직접적으로는 불가능합니다 - 동일한 메모리 표현이 아닙니다:

```go
t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v // 요소를 개별적으로 복사해야 함
}
```

### 동일한 기본 타입을 가진 []T1을 []T2로 변환할 수 있나요?

```go
type T1 int
type T2 int
var t1 T1
var x = T2(t1) // OK - 타입 변환

var st1 []T1
var sx = ([]T2)(st1) // OK가 아님 - 복합 타입 요소를 변경할 수 없음
```

Go는 타입이 메서드와 연결되어 있기 때문에 명시적 타입 변환을 요구합니다.

### 왜 내 nil 오류 값이 nil과 같지 않나요?

인터페이스는 타입 `T`와 값 `V`를 포함합니다:

```go
// nil *int가 인터페이스에 저장된 경우:
// T=*int, V=nil
// V가 nil이어도 T가 설정되어 있으므로 인터페이스는 non-nil

func returnsError() error {
    var p *MyError = nil
    if bad() {
        p = ErrBad
    }
    return p // (T=*MyError, V=nil) 반환 - non-nil 오류!
}

// 올바른 접근:
func returnsError() error {
    if bad() {
        return ErrBad
    }
    return nil // 명시적 nil
}
```

오류를 반환하는 함수는 구체적인 타입이 아닌 error 인터페이스 타입을 사용해야 합니다.

### 왜 크기가 0인 타입은 이상하게 동작하나요?

Go는 크기가 0인 타입을 지원합니다: `struct{}`, `[0]byte`. 특징:
- 변수가 동일한 메모리 위치에 있을 수 있음
- 언어는 포인터 동등성을 보장하지 않음
- 마지막 크기가 0인 구조체 필드는 포인터 중첩을 방지하기 위해 패딩됨

```go
type S struct {
    f1 byte
    f2 struct{}
}
fmt.Println(unsafe.Sizeof(S{})) // 1이 아닌 2 출력
```

### 왜 태그 없는 유니온이 없나요?

Go의 메모리 안전성 보장을 위반합니다.

### 왜 변형 타입이 없나요?

변형 타입(대수적 타입)은 인터페이스와 혼란스럽게 겹칩니다. Go는 인터페이스 값과 타입 스위치를 통해 유사한 요구를 해결합니다:

```go
// 오류에 대한 변형 타입 대신:
var err error = someFunction()
switch v := err.(type) {
case NetworkError:
    // 네트워크 오류 처리
case SecurityError:
    // 보안 오류 처리
}
```

### 왜 공변 결과 타입이 없나요?

```go
type Copyable interface {
    Copy() interface{}
}

func (v Value) Copy() Value // Go에서 Copyable을 만족하지 않음
// 메서드 타입 일치에서 Value ≠ interface{}이기 때문
```

Go는 "타입이 하는 일"(메서드)과 구현을 분리합니다. 다른 반환 타입 = 다른 메서드. 인터페이스와 구현 간의 깔끔한 분리를 유지합니다.

## 값

### 왜 암시적 숫자 변환이 없나요?

암시적 변환은 혼란을 야기합니다:
- 표현식이 언제 unsigned인가?
- 값이 얼마나 큰가?
- 오버플로우 되는가?
- 결과가 이식 가능한가?

또한 컴파일러를 복잡하게 만듭니다(C의 "일반적인 산술 변환"은 아키텍처 간에 일관성이 없음).

Go는 명확성을 위해 명시적 변환을 교환합니다:

```go
int64(x) // 명시적 변환 필요
```

상수가 이를 개선합니다 - 임의 정밀도, 할당 전까지 오버플로우/언더플로우 없음.

### 상수는 어떻게 작동하나요?

상수는 임의 정밀도의 이상적인 숫자 공간을 차지합니다:

```go
math.Pi // 소스에서 63자리 십진수
var x float64 = math.Pi // 그때서야 float64가 됨

sqrt2 := math.Sqrt(2) // 이상적인 숫자 2가 안전하게 float64로 변환
```

변수 위치에 할당해야만 일반적인 부동소수점 속성을 가진 "컴퓨터" 숫자가 됩니다.

### 왜 맵이 내장되어 있나요?

맵은 구문적 지원과 함께 훌륭한 구현을 받을 자격이 있는 강력한 데이터 구조입니다. 사용자 정의 구현은 가능하지만 편리하지 않습니다.

### 왜 맵은 슬라이스를 키로 허용하지 않나요?

맵 조회는 동등성 연산자가 필요합니다. 슬라이스는 동등성을 구현하지 않습니다 - 동등성이 무엇을 의미해야 하는지 명확한 정의가 없습니다(얕은 vs 깊은, 포인터 vs 값, 재귀 타입).

구조체와 배열에는 동등성이 정의되어 있습니다 - 맵 키가 될 수 있습니다.

### 왜 맵, 슬라이스, 채널은 참조이고 배열은 값인가요?

초기 설계: 맵과 채널은 구문적으로 포인터였습니다. 엄격한 포인터/값 분리는 언어를 사용하기 어렵게 만들었습니다. 이러한 타입을 관련 공유 데이터 구조에 대한 참조로 작동하도록 변경하여 약간의 복잡성을 희생하고 사용성 문제를 해결했습니다.

## 코드 작성

### 라이브러리는 어떻게 문서화되나요?

- **`go doc`** - 명령줄 문서
- **[pkg.go.dev](https://pkg.go.dev/)** - HTML 문서와 함께 전역 패키지 검색
- **`pkgsite`** - 로컬 문서 서버

### Go 프로그래밍 스타일 가이드가 있나요?

명시적 가이드는 없지만, 다음을 통해 확립된 관례가 있습니다:
- **Effective Go** - 명명, 레이아웃, 파일 구성에 대한 조언
- **`gofmt`** - 레이아웃 규칙 적용(대부분의 Go 코드가 사용)
- **Go Code Review Comments** - 관용구 에세이 모음

### 패치는 어떻게 제출하나요?

1. 메일링 리스트에서 먼저 중요한 변경 사항 논의
2. "Contributing to the Go project" 문서 참조
3. 라이브러리 소스는 저장소의 `src/` 디렉터리에 있음

### "go get"이 왜 HTTPS를 사용하나요?

- 회사들은 일반적으로 HTTP(포트 80)와 HTTPS(포트 443)만 허용
- HTTPS는 기본적으로 인증서 유효성 검사 강제
- 중간자 공격, 도청, 변조로부터 보호

**인증:**
```bash
# $HOME/.netrc에 추가
machine github.com login USERNAME password APIKEY

# 또는 SSH용 git 구성
[url "ssh://git@github.com/"]
    insteadOf = https://github.com/
```

### "go get"으로 패키지 버전을 어떻게 관리하나요?

**모듈** 사용(Go 1.11 도입, 1.14 프로덕션 준비):

```bash
go mod init example/project  # go.mod 생성
go get golang.org/x/text@v0.3.5  # 의존성 추가/업그레이드/다운그레이드
```

**가져오기 호환성 규칙**에 따라 하위 호환성 유지: 동일한 가져오기 경로를 가진 새 패키지는 하위 호환성이 있어야 합니다.

**시맨틱 버저닝:** 메이저 버전 2+는 가져오기 경로에 [메이저 버전 접미사](/v2)가 필요합니다:
```go
import "example.com/pkg/v2"
```

## 포인터 및 할당

### 함수 매개변수는 언제 값으로 전달되나요?

모든 것이 값으로 전달됩니다 - 함수는 복사본을 받습니다. 맵/슬라이스/채널은 포인터를 포함하는 설명자입니다; 복사하면 데이터가 아닌 포인터 복사본이 만들어집니다.

```go
func modify(p *int) {
    *p = 10 // 호출자의 값을 수정
}

func copyMap(m map[string]int) {
    m["key"] = 99 // 호출자의 맵을 수정(참조 의미)
}
```

### 언제 인터페이스에 대한 포인터를 사용해야 하나요?

**거의 절대.** 인터페이스 값에 대한 포인터는 드물고 까다로운 상황에서만 사용됩니다.

일반적인 실수:
```go
var w io.Writer
fmt.Fprintf(w, "hello\n")        // 올바름
fmt.Fprintf(&w, "hello\n")       // 컴파일 오류

// 예외: 빈 인터페이스는 무엇이든 받음
var x interface{} = &w // 합법적이지만 혼란스러움
```

### 값에 메서드를 정의해야 하나요, 포인터에 해야 하나요?

```go
func (s *MyStruct) pointerMethod() { } // 포인터에 대한 메서드
func (s MyStruct)  valueMethod()   { } // 값에 대한 메서드
```

**기준:**
1. **수신자를 수정하나요?** - 반드시 포인터 수신자
2. **효율성** - 큰 구조체: 포인터 수신자 사용
3. **일관성** - 어떤 메서드라도 포인터가 필요하면, 일관된 메서드 집합을 위해 모두 포인터여야 함
4. **비용** - 기본 타입, 슬라이스, 작은 구조체: 값 수신자가 효율적이고 명확

### new와 make의 차이점은 무엇인가요?

- **`new`** - 메모리 할당, 포인터 반환
- **`make`** - 슬라이스, 맵, 채널 타입 초기화, 초기화된 값 반환

```go
p := new(int)      // 할당, p는 *int, 역참조된 값은 0
s := make([]int, 10) // 용량 10인 슬라이스 생성
m := make(map[string]int) // 맵 생성
c := make(chan int) // 채널 생성
```

### 64비트 머신에서 int의 크기는 무엇인가요?

구현에 따라 다르지만 주어진 플랫폼에서 uint와 동일합니다. 이식성을 위해 명시적으로 크기가 지정된 타입을 사용하세요:

```go
var x int64 = 10 // 명시적 크기

// 부동소수점은 항상 크기 지정
var f float32 = 3.0
var d float64 = 3.0

// 타입 없는 상수
foo := 3.0 // float64로 추론
```

### 변수가 힙에 할당되는지 스택에 할당되는지 어떻게 알 수 있나요?

**정확성 관점에서: 알 필요 없습니다.** 참조가 존재하는 한 변수가 존재합니다. 저장 위치는 언어 의미에 영향을 미치지 않습니다.

**구현 세부사항:**
- 컴파일러는 스택에 지역 함수 변수 할당
- 주소가 취해진 변수는 힙 후보
- 이스케이프 분석은 스택 할당이 안전한 경우 인식
- 매우 큰 변수는 힙에 갈 수 있음
- 실제 메모리: `top`으로 `RES`(Linux) 또는 `RSIZE`(macOS) 확인

### 왜 내 Go 프로세스가 그렇게 많은 가상 메모리를 사용하나요?

Go 메모리 할당자는 아레나로 큰 가상 메모리 영역을 예약합니다. 예약은 프로세스 로컬입니다 - 다른 프로세스를 박탈하지 않습니다. 시스템 도구로 실제 메모리 사용량을 확인하세요.

## 동시성

### 어떤 연산이 원자적인가요?

[Go 메모리 모델](/ref/mem) 문서를 참조하세요.

**동기화 기본 요소:**
- `sync` 패키지 - 동기화
- `sync/atomic` 패키지 - 원자적 기본 요소, 참조 계수, 상호 배제

**고수준 접근:**

```
메모리를 공유하여 통신하지 마세요.
대신, 통신하여 메모리를 공유하세요.
```

특정 데이터에 대해 하나의 고루틴만 책임지도록 프로그램을 구조화하고, 고루틴과 채널을 통해 조정합니다.

### 왜 프로그램이 더 많은 CPU로 더 빠르게 실행되지 않나요?

동시성 ≠ 병렬성. 문제가 본질적으로 병렬인 경우에만 더 많은 CPU가 도움이 됩니다. 순차적 문제는 CPU로 속도를 높일 수 없습니다. 계산보다 동기화 오버헤드가 더 많은 프로그램은 더 많은 CPU로 느려질 수 있습니다(컨텍스트 전환 비용).

### CPU 수를 어떻게 제어하나요?

**`GOMAXPROCS`** 환경 변수(기본값 = CPU 코어 수):

```bash
GOMAXPROCS=4 go run program.go # 4개 CPU 사용

# 또는 코드에서
runtime.GOMAXPROCS(4)
```

1로 설정하면 병렬성이 제거되어 고루틴이 교대로 실행됩니다.

### 왜 고루틴 ID가 없나요?

고루틴은 고유 식별자가 없는 익명 작업자입니다. 이유:
- 동시성 코드에서 전체 Go 언어 사용 가능
- 명명된 고루틴은 라이브러리 설계 제한
- 특수 스레드/고루틴을 처리하기 위해 왜곡된 프로그램 강제
- 채널이 유연한 상호 작용 제공

## 함수 및 메서드

### 왜 T와 *T는 다른 메서드 집합을 가지나요?

```go
type T struct { ... }
func (t T) ValueMethod() { }    // T에 대한 메서드
func (t *T) PointerMethod() { } // *T에 대한 메서드

var t T
t.ValueMethod()      // OK
t.PointerMethod()    // OK - 컴파일러 자동 역참조
t.PointerMethod()    // 그러나 값에서 *T를 안정적으로 얻을 수 없음

var pt *T
pt.ValueMethod()     // OK - 역참조하여 호출
pt.PointerMethod()   // OK
```

포인터 수신자 메서드 집합은 값 수신자 메서드를 포함하지만 그 반대는 아닙니다. 메서드가 값을 수정하면 호출자에서 변경 사항이 손실됩니다.

### 고루틴으로 실행되는 클로저는 어떻게 되나요?

**Go 1.22 이전**, 루프 변수가 혼란을 야기했습니다:

```go
for _, v := range values {
    go func() {
        fmt.Println(v) // 문제: v가 고루틴 간에 공유됨
    }()
}
// 출력 종종: c, c, c (a, b, c가 아님)
```

**해결책:**

```go
// 인자로 전달
for _, v := range values {
    go func(u string) {
        fmt.Println(u)
    }(v)
}

// 반복마다 새 변수 생성
for _, v := range values {
    v := v // 새 'v' 생성
    go func() {
        fmt.Println(v)
    }()
}
```

**Go 1.22:** 이 동작을 수정했습니다 - 루프 변수는 이제 반복마다 자동으로 생성됩니다.

## 제어 흐름

### 왜 삼항 `?:` 연산자가 없나요?

```go
// n = expr ? trueVal : falseVal 대신:

if expr {
    n = trueVal
} else {
    n = falseVal
}
```

이유: 삼항은 꿰뚫을 수 없이 복잡한 표현식을 만듭니다. `if-else`가 더 명확합니다. 하나의 조건부 제어 흐름 구조로 충분합니다.

## 타입 매개변수

### 왜 Go에 타입 매개변수가 있나요?

제네릭 프로그래밍을 가능하게 합니다:

```go
// 모든 정렬된 타입에 대한 제네릭 함수
func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

x := Min(3, 5)        // int
y := Min(3.5, 5.5)    // float64
```

자세한 설명은 [블로그 게시물 "Why Generics?"](/blog/why-generics)를 참조하세요.

### 제네릭은 어떻게 구현되나요?

컴파일러는 다음을 할 수 있습니다:
- 각 인스턴스화를 별도로 컴파일하거나, 또는
- 유사한 인스턴스화를 단일 구현으로 컴파일(인터페이스 매개변수와 유사)

표준 컴파일러는 동일한 "형태"(크기, 포인터 위치)를 가진 타입에 대해 단일 인스턴스화를 생성합니다.

### Go의 제네릭은 다른 언어와 어떻게 비교되나요?

**Java:**
- 타입 소거 - 제네릭 정보가 런타임에 제거됨
- 공변/반공변을 위한 타입 와일드카드
- Go는 리플렉션에서 전체 컴파일 시간 타입 정보 유지

**C++:**
- 필수 제약 없음(C++20 개념은 선택적)
- Go 제약은 필수
- C++는 템플릿 메타프로그래밍 지원; Go는 지원하지 않음
- C++는 인스턴스화 시점에 컴파일; Go는 유연

**Rust:**
- 트레이트 바운드(명시적으로 선언해야 함)
- Go는 인터페이스처럼 암시적 만족
- Rust는 표준 트레이트 정의(비교, 덧셈); Go는 사용자 인터페이스 사용
- 예외: Go의 미리 정의된 `comparable` 인터페이스

**Python:**
- 동적 타입 - 모든 함수가 암시적으로 제네릭
- Python은 런타임 타입 검사 수행

### 왜 타입 매개변수에 대괄호인가요?

꺾쇠 괄호(`<`)는 타입 정보 없이 파싱 모호성을 만듭니다:

```go
a, b = w < x, y > (z)
// 타입 정보 없이: 이것이 (w < x, y > z)인가 (w<x, y>)(z)인가?
```

Go는 타입 정보 없이 파싱합니다. 꺾쇠 괄호는 불가능합니다. 대괄호가 명확합니다.

### 왜 타입 매개변수가 있는 메서드가 없나요?

```go
type Empty struct{}

func (Empty) Nop[T any](x T) T { // 잘못됨
    return x
}
```

인터페이스 만족 검사가 결정 불가능해지기 때문에 문제가 됩니다 - 동적 인터페이스 검사에 무한한 메서드 구현이 필요합니다.

Go는 제네릭 함수/타입을 메서드에서 분리하여 대신 최상위 함수 제네릭 또는 타입 매개변수화된 수신자를 요구합니다.

### 왜 매개변수화된 수신자에서 특정 타입을 사용할 수 없나요?

```go
type S[T any] struct { f T }

func (s S[string]) Add(t string) string {
    return s.f + t // 컴파일러 오류: 'string'은 타입 매개변수 이름
}
```

컴파일러는 `string`을 미리 선언된 타입이 아닌 타입 매개변수로 처리합니다.

### 왜 컴파일러가 타입 인자를 추론할 수 없나요?

타입 추론은 혼란이 없도록 의도적으로 제한됩니다. 명시적 타입 인자를 지정하는 것은 항상 가능합니다. 미래 버전에서 규칙이 간단하고 명확하게 유지된다면 새로운 추론 형식을 지원할 수 있습니다.

```go
result := someGeneric[int](data)  // 명시적 타입 인자
```

## 패키지 및 테스팅

### 다중 파일 패키지를 어떻게 만드나요?

모든 소스 파일을 디렉터리에 넣으세요. 파일은 다른 파일의 항목을 참조할 수 있습니다:

```
mypackage/
  file1.go
  file2.go
  file3.go
```

전방 선언이나 헤더 파일이 필요 없습니다.

### 단위 테스트는 어떻게 작성하나요?

테스트 함수가 있는 `_test.go` 파일을 만드세요:

```go
package mypackage

import "testing"

func TestFoo(t *testing.T) {
    result := Foo()
    if result != expected {
        t.Errorf("expected %v, got %v", expected, result)
    }
}
```

실행: `go test`

### 내가 좋아하는 테스트 헬퍼는 어디 있나요?

Go의 `testing` 패키지는 의도적으로 최소한입니다. 이유:
- 어설션은 적절한 오류 처리를 피하기 위한 보조 수단
- 적절한 오류 처리는 실패 후에도 다른 테스트 실행 가능
- 첫 번째가 아닌 모든 실패를 보고하는 것이 더 나음
- Go에는 이미 조건, 제어, 출력이 있음 - 미니 언어 불필요
- 테이블 기반 테스트가 종종 어설션 프레임워크보다 깔끔

```go
// 테이블 기반 테스트 접근 방식
var tests = []struct {
    input    int
    expected bool
}{
    {2, true},
    {3, true},
    {4, false},
}

for _, tt := range tests {
    t.Run(fmt.Sprint(tt.input), func(t *testing.T) {
        if result := isPrime(tt.input); result != tt.expected {
            t.Errorf("isPrime(%d) = %v, want %v", tt.input, result, tt.expected)
        }
    })
}
```

### 왜 _X_가 표준 라이브러리에 없나요?

**목적:** 런타임 지원, OS 연결, 핵심 기능 제공(형식화된 I/O, 네트워킹, 웹 프로그래밍).

**포함 기준이 높은 이유:**
- 큰 유지 관리 비용(종종 원저자가 아닌 사람들이)
- Go 1 호환성 약속의 대상(API 수정 차단)
- Go 릴리스 일정의 대상(버그 수정 차단)

**더 나은 대안:** 자체 유지 관리자, 릴리스 주기, 호환성 보장과 함께 `go get`을 통해 [pkg.go.dev](https://pkg.go.dev/)에 게시.

## 구현

### 어떤 컴파일러 기술이 사용되나요?

**`gc`(기본 컴파일러):**
- 재귀 하강 파서
- 사용자 정의 로더(Plan 9 기반)
- Go 1.5부터 셀프 호스팅(원래 C)
- ELF/Mach-O/PE 바이너리 생성

**`gccgo`:**
- 재귀 하강 파서가 있는 C++ 프론트엔드
- 표준 GCC 백엔드에 결합

**`gollvm`:**
- LLVM 기반(실험적)

**`gc`에 왜 LLVM이 아닌가요?**
- 성능 목표에 비해 너무 크고 느림
- Go가 요구하는 ABI 변경을 복잡하게 만듦

### 런타임은 어떻게 구현되나요?

원래 어셈블러와 함께 C로, 현재는 Go로(어셈블러 비트 제외):
- `gc`는 사용자 정의 구현 사용
- `gccgo`는 `glibc` 사용
- `gollvm`은 LLVM 인프라 사용

런타임은 고루틴, 가비지 컬렉션, 메모리 관리를 구현합니다.

### 왜 간단한 프로그램이 큰 바이너리인가요?

Go 링커는 기본적으로 정적 링크된 바이너리를 생성합니다. 포함:
- Go 런타임
- 런타임 타입 정보
- 동적 타입 검사 지원
- 리플렉션 지원
- 패닉 시 스택 추적 지원

**크기 최적화:** DWARF 디버깅 정보를 비활성화하려면 `-ldflags=-w`를 사용하세요.

### 사용하지 않는 변수/가져오기에 대한 불만을 중지할 수 있나요?

아니요 - 설계상입니다. 사용하지 않는 변수는 버그를 나타냅니다; 사용하지 않는 가져오기는 컴파일을 느리게 합니다. Go는 둘 중 하나라도 있는 프로그램을 컴파일하지 않습니다.

**개발 중 해결 방법:**

```go
import "unused"

var _ = unused.Item  // 사용된 것으로 표시

func main() {
    debugData := debug.Profile()
    _ = debugData // 디버깅 중에만 사용
}
```

**더 나은 해결책:** **[goimports](https://godoc.org/golang.org/x/tools/cmd/goimports)** 도구 사용 - 자동으로 가져오기 수정. IDE 지원을 위해 `gopls`에 통합됨.

### 왜 바이러스 스캐닝이 Go 바이너리가 감염되었다고 생각하나요?

거짓 양성 - 바이러스 백신 소프트웨어가 Go의 바이너리 구조에 익숙하지 않습니다. [다운로드 페이지](/dl/)의 체크섬을 사용하여 다운로드를 확인하세요.

거짓 양성을 바이러스 백신 공급업체에 보고하세요.

## 성능

### 왜 Go가 벤치마크 X에서 성능이 나쁜가요?

Go는 C 성능에 접근하지만 일부 벤치마크가 좋지 않은 이유:
- 누락된 전문 라이브러리(예: 다중 정밀도 수학)
- 고도로 최적화된 C 라이브러리에 비해 미성숙한 구현
- 불충분한 튜닝

**비교 가능한 C 및 Go 프로그램**은 벤치마크 스위트가 나타내는 것보다 언어가 훨씬 더 성능이 가깝다는 것을 보여줍니다.

**개선 영역:**
- 컴파일러 최적화
- 라이브러리 성능 작업
- 가비지 컬렉션 속도

도구 및 기술에 대해서는 [Go 프로그램 프로파일링 블로그 게시물](/blog/profiling-go-programs)을 참조하세요.

## C에서의 변경

### 왜 구문이 C와 그렇게 다른가요?

**차이점의 원인:**
1. 필수 키워드/반복 없이 가벼운 구문
2. 심볼 테이블 없이 쉬운 분석 - 도구 활성화(디버거, 문서 추출기, IDE 플러그인)

C는 파싱 어려움으로 악명 높습니다.

### 왜 선언이 거꾸로인가요?

C보다 더 일관적입니다. C에서:
```c
int* a, b;  // a는 포인터, b는 아님!
```

Go에서:
```go
var a, b *int  // 둘 다 포인터 - 일관적
```

`:=` 짧은 선언 형식과 일치:
```go
var a uint64 = 1  // 다음과 같은 순서:
a := uint64(1)    // a := type value
```

[Go의 선언 구문](/doc/articles/gos_declaration_syntax.html) 기사를 참조하세요.

### 왜 포인터 산술이 없나요?

**안전:** 불법 주소 도출 방지. 배열 인덱스 루프가 이제 포인터 산술만큼 효율적. 가비지 컬렉터 단순화.

### 왜 `++`와 `--`는 표현식이 아니라 문인가요? 접두사가 아니라 접미사인가요?

**단순화:**
- 포인터 산술 없이 값 감소
- 표현식 계층에서 제거하면 구문 단순화
- 지저분한 평가 순서 문제 제거(`f(i++)`, `p[i] = q[++i]`)
- 접미사가 더 전통적

### 왜 중괄호지만 세미콜론이 없나요?

세미콜론은 파서용이지 사람용이 아닙니다. Go는 BCPL에서 차용 - 렉서가 문을 끝낼 수 있는 줄 끝에 세미콜론을 자동 삽입(미리보기 없음). 일관된 중괄호 스타일을 강제합니다.

**여는 중괄호는 같은 줄에 있어야 합니다:**
```go
func foo() {  // 올바름
    // ...
}

func foo()    // 잘못된 구문
{
    // ...
}
```

`gofmt`이 이를 자동으로 적용합니다.

### 왜 가비지 컬렉션인가요?

**이점:**
- 수동 메모리 관리 기록 관리 제거
- C 프로그램의 주요 버그 원인
- 동시성 프로그래밍을 더 쉽게 만듦(객체 수명 문제)
- 인터페이스 단순화(수명 사양 불필요)

**현재 구현:**
- 마크 앤 스윕 컬렉터
- 별도의 CPU 코어에서 병렬로 실행(멀티프로세서 머신)
- 최근 작업으로 일시 중지 시간이 밀리초 미만으로 감소(큰 힙에서도)

**성능:**
신중한 프로그래머는 적절한 메모리 관리를 통해 GC 오버헤드를 극적으로 줄일 수 있습니다.

---

## 요약

이 포괄적인 FAQ는 Go의 설계 철학, 실용적 사용, 타입 시스템, 동시성 모델, 구현 세부사항을 다룹니다. 핵심 요점:

- **설계 목표:** C의 효율성과 동적 언어의 용이성 결합, 현대적 멀티코어, 네트워크 시스템용으로 구축
- **기능보다 단순성:** 직교 개념, 예외 없음, 제네릭 없음(초기)
- **동시성 일급:** 경량 기본 요소로서의 고루틴과 채널
- **실용적 접근:** 가비지 컬렉션, 빠른 컴파일, 자동 코드 포맷팅
- **프로덕션 검증:** Google 및 주요 클라우드 회사에서 널리 사용
