# Go 프로필 기반 최적화 (PGO)

## 개요

**프로필 기반 최적화(PGO)**, 피드백 기반 최적화(FDO)라고도 알려진, 대표적인 애플리케이션 실행의 정보를 컴파일러에 피드백하여 다음 빌드에 사용하는 컴파일러 최적화 기법입니다.

**주요 기능:**
- Go 1.20부터 사용 가능
- `runtime/pprof` 또는 `net/http/pprof`에서 CPU pprof 프로파일을 입력으로 사용
- Go 1.22 기준: 대표 벤치마크에서 2-14% 성능 향상
- 향후 Go 버전에서 예상 이득 증가

### 작동 방식
컴파일러는 프로파일 데이터를 사용하여 정보에 입각한 최적화 결정을 내립니다:
- 자주 호출되는 함수의 더 공격적인 인라이닝
- 더 나은 명령어 스케줄링
- 향상된 분기 예측 힌트

---

## 프로파일 수집

### 대표 프로파일 요구 사항

프로파일은 프로덕션 동작을 정확하게 반영해야 합니다. 권장 워크플로우:

1. 초기 바이너리 빌드 및 릴리스(PGO 없이)
2. 프로덕션에서 프로파일 수집
3. 업데이트된 바이너리 릴리스 시, 프로덕션 프로파일로 빌드
4. 2단계 반복

### 프로파일 수집 방법

**권장: 프로덕션 프로파일링**
- 실제 동작을 가장 잘 대표
- 가장 간단한 접근 방식: `net/http/pprof` 추가하고 `/debug/pprof/profile?seconds=30` 가져오기
- 단일 인스턴스 프로파일링의 제한:
  - 프로파일링 시 인스턴스가 유휴 상태일 수 있음
  - 트래픽 패턴이 하루 종일 변함
  - 장시간 실행 작업이 30초 윈도우에 캡처되지 않을 수 있음
  - 인스턴스 간 불균등한 요청 분포

**더 나은 전략: 다중 프로파일 수집**
- 다른 시간에 다른 인스턴스에서 여러 프로파일 수집
- 프로파일을 병합하여 인스턴스별 편차 제한
- 플릿 전체 샘플링을 위한 지속적인 프로파일링 서비스 사용

**대안: 대표 벤치마크**
- 프로덕션 프로파일링이 불가능한 경우(예: CLI 도구) 벤치마크에서 수집
- 경고: 마이크로벤치마크는 좋지 않은 후보 - 애플리케이션의 너무 작은 부분만 실행

### 프로파일 병합

```bash
$ go tool pprof -proto a.pprof b.pprof > merged.pprof
```

**중요:** 공정한 표현을 위해 모든 프로파일이 동일한 wall 지속 시간을 가지도록 하세요. 병합은 샘플을 합산하므로 더 긴 프로파일이 과대 표현됩니다.

---

## PGO로 빌드

### 기본 동작

메인 패키지 디렉터리에 `default.pgo`라는 이름의 pprof CPU 프로파일 저장:

```
myapp/
├── main.go
└── default.pgo
```

Go 빌드는 기본적으로 `default.pgo`를 자동으로 감지하고 사용합니다.

**권장:** 재현 가능하고 성능이 좋은 빌드를 위해 소스 저장소에 프로파일을 직접 커밋하세요.

### 빌드 플래그

```bash
# PGO 활성화(기본 동작 - default.pgo 찾기)
go build

# 명시적으로 default.pgo 사용
go build -pgo=auto

# PGO 비활성화
go build -pgo=off

# 특정 프로파일 사용
go build -pgo=/tmp/foo.pprof ./cmd/myapp
```

**참고(Go 1.21 이전):** 기본값은 `-pgo=off`입니다. PGO를 명시적으로 활성화해야 합니다.

### 다중 바이너리

**중요:** `-pgo`에 전달된 경로는 모든 메인 패키지에 적용됩니다:

```bash
# foo와 bar 바이너리 모두 foo.pprof 사용(일반적으로 원하지 않음)
go build -pgo=/tmp/foo.pprof ./cmd/foo ./cmd/bar
```

**해결책:** 각 바이너리에 대해 다른 프로파일로 별도의 `go build` 호출을 사용하세요.

---

## 고급 주제

### AutoFDO 워크플로우

Go PGO는 두 가지 핵심 속성을 가진 "AutoFDO" 스타일의 반복 워크플로우를 지원합니다:

#### 1. 소스 안정성
- 이전 소스 버전의 프로파일을 사용하면서 개발 계속
- 컴파일러가 휴리스틱을 사용하여 샘플을 현재 소스에 일치시킴
- 일치를 깨지 않는 변경:
  - 핫 함수 외부의 코드 변경
  - 동일 패키지 내 다른 파일로 함수 이동
- 일치를 깰 수 있는 변경:
  - 핫 함수 내부의 변경
  - 함수 이름 변경
  - 패키지 간 함수 이동
- 우아한 저하: 일치하지 않는 함수는 최적화를 잃지만 빌드가 깨지지 않음

#### 2. 반복 안정성
- 연속적인 PGO 빌드에서 성능 사이클 방지
- 보수적인 최적화 접근 방식이 핫 함수가 콜드가 되는 것을 방지
- 불안정성이 관찰되면 go.dev/issue/new에 이슈 제출

### 소스 안정성 및 리팩토링

Go는 일치를 위해 함수 내 줄 오프셋(예: `함수 foo의 5번째 줄에서 호출`)을 사용합니다.

**일치 전략:**
```
줄 오프셋 = Location.Line.line - Function.start_line
```

**대규모 리팩토링 영향:**
- 이름 변경 및 패키지 이동이 일치를 크게 저하시킴
- 새 프로파일이 구조를 반영할 때까지 단기 성능 저하
- 이론적 해결책: 새 심볼 이름으로 프로파일 다시 작성(기성 도구 없음)

### 새 코드의 성능

- 프로파일에 없는 새 코드는 처음에 PGO 최적화를 받지 못함
- 코드를 반영하는 새 프로파일 수집 후 최적화 사용 가능
- 롤아웃 타이밍 평가 시 이를 고려

---

## PGO로 빌드 영향

### 빌드 시간
- 패키지 빌드 시간의 측정 가능한 증가
- 가장 눈에 띔: 프로파일 첫 사용 시 전체 의존성 그래프 재빌드 필요
- 동일한 프로파일을 사용한 후속 증분 빌드는 정상적으로 캐시됨
- 극단적인 증가가 발생하면 go.dev/issue/new에 이슈 제출

### 바이너리 크기
- 약간 더 큰 바이너리가 될 수 있음
- PGO에 의해 활성화된 추가 함수 인라이닝으로 인함

---

## 자주 묻는 질문

### 표준 라이브러리 및 의존성

**Q: Go 표준 라이브러리 패키지가 PGO로 최적화될 수 있나요?**
A: 예. PGO는 전체 프로그램에 적용됩니다. 표준 라이브러리를 포함한 모든 패키지가 PGO 최적화로 재빌드됩니다.

**Q: 의존 모듈이 PGO로 최적화될 수 있나요?**
A: 예. 의존성의 모든 패키지가 애플리케이션이 사용하는 방식에 따라 PGO 최적화를 받습니다.

### 프로파일 동작

**Q: 대표적이지 않은 프로파일이 프로그램을 느리게 만드나요?**
A: 아니요. 대표적이지 않은 프로파일은 콜드 코드를 최적화하지만 핫 코드를 느리게 해서는 안 됩니다. go.dev/issue/new에 회귀를 보고하세요.

### 크로스 플랫폼 빌드

**Q: 다른 GOOS/GOARCH 빌드에 동일한 프로파일을 사용할 수 있나요?**
A: 예. 프로파일 형식은 OS 및 아키텍처 간에 동등합니다. 예: linux/arm64 프로파일을 windows/amd64 빌드에 사용할 수 있습니다.

**주의:** 소스 안정성 규칙이 적용됩니다. 플랫폼별 코드 차이는 최적화를 받지 못합니다. 대부분의 애플리케이션은 대부분 플랫폼 독립적이므로 저하가 제한됩니다.

다른 GOOS/GOARCH 빌드에서 프로파일을 병합할 수 있습니다.

### 다중 워크로드 유형

**Q: 다른 워크로드 유형에 대한 단일 바이너리를 어떻게 처리하나요?**

세 가지 옵션:

1. **워크로드당 다른 바이너리** (최고 성능, 더 많은 운영 복잡성)
   - 각 프로파일로 워크로드별 버전 빌드

2. **단일 바이너리, 가장 중요한 워크로드** (좋은 균형)
   - 가장 성능에 민감한 워크로드의 프로파일만 사용
   - 다른 워크로드도 공통 코드 최적화의 이점을 받음

3. **병합된 플릿 전체 프로파일** (모든 워크로드에 대한 적당한 개선)
   - 모든 워크로드의 프로파일 병합
   - 공정성을 위해 footprint로 가중치 부여

---

## 대체 프로파일 소스

### 형식 요구 사항

비Go 도구의 프로파일은 다음과 함께 [pprof 형식](https://github.com/google/pprof/tree/main/proto)으로 변환되면 사용할 수 있습니다:

1. 타입/단위가 "samples"/"count" 또는 "cpu"/"nanoseconds"인 하나의 샘플 인덱스
2. 샘플 위치에서 CPU 시간을 나타내는 샘플
3. 심볼화된 프로파일(Function.name이 설정되어야 함)
4. 인라인된 함수에 대한 스택 프레임 보존
5. **Function.start_line 설정**(`func` 키워드를 포함하는 줄)

**중요 참고:** Function.start_line은 줄 오프셋 계산을 가능하게 합니다:
```
줄_오프셋 = Location.Line.line - Function.start_line
```

많은 기존 변환기가 이 필드를 생략합니다. Go 1.21 이전 DWARF 메타데이터에는 `DW_AT_decl_line`이 부족할 수 있습니다.

### 서드파티 도구

특정 프로파일링 도구와의 호환성 정보에 대해서는 Go Wiki의 [PGO 도구](/wiki/PGO-Tools) 페이지를 참조하세요.

---

## 요약

Go의 프로필 기반 최적화는 프로덕션 프로파일을 사용하여 컴파일러 결정을 안내함으로써 2-14%의 성능 향상을 제공합니다. 반복적인 AutoFDO 워크플로우는 우아한 저하와 함께 지속적인 최적화 사이클을 지원합니다. 최상의 결과는 대표적인 프로덕션 프로파일을 수집하고 코드와 함께 소스에 커밋하는 것에서 나옵니다.
