# 퓨처, 태스크, 스레드

## 모든 것을 종합하기: 퓨처, 태스크, 스레드

### 개요
이 장에서는 Rust에서 동시성을 위해 스레드와 async/퓨처 중 언제 사용해야 하는지 논의하며, 선택이 종종 "둘 중 하나"가 아니라 "둘 다"임을 설명합니다.

### 스레딩 vs Async 모델

**스레딩 모델:**
- 수십 년 동안 운영 체제에서 사용되는 전통적인 접근 방식
- 스레드 *간* 동시성을 관리
- 트레이드오프: 스레드당 상당한 메모리 사용, OS 지원 필요
- "실행 후 잊기" 모델—스레드는 네이티브 퓨처 동등물 없이 완료까지 실행
- CPU 바운드, 병렬화 가능한 작업에 더 적합

**Async 모델:**
- 동시 작업이 라이브러리 수준 런타임(OS가 아님)이 관리하는 태스크에서 실행
- 태스크 *간* 및 *내*에서 동시성 가능
- 태스크가 퓨처를 관리; 런타임 실행기가 태스크를 관리
- 태스크는 런타임 이점이 있는 경량의 런타임 관리 스레드 대안
- I/O 바운드, 고도로 동시적인 작업에 더 적합

### 동시성 단위의 계층
1. **퓨처** - 가장 세분화된 단위; 다른 퓨처의 트리를 나타낼 수 있음
2. **태스크** - 퓨처를 관리; 런타임 이점이 있는 경량 스레드와 유사
3. **스레드** - 동기 작업의 경계; OS가 관리

### 작업 훔치기(Work Stealing)
이 장에서 사용되는 것을 포함한 많은 런타임은 기본적으로 멀티스레딩을 사용하며 최적의 성능을 위해 스레드 간에 태스크를 투명하게 이동하는 "작업 훔치기" 접근 방식을 사용합니다.

### 결정 규칙의 경험 법칙

| 시나리오 | 더 나은 선택 |
|----------|---------------|
| 매우 병렬화 가능(CPU 바운드) | 스레드 |
| 매우 동시적(I/O 바운드) | Async |
| 병렬성과 동시성 모두 | 스레드와 async 결합 |

### 코드 예제: 스레드와 Async 혼합

```rust
extern crate trpl; // mdbook 테스트용

use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::block_on(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}
```

**Listing 17-25**가 보여주는 것:
- async 채널 생성
- 값을 보내는 스레드(블로킹 송신자) 생성
- 메시지를 await하는 async 블록 실행
- 실제 패턴: 전용 스레드의 계산 바운드 작업과 UI로의 async 채널 알림

### 핵심 요점

- 스레드와 태스크는 경쟁하기보다 서로 보완합니다
- 많은 실제 애플리케이션이 두 접근 방식을 결합하는 것이 유리합니다
- 예: 스레드의 비디오 인코딩(CPU 바운드)과 UI로의 async 채널 알림
- Rust는 선택한 접근 방식에 관계없이 안전하고 빠른 동시 코드를 작성할 수 있는 도구를 제공합니다

### 다음 단계
21장에서는 이러한 개념을 더 현실적인 웹 서버 프로젝트에 적용하여 스레딩 vs 태스크/퓨처 접근 방식을 더 직접적으로 비교합니다.

## 선택 가이드라인

### 스레드 사용이 좋은 경우:
- CPU 집약적인 계산 작업
- 작업이 독립적이고 상태를 공유하지 않는 경우
- 운영 체제 수준의 병렬성이 필요한 경우
- 블로킹 I/O를 처리해야 하는 경우

### Async 사용이 좋은 경우:
- 많은 동시 연결을 처리하는 경우(예: 웹 서버)
- 네트워크 I/O가 많은 경우
- 메모리 효율성이 중요한 경우
- 수천 개의 동시 작업이 필요한 경우

### 두 가지를 결합하는 경우:
- CPU 바운드 작업과 I/O 바운드 작업이 모두 있는 경우
- 블로킹 라이브러리를 async 코드와 통합해야 하는 경우
- 최대의 성능과 확장성이 필요한 경우

## 요약

퓨처, 태스크, 스레드는 Rust의 동시성 모델에서 각각 다른 역할을 합니다:

1. **퓨처**는 비동기 계산의 가장 기본적인 빌딩 블록입니다
2. **태스크**는 퓨처를 실행하고 관리하는 경량 실행 단위입니다
3. **스레드**는 OS 수준의 병렬 실행을 제공합니다

이 세 가지를 적절히 조합하면 안전하고 효율적인 동시 프로그램을 작성할 수 있습니다. Rust의 타입 시스템과 소유권 모델은 동시성 버그를 컴파일 타임에 잡아내어 "두려움 없는 동시성"을 가능하게 합니다.
