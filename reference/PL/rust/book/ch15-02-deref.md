# `Deref` 트레이트로 스마트 포인터를 일반 참조처럼 취급하기

`Deref` 트레이트를 구현하면 *역참조 연산자* `*`의 동작을 사용자 정의할 수 있습니다(곱셈이나 글롭 연산자와 혼동하지 마세요). 스마트 포인터가 일반 참조처럼 취급될 수 있도록 `Deref`를 구현하면 참조에서 작동하는 코드를 작성하고 해당 코드를 스마트 포인터와 함께 사용할 수도 있습니다.

먼저 역참조 연산자가 일반 참조와 어떻게 작동하는지 살펴보겠습니다. 그런 다음 `Box<T>`처럼 동작하는 사용자 정의 타입을 정의하고 새로 정의한 타입에서 역참조 연산자가 작동하지 않는 이유를 살펴보겠습니다. `Deref` 트레이트를 구현하면 스마트 포인터가 참조와 유사한 방식으로 작동할 수 있는 방법을 살펴볼 것입니다. 그런 다음 Rust의 *역참조 강제 변환* 기능과 참조 또는 스마트 포인터와 함께 작동하는 방법을 살펴보겠습니다.

> 참고: 빌드할 `MyBox<T>` 타입과 실제 `Box<T>` 사이에는 큰 차이가 있습니다: 우리 버전은 데이터를 힙에 저장하지 않습니다. 이 예제를 `Deref`에 집중하고 있으므로 데이터가 실제로 어디에 저장되는지는 포인터와 같은 동작보다 덜 중요합니다.

## 포인터를 따라가서 값 얻기

일반 참조는 포인터의 한 유형이며 포인터를 생각하는 한 가지 방법은 다른 곳에 저장된 값을 가리키는 화살표로 생각하는 것입니다. Listing 15-6에서 `i32` 값에 대한 참조를 만든 다음 역참조 연산자를 사용하여 참조를 따라 값으로 이동합니다:

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

*Listing 15-6: 역참조 연산자를 사용하여 `i32` 값에 대한 참조 따라가기*

변수 `x`는 `i32` 값 `5`를 보유합니다. `y`를 `x`에 대한 참조와 같게 설정합니다. `x`가 `5`와 같다고 assert할 수 있습니다. 그러나 `y`의 값에 대해 assertion을 하려면 `*y`를 사용하여 참조가 가리키는 값으로 따라가야 합니다(따라서 *역참조*). `y`를 역참조하면 `5`와 비교할 수 있는 `y`가 가리키는 정수 값에 액세스할 수 있습니다.

대신 `assert_eq!(5, y);`를 작성하려고 하면 이 컴파일 오류가 발생합니다:

```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
```

숫자와 숫자에 대한 참조를 비교하는 것은 다른 타입이기 때문에 허용되지 않습니다. 역참조 연산자를 사용하여 참조가 가리키는 값으로 따라가야 합니다.

## `Box<T>`를 참조처럼 사용하기

Listing 15-6의 코드를 참조 대신 `Box<T>`를 사용하도록 다시 작성할 수 있습니다; Listing 15-7에서 `Box<T>`에 사용된 역참조 연산자는 Listing 15-6의 참조에 사용된 역참조 연산자와 동일한 방식으로 작동합니다:

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

*Listing 15-7: `Box<i32>`에 역참조 연산자 사용하기*

Listing 15-7과 Listing 15-6 사이의 주요 차이점은 여기서 `y`를 `x`의 값을 가리키는 `Box<T>`의 인스턴스로 설정한다는 것입니다. 이는 `x`의 복사된 값을 가리키는 것입니다. 마지막 assertion에서 박스의 포인터가 가리키는 값을 따라가기 위해 `y`가 참조일 때와 동일한 방식으로 역참조 연산자를 사용할 수 있습니다. 다음으로, 자체 타입을 정의하여 `Box<T>`가 역참조 연산자를 사용할 수 있게 하는 특별한 점이 무엇인지 살펴보겠습니다.

## 자체 스마트 포인터 정의하기

표준 라이브러리에서 제공하는 `Box<T>` 타입과 유사한 스마트 포인터를 빌드하여 스마트 포인터가 기본적으로 참조와 다르게 동작하는 방식을 경험해 봅시다. 그런 다음 역참조 연산자를 사용하는 기능을 추가하는 방법을 살펴보겠습니다.

`Box<T>` 타입은 궁극적으로 하나의 요소가 있는 튜플 구조체로 정의되므로 Listing 15-8은 `MyBox<T>` 타입을 동일한 방식으로 정의합니다. 또한 `Box<T>`에 정의된 `new` 함수와 일치하는 `new` 함수를 정의합니다.

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

*Listing 15-8: `MyBox<T>` 타입 정의하기*

`MyBox`라는 구조체를 정의하고 제네릭 매개변수 `T`를 선언합니다. 타입이 모든 타입의 값을 보유할 수 있도록 하기 때문입니다. `MyBox` 타입은 `T` 타입의 하나의 요소를 가진 튜플 구조체입니다. `MyBox::new` 함수는 `T` 타입의 매개변수 하나를 받아 해당 값을 보유하는 `MyBox` 인스턴스를 반환합니다.

Listing 15-7의 `main` 함수를 Listing 15-8에 추가하고 `Box<T>` 대신 우리가 정의한 `MyBox<T>` 타입을 사용하도록 변경해 봅시다. Listing 15-9의 코드는 Rust가 `MyBox`를 역참조하는 방법을 모르기 때문에 컴파일되지 않습니다.

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

*Listing 15-9: 참조와 `Box<T>`를 사용한 것과 같은 방식으로 `MyBox<T>` 사용 시도하기*

다음은 결과 컴파일 오류입니다:

```console
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
```

`MyBox<T>` 타입은 역참조할 수 없습니다. 해당 기능을 타입에 구현하지 않았기 때문입니다. `*` 연산자로 역참조를 활성화하려면 `Deref` 트레이트를 구현합니다.

## `Deref` 트레이트를 구현하여 타입을 참조처럼 취급하기

10장의 "타입에 트레이트 구현하기" 섹션에서 논의한 것처럼 트레이트를 구현하려면 트레이트의 필수 메서드에 대한 구현을 제공해야 합니다. 표준 라이브러리에서 제공하는 `Deref` 트레이트는 `self`를 빌리고 내부 데이터에 대한 참조를 반환하는 `deref`라는 메서드 하나를 구현해야 합니다. Listing 15-10에는 `MyBox`의 정의에 추가할 `Deref`의 구현이 포함되어 있습니다:

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

*Listing 15-10: `MyBox<T>`에 `Deref` 구현하기*

`type Target = T;` 구문은 `Deref` 트레이트가 사용할 연관 타입을 정의합니다. 연관 타입은 제네릭 매개변수를 선언하는 약간 다른 방법이지만 지금은 걱정할 필요가 없습니다; 20장에서 더 자세히 다룰 것입니다.

`deref` 메서드 본문을 `&self.0`으로 채워 `deref`가 `*` 연산자로 액세스하려는 값에 대한 참조를 반환하도록 합니다. 5장의 "이름 없는 필드가 있는 튜플 구조체를 사용하여 다른 타입 만들기" 섹션에서 `.0`이 튜플 구조체의 첫 번째 값에 액세스한다는 것을 기억하세요. Listing 15-9의 `MyBox<T>` 값에서 `*`를 호출하는 `main` 함수는 이제 컴파일되고 assertions가 통과합니다!

`Deref` 트레이트가 없으면 컴파일러는 `&` 참조만 역참조할 수 있습니다. `deref` 메서드는 컴파일러에게 `Deref`를 구현하는 모든 타입의 값을 받아 `deref` 메서드를 호출하여 역참조 방법을 아는 `&` 참조를 얻을 수 있는 기능을 제공합니다.

Listing 15-9에서 `*y`를 입력했을 때 Rust는 실제로 다음 코드를 실행했습니다:

```rust
*(y.deref())
```

Rust는 `*` 연산자를 `deref` 메서드 호출과 일반 역참조로 대체하므로 `deref` 메서드를 호출해야 하는지 여부를 생각할 필요가 없습니다. 이 Rust 기능을 사용하면 일반 참조가 있든 `Deref`를 구현하는 타입이 있든 동일하게 작동하는 코드를 작성할 수 있습니다.

`deref` 메서드가 값에 대한 참조를 반환하고 `*(y.deref())` 괄호 밖의 일반 역참조가 여전히 필요한 이유는 소유권 시스템 때문입니다. `deref` 메서드가 값에 대한 참조 대신 값을 직접 반환하면 값이 `self` 밖으로 이동됩니다. 이 경우나 역참조 연산자를 사용하는 대부분의 경우 `MyBox<T>` 내부 값의 소유권을 갖고 싶지 않습니다.

코드에서 `*`를 입력할 때마다 `*` 연산자가 `deref` 메서드 호출로 대체된 다음 `*`로 한 번 대체된다는 점에 유의하세요. `*` 연산자의 대체는 무한히 재귀하지 않으므로 `i32` 타입의 데이터가 됩니다. 이 데이터는 Listing 15-9의 `assert_eq!`에서 `5`와 일치합니다.

## 함수와 메서드에서 암묵적 역참조 강제 변환

*역참조 강제 변환*은 `Deref` 트레이트를 구현하는 타입에 대한 참조를 다른 타입에 대한 참조로 변환합니다. 예를 들어 역참조 강제 변환은 `&String`을 `&str`로 변환할 수 있습니다. `String`이 `&str`을 반환하도록 `Deref` 트레이트를 구현하기 때문입니다. 역참조 강제 변환은 Rust가 함수와 메서드에 대한 인수에 대해 수행하는 편의 기능이며 `Deref` 트레이트를 구현하는 타입에서만 작동합니다. 특정 타입의 값에 대한 참조를 함수 또는 메서드 정의의 매개변수 타입과 일치하지 않는 함수나 메서드에 인수로 전달할 때 자동으로 발생합니다. `deref` 메서드에 대한 일련의 호출은 제공한 타입을 매개변수에 필요한 타입으로 변환합니다.

역참조 강제 변환이 Rust에 추가되어 함수와 메서드 호출을 작성하는 프로그래머가 `&`와 `*`로 많은 명시적 참조와 역참조를 추가할 필요가 없습니다. 역참조 강제 변환 기능을 사용하면 참조 또는 스마트 포인터 모두에 대해 작동하는 더 많은 코드를 작성할 수 있습니다.

역참조 강제 변환이 실제로 작동하는 것을 보려면 Listing 15-8에서 정의한 `MyBox<T>` 타입과 Listing 15-10에서 추가한 `Deref`의 구현을 사용해 봅시다. Listing 15-11은 문자열 슬라이스 매개변수가 있는 함수의 정의를 보여줍니다:

```rust
fn hello(name: &str) {
    println!("안녕하세요, {name}님!");
}
```

*Listing 15-11: `&str` 타입의 매개변수 `name`이 있는 `hello` 함수*

예를 들어 `hello("Rust");`처럼 문자열 슬라이스를 인수로 `hello` 함수를 호출할 수 있습니다. 역참조 강제 변환을 사용하면 Listing 15-12에 표시된 대로 `MyBox<String>` 타입의 값에 대한 참조로 `hello`를 호출할 수 있습니다:

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

*Listing 15-12: 역참조 강제 변환 때문에 작동하는 `MyBox<String>` 값에 대한 참조로 `hello` 호출하기*

여기서 `&m` 인수로 `hello` 함수를 호출하며, 이것은 `MyBox<String>` 값에 대한 참조입니다. Listing 15-10에서 `MyBox<T>`에 `Deref` 트레이트를 구현했기 때문에 Rust는 `deref`를 호출하여 `&MyBox<String>`을 `&String`으로 변환할 수 있습니다. 표준 라이브러리는 문자열 슬라이스를 반환하는 `String`에 `Deref` 구현을 제공하며 이것은 `Deref`의 API 문서에 있습니다. Rust는 `deref`를 다시 호출하여 `&String`을 `&str`로 변환하며, 이것은 `hello` 함수의 정의와 일치합니다.

Rust가 역참조 강제 변환을 구현하지 않았다면 Listing 15-12의 코드 대신 Listing 15-13의 코드를 작성하여 `&MyBox<String>` 타입의 값으로 `hello`를 호출해야 합니다.

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

*Listing 15-13: Rust에 역참조 강제 변환이 없었다면 작성해야 했을 코드*

`(*m)`은 `MyBox<String>`을 `String`으로 역참조합니다. 그런 다음 `&`와 `[..]`는 전체 문자열과 같은 `String`의 문자열 슬라이스를 취하여 `hello`의 시그니처와 일치시킵니다. 역참조 강제 변환이 없는 이 코드는 관련된 모든 기호가 있어 읽고 쓰고 이해하기가 더 어렵습니다. 역참조 강제 변환을 사용하면 Rust가 이러한 변환을 자동으로 처리할 수 있습니다.

관련된 타입에 대해 `Deref` 트레이트가 정의되면 Rust는 타입을 분석하고 `Deref::deref`를 필요한 만큼 사용하여 매개변수 타입과 일치하는 참조를 얻습니다. `Deref::deref`가 삽입되어야 하는 횟수는 컴파일 시간에 해결되므로 역참조 강제 변환을 활용하는 데 런타임 페널티가 없습니다!

## 역참조 강제 변환이 가변성과 상호 작용하는 방식

불변 참조에서 `*` 연산자를 오버라이드하기 위해 `Deref` 트레이트를 사용하는 방법과 유사하게, `DerefMut` 트레이트를 사용하여 가변 참조에서 `*` 연산자를 오버라이드할 수 있습니다.

Rust는 다음 세 가지 경우에 타입과 트레이트 구현을 발견하면 역참조 강제 변환을 수행합니다:

* `T: Deref<Target=U>`일 때 `&T`에서 `&U`로
* `T: DerefMut<Target=U>`일 때 `&mut T`에서 `&mut U`로
* `T: Deref<Target=U>`일 때 `&mut T`에서 `&U`로

처음 두 경우는 가변성을 제외하면 동일합니다. 첫 번째 경우는 `&T`가 있고 `T`가 어떤 타입 `U`에 대해 `Deref`를 구현하면 `&U`를 투명하게 얻을 수 있다고 말합니다. 두 번째 경우는 가변 참조에 대해 동일한 역참조 강제 변환이 발생한다고 말합니다.

세 번째 경우는 더 까다롭습니다: Rust는 가변 참조를 불변 참조로도 강제 변환합니다. 그러나 그 반대는 *불가능*합니다: 불변 참조는 절대로 가변 참조로 강제 변환되지 않습니다. 빌림 규칙 때문에 가변 참조가 있으면 해당 가변 참조가 해당 데이터에 대한 유일한 참조여야 합니다(그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 가변 참조를 하나의 불변 참조로 변환해도 빌림 규칙을 위반하지 않습니다. 불변 참조를 가변 참조로 변환하려면 해당 데이터에 대한 초기 불변 참조가 해당 불변 참조 하나만 있어야 하지만 빌림 규칙은 그것을 보장하지 않습니다. 따라서 Rust는 불변 참조를 가변 참조로 변환하는 것이 가능하다고 가정할 수 없습니다.
