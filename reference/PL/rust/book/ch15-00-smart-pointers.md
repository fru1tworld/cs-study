# 스마트 포인터

*포인터*는 메모리의 주소를 포함하는 변수에 대한 일반적인 개념입니다. 이 주소는 다른 데이터를 참조하거나 "가리킵니다". Rust에서 가장 일반적인 종류의 포인터는 4장에서 배운 참조입니다. 참조는 `&` 기호로 표시되고 가리키는 값을 빌립니다. 데이터를 참조하는 것 외에는 특별한 기능이 없으며 오버헤드도 없습니다.

반면에 *스마트 포인터*는 포인터처럼 작동하지만 추가 메타데이터와 기능도 있는 데이터 구조입니다. 스마트 포인터의 개념은 Rust에 고유한 것이 아닙니다: 스마트 포인터는 C++에서 시작되었으며 다른 언어에도 존재합니다. Rust는 표준 라이브러리에 정의된 다양한 스마트 포인터를 가지고 있으며, 참조가 제공하는 것 이상의 기능을 제공합니다. 일반적인 개념을 탐구하기 위해 *참조 카운팅* 스마트 포인터 타입을 포함한 몇 가지 다른 예를 살펴보겠습니다. 이 포인터를 사용하면 데이터에 대한 여러 소유자를 허용할 수 있으며, 소유자 수를 추적하고 소유자가 남아 있지 않으면 데이터를 정리합니다.

빌림의 개념이 있는 Rust에서 참조와 스마트 포인터 사이의 추가적인 차이점은 참조가 데이터만 빌리는 반면, 많은 경우 스마트 포인터는 가리키는 데이터를 *소유*한다는 것입니다.

이 책에서 이미 몇 가지 스마트 포인터를 접했지만 그때는 그렇게 부르지 않았습니다. 8장의 `String`과 `Vec<T>`를 포함합니다. 이러한 타입은 둘 다 일부 메모리를 소유하고 조작할 수 있기 때문에 스마트 포인터로 간주됩니다. 또한 메타데이터와 추가 기능 또는 보장이 있습니다. 예를 들어 `String`은 용량을 메타데이터로 저장하고 데이터가 항상 유효한 UTF-8이 되도록 하는 추가 기능이 있습니다.

스마트 포인터는 일반적으로 구조체를 사용하여 구현됩니다. 일반 구조체와 달리 스마트 포인터는 `Deref` 및 `Drop` 트레이트를 구현합니다. `Deref` 트레이트는 스마트 포인터 구조체의 인스턴스가 참조처럼 동작하도록 하여 참조 또는 스마트 포인터와 함께 작동하는 코드를 작성할 수 있습니다. `Drop` 트레이트는 스마트 포인터 인스턴스가 범위를 벗어날 때 실행되는 코드를 사용자 정의할 수 있습니다. 이 장에서는 두 트레이트를 모두 논의하고 스마트 포인터에 중요한 이유를 보여드리겠습니다.

스마트 포인터 패턴이 Rust에서 자주 사용되는 일반적인 디자인 패턴이라는 점을 감안할 때 이 장에서 모든 기존 스마트 포인터를 다루지는 않습니다. 많은 라이브러리에는 자체 스마트 포인터가 있으며 직접 작성할 수도 있습니다. 표준 라이브러리에서 가장 일반적인 스마트 포인터를 다룹니다:

* 힙에 값을 할당하기 위한 `Box<T>`
* 여러 소유권을 가능하게 하는 참조 카운팅 타입인 `Rc<T>`
* `RefCell<T>`를 통해 액세스되고 컴파일 시간이 아닌 런타임에 빌림 규칙을 적용하는 타입인 `Ref<T>` 및 `RefMut<T>`

또한 불변 타입이 내부 값을 변경하기 위한 API를 노출하는 *내부 가변성* 패턴을 다룹니다. 또한 메모리 누수를 유발할 수 있는 *참조 순환*과 이를 방지하는 방법에 대해서도 논의합니다.

시작해 봅시다!
