# `Sync`와 `Send` 트레이트로 확장 가능한 동시성

흥미롭게도 Rust 언어에는 동시성 기능이 *매우* 적습니다. 이 장에서 지금까지 이야기한 거의 모든 동시성 기능은 언어가 아닌 표준 라이브러리의 일부였습니다. 동시성 처리 옵션은 언어나 표준 라이브러리에 국한되지 않습니다; 자체 동시성 기능을 작성하거나 다른 사람이 작성한 것을 사용할 수 있습니다.

그러나 두 가지 동시성 개념이 언어에 내장되어 있습니다: `std::marker` 트레이트 `Sync`와 `Send`.

## `Send`로 스레드 간 소유권 이전 허용하기

`Send` 마커 트레이트는 `Send`를 구현하는 타입의 값의 소유권이 스레드 간에 이전될 수 있음을 나타냅니다. 거의 모든 Rust 타입이 `Send`이지만 `Rc<T>`를 포함한 일부 예외가 있습니다: `Rc<T>` 값을 복제하고 복제의 소유권을 다른 스레드로 이전하려고 하면 두 스레드가 동시에 참조 카운트를 업데이트할 수 있기 때문에 `Send`가 될 수 없습니다. 이러한 이유로 `Rc<T>`는 스레드 안전 비용을 지불하고 싶지 않은 단일 스레드 상황에서 사용하도록 구현되었습니다.

따라서 Rust의 타입 시스템과 트레이트 바운드는 `Rc<T>` 값을 실수로 스레드 간에 안전하지 않게 보내는 것을 방지합니다. Listing 16-14에서 이것을 시도했을 때 ``the trait `Send` is not implemented for `Rc<Mutex<i32>>``라는 오류가 발생했습니다. 스레드 안전한 `Arc<T>`로 전환했을 때 코드가 컴파일되었습니다.

`Send` 타입으로 완전히 구성된 모든 타입도 자동으로 `Send`로 표시됩니다. 19장에서 논의할 원시 포인터를 제외한 거의 모든 기본 타입이 `Send`입니다.

## `Sync`로 여러 스레드에서 액세스 허용하기

`Sync` 마커 트레이트는 `Sync`를 구현하는 타입이 여러 스레드에서 참조되어도 안전함을 나타냅니다. 즉, `&T`(`T`에 대한 불변 참조)가 `Send`이면 타입 `T`는 `Sync`입니다. 이것은 참조가 다른 스레드로 안전하게 전송될 수 있음을 의미합니다. `Send`와 유사하게 기본 타입은 `Sync`이고 전적으로 `Sync` 타입으로 구성된 타입도 `Sync`입니다.

스마트 포인터 `Rc<T>`도 `Send`가 아닌 것과 같은 이유로 `Sync`가 아닙니다. `RefCell<T>` 타입(15장에서 이야기했습니다)과 관련 `Cell<T>` 타입 패밀리도 `Sync`가 아닙니다. `RefCell<T>`가 런타임에 수행하는 빌림 검사 구현은 스레드 안전하지 않습니다. 스마트 포인터 `Mutex<T>`는 `Sync`이며 "여러 스레드 간에 `Mutex<T>` 공유하기" 섹션에서 본 것처럼 여러 스레드에서 액세스를 공유하는 데 사용할 수 있습니다.

## `Send`와 `Sync` 수동 구현은 안전하지 않음

`Send`와 `Sync` 타입으로 구성된 타입은 자동으로 `Send`와 `Sync`이기도 하므로 이러한 트레이트를 수동으로 구현할 필요가 없습니다. 마커 트레이트로서 구현할 메서드도 없습니다. 동시성과 관련된 불변성을 적용하는 데만 유용합니다.

이러한 트레이트를 수동으로 구현하려면 안전하지 않은 Rust 코드를 구현해야 합니다. 안전하지 않은 Rust 코드 사용에 대해서는 20장에서 이야기할 것입니다; 지금은 중요한 정보는 `Send`와 `Sync` 부분으로 구성되지 않은 새 동시 타입을 구축하려면 안전 보장을 유지하기 위해 신중한 생각이 필요하다는 것입니다. ["The Rustonomicon"](https://doc.rust-lang.org/nomicon/index.html)에는 이러한 보장과 유지 방법에 대한 자세한 정보가 있습니다.

## 요약

이것이 이 책에서 동시성을 다루는 마지막 부분은 아닙니다: 다음 장의 async와 21장의 전체 프로젝트는 이 장에서 논의한 개념을 더 현실적인 상황에서 사용합니다.

앞서 언급했듯이 Rust가 동시성을 처리하는 방식의 매우 적은 부분이 언어의 일부이기 때문에 많은 동시성 솔루션이 크레이트로 구현됩니다. 이것들은 표준 라이브러리보다 빠르게 발전하므로 다중 스레드 상황에서 사용할 현재의 최신 크레이트를 온라인에서 검색하세요.

Rust 표준 라이브러리는 메시지 전달용 채널과 동시 컨텍스트에서 사용하기 안전한 `Mutex<T>` 및 `Arc<T>`와 같은 스마트 포인터 타입을 제공합니다. 타입 시스템과 빌림 검사기는 이러한 솔루션을 사용하는 코드가 데이터 레이스나 유효하지 않은 참조로 끝나지 않도록 보장합니다. 코드가 컴파일되면 여러 스레드에서 행복하게 실행되며 다른 언어에서 흔히 발생하는 추적하기 어려운 버그 종류가 없다고 확신할 수 있습니다. 동시 프로그래밍은 더 이상 두려워할 개념이 아닙니다: 앞으로 나아가 프로그램을 겁 없이 동시적으로 만드세요!

다음으로, Rust 프로그램이 커짐에 따라 문제를 모델링하고 솔루션을 구조화하는 관용적인 방법에 대해 이야기할 것입니다. 또한 Rust의 관용구가 객체 지향 프로그래밍에서 익숙할 수 있는 것들과 어떻게 관련되는지 논의할 것입니다.
