# `panic!`을 사용할지 말지 결정하기

## 개요

이 장에서는 Rust 오류 처리에서 `panic!`을 사용할지 `Result`를 반환할지 결정하는 방법을 설명합니다.

**핵심 원칙:** 코드가 패닉을 일으키면 복구할 방법이 없습니다. `Result`를 반환하면 호출 코드가 오류를 적절하게 처리할 수 있는 옵션을 제공합니다.

> 실패할 수 있는 함수를 정의할 때는 `Result`를 반환하는 것이 좋은 기본 선택입니다.

---

## `panic!` vs `Result` 사용 시점

### 예제, 프로토타입 코드, 테스트

다음 상황에서는 `panic!`을 사용합니다:

- **예제:** 강력한 오류 처리 코드를 포함하면 예제가 덜 명확해질 수 있습니다. `unwrap` 같은 메서드는 오류 처리가 플레이스홀더임을 나타냅니다.
- **프로토타이핑:** `unwrap`과 `expect`는 오류 처리 방법을 아직 결정하지 않았을 때 유용합니다.
- **테스트:** 테스트에서 메서드 호출이 실패하면 전체 테스트가 실패해야 합니다. `unwrap`이나 `expect`를 호출하는 것이 적절합니다. `panic!`이 테스트 실패를 표시하기 때문입니다.

### 컴파일러보다 더 많은 정보를 가지고 있을 때

`Result`가 `Ok`가 될 것이라는 로직이 있지만 컴파일러가 이해할 수 없는 경우 `expect`를 호출하는 것이 적절합니다.

```rust
fn main() {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
}
```

**핵심 포인트:**
- 컴파일러는 `"127.0.0.1"`이 항상 유효한지 판단할 수 없지만, 개발자는 수동으로 검증할 수 있음
- `expect` 메시지에 이유를 문서화하는 것이 좋음

---

## 오류 처리 가이드라인

### 패닉을 사용해야 하는 경우

코드가 **잘못된 상태(bad state)** 에 놓일 수 있을 때 패닉을 사용해야 합니다. 잘못된 상태란 가정, 보장, 계약 또는 불변성(invariant)이 위반된 상태를 말합니다:

1. 잘못된 상태가 **예상치 못한 것**일 때 (잘못된 사용자 입력처럼 가끔 발생하는 것이 아닌 경우)
2. 이 시점 이후의 코드가 **이 잘못된 상태가 아님에 의존**해야 할 때
3. 이 정보를 **타입 시스템에 인코딩할 좋은 방법이 없을** 때

**패닉 시나리오:**
- 코드에 잘못된 값이 전달된 경우
- 계속 진행하면 보안에 문제가 되거나 해로울 경우
- 외부 코드가 고칠 수 없는 잘못된 상태를 반환하는 경우
- 사용자에게 해를 끼칠 수 있는 작업(예: 메모리 접근) 전에 값을 검증할 때

> 계약(contract)이 위반되면 패닉을 일으키는 것이 합리적입니다. 계약 위반은 항상 호출자 측 버그를 나타내기 때문입니다.

### `Result`를 반환해야 하는 경우

실패가 **예상되는** 경우 `Result`를 반환합니다:

- 파서가 잘못된 형식의 데이터를 받는 경우
- HTTP 요청이 속도 제한 상태를 반환하는 경우
- `Result`를 반환하면 실패가 예상 가능한 상황임을 나타냄

---

## 유효성 검증을 위한 커스텀 타입

모든 함수에서 런타임 검사 대신, 생성 시 유효성을 검사하는 커스텀 타입을 만들어 Rust의 타입 시스템을 활용할 수 있습니다.

### 예제: Guess 타입

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

**핵심 이점:**
- `value` 필드는 **private**이므로 `Guess::new`를 통해서만 생성 가능
- 유효성 검사가 한 곳에서 이루어지며 코드 전체에 분산되지 않음
- 함수가 시그니처에서 `Guess`를 받을 수 있어 런타임 검사가 불필요
- 타입 시스템이 유효한 값만 존재함을 보장

### 이 타입을 사용하는 함수

```rust
fn some_function(guess: Guess) {
    // guess.value()가 1과 100 사이임을 안전하게 사용할 수 있음
}
```

---

## 요약

- 정말로 복구할 수 없는 오류와 계약 위반에는 `panic!`을 사용
- 잠재적으로 복구 가능한 오류에는 기본적으로 `Result`를 반환
- Rust의 타입 시스템을 활용하여 컴파일 타임에 잘못된 상태를 방지
- 유효성 검사가 포함된 커스텀 타입을 만들어 반복적인 런타임 검사를 제거
