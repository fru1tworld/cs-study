# 성능 비교: 루프 vs. 반복자

루프를 사용할지 반복자를 사용할지 결정하려면 어떤 구현이 더 빠른지 알아야 합니다: 명시적 `for` 루프가 있는 `search` 함수 버전 또는 반복자가 있는 버전.

우리는 아서 코난 도일 경의 *셜록 홈즈의 모험* 전체 내용을 `String`에 로드하고 내용에서 *the*라는 단어를 찾는 벤치마크를 실행했습니다. 다음은 `for` 루프를 사용하는 `search` 버전과 반복자를 사용하는 버전의 벤치마크 결과입니다:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

반복자 버전이 약간 더 빨랐습니다! 여기서 벤치마크 코드를 설명하지는 않겠습니다. 요점은 두 버전이 동등하다는 것을 증명하는 것이 아니라 이 두 구현이 성능 측면에서 어떻게 비교되는지에 대한 일반적인 감각을 얻는 것이기 때문입니다.

더 포괄적인 벤치마크를 위해서는 다양한 크기의 다양한 텍스트를 `contents`로 사용하고, 다른 단어와 다른 길이의 단어를 `query`로 사용하고, 기타 모든 종류의 변형을 확인해야 합니다. 요점은 이것입니다: 반복자는 고수준 추상화이지만 직접 저수준 코드를 작성한 것과 거의 동일한 코드로 컴파일됩니다. 반복자는 Rust의 *제로 비용 추상화* 중 하나입니다. 이는 추상화를 사용해도 추가 런타임 오버헤드가 발생하지 않음을 의미합니다. 이것은 C++의 원래 설계자이자 구현자인 비야네 스트롭스트룹이 "Foundations of C++"(2012)에서 *제로 오버헤드*를 정의하는 방식과 유사합니다:

> 일반적으로 C++ 구현은 제로 오버헤드 원칙을 따릅니다: 사용하지 않는 것에 대해 비용을 지불하지 않습니다. 그리고 더 나아가: 사용하는 것에 대해 직접 더 잘 작성할 수 없습니다.

또 다른 예로, 다음 코드는 오디오 디코더에서 가져온 것입니다. 디코딩 알고리즘은 선형 예측 수학 연산을 사용하여 이전 샘플의 선형 함수를 기반으로 미래 값을 추정합니다. 이 코드는 반복자 체인을 사용하여 범위 내의 세 변수에 대해 일부 수학을 수행합니다: `buffer` 데이터 슬라이스, 12개의 `coefficients` 배열, `qlp_shift`로 데이터를 시프트할 양. 이 예제 내에서 변수를 선언했지만 값은 부여하지 않았습니다; 이 코드가 컨텍스트 외부에서 큰 의미가 없더라도 Rust가 고수준 아이디어를 저수준 코드로 변환하는 방법의 간결하고 실제적인 예입니다.

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

`prediction` 값을 계산하기 위해 이 코드는 `coefficients`의 12개 값 각각을 반복하고 `zip` 메서드를 사용하여 coefficient 값을 `buffer`의 이전 12개 값과 쌍으로 만듭니다. 그런 다음 각 쌍에 대해 값을 함께 곱하고 모든 결과를 합산한 다음 합계의 비트를 `qlp_shift` 비트만큼 오른쪽으로 시프트합니다.

오디오 디코더와 같은 애플리케이션의 계산은 종종 성능을 가장 높이 우선시합니다. 여기서 우리는 두 개의 어댑터를 사용하여 반복자를 만든 다음 값을 소비합니다. 이 Rust 코드는 어떤 어셈블리 코드로 컴파일될까요? 글쎄, 이 글을 쓰는 현재 직접 손으로 작성했을 것과 동일한 어셈블리로 컴파일됩니다. `coefficients`의 값에 대한 반복에 해당하는 루프가 전혀 없습니다: Rust는 12번의 반복이 있다는 것을 알기 때문에 루프를 "언롤링"합니다. *언롤링*은 루프 제어 코드의 오버헤드를 제거하고 대신 루프의 각 반복에 대해 반복적인 코드를 생성하는 최적화입니다.

모든 coefficients는 레지스터에 저장되어 값에 대한 매우 빠른 액세스를 의미합니다. 런타임에 배열 액세스에 대한 경계 검사가 없습니다. Rust가 적용할 수 있는 이러한 모든 최적화는 결과 코드를 매우 효율적으로 만듭니다. 이제 이것을 알았으니 반복자와 클로저를 두려움 없이 사용할 수 있습니다! 그들은 코드를 더 고수준으로 보이게 하지만 그렇게 하기 위해 런타임 성능 페널티를 부과하지 않습니다.

## 요약

클로저와 반복자는 함수형 프로그래밍 언어 아이디어에서 영감을 받은 Rust 기능입니다. 그들은 저수준 성능으로 고수준 아이디어를 명확하게 표현하는 Rust의 능력에 기여합니다. 클로저와 반복자의 구현은 런타임 성능이 영향을 받지 않도록 합니다. 이것은 제로 비용 추상화를 제공하기 위해 노력하는 Rust의 목표의 일부입니다.

이제 I/O 프로젝트의 표현력을 개선했으니 프로젝트를 세상과 공유하는 데 도움이 될 `cargo`의 몇 가지 기능을 더 살펴보겠습니다.
