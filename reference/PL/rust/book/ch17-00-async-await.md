# 비동기 프로그래밍의 기초: Async, Await, Future, 그리고 Stream

많은 작업이 완료되는 데 시간이 필요합니다. 비디오 내보내기와 같은 CPU 바운드 작업이나 네트워크를 통해 파일을 다운로드하는 것과 같은 I/O 바운드 작업이 있을 수 있습니다. 둘 다 완료되기를 기다리는 것이 포함됩니다.

Rust의 *비동기 프로그래밍* 모델은 이러한 종류의 작업을 처리하는 방법을 제공합니다. 이 접근 방식의 핵심 요소는 *퓨처*, Rust의 `async` 및 `await` 키워드, 그리고 이들을 함께 작동하게 하는 런타임입니다.

시작하기 전에, 이 장에서 다루지 않는 관련 항목 두 가지를 언급해야 합니다:

* 이 장에서 사용하는 `trpl` 크레이트는 기본적으로 `futures` 크레이트의 타입과 함수, 그리고 인기 있는 런타임의 유틸리티를 재내보내는 래퍼입니다. 이러한 "어댑터" 크레이트는 Rust 생태계에서 일반적이며 공개 API 결정을 표준 라이브러리와 분리하여 반복할 수 있도록 합니다.

* Rust에서 비동기 프로그래밍의 중요한 역할을 하는 `Pin` 및 `Unpin` 타입에 대한 세부 사항도 다루지 않습니다. 대부분의 일상적인 async Rust에서는 직접 다룰 필요가 없습니다.

이것을 염두에 두고, 비동기 프로그래밍의 *이유*와 그것이 Rust의 어디에 맞는지 살펴보겠습니다.

## 병렬성 대 동시성

지금까지 병렬성과 동시성을 대부분 상호 교환적으로 취급했습니다. 이제 더 정밀하게 구분해야 합니다. 이 둘의 차이는 작업을 완료하기 위해 여러 사람이 있는 팀으로 작업할 때 나타납니다.

팀의 모든 구성원이 작업 A 또는 작업 B를 수행할 수 있고 각 구성원이 작업 중 하나를 선택하여 처음부터 끝까지 작업을 진행하면 이것이 *병렬* 작업의 예입니다. 두 작업 사이를 전환하는 대신 각 사람이 자신에게 할당된 작업에만 집중하고 처음부터 끝까지 진행하면 됩니다.

한 사람만 있거나 팀 구성원이 아직 한 작업만 할 수 있는 상태에서 두 작업 사이를 전환해야 할 때, 이것이 *동시* 작업의 예입니다. 한 작업이 막힐 때 "컨텍스트 전환"하여 다른 작업에서 진행합니다. 어느 시점에서든 실제로는 한 작업만 진행되지만, 시간이 지남에 따라 둘 다 진행됩니다.

이 두 접근 방식은 서로 배타적이지 않습니다. 종종 병렬성과 동시성을 함께 가집니다. 팀의 각 사람이 작업 세트를 받아 전환하면서 처리할 수 있습니다.

async Rust에서 퓨처는 동시성의 기본 단위입니다. 퓨처는 자체적으로 다른 퓨처로 구성될 수 있는 비동기 작업을 나타냅니다. 컴파일러가 async 코드 블록을 동시에 실행되는 다른 퓨처와 함께 인터리브될 수 있는 상태 머신으로 변환하기 때문에 복잡한 상태 전환 코드를 직접 작성할 필요가 없습니다.

이 장에서 다루는 내용:

* Rust의 `async` 및 `await` 구문 사용 방법
* 16장의 일부 동일한 도전을 해결하기 위해 async 모델 사용 방법
* 다중 스레딩과 async가 서로 보완하는 방법
