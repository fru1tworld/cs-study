# `Box<T>`를 사용하여 힙의 데이터 가리키기

가장 직접적인 스마트 포인터는 *박스*이며, 타입은 `Box<T>`로 작성됩니다. 박스를 사용하면 스택이 아닌 힙에 데이터를 저장할 수 있습니다. 스택에 남는 것은 힙 데이터에 대한 포인터입니다. 스택과 힙의 차이점을 검토하려면 4장을 참조하세요.

박스는 힙에 데이터를 저장하는 것 외에는 성능 오버헤드가 없습니다. 그러나 많은 추가 기능도 없습니다. 다음 상황에서 가장 자주 사용합니다:

* 컴파일 시간에 크기를 알 수 없는 타입이 있고 정확한 크기를 필요로 하는 컨텍스트에서 해당 타입의 값을 사용하려는 경우
* 큰 양의 데이터가 있고 소유권을 이전하고 싶지만 이전할 때 데이터가 복사되지 않도록 하려는 경우
* 값을 소유하고 특정 타입이 아닌 특정 트레이트를 구현하는 타입이라는 것만 신경 쓰려는 경우

첫 번째 상황은 "박스로 재귀 타입 활성화하기" 섹션에서 보여드리겠습니다. 두 번째 경우에서 큰 양의 데이터 소유권을 이전하면 데이터가 스택에서 복사되기 때문에 오랜 시간이 걸릴 수 있습니다. 이 상황에서 성능을 향상시키기 위해 힙의 박스에 큰 양의 데이터를 저장할 수 있습니다. 그런 다음 소유권이 이전될 때 작은 양의 포인터 데이터만 스택에서 복사되고 데이터가 참조하는 데이터는 힙의 한 곳에 유지됩니다. 세 번째 경우는 *트레이트 객체*로 알려져 있으며 18장에서 전체 섹션을 다룹니다. 따라서 여기서 배운 것은 18장에서 다시 적용될 것입니다!

## `Box<T>`를 사용하여 힙에 데이터 저장하기

`Box<T>`의 힙 저장 사용 사례를 논의하기 전에 구문과 `Box<T>` 내에 저장된 값과 상호 작용하는 방법을 다루겠습니다.

Listing 15-1은 박스를 사용하여 힙에 `i32` 값을 저장하는 방법을 보여줍니다:

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```

*Listing 15-1: 박스를 사용하여 힙에 `i32` 값 저장하기*

변수 `b`를 힙에 할당된 값 `5`를 가리키는 `Box`의 값을 갖도록 정의합니다. 이 프로그램은 `b = 5`를 출력합니다; 이 경우 데이터가 스택에 있는 것처럼 박스의 데이터에 액세스할 수 있습니다. 소유된 값과 마찬가지로 `main` 끝에서처럼 박스가 범위를 벗어나면 할당 해제됩니다. 할당 해제는 박스(스택에 저장됨)와 박스가 가리키는 데이터(힙에 저장됨) 모두에 대해 발생합니다.

힙에 단일 값을 넣는 것은 그다지 유용하지 않으므로 이런 식으로 박스를 자주 사용하지 않을 것입니다. 기본적으로 스택에 저장되는 단일 `i32`와 같은 값을 갖는 것이 대부분의 상황에서 더 적합합니다. 박스를 정의하지 않으면 정의할 수 없는 타입을 박스가 정의하도록 하는 경우를 살펴보겠습니다.

## 박스로 재귀 타입 활성화하기

*재귀 타입*의 값은 자체 타입의 다른 값을 자신의 일부로 가질 수 있습니다. 재귀 타입은 Rust가 컴파일 시간에 타입이 차지하는 공간을 알아야 하기 때문에 문제가 됩니다. 그러나 재귀 타입의 값 중첩은 이론적으로 무한히 계속될 수 있으므로 Rust는 값에 필요한 공간이 얼마인지 알 수 없습니다. 박스는 알려진 크기를 가지므로 재귀 타입 정의에 박스를 삽입하여 재귀 타입을 가질 수 있습니다.

재귀 타입의 예로 *cons 리스트*를 살펴보겠습니다. 이것은 함수형 프로그래밍 언어에서 흔히 볼 수 있는 데이터 타입입니다. 우리가 정의할 cons 리스트 타입은 재귀를 제외하면 간단합니다; 따라서 우리가 작업할 예제의 개념은 재귀 타입과 관련된 더 복잡한 상황에 처할 때마다 유용할 것입니다.

### Cons 리스트에 대한 자세한 정보

*cons 리스트*는 Lisp 프로그래밍 언어와 그 방언에서 유래한 데이터 구조이며 중첩된 쌍으로 구성됩니다. 그 이름은 Lisp의 `cons` 함수("construct function"의 약자)에서 유래했으며, 이 함수는 두 인수로 새로운 쌍을 구성합니다. 값과 다른 쌍으로 구성된 쌍에서 `cons`를 호출하면 재귀 쌍으로 구성된 cons 리스트를 형성할 수 있습니다.

예를 들어, 다음은 1, 2, 3을 포함하는 리스트의 의사 코드 표현입니다. 각 쌍은 괄호 안에 있습니다:

```text
(1, (2, (3, Nil)))
```

cons 리스트의 각 항목에는 현재 항목의 값과 다음 항목이라는 두 요소가 포함됩니다. 리스트의 마지막 항목에는 다음 항목 없이 `Nil`이라는 값만 포함됩니다. cons 리스트는 `cons` 함수를 재귀적으로 호출하여 생성됩니다. 재귀의 기본 케이스를 나타내는 표준 이름은 `Nil`입니다. 이것은 6장의 "null" 또는 "nil" 개념과 동일하지 않으며, 유효하지 않거나 부재한 값입니다.

cons 리스트는 Rust에서 자주 사용되는 데이터 구조가 아닙니다. Rust에서 항목 리스트가 있는 경우 대부분 `Vec<T>`가 더 나은 선택입니다. 다른 더 복잡한 재귀 데이터 타입은 다양한 상황에서 *유용하지만*, 이 장에서 cons 리스트로 시작하면 박스가 큰 혼란 없이 재귀 데이터 타입을 정의하도록 하는 방법을 탐구할 수 있습니다.

Listing 15-2에는 cons 리스트에 대한 열거형 정의가 포함되어 있습니다. 이 코드는 아직 컴파일되지 않습니다. `List` 타입의 크기가 알려져 있지 않기 때문입니다. 이에 대해서는 나중에 설명하겠습니다.

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

*Listing 15-2: `i32` 값의 cons 리스트 데이터 구조를 나타내는 열거형을 정의하는 첫 번째 시도*

> 참고: 이 예제의 목적을 위해 `i32` 값만 보유하는 cons 리스트를 구현하고 있습니다. 10장에서 논의한 대로 제네릭을 사용하여 모든 타입의 값을 저장하는 cons 리스트 타입을 정의할 수 있습니다.

`List` 타입을 사용하여 1, 2, 3 리스트를 저장하면 Listing 15-3의 코드처럼 보일 것입니다:

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

*Listing 15-3: `List` 열거형을 사용하여 1, 2, 3 리스트 저장하기*

첫 번째 `Cons` 값은 `1`과 다른 `List` 값을 보유합니다. 이 `List` 값은 `2`와 다른 `List` 값을 보유하는 또 다른 `Cons` 값입니다. 이 `List` 값은 `3`과 마지막으로 리스트의 끝을 나타내는 비재귀 변형인 `Nil`인 `List` 값을 보유하는 또 다른 `Cons` 값입니다.

Listing 15-3의 코드를 컴파일하려고 하면 Listing 15-4에 표시된 오류가 발생합니다:

```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

*Listing 15-4: 재귀 열거형을 정의하려고 할 때 발생하는 오류*

오류는 이 타입이 "무한 크기"를 가지고 있음을 보여줍니다. 그 이유는 재귀 변형을 가진 `List`를 정의했기 때문입니다: 자체 타입의 다른 값을 직접 보유합니다. 결과적으로 Rust는 `List` 값을 저장하는 데 필요한 공간을 파악할 수 없습니다. 이 오류가 발생하는 이유를 분석해 보겠습니다. 먼저 Rust가 비재귀 타입의 값을 저장하는 데 필요한 공간을 결정하는 방법을 살펴보겠습니다.

### 비재귀 타입의 크기 계산하기

6장에서 열거형 정의를 논의할 때 Listing 6-2에서 정의한 `Message` 열거형을 기억해 보세요:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

`Message` 값에 할당할 공간이 얼마나 필요한지 결정하기 위해 Rust는 각 변형을 살펴보고 가장 많은 공간이 필요한 변형을 확인합니다. Rust는 `Message::Quit`에 공간이 필요하지 않고, `Message::Move`에 두 `i32` 값을 저장할 충분한 공간이 필요하다는 것을 알 수 있습니다. 하나의 변형만 사용되므로 `Message` 값에 필요한 가장 많은 공간은 가장 큰 변형 중 하나를 저장하는 데 필요한 공간입니다.

Rust가 Listing 15-2의 `List` 열거형과 같은 재귀 타입에 필요한 공간을 결정하려고 할 때 어떤 일이 발생하는지 대조해 보세요. 컴파일러는 `Cons` 변형을 살펴보기 시작합니다. 이 변형은 `i32` 타입의 값과 `List` 타입의 값을 보유합니다. 따라서 `Cons`는 `i32`의 크기에 `List`의 크기를 더한 공간이 필요합니다. `List` 타입에 필요한 메모리 양을 파악하기 위해 컴파일러는 `Cons` 변형부터 시작하여 변형을 살펴봅니다. `Cons` 변형은 `i32` 타입의 값과 `List` 타입의 값을 보유하며 이 프로세스는 무한히 계속됩니다.

### 알려진 크기의 재귀 타입을 얻기 위해 `Box<T>` 사용하기

Rust는 재귀적으로 정의된 타입에 할당할 공간을 파악할 수 없으므로 컴파일러는 다음과 같은 유용한 제안과 함께 오류를 제공합니다:

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

이 제안에서 "간접"은 값을 직접 저장하는 대신 값에 대한 포인터를 저장하여 데이터 구조를 변경해야 함을 의미합니다.

`Box<T>`는 포인터이기 때문에 Rust는 항상 `Box<T>`에 필요한 공간을 알고 있습니다: 포인터의 크기는 가리키는 데이터의 양에 따라 변경되지 않습니다. 이것은 `Cons` 변형에 직접 다른 `List` 값 대신 `Box<T>`를 넣을 수 있음을 의미합니다. `Box<T>`는 `Cons` 변형 안이 아닌 힙에 있을 다음 `List` 값을 가리킵니다. 개념적으로 여전히 다른 리스트를 보유하는 리스트로 만들어진 리스트가 있습니다. 그러나 이 구현은 이제 항목이 서로 안에 있기보다 서로 옆에 배치되는 것과 더 비슷합니다.

Listing 15-2의 `List` 열거형 정의와 Listing 15-3의 `List` 사용을 Listing 15-5의 코드로 변경할 수 있으며 컴파일됩니다:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

*Listing 15-5: 알려진 크기를 갖기 위해 `Box<T>`를 사용하는 `List` 정의*

`Cons` 변형에는 `i32`의 크기에 박스의 포인터 데이터를 저장할 공간이 필요합니다. `Nil` 변형은 값을 저장하지 않으므로 `Cons` 변형보다 공간이 덜 필요합니다. 이제 모든 `List` 값이 `i32`의 크기에 박스의 포인터 데이터 크기를 더한 것임을 알 수 있습니다. 박스를 사용하여 무한 재귀 체인을 끊었으므로 컴파일러는 `List` 값을 저장하는 데 필요한 크기를 파악할 수 있습니다.

박스는 간접과 힙 할당만 제공합니다; 다른 스마트 포인터 타입에서 볼 수 있는 것과 같은 다른 특별한 기능은 없습니다. 또한 이러한 특별한 기능으로 인해 발생하는 성능 오버헤드도 없으므로 cons 리스트와 같이 간접만 필요한 기능인 경우에 유용할 수 있습니다. 17장에서 박스의 더 많은 사용 사례를 살펴보겠습니다.

`Box<T>` 타입은 `Deref` 트레이트를 구현하기 때문에 스마트 포인터입니다. 이를 통해 `Box<T>` 값을 참조처럼 처리할 수 있습니다. `Box<T>` 값이 범위를 벗어나면 박스가 가리키는 힙 데이터도 `Drop` 트레이트 구현으로 인해 정리됩니다. 이 두 트레이트는 이 장의 나머지 부분에서 논의할 다른 스마트 포인터 타입이 제공하는 기능에 더욱 중요할 것입니다. 이 두 트레이트를 더 자세히 살펴보겠습니다.
