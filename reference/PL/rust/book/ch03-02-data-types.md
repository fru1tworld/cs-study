# 데이터 타입

Rust의 모든 값은 특정 *데이터 타입*을 가지며, 이는 Rust에게 어떤 종류의 데이터가 지정되었는지 알려주어 해당 데이터를 어떻게 다룰지 알 수 있게 합니다. 스칼라와 복합이라는 두 가지 데이터 타입 하위 집합을 살펴보겠습니다.

Rust는 *정적 타입* 언어임을 기억하세요. 이는 컴파일 타임에 모든 변수의 타입을 알아야 한다는 것을 의미합니다. 컴파일러는 보통 값과 사용 방법에 따라 사용하고자 하는 타입을 추론할 수 있습니다. `String`을 `parse`를 사용하여 숫자 타입으로 변환할 때처럼 여러 타입이 가능한 경우에는 타입 어노테이션을 추가해야 합니다.

타입 어노테이션이 필요한 예:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

`: u32` 어노테이션 없이는 컴파일러가 타입 어노테이션이 필요하다는 오류를 표시합니다.

---

## 스칼라 타입

*스칼라* 타입은 단일 값을 나타냅니다. Rust에는 네 가지 주요 스칼라 타입이 있습니다: 정수, 부동 소수점 숫자, 불리언, 문자.

### 정수 타입

*정수*는 소수 부분이 없는 숫자입니다.

**표 3-1: Rust의 정수 타입**

| 길이 | 부호 있음 | 부호 없음 |
|------|----------|----------|
| 8비트 | `i8` | `u8` |
| 16비트 | `i16` | `u16` |
| 32비트 | `i32` | `u32` |
| 64비트 | `i64` | `u64` |
| 128비트 | `i128` | `u128` |
| 아키텍처 의존 | `isize` | `usize` |

*부호 있음*과 *부호 없음*은 숫자가 음수가 될 수 있는지 여부를 나타냅니다. 부호 있는 숫자는 2의 보수 표현을 사용하여 저장됩니다.

- 부호 있는 각 변형은 -(2^(n-1))에서 2^(n-1) - 1까지의 숫자를 저장할 수 있습니다
- 부호 없는 변형은 0에서 2^n - 1까지의 숫자를 저장할 수 있습니다
- `isize`와 `usize`는 컴퓨터 아키텍처에 따라 달라집니다 (64비트 시스템에서는 64비트, 32비트 시스템에서는 32비트)

**표 3-2: Rust의 정수 리터럴**

| 숫자 리터럴 | 예 |
|------------|-----|
| 십진수 | `98_222` |
| 16진수 | `0xff` |
| 8진수 | `0o77` |
| 이진수 | `0b1111_0000` |
| 바이트 (`u8`만) | `b'A'` |

숫자 리터럴은 `_`를 시각적 구분자로 사용할 수 있습니다. 예: `1_000` (`1000`과 동일).

정수 타입은 기본적으로 `i32`입니다. 컬렉션 인덱싱 시 주로 `isize` 또는 `usize`를 사용합니다.

#### 정수 오버플로

정수 오버플로는 변수가 보유할 수 있는 범위를 초과할 때 발생합니다. 동작은 컴파일 모드에 따라 다릅니다:

- **디버그 모드**: Rust는 런타임에 프로그램을 *패닉*시키는 검사를 포함합니다
- **릴리스 모드** (`--release` 플래그 사용): Rust는 *2의 보수 래핑*을 수행하여 값이 범위의 최소값으로 래핑됩니다

오버플로를 명시적으로 처리하려면 표준 라이브러리가 기본 숫자 타입에 대해 다음 메서드 계열을 제공합니다:

- `wrapping_*` 메서드 (예: `wrapping_add`) - 모든 모드에서 래핑
- `checked_*` 메서드 - 오버플로 발생 시 `None` 반환
- `overflowing_*` 메서드 - 값과 오버플로 여부를 나타내는 불리언 반환
- `saturating_*` 메서드 - 최소값 또는 최대값에서 포화

### 부동 소수점 타입

Rust에는 *부동 소수점 숫자*를 위한 두 가지 기본 타입이 있습니다: `f32`와 `f64`로, 각각 32비트와 64비트 크기입니다. 현대 CPU에서 `f64`가 `f32`와 거의 같은 속도지만 더 정밀하기 때문에 기본 타입은 `f64`입니다. 모든 부동 소수점 타입은 부호가 있습니다.

부동 소수점 숫자는 IEEE-754 표준에 따라 표현됩니다.

예:

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

### 숫자 연산

Rust는 모든 숫자 타입에 대해 기본 수학 연산을 지원합니다: 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지. 정수 나눗셈은 0 방향으로 가장 가까운 정수로 잘립니다.

```rust
fn main() {
    // 덧셈
    let sum = 5 + 10;

    // 뺄셈
    let difference = 95.5 - 4.3;

    // 곱셈
    let product = 4 * 30;

    // 나눗셈
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 결과는 -1

    // 나머지
    let remainder = 43 % 5;
}
```

### 불리언 타입

Rust의 불리언 타입은 `true`와 `false` 두 가지 가능한 값을 가집니다. 불리언은 1바이트 크기입니다. 불리언 타입은 `bool`을 사용하여 지정합니다.

```rust
fn main() {
    let t = true;

    let f: bool = false; // 명시적 타입 어노테이션 사용
}
```

불리언 값은 주로 `if` 표현식과 같은 조건문에서 사용됩니다.

### 문자 타입

Rust의 `char` 타입은 언어에서 가장 기본적인 알파벳 타입입니다. `char` 리터럴은 큰따옴표를 사용하는 문자열 리터럴과 달리 작은따옴표로 지정합니다.

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 명시적 타입 어노테이션 사용
    let heart_eyed_cat = '😻';
}
```

Rust의 `char` 타입은 4바이트 크기이며 유니코드 스칼라 값을 나타냅니다. 이것은 다음을 표현할 수 있음을 의미합니다:

- 악센트 문자
- 중국어, 일본어, 한국어 문자
- 이모지
- 제로 폭 공백
- `U+0000`에서 `U+D7FF` 및 `U+E000`에서 `U+10FFFF`까지의 유니코드 스칼라 값

---

## 복합 타입

*복합 타입*은 여러 값을 하나의 타입으로 그룹화할 수 있습니다. Rust에는 두 가지 기본 복합 타입이 있습니다: 튜플과 배열.

### 튜플 타입

*튜플*은 다양한 타입의 여러 값을 하나의 복합 타입으로 그룹화하는 일반적인 방법입니다. 튜플은 고정된 길이를 가지며 한 번 선언되면 늘어나거나 줄어들 수 없습니다.

튜플 생성:

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

**튜플 구조 분해:**

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

**인덱스로 튜플 요소 접근:**

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

튜플의 첫 번째 인덱스는 0입니다.

**유닛 타입:**

값이 없는 튜플은 *유닛*이라는 특별한 이름을 가집니다. 이 값과 해당 타입은 모두 `()`로 작성되며 빈 값 또는 빈 반환 타입을 나타냅니다. 표현식이 다른 값을 반환하지 않으면 암묵적으로 유닛 값을 반환합니다.

### 배열 타입

*배열*은 여러 값의 컬렉션을 가지는 또 다른 방법입니다. 튜플과 달리:

- 배열의 모든 요소는 같은 타입이어야 합니다
- Rust의 배열은 고정된 길이를 가집니다

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

배열은 다음과 같은 경우에 유용합니다:

- 스택에 데이터를 할당하고 싶을 때
- 항상 고정된 수의 요소를 갖도록 하고 싶을 때

늘어나거나 줄어들 수 있는 유연한 컬렉션이 필요하면 대신 **벡터**를 사용하세요 (8장에서 논의).

**배열 타입 어노테이션:**

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

여기서 `i32`는 요소 타입이고 `5`는 요소 수입니다.

**같은 값으로 배열 초기화:**

```rust
let a = [3; 5];
```

이것은 5개의 요소를 가진 배열을 생성하며, 모두 `3`으로 초기화됩니다 (`[3, 3, 3, 3, 3]`과 동일).

### 배열 요소 접근

인덱싱을 사용하여 배열 요소에 접근:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

### 잘못된 배열 요소 접근

배열의 끝을 넘어 요소에 접근하려고 하면 Rust는 패닉합니다:

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

5개 요소 배열에서 인덱스 10에 접근할 때 패닉 출력 예:

```text
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Rust는 런타임에 인덱스가 배열 길이보다 작은지 확인하고, 같거나 크면 패닉합니다. 이것은 많은 저수준 언어에서 발생하는 잘못된 메모리 접근을 방지하는 메모리 안전 원칙입니다.
