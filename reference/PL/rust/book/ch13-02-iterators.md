# 반복자로 일련의 항목 처리하기

반복자 패턴을 사용하면 일련의 항목에 대해 순서대로 어떤 작업을 수행할 수 있습니다. 반복자는 각 항목을 반복하고 시퀀스가 언제 끝났는지 결정하는 로직을 담당합니다. 반복자를 사용하면 이 로직을 직접 다시 구현할 필요가 없습니다.

Rust에서 반복자는 *지연적(lazy)*입니다. 즉, 반복자를 소비하는 메서드를 호출하여 사용하기 전까지는 아무런 효과가 없습니다. 예를 들어, Listing 13-10의 코드는 `Vec<T>`에 정의된 `iter` 메서드를 호출하여 벡터 `v1`의 항목에 대한 반복자를 생성합니다. 이 코드 자체로는 유용한 일을 수행하지 않습니다.

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
}
```

*Listing 13-10: 반복자 생성하기*

반복자는 `v1_iter` 변수에 저장됩니다. 반복자를 생성하면 다양한 방법으로 사용할 수 있습니다. 3장의 Listing 3-5에서 `for` 루프를 사용하여 배열을 반복하며 각 항목에 대해 일부 코드를 실행했습니다. 내부적으로 이것은 암묵적으로 반복자를 생성한 다음 소비했지만, 지금까지 그것이 정확히 어떻게 작동하는지 설명하지 않았습니다.

Listing 13-11의 예제에서는 반복자 생성을 `for` 루프에서의 반복자 사용과 분리합니다. `v1_iter`의 반복자를 사용하여 `for` 루프가 호출되면, 반복자의 각 요소가 루프의 한 반복에서 사용되어 각 값을 출력합니다.

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("받은 값: {val}");
    }
}
```

*Listing 13-11: `for` 루프에서 반복자 사용하기*

표준 라이브러리에서 제공하는 반복자가 없는 언어에서는 변수를 인덱스 0에서 시작하고, 그 변수를 사용하여 벡터에 인덱싱하여 값을 얻고, 벡터의 총 항목 수에 도달할 때까지 루프에서 변수 값을 증가시켜 동일한 기능을 작성할 수 있습니다.

반복자는 이 모든 로직을 처리하여 잠재적으로 엉망으로 만들 수 있는 반복적인 코드를 줄여줍니다. 반복자는 벡터와 같이 인덱싱할 수 있는 데이터 구조뿐만 아니라 많은 다른 종류의 시퀀스에서 동일한 로직을 사용할 수 있는 유연성을 더 많이 제공합니다. 반복자가 어떻게 그렇게 하는지 살펴보겠습니다.

## `Iterator` 트레이트와 `next` 메서드

모든 반복자는 표준 라이브러리에 정의된 `Iterator`라는 트레이트를 구현합니다. 트레이트의 정의는 다음과 같습니다:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // 기본 구현이 있는 메서드는 생략
}
```

이 정의는 새로운 구문을 사용하는 것에 주목하세요: `type Item`과 `Self::Item`, 이것은 이 트레이트와 함께 *연관 타입*을 정의합니다. 연관 타입에 대해서는 20장에서 자세히 설명하겠습니다. 지금은 이 코드가 `Iterator` 트레이트를 구현하려면 `Item` 타입도 정의해야 하며, 이 `Item` 타입이 `next` 메서드의 반환 타입에 사용된다는 것만 알면 됩니다. 즉, `Item` 타입은 반복자에서 반환되는 타입입니다.

`Iterator` 트레이트는 구현자가 `next` 메서드 하나만 정의하면 됩니다. 이 메서드는 반복자의 항목을 한 번에 하나씩 `Some`으로 감싸서 반환하고, 반복이 끝나면 `None`을 반환합니다.

반복자에서 직접 `next` 메서드를 호출할 수 있습니다; Listing 13-12는 벡터에서 생성된 반복자에서 `next`를 반복 호출했을 때 어떤 값이 반환되는지 보여줍니다.

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

*Listing 13-12: 반복자에서 `next` 메서드 호출하기*

`v1_iter`를 가변으로 만들어야 했다는 점에 유의하세요: 반복자에서 `next` 메서드를 호출하면 반복자가 시퀀스에서 현재 위치를 추적하는 데 사용하는 내부 상태가 변경됩니다. 다시 말해, 이 코드는 반복자를 *소비*하거나 사용합니다. `next`에 대한 각 호출은 반복자에서 항목을 소비합니다. `for` 루프를 사용할 때는 `v1_iter`를 가변으로 만들 필요가 없었습니다. 루프가 `v1_iter`의 소유권을 가져가고 내부적으로 가변으로 만들었기 때문입니다.

또한 `next` 호출에서 얻은 값이 벡터의 값에 대한 불변 참조라는 점에 유의하세요. `iter` 메서드는 불변 참조에 대한 반복자를 생성합니다. `v1`의 소유권을 가져가고 소유된 값을 반환하는 반복자를 생성하려면 `iter` 대신 `into_iter`를 호출할 수 있습니다. 마찬가지로, 가변 참조를 반복하려면 `iter` 대신 `iter_mut`를 호출할 수 있습니다.

## 반복자를 소비하는 메서드

`Iterator` 트레이트에는 표준 라이브러리에서 제공하는 기본 구현이 있는 여러 다른 메서드가 있습니다; 표준 라이브러리 API 문서에서 `Iterator` 트레이트를 살펴보면 이러한 메서드에 대해 알아볼 수 있습니다. 이러한 메서드 중 일부는 정의에서 `next` 메서드를 호출하므로 `Iterator` 트레이트를 구현할 때 `next` 메서드를 구현해야 합니다.

`next`를 호출하는 메서드는 *소비 어댑터*라고 합니다. 호출하면 반복자를 사용하기 때문입니다. 한 가지 예는 `sum` 메서드로, 반복자의 소유권을 가져가고 반복적으로 `next`를 호출하여 항목을 반복하여 반복자를 소비합니다. 반복하면서 누적 합계에 각 항목을 더하고 반복이 완료되면 합계를 반환합니다. Listing 13-13에는 `sum` 메서드 사용을 보여주는 테스트가 있습니다:

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

*Listing 13-13: `sum` 메서드를 호출하여 반복자의 모든 항목 합계 얻기*

`sum`이 호출된 반복자의 소유권을 가져가기 때문에 `sum` 호출 후에는 `v1_iter`를 사용할 수 없습니다.

## 다른 반복자를 생성하는 메서드

*반복자 어댑터*는 `Iterator` 트레이트에 정의된 메서드로, 반복자를 소비하지 않습니다. 대신 원래 반복자의 일부 측면을 변경하여 다른 반복자를 생성합니다.

Listing 13-14는 반복자 어댑터 메서드 `map`을 호출하는 예를 보여줍니다. 이 메서드는 항목이 반복될 때 각 항목에 대해 호출할 클로저를 받습니다. `map` 메서드는 수정된 항목을 생성하는 새 반복자를 반환합니다. 여기서 클로저는 벡터의 각 항목이 1씩 증가된 새 반복자를 생성합니다:

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
}
```

*Listing 13-14: 반복자 어댑터 `map`을 호출하여 새 반복자 생성하기*

그러나 이 코드는 경고를 생성합니다:

```text
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
```

Listing 13-14의 코드는 아무것도 하지 않습니다; 지정한 클로저가 호출되지 않습니다. 경고는 그 이유를 상기시켜 줍니다: 반복자 어댑터는 지연적이며, 여기서 반복자를 소비해야 합니다.

이를 수정하고 반복자를 소비하려면 `collect` 메서드를 사용합니다. 이 메서드는 13장에서 `env::args`와 함께 12장에서 사용했습니다. 이 메서드는 반복자를 소비하고 결과 값을 컬렉션 데이터 타입으로 수집합니다.

Listing 13-15에서 `map` 호출에서 반환된 반복자를 반복한 결과를 벡터에 수집합니다. 이 벡터는 원래 벡터의 각 항목이 1씩 증가된 값을 포함합니다.

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}
```

*Listing 13-15: `map` 메서드를 호출하여 새 반복자를 생성한 다음 `collect` 메서드를 호출하여 새 반복자를 소비하고 벡터 생성하기*

`map`은 클로저를 받기 때문에 각 항목에 수행하려는 모든 작업을 지정할 수 있습니다. 이것은 클로저가 `Iterator` 트레이트가 제공하는 반복 동작을 재사용하면서 일부 동작을 사용자 정의하는 방법의 좋은 예입니다.

반복자 어댑터에 대한 여러 호출을 연결하여 복잡한 작업을 읽기 쉬운 방식으로 수행할 수 있습니다. 그러나 모든 반복자는 지연적이므로 반복자 어댑터 호출에서 결과를 얻으려면 소비 어댑터 메서드 중 하나를 호출해야 합니다.

## 환경을 캡처하는 클로저 사용하기

많은 반복자 어댑터가 클로저를 인수로 받으며, 일반적으로 반복자 어댑터에 인수로 지정하는 클로저는 환경을 캡처하는 클로저입니다.

이 예제에서는 클로저를 받는 `filter` 메서드를 사용합니다. 클로저는 반복자에서 항목을 가져와 `bool`을 반환합니다. 클로저가 `true`를 반환하면 값이 `filter`에 의해 생성된 반복에 포함됩니다. 클로저가 `false`를 반환하면 값이 포함되지 않습니다.

Listing 13-16에서 `filter`를 사용하여 환경에서 `shoe_size` 변수를 캡처하는 클로저와 함께 `Shoe` 구조체 인스턴스 컬렉션을 반복합니다. 지정된 크기의 신발만 반환합니다.

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("스니커즈"),
            },
            Shoe {
                size: 13,
                style: String::from("샌들"),
            },
            Shoe {
                size: 10,
                style: String::from("부츠"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("스니커즈")
                },
                Shoe {
                    size: 10,
                    style: String::from("부츠")
                },
            ]
        );
    }
}
```

*Listing 13-16: `shoe_size`를 캡처하는 클로저와 함께 `filter` 메서드 사용하기*

`shoes_in_size` 함수는 매개변수로 신발 벡터의 소유권과 신발 크기를 받습니다. 지정된 크기의 신발만 포함하는 벡터를 반환합니다.

`shoes_in_size`의 본문에서 `into_iter`를 호출하여 벡터의 소유권을 갖는 반복자를 생성합니다. 그런 다음 `filter`를 호출하여 해당 반복자를 클로저가 `true`를 반환하는 요소만 포함하는 새 반복자로 변환합니다.

클로저는 환경에서 `shoe_size` 매개변수를 캡처하고 해당 값을 각 신발의 크기와 비교하여 지정된 크기의 신발만 유지합니다. 마지막으로 `collect`를 호출하면 적용된 반복자가 반환한 값을 함수가 반환하는 벡터에 수집합니다.

테스트는 `shoes_in_size`를 호출하면 지정한 것과 같은 크기의 신발만 반환된다는 것을 보여줍니다.
