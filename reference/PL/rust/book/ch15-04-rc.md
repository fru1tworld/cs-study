# `Rc<T>`, 참조 카운팅 스마트 포인터

대부분의 경우 소유권은 명확합니다: 주어진 값을 어떤 변수가 소유하는지 정확히 알 수 있습니다. 그러나 단일 값이 여러 소유자를 가질 수 있는 경우가 있습니다. 예를 들어 그래프 데이터 구조에서 여러 에지가 같은 노드를 가리킬 수 있으며, 해당 노드는 개념적으로 그것을 가리키는 모든 에지에 의해 소유됩니다. 노드는 에지가 가리키지 않아 소유자가 없을 때까지 정리되어서는 안 됩니다.

`Rc<T>` 타입을 사용하면 *참조 카운팅*을 통해 여러 소유권을 명시적으로 활성화해야 합니다. `Rc<T>`는 "reference counting"의 약자입니다. `Rc<T>` 타입은 값에 대한 참조 수를 추적하여 값이 여전히 사용 중인지 확인합니다. 값에 대한 참조가 0개이면 참조가 유효하지 않게 되지 않고 값을 정리할 수 있습니다.

`Rc<T>`를 거실의 TV로 상상해 보세요. 한 사람이 들어와서 TV를 볼 때 켭니다. 다른 사람들이 방에 들어와서 TV를 볼 수 있습니다. 마지막 사람이 거실을 떠날 때 더 이상 사용되지 않으므로 TV를 끕니다. 다른 사람들이 여전히 보고 있을 때 누군가가 TV를 끄면 나머지 TV 시청자들의 항의가 있을 것입니다!

프로그램의 여러 부분이 읽을 수 있도록 힙에 일부 데이터를 할당하고 컴파일 시간에 어느 부분이 데이터 사용을 마지막으로 끝낼지 결정할 수 없을 때 `Rc<T>` 타입을 사용합니다. 어느 부분이 마지막으로 끝낼지 알았다면 해당 부분을 데이터의 소유자로 만들 수 있으며, 컴파일 시간에 적용되는 일반 소유권 규칙이 적용됩니다.

`Rc<T>`는 단일 스레드 시나리오에서만 사용할 수 있습니다. 16장에서 동시성에 대해 논의할 때 다중 스레드 프로그램에서 참조 카운팅을 수행하는 방법을 다룰 것입니다.

## `Rc<T>`를 사용하여 데이터 공유하기

Listing 15-5의 cons 리스트 예제로 돌아가 봅시다. `Box<T>`를 사용하여 정의했음을 기억하세요. 이번에는 두 리스트가 모두 세 번째 리스트의 소유권을 공유하도록 만들 것입니다. 개념적으로 이것은 다음과 유사합니다:

```text
b (3) ─┐
       ├─► a (5) ─► (10) ─► Nil
c (4) ─┘
```

리스트 `a`는 5와 10을 포함합니다. 그런 다음 3으로 시작하는 리스트 `b`와 4로 시작하는 리스트 `c` 두 개를 더 만들 것입니다. `b`와 `c` 리스트 모두 5와 10을 포함하는 첫 번째 `a` 리스트로 계속됩니다. 다시 말해, 두 리스트는 5와 10을 포함하는 첫 번째 리스트를 공유합니다.

`Box<T>`를 사용한 `List` 정의로 이 시나리오를 구현하려고 하면 작동하지 않습니다. Listing 15-17에 표시된 대로:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

*Listing 15-17: `Box<T>`를 사용하여 두 리스트가 세 번째 리스트의 소유권을 공유하려고 시도하는 것이 허용되지 않음을 보여주기*

이 코드를 컴파일하면 이 오류가 발생합니다:

```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --> src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
```

`Cons` 변형은 보유한 데이터를 소유하므로 `b` 리스트를 만들 때 `a`가 `b`로 이동되고 `b`가 `a`를 소유합니다. 그런 다음 `c`를 만들 때 `a`를 다시 사용하려고 하면 `a`가 이동되었기 때문에 허용되지 않습니다.

`Cons`의 정의를 변경하여 참조를 대신 보유하도록 할 수 있지만, 그러면 라이프타임 매개변수를 지정해야 합니다. 라이프타임 매개변수를 지정하면 리스트의 모든 요소가 적어도 전체 리스트만큼 오래 살아야 한다고 지정하게 됩니다. 이것은 Listing 15-17의 요소와 리스트의 경우이지만 모든 시나리오에서는 그렇지 않습니다.

대신 `List`의 정의를 `Box<T>` 대신 `Rc<T>`를 사용하도록 변경합니다. Listing 15-18에 표시된 대로. 각 `Cons` 변형은 이제 값과 `List`를 가리키는 `Rc<T>`를 보유합니다. `b`를 만들 때 `a`의 소유권을 가져가는 대신 `a`가 보유한 `Rc<List>`를 복제하여 참조 수를 1에서 2로 늘리고 `a`와 `b`가 해당 `Rc<List>`의 데이터 소유권을 공유하도록 합니다. 또한 `c`를 만들 때 `a`를 복제하여 참조 수를 2에서 3으로 늘립니다. `Rc::clone`을 호출할 때마다 `Rc<List>` 내부 데이터에 대한 참조 카운트가 증가하고 참조가 0이 될 때까지 데이터가 정리되지 않습니다.

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

*Listing 15-18: `Rc<T>`를 사용하는 `List` 정의*

`Rc<T>`는 프렐루드에 없으므로 범위로 가져오기 위해 `use` 문을 추가해야 합니다. `main`에서 5와 10을 보유하는 리스트를 만들고 `a`의 새 `Rc<List>`에 저장합니다. 그런 다음 `b`와 `c`를 만들 때 `Rc::clone` 함수를 호출하고 `a`의 `Rc<List>`에 대한 참조를 인수로 전달합니다.

`Rc::clone(&a)` 대신 `a.clone()`을 호출할 수 있지만 Rust의 관례는 이 경우 `Rc::clone`을 사용하는 것입니다. `Rc::clone`의 구현은 대부분의 타입의 `clone` 구현처럼 모든 데이터의 딥 카피를 만들지 않습니다. `Rc::clone` 호출은 참조 카운트만 증가시키며 이는 많은 시간이 걸리지 않습니다. 데이터의 딥 카피는 많은 시간이 걸릴 수 있습니다. 참조 카운팅에 `Rc::clone`을 사용하면 딥 카피 종류의 복제와 참조 카운트를 증가시키는 종류의 복제를 시각적으로 구분할 수 있습니다. 코드에서 성능 문제를 찾을 때 딥 카피 복제만 고려하면 되고 `Rc::clone` 호출은 무시할 수 있습니다.

## `Rc<T>` 복제는 참조 카운트를 증가시킵니다

Listing 15-18의 작동 예제를 변경하여 `a`의 `Rc<List>`에 대한 참조를 만들고 드롭할 때 참조 카운트가 변경되는 것을 볼 수 있습니다.

Listing 15-19에서 `main`을 변경하여 리스트 `c` 주위에 내부 범위를 갖도록 합니다; 그런 다음 `c`가 범위를 벗어날 때 참조 카운트가 어떻게 변경되는지 볼 수 있습니다.

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("a 생성 후 카운트 = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("b 생성 후 카운트 = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("c 생성 후 카운트 = {}", Rc::strong_count(&a));
    }
    println!("c가 범위를 벗어난 후 카운트 = {}", Rc::strong_count(&a));
}
```

*Listing 15-19: 참조 카운트 출력하기*

프로그램에서 참조 카운트가 변경되는 각 지점에서 `Rc::strong_count` 함수를 호출하여 얻은 참조 카운트를 출력합니다. 이 함수는 `count` 대신 `strong_count`라고 명명됩니다. 왜냐하면 `Rc<T>` 타입에는 `weak_count`도 있기 때문입니다; "참조 순환 방지하기: `Rc<T>`를 `Weak<T>`로 변환하기" 섹션에서 `weak_count`가 무엇에 사용되는지 볼 것입니다.

이 코드는 다음을 출력합니다:

```console
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
a 생성 후 카운트 = 1
b 생성 후 카운트 = 2
c 생성 후 카운트 = 3
c가 범위를 벗어난 후 카운트 = 2
```

`a`의 `Rc<List>`가 초기 참조 카운트 1을 가지고 있는 것을 볼 수 있습니다; 그런 다음 `clone`을 호출할 때마다 카운트가 1씩 증가합니다. `c`가 범위를 벗어나면 카운트가 1 감소합니다. 참조 카운트를 증가시키기 위해 `Rc::clone`을 호출해야 하는 것처럼 참조 카운트를 감소시키기 위해 함수를 호출할 필요가 없습니다: `Rc<T>` 값이 범위를 벗어날 때 `Drop` 트레이트의 구현이 자동으로 참조 카운트를 감소시킵니다.

이 예제에서 볼 수 없는 것은 `main` 끝에서 `b` 다음에 `a`가 범위를 벗어나면 카운트가 0이 되고 `Rc<List>`가 완전히 정리된다는 것입니다. `Rc<T>`를 사용하면 단일 값이 여러 소유자를 가질 수 있으며, 카운트는 소유자 중 어느 것이든 여전히 존재하는 한 값이 유효하게 유지되도록 보장합니다.

불변 참조를 통해 `Rc<T>`를 사용하면 프로그램의 여러 부분 간에 읽기 전용으로 데이터를 공유할 수 있습니다. `Rc<T>`가 여러 가변 참조를 갖도록 허용하면 4장에서 논의한 빌림 규칙 중 하나를 위반할 수 있습니다: 같은 장소에 대한 여러 가변 빌림은 데이터 레이스와 불일치를 유발할 수 있습니다. 그러나 데이터를 변형할 수 있는 것은 매우 유용합니다! 다음 섹션에서는 내부 가변성 패턴과 이 불변성 제한을 해결하기 위해 `Rc<T>`와 함께 사용할 수 있는 `RefCell<T>` 타입에 대해 논의합니다.
