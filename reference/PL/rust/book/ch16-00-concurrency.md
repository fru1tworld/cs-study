# 겁 없는 동시성

동시 프로그래밍을 안전하고 효율적으로 처리하는 것은 Rust의 또 다른 주요 목표 중 하나입니다. *동시 프로그래밍*은 프로그램의 다른 부분이 독립적으로 실행되는 것이고, *병렬 프로그래밍*은 프로그램의 다른 부분이 동시에 실행되는 것입니다. 이 두 개념은 역사적으로 별도로 처리하기 어려웠고 안전하게 프로그래밍하기 어려웠습니다. 컴퓨터가 여러 프로세서를 활용함에 따라 점점 더 중요해지고 있습니다. Rust의 소유권 시스템과 타입 시스템은 이 문제를 관리하는 데 도움이 되는 강력한 도구 세트입니다.

많은 언어들은 동시성 문제에 대해 제공할 수 있는 잠재적 해결책에 대해 교조적입니다. 예를 들어 Erlang은 메시지 전달 동시성에 대한 우아한 기능을 가지고 있지만 스레드 간에 상태를 공유하는 모호한 방법만 있습니다. 가능한 해결책의 하위 집합만 지원하는 것은 높은 수준의 언어에 대한 합리적인 전략입니다. 높은 수준의 언어는 추상화를 얻기 위해 일부 제어를 포기하기로 약속하기 때문입니다. 그러나 낮은 수준의 언어는 주어진 상황에서 최고의 성능으로 어떤 솔루션이든 제공해야 하고 하드웨어에 대한 추상화가 적어야 합니다. 따라서 Rust는 상황과 요구 사항에 적합한 방식으로 문제를 모델링하기 위한 다양한 도구를 제공합니다.

다음은 이 장에서 다룰 주제입니다:

* 여러 코드 조각을 동시에 실행하기 위해 스레드를 만드는 방법
* 채널을 사용하여 스레드 간에 메시지를 보내는 *메시지 전달* 동시성
* 여러 스레드가 일부 데이터에 액세스할 수 있는 *공유 상태* 동시성
* 표준 라이브러리 타입뿐만 아니라 사용자 정의 타입에도 Rust의 동시성 보장을 확장하는 `Sync` 및 `Send` 트레이트

다음 장에서는 Rust에서 동시성에 대한 또 다른 접근 방식인 async/await을 다룰 것입니다.
