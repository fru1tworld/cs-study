# 공유 상태 동시성

메시지 전달은 동시성을 처리하는 좋은 방법이지만 유일한 방법은 아닙니다. 또 다른 방법은 여러 스레드가 같은 공유 데이터에 액세스하는 것입니다. Go 언어 문서의 슬로건의 이 부분을 다시 고려해 보세요: "메모리를 공유하여 통신하지 마세요."

메모리를 공유하여 통신하는 것은 어떤 모습일까요? 또한 메시지 전달 지지자들이 왜 메모리 공유를 사용하지 말라고 주의할까요?

어떤 면에서 모든 프로그래밍 언어의 채널은 단일 소유권과 유사합니다. 채널로 값을 전송하면 해당 값을 더 이상 사용해서는 안 되기 때문입니다. 공유 메모리 동시성은 다중 소유권과 같습니다: 여러 스레드가 동시에 같은 메모리 위치에 액세스할 수 있습니다. 15장에서 보았듯이 스마트 포인터가 다중 소유권을 가능하게 했으므로 다중 소유권은 복잡성을 추가할 수 있습니다. 이러한 다른 소유자가 관리되어야 하기 때문입니다. Rust의 타입 시스템과 소유권 규칙은 이 관리를 올바르게 하는 데 큰 도움이 됩니다. 예를 들어 공유 메모리에 대한 가장 일반적인 동시성 기본 요소 중 하나인 뮤텍스를 살펴보겠습니다.

## 뮤텍스를 사용하여 한 번에 하나의 스레드에서 데이터에 액세스 허용하기

*뮤텍스*는 *상호 배제(mutual exclusion)*의 약자로, 뮤텍스는 주어진 시간에 하나의 스레드만 일부 데이터에 액세스할 수 있도록 합니다. 뮤텍스의 데이터에 액세스하려면 스레드는 먼저 뮤텍스의 *잠금*을 획득하기를 요청하여 액세스를 원한다는 신호를 보내야 합니다. 잠금은 현재 누가 데이터에 대한 배타적 액세스 권한을 가지고 있는지 추적하는 뮤텍스의 일부인 데이터 구조입니다. 따라서 뮤텍스는 잠금 시스템을 통해 보유한 데이터를 *보호*하는 것으로 설명됩니다.

뮤텍스는 사용하기 어려운 것으로 유명합니다. 두 가지 규칙을 기억해야 하기 때문입니다:

* 데이터를 사용하기 전에 잠금을 획득해야 합니다.
* 뮤텍스가 보호하는 데이터 사용이 완료되면 다른 스레드가 잠금을 획득할 수 있도록 데이터 잠금을 해제해야 합니다.

뮤텍스의 실제 비유로 마이크가 하나뿐인 회의 패널 토론을 상상해 보세요. 패널리스트가 발언하기 전에 마이크 사용을 원한다고 요청하거나 신호를 보내야 합니다. 마이크를 받으면 원하는 만큼 이야기한 다음 발언을 원하는 다음 패널리스트에게 마이크를 넘깁니다. 패널리스트가 마이크 사용이 끝났을 때 마이크를 넘기는 것을 잊으면 아무도 발언할 수 없습니다. 공유 마이크 관리가 잘못되면 패널이 계획대로 작동하지 않습니다!

뮤텍스 관리는 올바르게 하기가 매우 까다로울 수 있으며 이것이 많은 사람들이 채널에 열광하는 이유입니다. 그러나 Rust의 타입 시스템과 소유권 규칙 덕분에 잠금과 잠금 해제를 잘못하는 것이 불가능합니다.

## `Mutex<T>`의 API

뮤텍스 사용 방법의 예로 Listing 16-12에 표시된 것처럼 단일 스레드 컨텍스트에서 뮤텍스를 사용하여 시작해 보겠습니다:

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}
```

*Listing 16-12: 단일 스레드 컨텍스트에서 단순성을 위해 `Mutex<T>`의 API 탐색*

많은 타입과 마찬가지로 연관 함수 `new`를 사용하여 `Mutex<T>`를 만듭니다. 뮤텍스 내부의 데이터에 액세스하려면 `lock` 메서드를 사용하여 잠금을 획득합니다. 이 호출은 현재 스레드를 차단하여 잠금을 얻을 차례가 될 때까지 아무 작업도 수행할 수 없습니다.

잠금을 보유한 다른 스레드가 패닉하면 `lock` 호출이 실패합니다. 이 경우 아무도 잠금을 얻을 수 없으므로 `unwrap`을 선택했고 그 상황이 발생하면 이 스레드가 패닉하도록 합니다.

잠금을 획득한 후 이 경우 `num`이라는 반환 값을 내부의 데이터에 대한 가변 참조로 취급할 수 있습니다. 타입 시스템은 `m`의 값을 사용하기 전에 잠금을 획득하도록 합니다. `Mutex<i32>`는 `i32`가 아니므로 `i32` 값을 사용하려면 *반드시* 잠금을 획득해야 합니다. 잊을 수 없습니다; 그렇지 않으면 타입 시스템이 내부 `i32`에 액세스하도록 허용하지 않습니다.

짐작할 수 있듯이 `Mutex<T>`는 스마트 포인터입니다. 더 정확하게는 `lock` 호출은 `LockResult`로 래핑된 `MutexGuard`라는 스마트 포인터를 *반환*하며, 이것이 `unwrap` 호출로 처리했습니다. `MutexGuard` 스마트 포인터는 내부 데이터를 가리키도록 `Deref`를 구현합니다; 스마트 포인터는 또한 `MutexGuard`가 범위를 벗어날 때 잠금을 자동으로 해제하는 `Drop` 구현이 있으며, 이것은 내부 범위 끝에서 발생합니다. 결과적으로 잠금을 해제하는 것을 잊을 위험이 없습니다. 잠금 해제는 자동으로 발생하기 때문에 잠금으로 인해 다른 스레드가 뮤텍스를 사용하는 것을 차단합니다.

잠금을 드롭한 후 뮤텍스 값을 출력하고 내부 `i32`를 6으로 변경할 수 있었음을 확인할 수 있습니다.

## 여러 스레드 간에 `Mutex<T>` 공유하기

이제 `Mutex<T>`를 사용하여 여러 스레드 간에 값을 공유해 보겠습니다. 10개의 스레드를 생성하고 각각 카운터 값을 1씩 증가시켜 카운터가 0에서 10으로 증가하도록 합니다. Listing 16-13의 다음 예제는 컴파일러 오류가 발생하며 해당 오류를 사용하여 `Mutex<T>` 사용 방법과 Rust가 올바르게 사용하도록 돕는 방법에 대해 자세히 알아보겠습니다.

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}
```

*Listing 16-13: `Mutex<T>`로 보호되는 카운터를 10개 스레드 각각이 증가시키기*

Listing 16-12에서처럼 `Mutex<T>` 내부에 `i32`를 보유하는 `counter` 변수를 만듭니다. 다음으로 숫자 범위를 반복하여 10개의 스레드를 만듭니다. `thread::spawn`을 사용하고 모든 스레드에 동일한 클로저를 제공합니다: 카운터를 스레드로 이동하고 `lock` 메서드를 호출하여 `Mutex<T>`에 대한 잠금을 획득한 다음 뮤텍스의 값에 1을 더합니다. 스레드가 클로저 실행을 마치면 `num`이 범위를 벗어나고 잠금을 해제하여 다른 스레드가 획득할 수 있습니다.

메인 스레드에서 모든 조인 핸들을 수집합니다. 그런 다음 Listing 16-2에서처럼 각 핸들에서 `join`을 호출하여 모든 스레드가 완료되도록 합니다. 그 시점에서 메인 스레드가 잠금을 획득하고 이 프로그램의 결과를 출력합니다.

이 예제가 컴파일되지 않을 것이라고 암시했습니다. 이제 그 이유를 알아봅시다!

```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --> src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("결과: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
```

오류 메시지는 `counter` 값이 루프의 이전 반복에서 이동되었음을 나타냅니다. Rust는 `counter`의 소유권을 여러 스레드로 이동할 수 없다고 말하고 있습니다.

## 여러 스레드와 다중 소유권

15장에서 스마트 포인터 `Rc<T>`를 사용하여 참조 카운팅 값을 만들어 값에 여러 소유자를 부여했습니다. 여기서 같은 작업을 수행하고 결과를 확인해 봅시다. Listing 16-14에서 `Mutex<T>`를 `Rc<T>`로 래핑하고 소유권을 스레드로 이동하기 전에 `Rc<T>`를 복제합니다.

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}
```

*Listing 16-14: `Rc<T>`를 사용하여 여러 스레드가 `Mutex<T>`를 소유하도록 시도*

다시 한번 컴파일하면... 다른 오류가 발생합니다! 컴파일러가 많이 가르쳐 주고 있습니다.

```console
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
   --> src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely
```

와, 오류 메시지가 정말 장황합니다! 여기 집중할 중요한 부분이 있습니다: ``Rc<Mutex<i32>>` cannot be sent between threads safely``. 컴파일러는 그 이유도 알려줍니다: ``the trait `Send` is not implemented for `Rc<Mutex<i32>>```. 다음 섹션에서 `Send`에 대해 이야기할 것입니다: 스레드에서 사용하는 타입이 동시 상황에서 사용하도록 의도되었는지 확인하는 트레이트 중 하나입니다.

불행히도 `Rc<T>`는 스레드 간에 공유하기에 안전하지 않습니다. `Rc<T>`가 참조 카운트를 관리할 때 각 `clone` 호출에 대해 카운트에 추가하고 각 복제가 드롭될 때 카운트에서 빼기합니다. 그러나 동시성 기본 요소를 사용하여 카운트 변경이 다른 스레드에 의해 중단되지 않도록 하지 않습니다. 이로 인해 잘못된 카운트가 발생할 수 있습니다—메모리 누수 또는 사용하기 전에 드롭되는 값으로 이어질 수 있는 미묘한 버그입니다. 필요한 것은 `Rc<T>`와 정확히 같지만 스레드 안전 방식으로 참조 카운트를 변경하는 타입입니다.

## `Arc<T>`로 원자적 참조 카운팅

다행히도 `Arc<T>`는 동시 상황에서 안전하게 사용할 수 있는 `Rc<T>` *같은* 타입입니다. *a*는 *원자적(atomic)*을 의미하며 *원자적으로 참조 카운팅*되는 타입입니다. 원자성은 여기서 자세히 다루지 않을 추가적인 종류의 동시성 기본 요소입니다: 자세한 내용은 [`std::sync::atomic`][atomic]의 표준 라이브러리 문서를 참조하세요. 이 시점에서는 원자성이 기본 타입처럼 작동하지만 스레드 간에 공유하기에 안전하다는 것만 알면 됩니다.

그러면 왜 모든 기본 타입이 원자적이지 않고 왜 표준 라이브러리 타입이 기본적으로 `Arc<T>`를 사용하도록 구현되지 않았는지 궁금할 수 있습니다. 그 이유는 스레드 안전성에는 실제로 필요하지 않을 때 지불하고 싶지 않은 성능 페널티가 따르기 때문입니다. 단일 스레드 내에서만 값에 대한 작업을 수행하는 경우 원자성이 제공하는 보장을 적용하지 않아도 되므로 코드가 더 빠르게 실행될 수 있습니다.

예제로 돌아가 봅시다: `Arc<T>`와 `Rc<T>`는 같은 API를 가지므로 `use` 줄, `new` 호출, `clone` 호출을 변경하여 프로그램을 수정합니다. Listing 16-15의 코드는 마침내 컴파일되고 실행됩니다:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}
```

*Listing 16-15: `Arc<T>`를 사용하여 `Mutex<T>`를 래핑하여 여러 스레드 간에 소유권 공유*

이 코드는 다음을 출력합니다:

```text
결과: 10
```

해냈습니다! 0에서 10까지 카운트했는데 매우 인상적이지 않을 수 있지만 `Mutex<T>`와 스레드 안전성에 대해 많이 가르쳐 주었습니다. 이 프로그램의 구조를 사용하여 카운터를 증가시키는 것보다 더 복잡한 작업을 수행할 수도 있습니다. 이 전략을 사용하면 계산을 독립적인 부분으로 나누고 해당 부분을 스레드에 걸쳐 분할한 다음 `Mutex<T>`를 사용하여 각 스레드가 최종 결과를 자체 부분으로 업데이트하도록 할 수 있습니다.

단순한 숫자 연산을 수행하는 경우 [`std::sync::atomic` 모듈][atomic]에서 제공하는 `Mutex<T>` 타입보다 더 간단한 타입이 있습니다. 이러한 타입은 기본 타입에 대한 안전하고 동시적이며 원자적인 액세스를 제공합니다. 이 예제에서는 기본 타입에 `Mutex<T>`를 사용하기로 선택했기 때문에 `Mutex<T>`가 작동하는 방식에 집중할 수 있습니다.

## `RefCell<T>`/`Rc<T>`와 `Mutex<T>`/`Arc<T>` 사이의 유사점

`counter`가 불변이지만 그 안의 값에 대한 가변 참조를 얻을 수 있었다는 것을 눈치챘을 수 있습니다; 이것은 `Mutex<T>`가 `Cell` 패밀리처럼 내부 가변성을 제공한다는 것을 의미합니다. 15장에서 `RefCell<T>`를 사용하여 `Rc<T>` 내부의 내용을 변형할 수 있도록 했던 것과 같은 방식으로 `Mutex<T>`를 사용하여 `Arc<T>` 내부의 내용을 변형합니다.

주목할 또 다른 세부 사항은 Rust가 `Mutex<T>` 사용 시 모든 종류의 논리 오류로부터 보호할 수 없다는 것입니다. 15장에서 `Rc<T>` 사용이 참조 순환을 만들 위험이 있으며 두 `Rc<T>` 값이 서로를 참조하여 메모리 누수를 유발한다는 것을 기억하세요. 마찬가지로 `Mutex<T>`는 *교착 상태*를 만들 위험이 있습니다. 이것은 작업이 두 리소스를 잠그고 두 스레드가 각각 하나의 잠금을 획득하여 영원히 서로를 기다리게 할 때 발생합니다. 교착 상태에 관심이 있으시면 교착 상태가 있는 Rust 프로그램을 만들어 보세요; 그런 다음 모든 언어의 뮤텍스에 대한 교착 상태 완화 전략을 연구하고 Rust에서 구현해 보세요. `Mutex<T>` 및 `MutexGuard`에 대한 표준 라이브러리 API 문서는 유용한 정보를 제공합니다.

`Send`와 `Sync` 트레이트, 그리고 사용자 정의 타입과 함께 사용하는 방법에 대해 이야기하면서 이 장을 마무리하겠습니다.

[atomic]: https://doc.rust-lang.org/std/sync/atomic/index.html
