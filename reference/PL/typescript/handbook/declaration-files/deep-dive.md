# 심층 분석

## 선언 파일 이론: 심층 분석

원하는 정확한 API 형태를 제공하도록 모듈을 구조화하는 것은 까다로울 수 있습니다. 예를 들어, `new`를 사용하거나 사용하지 않고 호출하여 다른 타입을 생성할 수 있는 모듈을 원할 수 있고, 계층 구조로 노출되는 다양한 명명된 타입이 있으며, 모듈 객체에 일부 프로퍼티도 있을 수 있습니다.

이 가이드를 읽으면 친숙한 API 표면을 노출하는 복잡한 선언 파일을 작성할 수 있는 도구를 갖추게 됩니다. 이 가이드는 옵션이 더 다양한 모듈(또는 UMD) 라이브러리에 초점을 맞춥니다.

## 핵심 개념

TypeScript가 어떻게 작동하는지에 대한 몇 가지 핵심 개념을 이해하면 어떤 형태의 선언도 만드는 방법을 완전히 이해할 수 있습니다.

### 타입

이 가이드를 읽고 있다면, TypeScript에서 타입이 무엇인지 대략적으로 이미 알고 있을 것입니다. 하지만 더 명시적으로 말하면, _타입_은 다음으로 도입됩니다:

- 타입 별칭 선언 (`type sn = number | string;`)
- 인터페이스 선언 (`interface I { x: number[]; }`)
- 클래스 선언 (`class C { }`)
- 열거형 선언 (`enum E { A, B, C }`)
- 타입을 참조하는 `import` 선언

이러한 선언 형식 각각은 새로운 타입 이름을 만듭니다.

### 값

타입과 마찬가지로, 값이 무엇인지 이미 이해하고 있을 것입니다. 값은 표현식에서 참조할 수 있는 런타임 이름입니다. 예를 들어 `let x = 5;`는 `x`라는 값을 만듭니다.

다시, 명시적으로 말하면, 다음은 값을 만듭니다:

- `let`, `const`, `var` 선언
- 값을 포함하는 `namespace` 또는 `module` 선언
- `enum` 선언
- `class` 선언
- 값을 참조하는 `import` 선언
- `function` 선언

### 네임스페이스

타입은 _네임스페이스_에 존재할 수 있습니다. 예를 들어, `let x: A.B.C` 선언이 있다면, 타입 `C`가 `A.B` 네임스페이스에서 온다고 말합니다.

이 구별은 미묘하지만 중요합니다 -- 여기서 `A.B`가 반드시 타입이나 값은 아닙니다.

## 간단한 조합: 하나의 이름, 여러 의미

이름 `A`가 주어지면, `A`에 대해 타입, 값, 또는 네임스페이스라는 최대 세 가지 다른 의미를 찾을 수 있습니다. 이름이 해석되는 방식은 사용되는 컨텍스트에 따라 다릅니다. 예를 들어, `let m: A.A = A;` 선언에서 `A`는 먼저 네임스페이스로, 그 다음 타입 이름으로, 그 다음 값으로 사용됩니다. 이러한 의미는 완전히 다른 선언을 참조할 수 있습니다!

이것은 혼란스러워 보일 수 있지만, 과도하게 오버로드하지 않는 한 실제로 매우 편리합니다. 이 조합 동작의 유용한 측면을 살펴보겠습니다.

### 내장 조합

예민한 독자는 예를 들어 `class`가 _타입_과 _값_ 목록 모두에 나타났다는 것을 알아차렸을 것입니다. `class C { }` 선언은 두 가지를 만듭니다: 클래스의 인스턴스 형태를 참조하는 _타입_ `C`와 클래스의 생성자 함수를 참조하는 _값_ `C`입니다. 열거형 선언도 비슷하게 동작합니다.

### 사용자 조합

모듈 파일 `foo.d.ts`를 작성했다고 가정해봅시다:

```ts
export var SomeVar: { a: SomeType };
export interface SomeType {
  count: number;
}
```

그런 다음 이를 사용합니다:

```ts
import * as foo from "./foo";
let x: foo.SomeType = foo.SomeVar.a;
console.log(x.count);
```

이것은 충분히 잘 작동하지만, `SomeType`과 `SomeVar`가 매우 밀접하게 관련되어 있어서 같은 이름을 갖고 싶을 수 있습니다. 조합을 사용하여 이 두 개의 다른 객체(값과 타입)를 같은 이름 `Bar`로 표현할 수 있습니다:

```ts
export var Bar: { a: Bar };
export interface Bar {
  count: number;
}
```

이것은 소비 코드에서 구조 분해를 위한 매우 좋은 기회를 제공합니다:

```ts
import { Bar } from "./foo";
let x: Bar = Bar.a;
console.log(x.count);
```

다시, 여기서 `Bar`를 타입과 값 모두로 사용했습니다. `Bar` 값을 `Bar` 타입으로 선언할 필요가 없었다는 점에 유의하세요 -- 이들은 독립적입니다.

## 고급 조합

일부 종류의 선언은 여러 선언에 걸쳐 조합될 수 있습니다. 예를 들어, `class C { }`와 `interface C { }`가 공존할 수 있으며 둘 다 `C` 타입에 프로퍼티를 기여합니다.

이것은 충돌을 만들지 않는 한 합법적입니다. 일반적인 경험 법칙은 값이 `namespace`로 선언되지 않는 한 같은 이름의 다른 값과 항상 충돌하고, 타입 별칭 선언(`type s = string`)으로 선언된 경우 타입이 충돌하며, 네임스페이스는 절대 충돌하지 않는다는 것입니다.

어떻게 사용할 수 있는지 살펴보겠습니다.

### `interface`를 사용한 추가

다른 `interface` 선언으로 `interface`에 추가 멤버를 추가할 수 있습니다:

```ts
interface Foo {
  x: number;
}
// ... 다른 곳에서 ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

이것은 클래스에서도 작동합니다:

```ts
class Foo {
  x: number;
}
// ... 다른 곳에서 ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

인터페이스를 사용하여 타입 별칭(`type s = string;`)에 추가할 수는 없습니다.

### `namespace`를 사용한 추가

`namespace` 선언은 충돌을 만들지 않는 방식으로 새 타입, 값, 네임스페이스를 추가하는 데 사용할 수 있습니다.

예를 들어, 클래스에 정적 멤버를 추가할 수 있습니다:

```ts
class C {}
// ... 다른 곳에서 ...
namespace C {
  export let x: number;
}
let y = C.x; // OK
```

이 예제에서 `C`의 _정적_ 측면(생성자 함수)에 값을 추가했습니다. 값을 추가했고, 모든 값의 컨테이너는 또 다른 값이기 때문입니다(타입은 네임스페이스에 포함되고, 네임스페이스는 다른 네임스페이스에 포함됨).

클래스에 네임스페이스화된 타입을 추가할 수도 있습니다:

```ts
class C {}
// ... 다른 곳에서 ...
namespace C {
  export interface D {}
}
let y: C.D; // OK
```

이 예제에서는 `namespace` 선언을 작성할 때까지 네임스페이스 `C`가 없었습니다. 네임스페이스로서의 `C` 의미는 클래스에 의해 생성된 `C`의 값 또는 타입 의미와 충돌하지 않습니다.

마지막으로, `namespace` 선언을 사용하여 많은 다른 병합을 수행할 수 있습니다. 이것은 특별히 현실적인 예제는 아니지만, 모든 종류의 흥미로운 동작을 보여줍니다:

```ts
namespace X {
  export interface Y {}
  export class Z {}
}

// ... 다른 곳에서 ...
namespace X {
  export var Y: number;
  export namespace Z {
    export class C {}
  }
}
type X = string;
```

이 예제에서 첫 번째 블록은 다음 이름 의미를 만듭니다:

- 값 `X` (`namespace` 선언이 값 `Z`를 포함하므로)
- 네임스페이스 `X` (`namespace` 선언이 타입 `Y`를 포함하므로)
- `X` 네임스페이스 내의 타입 `Y`
- `X` 네임스페이스 내의 타입 `Z` (클래스의 인스턴스 형태)
- `X` 값의 프로퍼티인 값 `Z` (클래스의 생성자 함수)

두 번째 블록은 다음 이름 의미를 만듭니다:

- `X` 값의 프로퍼티인 값 `Y` (`number` 타입)
- 네임스페이스 `Z`
- `X` 값의 프로퍼티인 값 `Z`
- `X.Z` 네임스페이스 내의 타입 `C`
- `X.Z` 값의 프로퍼티인 값 `C`
- 타입 `X`
