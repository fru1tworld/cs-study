# 처음 프로그래밍을 배우는 사람을 위한 TypeScript

TypeScript를 첫 번째 언어 중 하나로 선택하신 것을 축하드립니다. 이미 좋은 결정을 내리고 계시네요!

TypeScript가 JavaScript의 "변형" 또는 "파생형"이라는 말을 이미 들어보셨을 것입니다.
TypeScript(TS)와 JavaScript(JS) 사이의 관계는 현대 프로그래밍 언어들 사이에서 매우 독특하므로, 이 관계에 대해 더 알아보면 TypeScript가 JavaScript에 어떤 것을 추가하는지 이해하는 데 도움이 될 것입니다.

## JavaScript란 무엇인가? 간략한 역사

JavaScript(ECMAScript라고도 알려진)는 브라우저를 위한 간단한 스크립팅 언어로 시작했습니다.
발명될 당시에는 웹 페이지에 포함된 짧은 코드 조각에 사용될 것으로 예상되었으며, 수십 줄 이상의 코드를 작성하는 것은 다소 드문 일이었을 것입니다.
이 때문에 초기 웹 브라우저들은 이러한 코드를 상당히 느리게 실행했습니다.
그러나 시간이 지남에 따라 JS는 점점 더 인기를 얻게 되었고, 웹 개발자들은 이를 사용하여 인터랙티브한 경험을 만들기 시작했습니다.

웹 브라우저 개발자들은 이렇게 증가하는 JS 사용에 대응하여 실행 엔진을 최적화하고(동적 컴파일) JS로 할 수 있는 것을 확장(API 추가)했으며, 이는 다시 웹 개발자들이 JS를 더 많이 사용하게 만들었습니다.
현대의 웹사이트에서 브라우저는 수십만 줄에 달하는 코드로 이루어진 애플리케이션을 자주 실행합니다.
이것이 "웹"의 길고 점진적인 성장입니다. 단순한 정적 페이지들의 네트워크로 시작하여 모든 종류의 풍부한 *애플리케이션*을 위한 플랫폼으로 진화한 것입니다.

그 이상으로, JS는 브라우저의 맥락 바깥에서도 사용될 만큼 충분히 인기를 얻었습니다. 예를 들어 node.js를 사용하여 JS 서버를 구현하는 것처럼요.
JS의 "어디서나 실행 가능한" 특성은 크로스 플랫폼 개발에 매력적인 선택이 되게 합니다.
요즘에는 *오직* JavaScript만을 사용하여 전체 스택을 프로그래밍하는 개발자들이 많습니다!

요약하자면, 우리에게는 빠른 사용을 위해 설계되었다가 수백만 줄의 애플리케이션을 작성하는 완전한 도구로 성장한 언어가 있습니다.
모든 언어에는 고유한 *특이점*이 있습니다. 이상하고 놀라운 점들 말이죠. JavaScript의 소박한 시작은 이런 것들이 *많게* 만들었습니다. 몇 가지 예를 들면:

- JavaScript의 동등 연산자(`==`)는 피연산자를 *강제 변환*하여 예상치 못한 동작을 유발합니다:

```ts
if ("" == 0) {
  // 참입니다! 하지만 왜??
}
if (1 < x < 3) {
  // *어떤* x 값에 대해서도 참입니다!
}
```

- JavaScript는 존재하지 않는 속성에 접근하는 것도 허용합니다:

```ts
const obj = { width: 10, height: 15 };
// 왜 이것이 NaN일까요? 철자를 쓰기가 어렵네요!
const area = obj.width * obj.heigth;
```

대부분의 프로그래밍 언어는 이런 종류의 오류가 발생할 때 에러를 발생시킵니다. 일부는 컴파일 중에, 즉 코드가 실행되기 전에 그렇게 합니다.
작은 프로그램을 작성할 때 이런 특이점들은 귀찮지만 관리할 수 있습니다. 하지만 수백 또는 수천 줄의 코드로 애플리케이션을 작성할 때 이런 끊임없는 놀라움은 심각한 문제가 됩니다.

## TypeScript: 정적 타입 검사기

앞서 일부 언어는 그런 버그가 있는 프로그램을 아예 실행하지 않을 것이라고 말했습니다.
코드를 실행하지 않고 오류를 감지하는 것을 *정적 검사*라고 합니다.
연산되는 값의 종류를 기반으로 무엇이 오류이고 무엇이 아닌지 결정하는 것을 정적 *타입* 검사라고 합니다.

TypeScript는 실행 전에 프로그램의 오류를 검사하고, *값의 종류*를 기반으로 검사하므로, *정적 타입 검사기*입니다.
예를 들어, 위의 마지막 예제는 `obj`의 *타입* 때문에 오류가 있습니다.
TypeScript가 발견한 오류는 다음과 같습니다:

```ts
const obj = { width: 10, height: 15 };
const area = obj.width * obj.heigth;
// Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?
// '{ width: number; height: number; }' 타입에 'heigth' 속성이 존재하지 않습니다. 'height'를 의미했나요?
```

### JavaScript의 타입이 있는 상위 집합

그렇다면 TypeScript는 JavaScript와 어떤 관계가 있을까요?

#### 문법

TypeScript는 JavaScript의 *상위 집합*인 언어입니다. 따라서 JS 문법은 유효한 TS입니다.
문법은 프로그램을 형성하기 위해 텍스트를 작성하는 방식을 말합니다.
예를 들어, 이 코드는 `)`가 빠져 있기 때문에 *문법* 오류가 있습니다:

```ts
let a = (4
// ')' expected.
// ')'가 필요합니다.
```

TypeScript는 문법 때문에 어떤 JavaScript 코드도 오류로 간주하지 않습니다.
이는 작동하는 JavaScript 코드를 가져와서 정확히 어떻게 작성되었는지 걱정하지 않고 TypeScript 파일에 넣을 수 있다는 것을 의미합니다.

#### 타입

그러나 TypeScript는 *타입이 있는* 상위 집합입니다. 이는 다양한 종류의 값이 어떻게 사용될 수 있는지에 대한 규칙을 추가한다는 의미입니다.
앞서 `obj.heigth`에 대한 오류는 *문법* 오류가 아니었습니다. 이것은 어떤 종류의 값(*타입*)을 잘못된 방식으로 사용하는 오류입니다.

또 다른 예로, 이것은 브라우저에서 실행할 수 있는 JavaScript 코드이며, 값을 로그로 *출력할 것입니다*:

```ts
console.log(4 / []);
```

이 문법적으로 유효한 프로그램은 `Infinity`를 로그로 출력합니다.
하지만 TypeScript는 숫자를 배열로 나누는 것을 무의미한 연산으로 간주하고 오류를 발생시킵니다:

```ts
console.log(4 / []);
// The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
// 산술 연산의 오른쪽은 'any', 'number', 'bigint' 또는 열거형 타입이어야 합니다.
```

숫자를 배열로 나누려는 의도가 정말로 있었을 수도 있습니다. 아마도 무슨 일이 일어나는지 보기 위해서요. 하지만 대부분의 경우 이것은 프로그래밍 실수입니다.
TypeScript의 타입 검사기는 올바른 프로그램은 통과시키면서도 가능한 한 많은 일반적인 오류를 잡도록 설계되었습니다.
(나중에 TypeScript가 코드를 얼마나 엄격하게 검사하는지 구성하는 데 사용할 수 있는 설정에 대해 배울 것입니다.)

JavaScript 파일에서 TypeScript 파일로 일부 코드를 옮기면, 코드가 어떻게 작성되었는지에 따라 *타입 오류*를 볼 수 있습니다.
이것들은 코드의 정당한 문제일 수도 있고, TypeScript가 지나치게 보수적인 것일 수도 있습니다.
이 가이드 전체에서 우리는 그러한 오류를 제거하기 위해 다양한 TypeScript 문법을 추가하는 방법을 보여드릴 것입니다.

#### 런타임 동작

TypeScript는 또한 JavaScript의 *런타임 동작*을 보존하는 프로그래밍 언어입니다.
예를 들어, JavaScript에서 0으로 나누면 런타임 예외를 발생시키는 대신 `Infinity`를 생성합니다.
원칙적으로 TypeScript는 **절대로** JavaScript 코드의 런타임 동작을 변경하지 않습니다.

이것은 JavaScript에서 TypeScript로 코드를 옮기면, TypeScript가 코드에 타입 오류가 있다고 생각하더라도 동일한 방식으로 실행되는 것이 **보장된다**는 것을 의미합니다.

JavaScript와 동일한 런타임 동작을 유지하는 것은 TypeScript의 기본적인 약속입니다. 이것은 프로그램이 작동을 멈추게 할 수 있는 미묘한 차이점에 대해 걱정하지 않고 두 언어 사이를 쉽게 전환할 수 있다는 것을 의미하기 때문입니다.

#### 지워지는 타입

대략적으로 말해서, TypeScript의 컴파일러가 코드 검사를 완료하면, 결과적인 "컴파일된" 코드를 생성하기 위해 타입을 *지웁니다*.
이것은 코드가 컴파일되면 결과적인 일반 JS 코드에는 타입 정보가 없다는 것을 의미합니다.

이것은 또한 TypeScript가 추론한 타입을 기반으로 프로그램의 *동작*을 절대 변경하지 않는다는 것을 의미합니다.
결론은 컴파일 중에 타입 오류를 볼 수 있지만, 타입 시스템 자체는 프로그램이 실행될 때 작동하는 방식에 영향을 미치지 않는다는 것입니다.

마지막으로, TypeScript는 추가적인 런타임 라이브러리를 제공하지 않습니다.
프로그램은 JavaScript 프로그램과 동일한 표준 라이브러리(또는 외부 라이브러리)를 사용하므로, 배울 추가적인 TypeScript 전용 프레임워크가 없습니다.

## JavaScript와 TypeScript 배우기

우리는 "JavaScript를 배워야 할까요, TypeScript를 배워야 할까요?"라는 질문을 자주 봅니다.

대답은 JavaScript를 배우지 않고는 TypeScript를 배울 수 없다는 것입니다!
TypeScript는 JavaScript와 문법과 런타임 동작을 공유하므로, JavaScript에 대해 배우는 모든 것은 동시에 TypeScript를 배우는 데 도움이 됩니다.

프로그래머들이 JavaScript를 배울 수 있는 많은 리소스가 있습니다. TypeScript를 작성한다면 이러한 리소스를 무시하지 *마세요*.
예를 들어, `typescript`보다 약 20배 더 많은 `javascript` 태그가 달린 StackOverflow 질문이 있지만, *모든* `javascript` 질문은 TypeScript에도 적용됩니다.

"TypeScript에서 리스트를 정렬하는 방법"과 같은 것을 검색하고 있다면, 기억하세요: **TypeScript는 컴파일 타임 타입 검사기가 있는 JavaScript의 런타임입니다**.
TypeScript에서 리스트를 정렬하는 방법은 JavaScript에서 하는 방법과 같습니다.
TypeScript를 직접 사용하는 리소스를 찾으면 그것도 좋지만, 런타임 작업을 수행하는 방법에 대한 일상적인 질문에 TypeScript 전용 답변이 필요하다고 생각하여 자신을 제한하지 마세요.

## 다음 단계

이것은 일상적인 TypeScript에서 사용되는 문법과 도구에 대한 간략한 개요였습니다. 여기서부터 다음을 할 수 있습니다:

- JavaScript 기본 사항을 배우세요. 다음을 권장합니다:
  - [Microsoft의 JavaScript 리소스](https://developer.microsoft.com/javascript/) 또는
  - [Mozilla Web Docs의 JavaScript 가이드](https://developer.mozilla.org/docs/Web/JavaScript/Guide)

- [JavaScript 프로그래머를 위한 TypeScript](/docs/handbook/typescript-in-5-minutes.html)로 계속하세요

- 전체 핸드북을 [처음부터 끝까지](/docs/handbook/intro.html) 읽으세요

- [플레이그라운드 예제](/play#show-examples)를 탐색하세요
