# Java/C# 프로그래머를 위한 TypeScript

TypeScript는 C#이나 Java 같은 정적 타이핑을 가진 다른 언어에 익숙한 프로그래머들에게 인기 있는 선택입니다.

TypeScript의 타입 시스템은 더 나은 코드 완성, 더 빠른 오류 감지, 프로그램 부분들 간의 더 명확한 통신 같은 많은 동일한 이점을 제공합니다.
이러한 개발자들에게 TypeScript가 많은 익숙한 기능을 제공하지만, JavaScript(그리고 따라서 TypeScript)가 전통적인 OOP 언어와 어떻게 다른지 살펴볼 가치가 있습니다.
이러한 차이점을 이해하면 더 나은 JavaScript 코드를 작성하는 데 도움이 되고, C#/Java에서 바로 TypeScript로 넘어온 프로그래머들이 빠지기 쉬운 일반적인 함정을 피할 수 있습니다.

## JavaScript 함께 배우기

이미 JavaScript에 익숙하지만 주로 Java나 C# 프로그래머라면, 이 소개 페이지가 여러분이 빠지기 쉬운 일반적인 오해와 함정을 설명하는 데 도움이 될 수 있습니다.
TypeScript가 타입을 모델링하는 방식 중 일부는 Java나 C#과 상당히 다르며, TypeScript를 배울 때 이것을 염두에 두는 것이 중요합니다.

Java나 C# 프로그래머이면서 일반적으로 JavaScript를 처음 접한다면, JavaScript의 런타임 동작을 이해하기 위해 먼저 타입 *없이* 약간의 JavaScript를 배우는 것을 권장합니다.
TypeScript는 코드가 *실행되는* 방식을 변경하지 않으므로, 실제로 무언가를 하는 코드를 작성하려면 여전히 JavaScript가 어떻게 작동하는지 배워야 합니다!

TypeScript가 JavaScript와 동일한 *런타임*을 사용한다는 것을 기억하는 것이 중요합니다. 따라서 특정 런타임 동작(문자열을 숫자로 변환, 알림 표시, 디스크에 파일 쓰기 등)을 수행하는 방법에 대한 모든 리소스는 TypeScript 프로그램에도 동일하게 적용됩니다.
TypeScript 전용 리소스로 자신을 제한하지 마세요!

## 클래스 다시 생각하기

C#과 Java는 우리가 *필수 OOP* 언어라고 부를 수 있는 것입니다.
이러한 언어에서 *클래스*는 코드 구성의 기본 단위이자 런타임에 모든 데이터 *와* 동작의 기본 컨테이너입니다.
모든 기능과 데이터를 클래스에 강제로 담는 것은 일부 문제에 대해 좋은 도메인 모델이 될 수 있지만, 모든 도메인이 이 방식으로 표현될 *필요*는 없습니다.

### 자유 함수와 데이터

JavaScript에서 함수는 어디에나 존재할 수 있고, 데이터는 미리 정의된 `class`나 `struct` 안에 있지 않고도 자유롭게 전달될 수 있습니다.
이러한 유연성은 매우 강력합니다.
암시적인 OOP 계층 구조 없이 데이터를 다루는 "자유" 함수(클래스와 연관되지 않은 함수)는 JavaScript에서 프로그램을 작성하는 선호되는 모델인 경향이 있습니다.

### 정적 클래스

또한, C#과 Java의 싱글톤이나 정적 클래스 같은 특정 구조는 TypeScript에서 불필요합니다.

## TypeScript에서의 OOP

그렇다고 해서, 원한다면 여전히 클래스를 사용할 수 있습니다!
일부 문제는 전통적인 OOP 계층 구조로 해결하기에 적합하며, TypeScript의 JavaScript 클래스 지원은 이러한 모델을 더욱 강력하게 만들어줍니다.
TypeScript는 인터페이스 구현, 상속, 정적 메서드 같은 많은 일반적인 패턴을 지원합니다.

클래스에 대해서는 이 가이드의 뒷부분에서 다룰 것입니다.

## 타입 다시 생각하기

TypeScript의 *타입* 이해는 실제로 C#이나 Java의 것과 상당히 다릅니다.
몇 가지 차이점을 살펴보겠습니다.

### 명목적 구체화 타입 시스템

C#이나 Java에서 주어진 값이나 객체는 하나의 정확한 타입을 가집니다 - `null`, 원시 타입, 또는 알려진 클래스 타입 중 하나입니다.
런타임에 정확한 타입을 조회하기 위해 `value.GetType()` 또는 `value.getClass()` 같은 메서드를 호출할 수 있습니다.
이 타입의 정의는 어딘가의 클래스에 어떤 이름으로 존재할 것이며, 명시적인 상속 관계나 공통으로 구현된 인터페이스가 없으면 유사한 모양의 두 클래스를 서로 대신 사용할 수 없습니다.

이러한 측면은 *구체화된, 명목적* 타입 시스템을 설명합니다.
코드에 작성한 타입이 런타임에 존재하며, 타입은 구조가 아니라 선언을 통해 관련됩니다.

### 집합으로서의 타입

C#이나 Java에서는 런타임 타입과 컴파일 타임 선언 사이의 일대일 대응을 생각하는 것이 의미 있습니다.

TypeScript에서는 타입을 공통점을 공유하는 *값들의 집합*으로 생각하는 것이 좋습니다.
타입은 단지 집합이기 때문에, 특정 값은 동시에 *많은* 집합에 속할 수 있습니다.

타입을 집합으로 생각하기 시작하면 특정 연산이 매우 자연스러워집니다.
예를 들어, C#에서는 `string` *또는* `int`인 값을 전달하는 것이 어색합니다. 이런 종류의 값을 나타내는 단일 타입이 없기 때문입니다.

TypeScript에서는 모든 타입이 단지 집합이라는 것을 깨닫는 순간 이것이 매우 자연스러워집니다.
`string` 집합 또는 `number` 집합에 속하는 값을 어떻게 설명할까요?
그것은 단순히 해당 집합들의 *유니온*에 속합니다: `string | number`.

TypeScript는 집합론적 방식으로 타입을 다루는 여러 메커니즘을 제공하며, 타입을 집합으로 생각하면 더 직관적으로 느껴질 것입니다.

### 지워지는 구조적 타입

TypeScript에서 객체는 하나의 정확한 타입이 *아닙니다*.
예를 들어, 인터페이스를 만족하는 객체를 구성하면, 둘 사이에 선언적 관계가 없었더라도 해당 인터페이스가 예상되는 곳에서 그 객체를 사용할 수 있습니다.

```ts
interface Pointlike {
  x: number;
  y: number;
}
interface Named {
  name: string;
}

function logPoint(point: Pointlike) {
  console.log("x = " + point.x + ", y = " + point.y);
}

function logName(x: Named) {
  console.log("Hello, " + x.name);
}

const obj = {
  x: 0,
  y: 0,
  name: "Origin",
};

logPoint(obj);
logName(obj);
```

TypeScript의 타입 시스템은 명목적이 아니라 *구조적*입니다: `obj`가 둘 다 숫자인 `x`와 `y` 속성을 가지고 있기 때문에 `Pointlike`로 사용할 수 있습니다.
타입 간의 관계는 특정 관계로 선언되었는지가 아니라 포함하는 속성에 의해 결정됩니다.

TypeScript의 타입 시스템은 또한 *구체화되지 않습니다*: 런타임에 `obj`가 `Pointlike`라고 알려주는 것은 아무것도 없습니다.
사실, `Pointlike` 타입은 런타임에 *어떤 형태로도* 존재하지 않습니다.

*집합으로서의 타입* 아이디어로 돌아가면, `obj`를 `Pointlike` 값 집합과 `Named` 값 집합 둘 다의 구성원으로 생각할 수 있습니다.

### 구조적 타이핑의 결과

OOP 프로그래머들은 종종 구조적 타이핑의 두 가지 특정 측면에 놀라곤 합니다.

#### 빈 타입

첫 번째는 *빈 타입*이 기대를 거스르는 것처럼 보인다는 것입니다:

```ts
class Empty {}

function fn(arg: Empty) {
  // 무언가를 하나?
}

// 오류 없음, 하지만 이것은 'Empty'가 아니지 않나?
fn({ k: 10 });
```

TypeScript는 제공된 인수가 유효한 `Empty`인지 확인하여 여기서 `fn` 호출이 유효한지 결정합니다.
이것은 `{ k: 10 }`과 `class Empty { }`의 *구조*를 검사하여 수행합니다.
`Empty`는 속성이 없기 때문에 `{ k: 10 }`이 `Empty`가 가진 *모든* 속성을 가지고 있음을 알 수 있습니다.
따라서 이것은 유효한 호출입니다!

이것은 놀랍게 보일 수 있지만, 궁극적으로 명목적 OOP 언어에서 강제하는 것과 매우 유사한 관계입니다.
하위 클래스는 기본 클래스의 속성을 *제거*할 수 없습니다. 그렇게 하면 파생 클래스와 기본 클래스 사이의 자연스러운 하위 타입 관계가 깨지기 때문입니다.
구조적 타입 시스템은 호환 가능한 타입의 속성을 가지는 것으로 하위 타입을 설명하여 이 관계를 암묵적으로 식별합니다.

#### 동일한 타입

또 다른 빈번한 놀라움의 원인은 동일한 타입에서 옵니다:

```ts
class Car {
  drive() {
    // 액셀을 밟는다
  }
}
class Golfer {
  drive() {
    // 공을 멀리 친다
  }
}
// 오류 없음?
let w: Car = new Golfer();
```

다시 말하지만, 이러한 클래스들의 *구조*가 같기 때문에 이것은 오류가 아닙니다.
이것이 잠재적인 혼란의 원인처럼 보일 수 있지만, 실제로 관련되어서는 안 되는 동일한 클래스는 일반적이지 않습니다.

클래스가 서로 어떻게 관련되는지에 대해서는 클래스 챕터에서 더 배울 것입니다.

### 리플렉션

OOP 프로그래머들은 제네릭 타입을 포함하여 모든 값의 타입을 조회할 수 있는 것에 익숙합니다:

```csharp
// C#
static void LogType<T>() {
    Console.WriteLine(typeof(T).Name);
}
```

TypeScript의 타입 시스템이 완전히 지워지기 때문에, 예를 들어 제네릭 타입 매개변수의 인스턴스화에 대한 정보는 런타임에 사용할 수 없습니다.

JavaScript에는 `typeof`와 `instanceof` 같은 일부 제한된 원시 기능이 있지만, 이러한 연산자는 여전히 타입이 지워진 출력 코드에 존재하는 값에 대해 작동한다는 것을 기억하세요.
예를 들어, `typeof (new Car())`는 `Car`나 `"Car"`가 아니라 `"object"`가 됩니다.

## 다음 단계

이것은 일상적인 TypeScript에서 사용되는 문법과 도구에 대한 간략한 개요였습니다. 여기서부터 다음을 할 수 있습니다:

- 전체 핸드북을 [처음부터 끝까지](/docs/handbook/intro.html) 읽으세요

- [플레이그라운드 예제](/play#show-examples)를 탐색하세요
