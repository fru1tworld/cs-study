# RFC 791 - Internet Protocol (IPv4)

> 1981년 9월 발행, DoD Standard Internet Protocol 명세서
> RFC 760을 대체하며 IPv4를 정의한 인터넷 프로토콜의 원형 문서

## 1. 개요

RFC 791은 인터넷 프로토콜(IP)의 기초를 정의한 문서로, 인터넷 통신의 근간이 되는 IPv4를 명세합니다.

### 핵심 설계 철학

> "구현은 전송할 때는 보수적이어야 하고, 수신할 때는 관대해야 한다. 즉, 올바른 형식의 데이터그램을 전송하는 데 신중해야 하지만, 해석할 수 있는 모든 데이터그램을 수용해야 한다."

- 비연결형(Connectionless): 각 데이터그램을 독립적인 개체로 취급
- 연결이나 논리적 회선 없음: 종단 간 확인응답, 재전송, 흐름 제어 없음
- 단순성 우선: 신뢰성보다 단순성을 우선시

## 2. IPv4 헤더 구조

IPv4 헤더는 최소 20옥텟(160비트)으로 구성됩니다.

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 헤더 필드 상세

| 필드 | 크기 | 설명 |
|------|------|------|
| Version | 4비트 | IP 버전 번호 (IPv4 = 4) |
| IHL (Internet Header Length) | 4비트 | 헤더 길이를 32비트 워드 단위로 표시 |
| Type of Service (ToS) | 8비트 | QoS 파라미터 (우선순위, 지연, 처리량, 신뢰성) |
| Total Length | 16비트 | 데이터그램 전체 길이 (최대 65,535 옥텟) |
| Identification | 16비트 | 단편 재조립에 사용되는 식별자 |
| Flags | 3비트 | 예약(0), DF(Don't Fragment), MF(More Fragments) |
| Fragment Offset | 13비트 | 단편 위치를 8옥텟 단위로 표시 |
| Time to Live (TTL) | 8비트 | 데이터그램 수명 상한 |
| Protocol | 8비트 | 상위 계층 프로토콜 식별자 (TCP=6, UDP=17 등) |
| Header Checksum | 16비트 | 헤더만의 1의 보수 체크섬 (아래 상세 참조) |
| Source Address | 32비트 | 출발지 IP 주소 |
| Destination Address | 32비트 | 목적지 IP 주소 |
| Options | 가변 | 선택적 제어 기능 |

### Header Checksum 계산 알고리즘

Header Checksum은 IP 헤더의 무결성을 검증하기 위한 16비트 체크섬입니다.

계산 알고리즘:

1. 초기화: 체크섬 필드를 0으로 설정
2. 16비트 워드 분할: 헤더를 16비트(2옥텟) 단위로 분할
3. 1의 보수 합산: 모든 16비트 워드를 1의 보수 산술로 더함
4. 캐리 처리: 합이 16비트를 초과하면 캐리를 하위 비트에 더함
5. 1의 보수 취함: 최종 합의 1의 보수가 체크섬

```
계산 예시 (의사코드):

checksum = 0
for each 16-bit word in header:
    checksum = checksum + word
    if checksum > 0xFFFF:
        checksum = (checksum & 0xFFFF) + 1  // 캐리 추가
checksum = ~checksum  // 1의 보수

검증 시:
- 수신된 헤더 전체(체크섬 포함)를 동일하게 합산
- 결과가 0xFFFF(모든 비트가 1)이면 유효
```

중요 특성:

- 헤더만 검증: 데이터(페이로드)는 체크섬에 포함되지 않음
- 매 홉마다 재계산: TTL이 감소하므로 각 라우터에서 재계산 필요
- 빠른 계산: 1의 보수 연산은 하드웨어에서 효율적으로 구현 가능
- 오류 검출 한계: 일부 오류 패턴은 검출하지 못할 수 있음

라우터에서의 증분 업데이트:

TTL만 변경되는 경우, 전체 재계산 대신 증분 업데이트 가능:
```
new_checksum = old_checksum + (old_TTL - new_TTL)
```

### Type of Service (ToS) 필드 구조

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|  PRECEDENCE   | D | T | R | 0 |
+---+---+---+---+---+---+---+---+
```

- Precedence (3비트): 우선순위 (0=일반, 7=네트워크 제어)
- D (Delay): 0=일반 지연, 1=낮은 지연
- T (Throughput): 0=일반 처리량, 1=높은 처리량
- R (Reliability): 0=일반 신뢰성, 1=높은 신뢰성

## 3. 주소 지정 체계

IPv4는 32비트 주소를 사용하며, 세 가지 주요 클래스로 구분됩니다.

### 주소 클래스

| 클래스 | 첫 번째 옥텟 범위 | 네트워크 비트 | 호스트 비트 | 용도 |
|--------|-------------------|---------------|-------------|------|
| Class A | 1-127 | 7비트 | 24비트 | 대규모 네트워크 |
| Class B | 128-191 | 14비트 | 16비트 | 중규모 네트워크 |
| Class C | 192-223 | 21비트 | 8비트 | 소규모 네트워크 |
| Class D | 224-239 | N/A | N/A | 멀티캐스트 |
| Class E | 240-255 | N/A | N/A | 실험용/예약 |

### 주소 형식

```
Class A: |0|네트워크(7)|        호스트(24)           |
Class B: |1|0|  네트워크(14)  |    호스트(16)       |
Class C: |1|1|0|    네트워크(21)     | 호스트(8)   |
Class D: |1|1|1|0|       멀티캐스트 그룹 ID(28)     |
Class E: |1|1|1|1|             예약(28)             |
```

### Class D (멀티캐스트)

Class D 주소는 멀티캐스트 통신을 위해 예약되어 있습니다.

- 주소 범위: 224.0.0.0 ~ 239.255.255.255
- 첫 4비트: 항상 1110
- 특징: 네트워크/호스트 구분 없이 28비트의 멀티캐스트 그룹 ID 사용
- 용도: 단일 발신자가 다수의 수신자에게 동시에 데이터 전송

주요 멀티캐스트 주소:

| 주소 | 용도 |
|------|------|
| 224.0.0.1 | 서브넷의 모든 호스트 |
| 224.0.0.2 | 서브넷의 모든 라우터 |
| 224.0.0.5 | OSPF 라우터 |
| 224.0.0.9 | RIPv2 라우터 |

### Class E (실험용)

Class E 주소는 실험 및 미래 사용을 위해 예약되어 있습니다.

- 주소 범위: 240.0.0.0 ~ 255.255.255.254
- 첫 4비트: 항상 1111
- 특징: 일반적인 유니캐스트 또는 멀티캐스트 통신에 사용 불가
- 용도: IETF 연구 및 실험 목적

### 특수 주소

IPv4에는 특별한 목적으로 예약된 주소들이 있습니다.

| 주소/범위 | 이름 | 설명 |
|-----------|------|------|
| 0.0.0.0 | This Host | 자신의 주소를 모를 때 사용 (부팅 시) |
| 0.0.0.0/8 | This Network | 현재 네트워크의 호스트 지정 |
| 127.0.0.0/8 | Loopback | 루프백 주소 (자기 자신에게 전송) |
| 127.0.0.1 | Localhost | 로컬호스트 표준 주소 |
| 255.255.255.255 | Limited Broadcast | 제한된 브로드캐스트 (로컬 네트워크 전체) |
| 네트워크.255 | Directed Broadcast | 지정된 브로드캐스트 (특정 네트워크 전체) |
| 네트워크.0 | Network Address | 네트워크 자체를 식별 (호스트 부분 모두 0) |

특수 주소 상세:

1. 0.0.0.0 (This Host)
   - 호스트가 자신의 IP 주소를 알지 못할 때 출발지 주소로 사용
   - DHCP 요청 시 클라이언트가 사용
   - 목적지로는 사용 불가

2. 127.x.x.x (Loopback)
   - 127.0.0.0/8 전체가 루프백용으로 예약
   - 네트워크 인터페이스를 거치지 않고 내부적으로 처리
   - 네트워크 소프트웨어 테스트에 사용
   - 이 주소로 향하는 패킷은 절대 네트워크로 전송되지 않음

3. 브로드캐스트 주소
   - 제한된 브로드캐스트 (255.255.255.255): 로컬 네트워크의 모든 호스트에게 전송, 라우터를 통과하지 않음
   - 지정된 브로드캐스트 (네트워크.255): 특정 네트워크의 모든 호스트에게 전송, 라우터를 통과할 수 있음

## 4. 단편화(Fragmentation)와 재조립(Reassembly)

### 단편화 메커니즘

데이터그램이 네트워크의 MTU(Maximum Transmission Unit)를 초과할 경우, 게이트웨이에서 8옥텟 경계로 단편화합니다.

단편화 절차:
1. 원본 헤더 필드를 복사한 새 헤더 생성
2. More Fragments (MF) 플래그 적절히 설정
3. Fragment Offset 값 업데이트
4. 체크섬 재계산

> "첫 번째 단편은 fragment offset이 0이고, 마지막 단편은 more-fragments 플래그가 0으로 재설정된다."

### 단편화 규칙

단편화에는 엄격한 규칙이 적용됩니다:

1. 8옥텟 경계 규칙

모든 단편(마지막 단편 제외)은 8옥텟(64비트)의 배수여야 합니다:

```
Fragment Offset 필드가 13비트이므로:
- 표현 가능한 최대 오프셋: 8191 x 8 = 65,528 옥텟
- 각 단편의 데이터 길이: 8의 배수
- 마지막 단편만 8의 배수가 아닐 수 있음
```

2. 옵션 복사 규칙

단편화 시 옵션의 Copied 플래그에 따라 처리:

| Copied 플래그 | 동작 | 해당 옵션 |
|---------------|------|-----------|
| 1 (복사) | 모든 단편에 복사 | Security, Source Routing |
| 0 (비복사) | 첫 번째 단편에만 포함 | Record Route, Timestamp |

```
원본: [헤더][옵션A(C=1)][옵션B(C=0)][데이터...]

단편1: [헤더][옵션A][옵션B][데이터1]  (첫 단편 - 모든 옵션)
단편2: [헤더][옵션A][데이터2]          (C=1인 옵션만)
단편3: [헤더][옵션A][데이터3]          (C=1인 옵션만)
```

3. DF (Don't Fragment) 플래그 처리

| DF 값 | 의미 | MTU 초과 시 동작 |
|-------|------|------------------|
| 0 | 단편화 허용 | 단편화 수행 |
| 1 | 단편화 금지 | 패킷 폐기 + ICMP 오류 전송 |

DF=1인 데이터그램이 MTU를 초과하는 경우:
1. 데이터그램 폐기
2. ICMP Destination Unreachable 메시지 전송 (Code 4: Fragmentation Needed)
3. ICMP 메시지에 다음 홉 MTU 정보 포함 (RFC 1191 Path MTU Discovery)

```
ICMP Type 3, Code 4 메시지:
+---+---+---+---+---+---+---+---+
| Type=3| Code=4|   Checksum    |
+---+---+---+---+---+---+---+---+
|   unused  |    Next-Hop MTU   |
+---+---+---+---+---+---+---+---+
|    원본 IP 헤더 + 8옥텟 데이터    |
+---+---+---+---+---+---+---+---+
```

4. 최소 단편 크기

- 최소 MTU: 68옥텟 (헤더 60 + 데이터 8)
- 모든 네트워크는 최소 68옥텟 데이터그램을 전달해야 함
- 단편의 데이터 부분은 최소 8옥텟

### 단편화 예시

```
원본 데이터그램: 3000 바이트 (헤더 20 + 데이터 2980)
MTU: 1500 바이트

단편 1: 헤더(20) + 데이터(1480) = 1500 바이트
        Offset=0, MF=1

단편 2: 헤더(20) + 데이터(1480) = 1500 바이트
        Offset=185 (1480/8), MF=1

단편 3: 헤더(20) + 데이터(20) = 40 바이트
        Offset=370 (2960/8), MF=0
```

### 재조립 과정

목적지 호스트는 다음 필드를 조합하여 버퍼 식별자를 생성합니다:
- Source Address
- Destination Address
- Protocol
- Identification

재조립 리소스:
- 데이터 버퍼
- 헤더 버퍼
- 단편 블록 비트 테이블

### 재조립 타임아웃 및 ICMP 메시지

재조립 과정에는 타임아웃 메커니즘이 적용됩니다.

재조립 타임아웃:

| 항목 | 값 | 설명 |
|------|-----|------|
| 타이머 시작 | 첫 단편 수신 시 | 재조립 타이머 초기화 |
| 기본 타임아웃 | TTL 값 (초) | 원본 데이터그램의 TTL을 타임아웃으로 사용 |
| 권장 하한 | 15초 | RFC 1122 권장 최소값 |
| 권장 상한 | 120초 | 과도한 리소스 점유 방지 |

타임아웃 발생 시 동작:

1. 불완전한 데이터그램의 모든 단편 폐기
2. 재조립 버퍼 해제
3. ICMP Time Exceeded 메시지 전송 (Code 1)

```
ICMP Time Exceeded (재조립 타임아웃):
+---+---+---+---+---+---+---+---+
| Type=11| Code=1|   Checksum   |
+---+---+---+---+---+---+---+---+
|           unused (0)          |
+---+---+---+---+---+---+---+---+
|   원본 IP 헤더 + 8옥텟 데이터   |
+---+---+---+---+---+---+---+---+
```

ICMP Time Exceeded 코드:

| 코드 | 의미 | 발생 조건 |
|------|------|-----------|
| 0 | TTL exceeded in transit | TTL이 0이 되어 패킷 폐기 |
| 1 | Fragment reassembly time exceeded | 재조립 타임아웃 |

재조립 관련 고려사항:

- 단편 도착 순서: 단편은 순서대로 도착하지 않을 수 있음
- 중복 단편: 동일 단편이 여러 번 도착할 수 있음 (무시)
- 겹치는 단편: RFC 791은 명확히 정의하지 않음 (보안 이슈)
- 리소스 관리: 재조립 버퍼는 유한하므로 타임아웃 필수
- 첫 단편 미수신: 첫 단편이 없으면 원본 헤더 정보 부족

재조립 실패 시 ICMP 전송 조건:

ICMP 메시지는 다음 조건을 모두 만족할 때만 전송:
1. 첫 번째 단편(Offset=0)이 수신된 경우
2. 출발지 주소가 유효한 유니캐스트 주소인 경우
3. 브로드캐스트/멀티캐스트 주소로 전송된 것이 아닌 경우

## 5. 프로토콜 동작 메커니즘

### 네 가지 핵심 메커니즘

1. Type of Service: 라우팅 결정을 위한 품질 표시
2. Time to Live: 영구 순환 방지를 위한 자동 파괴 타이머
3. Options: 타임스탬프, 보안, 라우팅을 위한 제어 기능
4. Header Checksum: 데이터그램 처리 정보의 정확한 전송 검증

### TTL (Time to Live)

- 각 라우터에서 최소 1씩 감소
- 0에 도달하면 패킷 폐기
- ICMP Time Exceeded 메시지 생성
- 무한 루프 방지 목적

## 6. Options 필드

옵션은 선택적으로 전송하지만, 구현은 필수입니다.

### 주요 옵션들

| 옵션 | 타입 | 설명 |
|------|------|------|
| End of Option List | 0 | 옵션 목록 종료 표시 |
| No Operation | 1 | 패딩/정렬용 |
| Security | 130 | 분류, 구획화, 취급 제한 코드 |
| Loose Source Routing | 131 | 느슨한 소스 라우팅 (중간 경로 허용) |
| Strict Source Routing | 137 | 엄격한 소스 라우팅 (직접 연결만) |
| Record Route | 7 | 데이터그램 경로 추적 |
| Internet Timestamp | 68 | 각 홉에서 처리 타임스탬프 기록 |
| Stream ID | 136 | SATNET 스트림 식별자 |

### 옵션 포맷

```
단일 옥텟 옵션:
+--------+
|  type  |
+--------+

다중 옥텟 옵션:
+--------+--------+--------+--------+
|  type  | length |      data       |
+--------+--------+--------+--------+
```

### Option Type 바이트 구조

Option Type 바이트는 3개의 필드로 구성됩니다:

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| C |  CLASS  |     NUMBER      |
+---+---+---+---+---+---+---+---+
```

| 필드 | 비트 | 설명 |
|------|------|------|
| Copied (C) | 1비트 (비트 0) | 단편화 시 옵션 복사 여부 |
| Class | 2비트 (비트 1-2) | 옵션 클래스 |
| Number | 5비트 (비트 3-7) | 옵션 번호 |

Copied Flag (C):

| 값 | 의미 |
|----|------|
| 0 | 첫 번째 단편에만 복사 |
| 1 | 모든 단편에 복사 |

Option Class:

| 값 | 의미 | 설명 |
|----|------|------|
| 0 | Control | 데이터그램 또는 네트워크 제어 |
| 1 | Reserved | 예약됨 |
| 2 | Debugging and Measurement | 디버깅 및 측정 |
| 3 | Reserved | 예약됨 |

주요 옵션 타입 분석:

| 옵션 | Type 값 | C | Class | Number | 설명 |
|------|---------|---|-------|--------|------|
| End of Option List | 0 (0x00) | 0 | 0 | 0 | 옵션 종료 |
| No Operation | 1 (0x01) | 0 | 0 | 1 | 패딩 |
| Security | 130 (0x82) | 1 | 0 | 2 | 보안 (모든 단편에 복사) |
| Loose Source Routing | 131 (0x83) | 1 | 0 | 3 | 느슨한 라우팅 (모든 단편에 복사) |
| Strict Source Routing | 137 (0x89) | 1 | 0 | 9 | 엄격한 라우팅 (모든 단편에 복사) |
| Record Route | 7 (0x07) | 0 | 0 | 7 | 경로 기록 (첫 단편만) |
| Internet Timestamp | 68 (0x44) | 0 | 2 | 4 | 타임스탬프 (첫 단편만) |

## 7. 라우팅 기본 개념

IP 라우팅은 데이터그램을 출발지에서 목적지까지 전달하는 과정입니다.

### 게이트웨이(라우터) 동작

게이트웨이는 서로 다른 네트워크를 연결하고 데이터그램을 전달하는 역할을 합니다.

게이트웨이의 기본 동작:

1. 데이터그램 수신: 네트워크 인터페이스에서 패킷 수신
2. 헤더 검증: 체크섬 확인, 버전/IHL 검증
3. TTL 확인: TTL > 0인지 확인, 0이면 폐기 + ICMP
4. 라우팅 결정: 라우팅 테이블 참조하여 다음 홉 결정
5. TTL 감소: TTL을 최소 1 감소
6. 체크섬 재계산: 변경된 헤더의 체크섬 업데이트
7. 단편화 (필요시): 출력 인터페이스 MTU에 맞게 단편화
8. 전달: 다음 홉으로 데이터그램 전송

```
                    게이트웨이 처리 흐름

수신 → 검증 → TTL 확인 → 라우팅 → TTL 감소 → 단편화 → 전송
              ↓                              ↓
         TTL=0이면                    MTU 초과 + DF=1
         ICMP 전송                    ICMP 전송 후 폐기
```

### 직접 라우팅 (Direct Routing)

목적지가 발신자와 동일한 네트워크에 있는 경우:

```
호스트 A (192.168.1.10) → 호스트 B (192.168.1.20)
        ↓
   동일 네트워크 (192.168.1.0/24)
        ↓
   직접 전송 (게이트웨이 불필요)
```

직접 라우팅 조건:
- 출발지와 목적지의 네트워크 주소가 동일
- ARP를 통해 목적지 MAC 주소 획득
- 로컬 네트워크로 직접 전송

### 간접 라우팅 (Indirect Routing)

목적지가 다른 네트워크에 있는 경우:

```
호스트 A (192.168.1.10) → 게이트웨이 (192.168.1.1) → ... → 호스트 B (10.0.0.50)
        ↓                       ↓                           ↓
   네트워크 1              라우팅 결정                  네트워크 2
   (192.168.1.0/24)                                   (10.0.0.0/8)
```

간접 라우팅 과정:

1. 목적지 네트워크가 로컬이 아님을 판단
2. 라우팅 테이블에서 다음 홉(게이트웨이) 결정
3. 게이트웨이의 MAC 주소로 프레임 전송
4. IP 헤더의 목적지 주소는 변경 없음 (최종 목적지 유지)

### 라우팅 테이블

라우팅 테이블은 목적지에 따른 다음 홉 정보를 제공합니다:

| 목적지 네트워크 | 넷마스크 | 게이트웨이 | 인터페이스 | 메트릭 |
|-----------------|----------|------------|------------|--------|
| 0.0.0.0 | 0.0.0.0 | 192.168.1.1 | eth0 | 1 |
| 192.168.1.0 | 255.255.255.0 | 직접 연결 | eth0 | 0 |
| 10.0.0.0 | 255.0.0.0 | 192.168.1.254 | eth0 | 1 |

라우팅 결정 알고리즘:

1. 최장 일치 (Longest Prefix Match): 가장 구체적인 경로 선택
2. 메트릭 비교: 동일 목적지에 여러 경로가 있으면 메트릭이 낮은 경로
3. 기본 게이트웨이: 일치하는 경로가 없으면 0.0.0.0/0 경로 사용

### 소스 라우팅

RFC 791은 발신자가 경로를 지정할 수 있는 소스 라우팅 옵션을 정의합니다:

Loose Source Routing (LSR):
- 지정된 라우터를 반드시 경유
- 중간에 다른 라우터 경유 가능
- 옵션 타입: 131 (0x83)

Strict Source Routing (SSR):
- 지정된 라우터만 순서대로 경유
- 다른 라우터 경유 불가
- 옵션 타입: 137 (0x89)

```
소스 라우팅 옵션 형식:
+--------+--------+--------+--------+--------+
|  type  | length | pointer| route data ...  |
+--------+--------+--------+--------+--------+

pointer: 다음 처리할 주소 위치 (4부터 시작)
route data: IP 주소 목록
```

> 보안상의 이유로 현대 네트워크에서는 소스 라우팅이 대부분 비활성화되어 있습니다.

## 8. 인터페이스

### SEND 호출 (전송)

필요 파라미터:
- Source Address
- Destination Address
- Protocol
- Type of Service
- Time to Live
- Buffer Pointer
- Data Length
- Identification
- Don't Fragment Flag

### RECV 호출 (수신)

반환 정보:
- Source Address
- Destination Address
- Type of Service
- Data Length
- Option Data

## 9. 최소 요구사항

### 호스트 최소 요구사항

- 수신: 최대 576 옥텟 데이터그램 수신 가능
- 전달: 최소 68 옥텟 데이터그램을 단편화 없이 전달

### 68 옥텟의 의미

```
최소 데이터그램 = 최대 헤더(60) + 최소 데이터(8)
              = 20(기본 헤더) + 40(옵션) + 8(단편 최소 단위)
              = 68 옥텟
```

## 10. 요약

RFC 791은 인터넷 통신의 근간이 되는 IPv4 프로토콜을 정의합니다:

- 비연결형 패킷 전달: 각 패킷을 독립적으로 처리
- 32비트 주소 체계: 클래스 기반 주소 할당
- 단편화/재조립: MTU 제한 극복
- Best-effort 서비스: 신뢰성 보장 없음 (상위 계층에서 처리)

이 프로토콜은 40년 이상 인터넷의 기반으로 사용되어 왔으며, 현재도 대부분의 인터넷 트래픽이 IPv4를 통해 전송됩니다.

## 참고 문서

- RFC 760: DoD Standard Internet Protocol (대체됨)
- RFC 792: Internet Control Message Protocol (ICMP)
- RFC 1122: Requirements for Internet Hosts
