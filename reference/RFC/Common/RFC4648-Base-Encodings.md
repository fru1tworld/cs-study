Network Working Group                                       S. Josefsson
Request for Comments: 4648                                           SJD
Obsoletes: 3548                                             October 2006
Category: Standards Track


                 Base16, Base32, Base64 데이터 인코딩

이 메모의 상태

   이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하며, 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태와 현황은 "Internet Official Protocol Standards" (STD 1)의 최신판을 참조하시기 바랍니다. 이 메모의 배포에는 제한이 없습니다.

저작권 고지

   Copyright (C) The Internet Society (2006).

초록

   이 문서는 일반적으로 사용되는 base 64, base 32, base 16 인코딩 체계를 기술합니다. 또한 인코딩된 데이터에서의 줄 바꿈 사용, 인코딩된 데이터에서의 패딩 사용, 인코딩된 데이터에서의 알파벳 외 문자 사용, 서로 다른 인코딩 알파벳의 사용, 그리고 표준(canonical) 인코딩에 대해 논의합니다.

목차

   1. 서론 ............................................................2
   2. 이 문서에서 사용된 규칙 ..........................................2
   3. 구현 불일치 사항 ................................................3
      3.1. 인코딩된 데이터에서의 줄 바꿈 ..............................3
      3.2. 인코딩된 데이터의 패딩 .....................................4
      3.3. 인코딩된 데이터에서 알파벳 외 문자의 해석 ..................4
      3.4. 알파벳 선택 ................................................5
      3.5. 표준(Canonical) 인코딩 .....................................5
   4. Base 64 인코딩 ..................................................5
   5. URL 및 파일명 안전 알파벳을 사용한 Base 64 인코딩 ...............7
   6. Base 32 인코딩 ..................................................8
   7. 확장 16진수 알파벳을 사용한 Base 32 인코딩 .....................10
   8. Base 16 인코딩 .................................................11
   9. 그림 및 예시 ...................................................12
   10. 테스트 벡터 ...................................................14
   11. Base64의 ISO C99 구현 .........................................15
   12. 보안 고려사항 .................................................15
   13. RFC 3548 이후 변경사항 ........................................16
   14. 감사의 글 .....................................................16
   15. 복사 조건 .....................................................17
   16. 참고 문헌 .....................................................17
      16.1. 규범적 참고 문헌 .........................................17
      16.2. 참고적 참고 문헌 .........................................17

1. 서론

   데이터의 Base 인코딩은 아마도 레거시 이유로 인해 US-ASCII 데이터로 제한된 환경에서 데이터를 저장하거나 전송하기 위해 많은 상황에서 사용됩니다. Base 인코딩은 또한 레거시 제한이 없는 새로운 애플리케이션에서도 사용될 수 있는데, 이는 단순히 텍스트 편집기로 객체를 조작할 수 있게 해주기 때문입니다.

   과거에 서로 다른 애플리케이션들은 서로 다른 요구사항을 가지고 있었으며, 따라서 때때로 base 인코딩을 약간 다른 방식으로 구현하였습니다. 오늘날 프로토콜 명세서들은 때때로 일반적으로 base 인코딩을, 특히 "base64"를 정확한 설명이나 참조 없이 사용합니다. MIME [4]은 결과에 대한 영향을 고려하지 않고 종종 base64의 참조로 사용됩니다(예: 줄 바꿈 또는 알파벳 외 문자). 또한, 다른 base 인코딩 변형들이 base 인코딩의 원본 설명에 대한 참조 없이 다양한 곳에 등장하고 있어, 구현자들이 정확한 상세 사항을 판단하기 어렵게 만들고 있습니다. 이 문서의 목적은 다른 문서에서의 모호성을 줄이고 더 나은 상호운용성으로 이어지기를 희망하면서, 공통 알파벳 및 인코딩 고려사항을 확립하는 것입니다.

2. 이 문서에서 사용된 규칙

   이 문서에서 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL"이라는 키워드는 [2]에 기술된 대로 해석되어야 합니다.

3. 구현 불일치 사항

   여기서는 과거의 base 인코딩 구현들 사이의 불일치 사항을 논의하고, 적절한 경우 미래를 위한 특정 권장 동작을 명시합니다.

3.1. 인코딩된 데이터에서의 줄 바꿈

   MIME [4]은 종종 base 64 인코딩의 참조로 사용됩니다. 그러나 MIME은 그 자체로 "base 64"를 정의하지 않고, MIME 내에서 사용하기 위한 "base 64 Content-Transfer-Encoding"을 정의합니다. 따라서 MIME은 base 64로 인코딩된 줄의 길이를 76자로 강제합니다. MIME은 PEM [3]에 기반한 base 64 인코딩의 "Content-Transfer-Encoding" 변형을 상속한 것이며, PEM은 64자 줄로 제한합니다. PEM과 MIME 모두 SMTP를 통해 전송하기에 적합한 텍스트 줄을 생성하기 위해 특정 줄 길이를 사용하며, 이것은 이 문서의 범위를 벗어납니다. MIME [4]과 PEM [3]의 줄 길이 제한 사이의 차이는 그 자체로 base 인코딩의 불일치를 일으킨 요인이 됩니다.

   구현체는 이 문서를 참조하는 명세서가 명시적으로 base 인코더에게 특정 문자 수 이후에 줄 바꿈을 추가하도록 지시하지 않는 한 base 인코딩된 데이터에 줄 바꿈을 추가해서는 안 됩니다(MUST NOT).

3.2. 인코딩된 데이터의 패딩

   일부 상황에서는 base 인코딩된 데이터에서 패딩("=")의 사용이 필요하지 않거나 사용되지 않습니다. 일반적인 경우, 데이터의 크기에 대해 어떤 가정도 할 수 없을 때, 패딩이 올바른 디코딩된 데이터를 산출하기 위해 필요합니다.

   구현체는 이 문서를 참조하는 명세서가 명시적으로 달리 명시하지 않는 한 인코딩된 데이터 끝에 적절한 패드 문자를 포함해야 합니다(MUST).

   base 64와 base 32 알파벳은 패딩을 사용하며, 아래에서 각각의 해당 섹션에서 설명됩니다. 그러나 base 16에서는 패딩이 필요하지 않습니다.

3.3. 인코딩된 데이터에서 알파벳 외 문자의 해석

   Base 인코딩은 바이너리 데이터를 인코딩하기 위해 특정하고 축소된 알파벳을 사용합니다. 알파벳 외 문자는 데이터 손상이나 설계상의 이유로 base 인코딩된 데이터 내에 존재할 수 있습니다. 알파벳 외 문자가 무시되면, 이는 정보를 "유출"하는 데 사용될 수 있는 은닉 채널을 생성할 수 있습니다. 또한 "명시적 알파벳 외" 문자(예: CR 및 LF)는 정보를 은닉 채널을 통해 보내기 위한 의도가 거의 없으며, 새로운 줄이 발견되면 인코딩을 거부하는 것은 기존 시스템과의 상호운용성 문제를 유발할 수 있습니다.

   구현체는 base 인코딩된 데이터를 해석할 때 base 알파벳 외의 문자가 포함된 경우 인코딩된 데이터를 거부해야 합니다(MUST). 단, 이 문서를 참조하는 명세서가 명시적으로 달리 명시한 경우는 예외입니다. 이러한 명세서는 대신 MIME이 하듯이 알파벳 외 문자를 무시하도록 디코더에게 지시할 수 있습니다.

3.4. 알파벳 선택

   Base 인코딩의 다양한 응용 프로그램들은 서로 다른 요구사항을 가지고 있습니다. 알파벳 선택에 영향을 미치는 요인에 대한 상세한 논의는 여기서 다룹니다. 모든 요구사항을 충족하는 보편적으로 수용되는 알파벳은 없습니다. 예를 들어, 인코딩된 데이터를 사람이 처리해야 하는 경우가 요구사항이 될 수 있습니다. 사람 사용자들은 쉽게 혼동할 수 있는 문자들을 처리하기 어렵습니다. 예를 들어, base 32에서 사용되는 알파벳, 또는 '0'(영)과 'O'(오), '1'(일)과 'l'(엘)이 제외된 특수 알파벳이 있습니다. 또한 알파벳 외의 문자를 사용하는 구조에 인코딩된 데이터를 넣어야 할 때도 고려가 필요합니다. URL의 경우 특정 문자(예: "~" 물결표)가 일부 운영체제에서 문제가 됩니다. 인코딩된 데이터를 식별자로 사용해야 할 때도 중요한 고려사항이 있습니다.

   이 문서에서는 현재 사용 중인 다양한 알파벳들에 이름을 붙이고 문서화합니다.

3.5. 표준(Canonical) 인코딩

   base 64와 base 32 인코딩의 패딩 단계는, 부적절하게 구현될 경우, 인코딩된 데이터의 비유의적 변경으로 이어질 수 있습니다. 예를 들어, base 64에 대한 입력이 오직 하나의 옥텟인 경우, 첫 번째 기호의 6비트 모두가 사용되지만, 두 번째 기호의 6비트 중 처음 2비트만 사용됩니다. 이러한 패드 비트는 적합한 인코더에 의해 0으로 설정되어야 합니다(MUST). 이 속성이 유지되지 않으면, base 인코딩된 데이터의 표준 표현이 없게 되며, 여러 base 인코딩된 문자열이 동일한 바이너리 데이터로 디코딩될 수 있습니다. 이것이 보안 문제가 되는 경우, 다른 수단(예: CRC)을 통해 디코딩된 데이터의 정확한 전송을 보장하지 않는다면, 명세서에서 패드 비트가 0으로 설정되지 않은 인코딩을 거부하도록 디코더에게 의무화할 수 있습니다(MAY). 이 문서에서 논의된 인코딩의 디코더는 표준(canonical) 인코딩을 필요로 하는 명세서의 명시적 설명이 없으면 패드 비트에 대해 비유연하게 동작하는 것을 선택할 수 있습니다(MAY).

4. Base 64 인코딩

   다음 base 64에 대한 기술은 [3], [4], [5], [6]에서 파생되었습니다. 이 인코딩은 "base64"로 지칭될 수 있습니다.

   Base 64 인코딩은 대문자와 소문자를 모두 사용할 수 있지만 사람이 읽을 수 있을 필요는 없는 형태로 임의의 옥텟 시퀀스를 표현하도록 설계되었습니다.

   US-ASCII의 65문자 부분집합이 사용되어, 출력 가능한 문자당 6비트를 가능하게 합니다. (추가적인 65번째 문자 "="는 인코딩된 데이터의 끝이 어떤 특별한 처리를 거쳐야 할 수 있음을 나타내기 위해 사용됩니다 -- 아래의 "패딩(Padding)" 참조.)

   인코딩 과정은 24비트 입력 비트 그룹을 4개의 인코딩된 문자 출력 문자열로 표현합니다. 왼쪽에서 오른쪽으로 진행하면서, 3개의 8비트 입력 그룹을 연결하여 24비트 입력 그룹을 형성합니다. 이 24비트는 그 다음 4개의 연결된 6비트 그룹으로 취급되며, 각 그룹은 base 64 알파벳의 단일 문자로 변환됩니다.

   각 6비트 그룹은 64개의 출력 가능한 문자 배열에 대한 인덱스로 사용됩니다. 인덱스가 참조하는 문자가 출력 문자열에 배치됩니다.

                       Table 1: Base 64 알파벳

     값 인코딩  값 인코딩  값 인코딩  값 인코딩
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (패드) =
        15 P            32 g            49 x
        16 Q            33 h            50 y

   인코딩 입력의 마지막 양자(quantum)에서 남은 비트가 24비트보다 적을 때 특별한 처리가 수행됩니다. 완전한 인코딩 양자는 항상 데이터의 끝에서 완성됩니다. 충분한 비트가 남아 있지 않을 때, 6비트 그룹을 형성하기 위해 입력 데이터의 오른쪽에 0값 비트가 추가됩니다. "=" 문자로 패딩하면 디코더가 인코딩될 때 추가된 비트 수를 계산할 수 있습니다.

   (1) 인코딩 입력의 마지막 양자가 정확히 24비트의 정수배인 경우; 여기서 인코딩된 출력의 마지막 단위는 "=" 패딩 없이 4문자의 정수배가 됩니다.

   (2) 인코딩 입력의 마지막 양자가 정확히 8비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 2개의 "=" 패딩 문자가 뒤따르는 2문자가 됩니다.

   (3) 인코딩 입력의 마지막 양자가 정확히 16비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 1개의 "=" 패딩 문자가 뒤따르는 3문자가 됩니다.

5. URL 및 파일명 안전 알파벳을 사용한 Base 64 인코딩

   URL 및 파일명 안전 알파벳을 사용한 Base 64 인코딩은 [12]에서 사용되었습니다.

   63번째 문자로 "~"를 사용하는 대안 알파벳이 제안된 바 있습니다. "~" 문자가 일부 파일 시스템 환경에서 특별한 의미를 가지므로, 이 섹션에서 기술된 인코딩이 대신 권장됩니다. 이 인코딩은 기술적으로 섹션 4의 인코딩과 동일하되, 62번째와 63번째 문자가 아래 Table 2에 표시된 대로 변경되었습니다.

                    Table 2: "URL 및 파일명 안전" Base 64 알파벳

     값 인코딩  값 인코딩  값 인코딩  값 인코딩
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 - (마이너스)
        12 M            29 d            46 u            63 _
        13 N            30 e            47 v                  (언더라인)
        14 O            31 f            48 w
        15 P            32 g            49 x         (패드) =
        16 Q            33 h            50 y

   이 인코딩은 "base64url"로 지칭될 수 있습니다. 이 인코딩은 "base64" 인코딩과 동일한 것으로 간주되어서는 안 되며(SHOULD NOT), 단순히 "base64"로 지칭되어서는 안 됩니다(SHOULD NOT). 달리 명시되지 않는 한, "base64"는 이전 섹션의 base 64를 지칭합니다.

   이 인코딩은 URI에서 사용될 때 패드 문자 "="가 일반적으로 퍼센트 인코딩되므로, 데이터 길이가 암묵적으로 알려진 경우 패딩을 건너뜀으로써 이를 피할 수 있습니다. 이에 대한 정확한 명세는 이 문서의 범위를 벗어납니다.

6. Base 32 인코딩

   다음 base 32에 대한 기술은 [11]에서 파생되었습니다(수정 포함). 이 인코딩은 "base32"로 지칭될 수 있습니다.

   Base 32 인코딩은 대소문자 구분이 불필요하지만 사람이 읽을 수 있을 필요는 없는 형태로 임의의 옥텟 시퀀스를 표현하도록 설계되었습니다.

   US-ASCII의 33문자 부분집합이 사용되어, 출력 가능한 문자당 5비트를 가능하게 합니다. (추가적인 33번째 문자 "="는 인코딩된 데이터의 끝이 어떤 특별한 처리를 거쳐야 할 수 있음을 나타내기 위해 사용됩니다 -- 아래의 "패딩(Padding)" 참조.)

   인코딩 과정은 40비트 입력 비트 그룹을 8개의 인코딩된 문자 출력 문자열로 표현합니다. 왼쪽에서 오른쪽으로 진행하면서, 5개의 연속된 8비트 입력 그룹을 연결하여 40비트 입력 그룹을 형성합니다. 이 40비트는 그 다음 8개의 연결된 5비트 그룹으로 취급되며, 각 그룹은 base 32 알파벳의 단일 문자로 변환됩니다. 비트 스트림이 base 32 인코딩을 통해 인코딩될 때, 비트 스트림은 최상위 비트가 먼저 오는 순서로 간주되어야 합니다. 즉, 스트림의 첫 번째 비트가 첫 번째 8비트 바이트의 최상위 비트이고, 여덟 번째 비트가 첫 번째 8비트 바이트의 최하위 비트이며, 이런 식으로 계속됩니다.

   각 5비트 그룹은 32개의 출력 가능한 문자 배열에 대한 인덱스로 사용됩니다. 인덱스가 참조하는 문자가 출력 문자열에 배치됩니다. 이 문자들은 아래의 Table 3에서 선택되며, 알파벳의 대문자와 숫자 2에서 7을 사용합니다. 숫자 0, 1, 8은 사용되지 않는데, 이는 O, I, B 문자와 유사하기 때문입니다.

                       Table 3: Base 32 알파벳

     값 인코딩  값 인코딩  값 인코딩  값 인코딩
         0 A             9 J            18 S            27 3
         1 B            10 K            19 T            28 4
         2 C            11 L            20 U            29 5
         3 D            12 M            21 V            30 6
         4 E            13 N            22 W            31 7
         5 F            14 O            23 X
         6 G            15 P            24 Y         (패드) =
         7 H            16 Q            25 Z
         8 I            17 R            26 2

   인코딩 입력의 마지막 양자에서 남은 비트가 40비트보다 적을 때 특별한 처리가 수행됩니다. 완전한 인코딩 양자는 항상 데이터의 끝에서 완성됩니다. 충분한 비트가 남아 있지 않을 때, 5비트 그룹을 형성하기 위해 입력 데이터의 오른쪽에 0값 비트가 추가됩니다. "=" 문자로 패딩하면 디코더가 인코딩될 때 추가된 비트 수를 계산할 수 있습니다.

   (1) 인코딩 입력의 마지막 양자가 정확히 40비트의 정수배인 경우; 여기서 인코딩된 출력의 마지막 단위는 "=" 패딩 없이 8문자의 정수배가 됩니다.

   (2) 인코딩 입력의 마지막 양자가 정확히 8비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 6개의 "=" 패딩 문자가 뒤따르는 2문자가 됩니다.

   (3) 인코딩 입력의 마지막 양자가 정확히 16비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 4개의 "=" 패딩 문자가 뒤따르는 4문자가 됩니다.

   (4) 인코딩 입력의 마지막 양자가 정확히 24비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 3개의 "=" 패딩 문자가 뒤따르는 5문자가 됩니다.

   (5) 인코딩 입력의 마지막 양자가 정확히 32비트인 경우; 여기서 인코딩된 출력의 마지막 단위는 1개의 "=" 패딩 문자가 뒤따르는 7문자가 됩니다.

7. 확장 16진수 알파벳을 사용한 Base 32 인코딩

   다음 base 32에 대한 기술은 [7]에서 파생되었습니다. 이 인코딩은 "base32hex"로 지칭될 수 있습니다. 이 인코딩은 "base32" 인코딩과 동일한 것으로 간주되어서는 안 되며(SHOULD NOT), 단순히 "base32"로 지칭되어서는 안 됩니다(SHOULD NOT).

   이 인코딩은 동일한 알파벳을 제외하고 섹션 6에서 기술된 base 32 인코딩과 동일하게 사용되어야 합니다.

   이 알파벳이 가지고 있고 base64 및 base32 알파벳에는 없는 한 가지 속성은, 인코딩된 데이터가 비트 단위로 비교될 때 정렬 순서를 유지한다는 것입니다. 이 인코딩은 [10]에서 설명된 NSEC3 RR 유형에 의해 사용됩니다.

                  Table 4: "확장 16진수" Base 32 알파벳

     값 인코딩  값 인코딩  값 인코딩  값 인코딩
         0 0             9 9            18 I            27 R
         1 1            10 A            19 J            28 S
         2 2            11 B            20 K            29 T
         3 3            12 C            21 L            30 U
         4 4            13 D            22 M            31 V
         5 5            14 E            23 N
         6 6            15 F            24 O         (패드) =
         7 7            16 G            25 P
         8 8            17 H            26 Q

8. Base 16 인코딩

   다음 기술은 원본이지만 이전 기술들과 유사합니다. 본질적으로, Base 16 인코딩은 표준적인 대소문자 구분 없는 16진수 인코딩이며 "base16" 또는 "hex"로 지칭될 수 있습니다.

   US-ASCII의 16문자 부분집합이 사용되어, 출력 가능한 문자당 4비트를 가능하게 합니다.

   인코딩 과정은 8비트 입력 그룹을 2개의 인코딩된 문자 출력 문자열로 표현합니다. 왼쪽에서 오른쪽으로 진행하면서, 8비트 입력을 2개의 연결된 4비트 그룹으로 취급하며, 각 그룹은 base 16 알파벳의 단일 문자로 변환됩니다.

   각 4비트 그룹은 16개의 출력 가능한 문자 배열에 대한 인덱스로 사용됩니다. 인덱스가 참조하는 문자가 출력 문자열에 배치됩니다.

                       Table 5: Base 16 알파벳

         값 인코딩  값 인코딩  값 인코딩  값 인코딩
             0 0         4 4         8 8        12 C
             1 1         5 5         9 9        13 D
             2 2         6 6        10 A        14 E
             3 3         7 7        11 B        15 F

   base 32와 base 64와 달리, 완전한 코드 워드가 항상 사용 가능하므로 특별한 패딩이 필요하지 않습니다.

9. 그림 및 예시

   데이터의 바이너리에서 base 인코딩으로의 변환을 설명하기 위해, 입력은 입력이 저장되는 구조로, 출력은 그것으로부터 추출됩니다. base 64의 경우, 아래에 [5]에서 차용한 것이 있습니다:

         +--first octet--+-second octet--+--third octet--+
         |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
         +-----------+---+-------+-------+---+-----------+
         |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|
         +--1.index--+--2.index--+--3.index--+--4.index--+

   base 32의 경우, 각 연속 문자는 기반 옥텟 시퀀스의 5개의 연속 비트를 나타냅니다. 따라서, 각 8문자 그룹은 5옥텟(40비트)의 시퀀스를 나타냅니다. 이것은 시각적으로 [7]에서 차용하여 다음과 같이 나타낼 수 있습니다:

                        1          2          3
             01234567 89012345 67890123 45678901 23456789
            +--------+--------+--------+--------+--------+
            |< 1 >< 2| >< 3 ><|.4 >< 5.|>< 6 ><.|7 >< 8 >|
            +--------+--------+--------+--------+--------+
                                                    <===> 8번째 문자
                                              <====> 7번째 문자
                                         <===> 6번째 문자
                                   <====> 5번째 문자
                             <====> 4번째 문자
                        <===> 3번째 문자
                  <====> 2번째 문자
             <===> 1번째 문자

   다음 예시에서는 입력 데이터가 3개의 옥텟 시퀀스의 정수배인 경우, 8비트 데이터 입력 그룹에서 base 64 인코딩으로의 변환이 이루어집니다.

   입력 데이터:  0x14fb9c03d97e

       Hex:     1   4    f   b    9   c     | 0   3    d   9    7   e
       8-bit:   00010100 11111011 10011100  | 00000011 11011001 01111110
       6-bit:   000101 001111 101110 011100 | 000000 111101 100101 111110
       Decimal: 5      15     46     28       0      61     37     62
       Output:  F      P      u      c       A      9      l      +

   입력 데이터가 3개의 옥텟의 정수배가 아닌 경우, 특별한 패딩 처리가 이루어지며, 나머지가 단일 옥텟인 경우 패딩 문자가 2개, 나머지가 2개의 옥텟인 경우 패딩 문자가 1개가 뒤따릅니다.

   입력 데이터:  0x14fb9c03d9

       Hex:     1   4    f   b    9   c     | 0   3    d   9
       8-bit:   00010100 11111011 10011100  | 00000011 11011001
                                                       pad with 00
       6-bit:   000101 001111 101110 011100 | 000000 111101 100100
       Decimal: 5      15     46     28       0      61     36
                                                          pad with =
       Output:  F      P      u      c       A      9      k      =

   입력 데이터:  0x14fb9c03

       Hex:     1   4    f   b    9   c     | 0   3
       8-bit:   00010100 11111011 10011100  | 00000011
                                              pad with 0000
       6-bit:   000101 001111 101110 011100 | 000000 110000
       Decimal: 5      15     46     28       0      48
                                                    pad with =      =
       Output:  F      P      u      c       A      w      =      =

10. 테스트 벡터

   BASE64("") = ""

   BASE64("f") = "Zg=="

   BASE64("fo") = "Zm8="

   BASE64("foo") = "Zm9v"

   BASE64("foob") = "Zm9vYg=="

   BASE64("fooba") = "Zm9vYmE="

   BASE64("foobar") = "Zm9vYmFy"

   BASE32("") = ""

   BASE32("f") = "MY======"

   BASE32("fo") = "MZXQ===="

   BASE32("foo") = "MZXW6==="

   BASE32("foob") = "MZXW6YQ="

   BASE32("fooba") = "MZXW6YTB"

   BASE32("foobar") = "MZXW6YTBOI======"

   BASE32-HEX("") = ""

   BASE32-HEX("f") = "CO======"

   BASE32-HEX("fo") = "CPNG===="

   BASE32-HEX("foo") = "CPNMU==="

   BASE32-HEX("foob") = "CPNMUOG="

   BASE32-HEX("fooba") = "CPNMUOJ1"

   BASE32-HEX("foobar") = "CPNMUOJ1E8======"

   BASE16("") = ""

   BASE16("f") = "66"

   BASE16("fo") = "666F"

   BASE16("foo") = "666F6F"

   BASE16("foob") = "666F6F62"

   BASE16("fooba") = "666F6F6261"

   BASE16("foobar") = "666F6F626172"

11. Base64의 ISO C99 구현

   RFC 4648의 모든 권고사항을 따르는 것으로 확인된 ISO C99 구현은 다음에서 이용 가능합니다:

      http://josefsson.org/base-encoding/

   이 코드는 규범적이지 않습니다.

   절차상의 이유(RFC 3978 섹션 5.4)로 인해 코드를 이 RFC에 포함할 수 없었습니다.

12. 보안 고려사항

   base 인코딩과 디코딩이 구현될 때, 버퍼 오버플로우 공격이나 구현에 대한 기타 공격에 취약점을 도입하지 않도록 주의해야 합니다. 디코더는 예를 들어 내장된 NUL 문자(ASCII 0)를 포함한 잘못된 입력에서 중단되어서는 안 됩니다.

   알파벳 외 문자가 (권장대로) 전체 인코딩의 거부를 유발하는 대신 무시되면, 정보를 "유출"하는 데 사용될 수 있는 은닉 채널이 가능해집니다. 무시된 문자는 또한 문자열 동일성 비교를 회피하거나 구현 버그를 유발하는 것과 같은 다른 악의적인 목적에 사용될 수 있습니다. 알파벳 외 문자를 무시하는 것의 함의는 권장 관행을 따르지 않는 애플리케이션에서 이해되어야 합니다. 마찬가지로, base 16과 base 32 알파벳이 대소문자를 구분하지 않고 처리될 때, 대소문자의 변경이 정보를 유출하거나 문자열 동일성 비교를 실패하게 만드는 데 사용될 수 있습니다.

   패딩이 사용될 때, 보안 우려를 야기하는 일부 비유의적 비트가 있으며, 이는 정보를 유출하기 위해 남용되거나 문자열 동일성 비교를 우회하거나 구현 문제를 유발하는 데 사용될 수 있습니다.

   Base 인코딩은 비밀번호와 같이 쉽게 인식할 수 있는 정보를 시각적으로 숨기지만, 어떠한 계산적 기밀성도 제공하지 않습니다. 이것은, 예를 들어 사용자가 (아마도 다른 문제를 설명하기 위해) 네트워크 프로토콜 교환의 세부사항을 보고하면서 base 인코딩이 비밀번호를 보호하지 않는다는 것을 인지하지 못해 실수로 비밀번호를 노출하는 등의 보안 사고를 유발하는 것으로 알려져 있습니다.

   Base 인코딩은 평문에 엔트로피를 추가하지 않지만, 사용 가능한 평문의 양을 증가시키고 특성적 확률 분포의 형태로 암호 분석을 위한 서명을 제공합니다.

13. RFC 3548 이후 변경사항

   인코딩된 데이터의 정렬 순서를 유지하기 위한 "base32 확장 16진수 알파벳"을 추가하였습니다. 그곳에서 사용되는 특수한 Base 64 인코딩을 위해 IMAP [8]을 참조하였습니다. [5]의 예시를 수정하였습니다. 암호 분석 서명에 대한 보안 고려사항을 추가하였습니다. 테스트 벡터를 추가하였습니다. 오타를 수정하였습니다.

14. 감사의 글

   몇 가지 유용한 제안을 해주신 분들께 감사드립니다. 이 문서에 대한 논평자들은 John E. Hadstate, Tony Hansen, Gordon Mohr, John Myers, Chris Newman, Andrew Sieber 등입니다. 이 문서의 텍스트는 특정 base 인코딩의 사용을 기술하는 이전 RFC들에서 차용되었습니다. 이 작업을 지원해 주신 RSA Laboratories에 감사드립니다.

   개정 버전에 대한 논평에는 Roy Arends, Eric Blake, Brian E Carpenter, Elwyn Davies, Bill Fenner, Sam Hartman, Ted Hardie, Per Hygum, Jelte Jansen, Clement Kent, Tero Kivinen, Paul Kwiatkowski, Ben Laurie를 포함한 여러 사람들로부터의 의견이 반영되었습니다.

15. 복사 조건

   Copyright (c) 2000-2006 Simon Josefsson

   이 문서의 초록과 (Simon Josefsson이 작성한) 섹션 1, 3, 8, 10, 12, 13, 14에 관하여, 저자는 어떠한 보증도 하지 않으며 이 정보의 사용으로 인한 손해에 대해 어떠한 책임도 지지 않습니다. 저자는 타인의 권리를 감소시키지 않는 방식으로 이 정보를 수정하고 어떠한 방식으로든 배포할 수 있는 취소 불가능한 허가를 부여합니다. 단, 재배포된 파생물은 오도하는 저자 귀속을 포함하지 않아야 합니다. 파생물은 IETF RFC 문서인 것으로 주장해서는 안 됩니다. 파생 작품은 유사한 라이선스 조건 하에 이용 가능하게 될 필요가 없습니다.

16. 참고 문헌

16.1. 규범적 참고 문헌

   [1]  Cerf, V., "ASCII format for network interchange", RFC 20,
        October 1969.

   [2]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

16.2. 참고적 참고 문헌

   [3]  Linn, J., "Privacy Enhancement for Internet Electronic Mail:
        Part I: Message Encryption and Authentication Procedures",
        RFC 1421, February 1993.

   [4]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
        Extensions (MIME) Part One: Format of Internet Message Bodies",
        RFC 2045, November 1996.

   [5]  Callas, J., Donnerhacke, L., Finney, H., and R. Thayer,
        "OpenPGP Message Format", RFC 2440, November 1998.

   [6]  Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose,
        "DNS Security Introduction and Requirements", RFC 4033,
        March 2005.

   [7]  Klyne, G. and L. Masinter, "Identifying Composite Media
        Features", RFC 2938, September 2000.

   [8]  Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
        4rev1", RFC 3501, March 2003.

   [9]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
        Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986,
        January 2005.

   [10] Laurie, B., Sisson, G., Arends, R., and D. Blacka, "DNSSEC
        Hash Authenticated Denial of Existence", Work in Progress,
        June 2006.

   [11] Myers, J., "SASL GSSAPI mechanisms", Work in Progress,
        May 2000.

   [12] Wilcox-O'Hearn, B., "Post to P2P-hackers mailing list",
        http://zgp.org/pipermail/p2p-hackers/2001-September/
        000315.html, September 2001.

저자 주소

   Simon Josefsson
   SJD
   EMail: simon@josefsson.org

전체 저작권 선언

   Copyright (C) The Internet Society (2006).

   이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한의 적용을 받으며, 이 문서에 명시된 경우를 제외하고 저자는 모든 권리를 보유합니다.

   이 문서와 여기에 포함된 정보는 "있는 그대로(AS IS)" 제공되며, 기여자, 그/그녀가 대표하거나 후원하는 조직(있는 경우), 인터넷 사회 및 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증을 포함하되 이에 국한되지 않는 어떠한 권리도 침해하지 않을 것이라는 것에 대해 명시적이든 묵시적이든 모든 보증을 부인합니다.

지적 재산권

   IETF는 이 문서에 기술된 기술의 구현이나 사용에 관련될 수 있는 지적 재산권이나 기타 권리의 유효성 또는 범위, 또는 그러한 권리에 따른 라이선스가 이용 가능하거나 이용 가능하지 않을 수 있는 범위에 대해 어떠한 입장도 취하지 않습니다; 또한 그러한 권리를 식별하기 위한 독립적인 노력을 기울였다는 것을 표명하지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78과 BCP 79에서 찾을 수 있습니다.

   IETF 사무국에 제출된 IPR 공개의 사본과 이용 가능한 라이선스에 대한 보증, 또는 이 명세서의 구현자나 사용자가 그러한 독점적 권리의 사용에 대한 일반 라이선스나 허가를 얻으려는 시도의 결과는 IETF 온라인 IPR 저장소(http://www.ietf.org/ipr)에서 얻을 수 있습니다.

   IETF는 이 표준의 구현에 필요할 수 있는 기술에 적용될 수 있는 저작권, 특허 또는 특허 출원, 기타 독점적 권리에 관심을 기울여 달라는 관련 당사자의 요청을 초대합니다. 정보는 IETF(ietf-ipr@ietf.org)로 보내주시기 바랍니다.

감사의 글

   RFC 편집기 기능에 대한 자금은 IETF 관리 지원 활동(IASA)에 의해 제공됩니다.
