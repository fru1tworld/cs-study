# RFC 1122: Requirements for Internet Hosts - Communication Layers

> 인터넷 호스트의 통신 계층 요구사항

## 문서 정보

| 항목 | 내용 |
|------|------|
| RFC 번호 | 1122 |
| 분류 | STD 3 (Internet Standard) |
| 편집자 | R. Braden (ISI) |
| 발행일 | 1989년 10월 |
| 상태 | 현행 표준 |
| 관련 문서 | RFC 1123 (Application Layer) |

## 개요

RFC 1122는 인터넷 호스트 소프트웨어의 통신 프로토콜 계층 에 대한 요구사항을 정의합니다. 이 문서는 벤더, 구현자, 인터넷 통신 소프트웨어 사용자를 위한 가이드라인을 제공합니다.

이 문서는 RFC 1123과 함께 호스트 요구사항의 표준 문서(STD 3) 를 구성합니다:
- RFC 1122: Link Layer, IP Layer, Transport Layer (이 문서)
- RFC 1123: Application Layer 및 지원 프로토콜

---

## 핵심 설계 원칙

### 견고성 원칙 (Robustness Principle)

> "Be liberal in what you accept, and conservative in what you send"
>
> "받는 것에는 관대하고, 보내는 것에는 보수적으로 하라"

이 원칙은 인터넷 아키텍처의 초석 입니다:

- 하나의 잘못 동작하는 호스트가 다른 많은 호스트에게 서비스 장애를 일으킬 수 있음
- 모든 구현체는 명세를 엄격히 따라 전송해야 함
- 다른 구현체의 결함을 수용할 수 있도록 수신에는 유연해야 함

```
송신 시: 명세를 100% 준수
수신 시: 유효한 입력은 물론, 다소 벗어난 입력도 처리 가능해야 함
```

### 다른 핵심 원칙들

1. 구성 가능성 (Configurability)
   - 파라미터는 합리적인 기본값을 가져야 함
   - 필요시 재정의 가능해야 함

2. 오류 로깅 (Error Logging)
   - 상세한 로깅 기능 제공
   - 리소스 고갈 없이 동작해야 함

3. 진화 (Evolution)
   - 프로토콜 명세는 변경될 수 있음
   - 구현체는 업데이트를 지원해야 함

4. 상호운용성 (Interoperability)
   - 네트워크 특성에 관계없이 다양한 인터넷 경로에서 완전히 동작해야 함

---

## 인터넷 프로토콜 계층 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                         │
│         (사용자 프로토콜 + 지원 프로토콜)                    │
│                     → RFC 1123                               │
├─────────────────────────────────────────────────────────────┤
│                    Transport Layer                           │
│              (TCP, UDP - 종단간 통신)                        │
├─────────────────────────────────────────────────────────────┤
│                    Internet Layer                            │
│               (IP, ICMP, IGMP - 라우팅)                      │
├─────────────────────────────────────────────────────────────┤
│                      Link Layer                              │
│          (ARP, 물리적 네트워크 인터페이스)                   │
└─────────────────────────────────────────────────────────────┘
                    → RFC 1122 (이 문서)
```

---

## 1. Link Layer (링크 계층)

### 개요

링크 계층은 직접 연결된 네트워크에서 통신을 처리합니다. 다양한 네트워크 유형에 따라 여러 종류의 링크 계층 프로토콜이 존재합니다.

### 핵심 요구사항

#### Trailer Protocol (트레일러 프로토콜)

| 요구사항 | 수준 |
|----------|------|
| 양쪽 시스템이 지원하는지 확인 후에만 사용 | MAY |
| 기본값은 비활성화 | MUST |

#### ARP (Address Resolution Protocol) 관리

```
┌────────────────────────────────────────────────────────────┐
│                    ARP 캐시 관리                            │
├────────────────────────────────────────────────────────────┤
│  • 오래된 캐시 항목 삭제 (MUST)                             │
│  • 구성 가능한 타임아웃 메커니즘 (MUST)                     │
│  • 요청 플러딩 방지: 목적지당 최대 1요청/초 (MUST)         │
│  • 미해결 주소에 대해 최소 마지막 패킷 유지 (SHOULD)       │
│  • 해결 시 패킷 전송 (SHOULD)                               │
└────────────────────────────────────────────────────────────┘
```

ARP 캐시 항목 무효화가 필요한 이유:
- 네트워크 카드 교체
- IP 주소 재할당
- 호스트 이동
- 보안 (ARP 스푸핑 방지)

#### Ethernet 지원

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| RFC-894 캡슐화 송수신 | MUST | 표준 Ethernet 프레임 |
| RFC-1042 캡슐화 수신 | SHOULD | IEEE 802.3 프레임 |
| RFC-1042 캡슐화 송신 | MAY | 구성 스위치로 제어, 기본값 RFC-894 |

#### MTU (Maximum Transmission Unit) 값

| 네트워크 유형 | MTU (바이트) |
|--------------|-------------|
| Ethernet | 1500 |
| IEEE 802.3 | 1492 |

---

## 2. Internet Layer (인터넷 계층)

### 개요

인터넷 계층은 IP 주소 지정, 서비스 유형 지정, 단편화 및 재조립, 보안 정보를 포함합니다. 비연결형(connectionless) 특성 이 인터넷 아키텍처의 근본적인 특징입니다.

### IP 프로토콜 요구사항

#### 헤더 처리

```
┌─────────────────────────────────────────────────────────────┐
│                   IP 헤더 요구사항                           │
├─────────────────────────────────────────────────────────────┤
│  ✓ 헤더 체크섬 검증 (MUST)                                  │
│  ✓ 유효하지 않은 데이터그램은 조용히 폐기 (MUST)           │
│  ✓ 서브넷 확장 및 주소 마스크 지원 (MUST)                  │
│  ✓ 소스 주소는 호스트 자신의 주소여야 함 (MUST)            │
│  ✓ 브로드캐스트/멀티캐스트를 소스로 사용 금지 (MUST NOT)   │
│  ✓ 유효하지 않은 소스 주소의 데이터그램 폐기 (MUST)        │
└─────────────────────────────────────────────────────────────┘
```

#### 단편화 및 재조립

| 요구사항 | 수준 |
|----------|------|
| 단편화된 데이터그램 재조립 지원 | MUST |
| TTL 값 0으로 전송하지 않음 | MUST |
| 전송 계층에 TOS/TTL 설정 수단 제공 | MUST |

#### IP 옵션 처리

```
IP/Transport 계층은:
- 이해하는 IP 옵션은 해석해야 함 (MUST)
- 이해하지 못하는 옵션은 조용히 무시해야 함 (MUST)
```

| IP 옵션 | 요구사항 |
|---------|----------|
| Source Route | 발신 지원 (MUST), 최종 목적지 역할 (MUST) |
| Record Route | 지원 (SHOULD) |
| Timestamp | 지원 (SHOULD) |
| Stream Identifier | 폐기됨 - 전송 금지 (SHOULD NOT), 수신 시 무시 (MUST) |

### 게이트웨이 기능

호스트에 내장된 게이트웨이 코드가 있는 경우:

```
┌─────────────────────────────────────────────────────────────┐
│                게이트웨이 기능 요구사항                       │
├─────────────────────────────────────────────────────────────┤
│  1. 게이트웨이 기능 비활성화 구성 스위치 포함 (MUST)        │
│  2. 기본값은 비활성화 (MUST)                                 │
│  3. 다중 인터페이스라도 자동으로 게이트웨이 모드 전환 금지   │
│     (MUST NOT)                                               │
│  4. 게이트웨이 명세 요구사항 준수 (MUST)                    │
└─────────────────────────────────────────────────────────────┘
```

중요: 멀티홈 호스트(여러 인터페이스를 가진 호스트)라고 해서 자동으로 게이트웨이 역할을 해서는 안 됩니다.

### ICMP (Internet Control Message Protocol)

ICMP는 IP의 필수적인 부분 으로, 아키텍처적으로는 IP 위에 계층화되어 있습니다.

#### ICMP 주요 기능

```
┌────────────────┬────────────────────────────────────────────┐
│   기능         │   설명                                      │
├────────────────┼────────────────────────────────────────────┤
│ 오류 보고      │ 전달 불가, 시간 초과 등                    │
│ 혼잡 보고      │ Source Quench 메시지                       │
│ 리다이렉트     │ 첫 번째 홉 게이트웨이 재지정               │
│ 진단          │ Echo Request/Reply (ping)                  │
└────────────────┴────────────────────────────────────────────┘
```

#### ICMP 요구사항

| 요구사항 | 수준 |
|----------|------|
| 알 수 없는 타입의 ICMP 메시지는 조용히 폐기 | MUST |
| ICMP 오류 메시지에 원본 데이터그램의 8 옥텟 이상 포함 | SHOULD |
| ICMP 오류를 전송 프로토콜로 역다중화 | MUST |
| ICMP 오류 메시지 전송 시 TOS=0 사용 | MUST |

### 라우팅 결정

호스트는 나가는 데이터그램의 "다음 홉(next hop)" 을 결정해야 합니다:

```
                    목적지 주소
                         │
                         ▼
              ┌─────────────────────┐
              │ 같은 서브넷인가?    │
              └─────────────────────┘
                    │         │
                   예         아니오
                    │         │
                    ▼         ▼
               직접 전송   게이트웨이로 전송
                              │
                              ▼
                    ┌─────────────────┐
                    │ 라우팅 테이블   │
                    │ 조회           │
                    └─────────────────┘
```

필수 기능:
- 죽은 게이트웨이 탐지 (Dead Gateway Detection)
- 라우트 캐싱 전략

### "조용히 폐기 (Silently Discard)" 정의

> 데이터그램을 추가 처리 없이 폐기하며, ICMP 오류 메시지를 보내지 않습니다.

하지만:
- 오류 로깅 기능 제공 (SHOULD)
- 폐기된 데이터그램 내용 포함 (SHOULD)
- 통계 카운터에 이벤트 기록 (SHOULD)

### ICMP 메시지 유형별 처리 요구사항

#### 쿼리 메시지 (Query Messages)

```
┌────────────────────────────────────────────────────────────────────┐
│                    ICMP 쿼리 메시지 처리                            │
├────────────────────────────────────────────────────────────────────┤
│  Echo (Type 8/0)                                                    │
│  ├─ Echo Request 수신 시 Echo Reply 응답 (MUST)                    │
│  ├─ 수신된 데이터를 Reply에 그대로 포함 (MUST)                     │
│  └─ 브로드캐스트/멀티캐스트 주소로 수신된 Echo에도 응답 (MAY)      │
│                                                                     │
│  Timestamp (Type 13/14)                                             │
│  ├─ Timestamp Request 수신 시 Reply 응답 (SHOULD)                  │
│  ├─ Originate Timestamp를 정확한 시간으로 설정 (MUST)              │
│  └─ 밀리초 단위 시간 사용 (자정 기준 UTC) (SHOULD)                 │
│                                                                     │
│  Address Mask (Type 17/18)                                          │
│  ├─ 호스트는 Address Mask Request 전송 가능 (MAY)                  │
│  ├─ Address Mask Reply 수신 시 서브넷 마스크 설정 (SHOULD)         │
│  └─ 권한 있는 응답만 수락 (SHOULD)                                  │
│                                                                     │
│  Information Request/Reply (Type 15/16)                             │
│  └─ 폐기됨 - 구현 금지 (SHOULD NOT)                                 │
└────────────────────────────────────────────────────────────────────┘
```

#### 오류 메시지 (Error Messages)

| 메시지 유형 | Type | 요구사항 | 처리 방법 |
|-------------|------|----------|-----------|
| Destination Unreachable | 3 | MUST 처리 | 상위 계층에 통지, 연결 중단 판단 |
| Redirect | 5 | MUST 처리 | 라우팅 테이블 업데이트 |
| Time Exceeded | 11 | MUST 처리 | Traceroute 지원, 재조립 실패 알림 |
| Parameter Problem | 12 | MUST 처리 | 잘못된 헤더 필드 진단 |
| Source Quench | 4 | MAY 처리 | 혼잡 제어 신호 (폐기 예정) |

#### Destination Unreachable 코드별 처리

```
┌─────────────────────────────────────────────────────────────────────┐
│              Destination Unreachable 코드 상세                       │
├──────┬──────────────────────────────┬───────────────────────────────┤
│ Code │ 의미                          │ 처리 방법                      │
├──────┼──────────────────────────────┼───────────────────────────────┤
│  0   │ Net Unreachable              │ 라우팅 실패로 처리            │
│  1   │ Host Unreachable             │ 해당 호스트 도달 불가         │
│  2   │ Protocol Unreachable         │ 프로토콜 사용 불가            │
│  3   │ Port Unreachable             │ 포트 닫힘 (UDP: 연결 거부)    │
│  4   │ Fragmentation Needed         │ Path MTU Discovery 지원       │
│  5   │ Source Route Failed          │ 소스 라우팅 실패              │
│  6   │ Destination Network Unknown  │ 네트워크 존재하지 않음        │
│  7   │ Destination Host Unknown     │ 호스트 존재하지 않음          │
│  8   │ Source Host Isolated         │ 소스 호스트 격리됨            │
│  9   │ Network Administratively     │ 관리적으로 네트워크 금지      │
│      │ Prohibited                   │                               │
│ 10   │ Host Administratively        │ 관리적으로 호스트 금지        │
│      │ Prohibited                   │                               │
│ 11   │ Network Unreachable for TOS  │ 해당 TOS로 네트워크 도달 불가 │
│ 12   │ Host Unreachable for TOS     │ 해당 TOS로 호스트 도달 불가   │
└──────┴──────────────────────────────┴───────────────────────────────┘
```

#### ICMP 오류 메시지 생성 규칙

```
┌─────────────────────────────────────────────────────────────────────┐
│           ICMP 오류 메시지를 생성하지 말아야 하는 경우              │
├─────────────────────────────────────────────────────────────────────┤
│  ✗ ICMP 오류 메시지에 대한 응답으로 (MUST NOT)                      │
│  ✗ 첫 번째 단편이 아닌 IP 단편에 대해 (MUST NOT)                   │
│  ✗ 브로드캐스트/멀티캐스트 주소로 전송된 데이터그램에 대해         │
│    (MUST NOT)                                                        │
│  ✗ 링크 계층 브로드캐스트로 전송된 데이터그램에 대해 (MUST NOT)    │
│  ✗ 소스 주소가 0.0.0.0인 데이터그램에 대해 (MUST NOT)              │
│  ✗ 소스 주소가 루프백인 데이터그램에 대해 (MUST NOT)               │
└─────────────────────────────────────────────────────────────────────┘
```

### IGMP (Internet Group Management Protocol)

IGMP는 호스트가 멀티캐스트 그룹 멤버십을 라우터에 보고하는 데 사용됩니다.

#### IGMP 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│                        IGMP 기능                                     │
├─────────────────────────────────────────────────────────────────────┤
│  • 멀티캐스트 그룹 참가/탈퇴 관리                                   │
│  • 로컬 멀티캐스트 라우터에 그룹 멤버십 보고                        │
│  • 효율적인 멀티캐스트 트래픽 배포 지원                             │
└─────────────────────────────────────────────────────────────────────┘
```

#### IGMP 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| IGMP 구현 | SHOULD | 멀티캐스트 지원 시 |
| Host Membership Query 응답 | MUST | 멀티캐스트 지원 시 |
| Host Membership Report 전송 | MUST | 그룹 참가 시 |
| 모든 호스트 그룹(224.0.0.1) 참가 | MUST | 멀티캐스트 지원 시 |
| 그룹 탈퇴 시 Leave 메시지 | SHOULD | IGMPv2 이상 |

#### IGMP 메시지 유형

```
┌────────────────────────────────────────────────────────────────────┐
│                     IGMP 메시지 유형                                │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Membership Query (Type 0x11)                                       │
│  ├─ 라우터가 그룹 멤버십 확인을 위해 전송                          │
│  ├─ General Query: 모든 그룹에 대한 질의                           │
│  └─ Group-Specific Query: 특정 그룹에 대한 질의                    │
│                                                                     │
│  Membership Report (Type 0x16 for IGMPv2)                           │
│  ├─ 호스트가 그룹 멤버십을 보고                                    │
│  └─ Query 응답 또는 그룹 참가 시 전송                               │
│                                                                     │
│  Leave Group (Type 0x17 for IGMPv2)                                 │
│  ├─ 호스트가 그룹 탈퇴를 알림                                      │
│  └─ 마지막 멤버가 탈퇴 시 신속한 정리 지원                         │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

#### IGMP 타이밍 요구사항

| 파라미터 | 기본값 | 설명 |
|----------|--------|------|
| Query 응답 간격 | 10초 | 최대 응답 시간 |
| Unsolicited Report 간격 | 1-10초 | 무작위 지연 |
| Robustness Variable | 2 | 패킷 손실 대비 |

### 브로드캐스트 및 멀티캐스트 처리

#### 브로드캐스트 주소 유형

```
┌─────────────────────────────────────────────────────────────────────┐
│                    브로드캐스트 주소 유형                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Limited Broadcast: 255.255.255.255                                  │
│  ├─ 로컬 네트워크로만 제한                                          │
│  └─ 라우터를 통과하지 않음                                          │
│                                                                      │
│  Directed Broadcast: 네트워크.255 (예: 192.168.1.255)               │
│  ├─ 특정 네트워크의 모든 호스트에 전달                              │
│  └─ 라우터를 통과할 수 있음                                         │
│                                                                      │
│  Subnet Broadcast: 서브넷.255                                        │
│  └─ 특정 서브넷의 모든 호스트에 전달                                │
│                                                                      │
│  All-zeros Broadcast (구형): 네트워크.0                              │
│  └─ 역사적 이유로 인식해야 함                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 브로드캐스트 처리 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| Limited Broadcast 수신 인식 | MUST | 255.255.255.255 |
| Directed Broadcast 수신 인식 | MUST | 자신의 네트워크로 향하는 경우 |
| 브로드캐스트 주소를 소스로 사용 금지 | MUST NOT | |
| 브로드캐스트 수신 시 ICMP 오류 응답 금지 | MUST NOT | |
| All-zeros 브로드캐스트 형식 인식 | SHOULD | 수신 시 |

#### 멀티캐스트 처리 요구사항

```
┌─────────────────────────────────────────────────────────────────────┐
│                  멀티캐스트 요구사항                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  IP 멀티캐스트 지원 (SHOULD)                                        │
│  ├─ 클래스 D 주소 (224.0.0.0 - 239.255.255.255) 인식               │
│  ├─ 멀티캐스트 그룹 참가/탈퇴 기능                                  │
│  └─ IGMP 프로토콜 구현                                              │
│                                                                      │
│  로컬 멀티캐스트 (링크-로컬) 지원 (MUST, 멀티캐스트 지원 시)       │
│  ├─ 224.0.0.0 - 224.0.0.255 범위                                    │
│  └─ TTL=1로 전송, 라우터 통과 금지                                  │
│                                                                      │
│  멀티캐스트 전송 시 요구사항                                        │
│  ├─ 적절한 TTL 설정 (MUST)                                          │
│  ├─ 루프백 제어 가능 (SHOULD)                                       │
│  └─ 소스 주소는 유니캐스트여야 함 (MUST)                            │
│                                                                      │
│  멀티캐스트 수신 시 요구사항                                        │
│  ├─ 참가한 그룹의 패킷만 상위 계층에 전달 (MUST)                   │
│  └─ 멀티캐스트 수신 시 ICMP 오류 응답 금지 (MUST NOT)              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 예약된 멀티캐스트 주소

| 주소 | 설명 | 용도 |
|------|------|------|
| 224.0.0.1 | All Hosts | 서브넷의 모든 멀티캐스트 가능 호스트 |
| 224.0.0.2 | All Routers | 서브넷의 모든 멀티캐스트 라우터 |
| 224.0.0.5 | OSPF All Routers | OSPF 라우팅 프로토콜 |
| 224.0.0.6 | OSPF DR Routers | OSPF Designated Router |
| 224.0.0.9 | RIPv2 Routers | RIP 라우팅 프로토콜 |

---

## 3. Transport Layer (전송 계층)

전송 계층은 애플리케이션을 위한 종단간(end-to-end) 통신 서비스 를 제공합니다.

### UDP (User Datagram Protocol)

#### 개요

UDP는 단순하고 비연결형 의 전송 서비스를 제공합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    UDP 특성                                  │
├─────────────────────────────────────────────────────────────┤
│  • 비연결형 (Connectionless)                                │
│  • 비신뢰성 (Unreliable) - 전달 보장 없음                  │
│  • 순서 보장 없음                                           │
│  • 낮은 오버헤드                                            │
│  • 빠른 전송                                                │
└─────────────────────────────────────────────────────────────┘
```

#### UDP 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| 포트 주소 지정 적절히 처리 | MUST | |
| IP 옵션 및 ICMP 메시지 처리 | SHOULD | |
| 체크섬 | RECOMMENDED | 일부 컨텍스트에서는 필수 |
| 멀티홈 지원 | SHOULD | 해당되는 경우 |
| ICMP 오류 메시지를 애플리케이션 계층으로 전달 | MUST | |

### TCP (Transmission Control Protocol)

#### 개요

TCP는 신뢰성 있는 연결 지향 전송 서비스를 제공합니다:
- 종단간 신뢰성 (End-to-end Reliability)
- 재정렬 (Resequencing)
- 흐름 제어 (Flow Control)

```
┌─────────────────────────────────────────────────────────────┐
│                    TCP 특성                                  │
├─────────────────────────────────────────────────────────────┤
│  • 연결 지향 (Connection-oriented)                          │
│  • 신뢰성 (Reliable) - 전달 보장                           │
│  • 순서 보장 (In-order delivery)                           │
│  • 흐름 제어 (Flow control)                                 │
│  • 혼잡 제어 (Congestion control)                           │
│  • 바이트 스트림 (Byte stream)                              │
└─────────────────────────────────────────────────────────────┘
```

#### TCP 상태 머신 (State Machine)

TCP 연결은 유한 상태 머신(Finite State Machine)으로 관리됩니다. 모든 TCP 구현체는 이 상태 전이를 정확히 따라야 합니다 (MUST).

```
┌─────────────────────────────────────────────────────────────────────┐
│                     TCP 상태 다이어그램                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│                           ┌─────────┐                               │
│                           │ CLOSED  │                               │
│                           └────┬────┘                               │
│                    ┌───────────┴───────────┐                        │
│              passive open              active open                   │
│              (listen)                  (connect)                     │
│                    ▼                       ▼                         │
│              ┌─────────┐             ┌──────────┐                   │
│              │ LISTEN  │             │ SYN-SENT │                   │
│              └────┬────┘             └────┬─────┘                   │
│                   │ rcv SYN               │ rcv SYN+ACK             │
│                   │ snd SYN+ACK           │ snd ACK                 │
│                   ▼                       ▼                         │
│              ┌──────────┐           ┌─────────────┐                 │
│              │ SYN-RCVD │──────────▶│ ESTABLISHED │                 │
│              └──────────┘  rcv ACK  └──────┬──────┘                 │
│                                            │                         │
│                    ┌───────────────────────┴────────────────┐       │
│              close │                                   rcv FIN      │
│              snd FIN                                   snd ACK      │
│                    ▼                                        ▼       │
│              ┌──────────┐                          ┌────────────┐   │
│              │ FIN-WAIT-1│                         │ CLOSE-WAIT │   │
│              └────┬─────┘                          └─────┬──────┘   │
│                   │ rcv ACK                              │ close    │
│                   ▼                                      │ snd FIN  │
│              ┌──────────┐                                ▼          │
│              │ FIN-WAIT-2│                         ┌──────────┐     │
│              └────┬─────┘                          │ LAST-ACK │     │
│                   │ rcv FIN                        └────┬─────┘     │
│                   │ snd ACK                             │ rcv ACK   │
│                   ▼                                     ▼           │
│              ┌──────────┐                          ┌─────────┐      │
│              │ TIME-WAIT│─────── 2MSL timeout ────▶│ CLOSED  │      │
│              └──────────┘                          └─────────┘      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

##### TCP 상태 설명

| 상태 | 설명 |
|------|------|
| CLOSED | 연결 없음 (초기/최종 상태) |
| LISTEN | 수동 열기, 연결 요청 대기 중 |
| SYN-SENT | SYN 전송, 연결 설정 시도 중 |
| SYN-RCVD | SYN 수신, SYN+ACK 전송 완료 |
| ESTABLISHED | 연결 설정 완료, 데이터 전송 가능 |
| FIN-WAIT-1 | 종료 시작, FIN 전송 완료 |
| FIN-WAIT-2 | FIN에 대한 ACK 수신, 상대방 FIN 대기 |
| CLOSE-WAIT | 상대방 FIN 수신, 애플리케이션 종료 대기 |
| LAST-ACK | FIN 전송, 최종 ACK 대기 |
| TIME-WAIT | 2MSL 대기 (지연된 세그먼트 처리) |
| CLOSING | 동시 종료 상황 (양측이 동시에 FIN 전송) |

##### 상태 머신 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| 모든 상태 전이 정확히 구현 | MUST | RFC 793 상태 다이어그램 준수 |
| TIME-WAIT 상태에서 2MSL 대기 | MUST | 일반적으로 2분 (MSL=1분) |
| 동시 열기(Simultaneous Open) 처리 | MUST | 양측이 동시에 SYN 전송 |
| 동시 종료(Simultaneous Close) 처리 | MUST | 양측이 동시에 FIN 전송 |
| Half-Close 지원 | MUST | 한쪽만 종료 가능 |

#### TCP 상세 요구사항

##### 연결 관리 (Connection Management)

| 요구사항 | 수준 |
|----------|------|
| 적절한 상태 전이 | MUST |
| 동시 열기(simultaneous opens) 처리 | MUST |
| RST 세그먼트 동작 적절히 처리 | MUST |
| 초기 시퀀스 번호(ISN) 임의 선택 | MUST |
| 연결당 고유 소켓 쌍 사용 | MUST |

##### RST 세그먼트 처리

```
┌─────────────────────────────────────────────────────────────────────┐
│                    RST 세그먼트 요구사항                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  RST 수신 시:                                                        │
│  ├─ SYN-SENT 상태: 허용 가능한 ACK를 가진 경우에만 처리 (MUST)      │
│  ├─ LISTEN 상태: 무시 (MUST)                                         │
│  ├─ 다른 상태: 시퀀스 번호가 윈도우 내에 있으면 처리 (MUST)         │
│  └─ 연결 중단 및 애플리케이션에 통지 (MUST)                         │
│                                                                      │
│  RST 전송 시:                                                        │
│  ├─ CLOSED 상태에서 세그먼트 수신 시 (MUST)                         │
│  ├─ ACK 비트 없는 세그먼트: SEQ=0, ACK=SEG.SEQ+SEG.LEN             │
│  └─ ACK 비트 있는 세그먼트: SEQ=SEG.ACK                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

##### 재전송 (Retransmission)

```
┌─────────────────────────────────────────────────────────────┐
│              TCP 재전송 타이머 (RTO) 계산                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  SRTT = (1 - α) × SRTT + α × RTT                           │
│  RTTVAR = (1 - β) × RTTVAR + β × |SRTT - RTT|             │
│  RTO = SRTT + max(G, K × RTTVAR)                           │
│                                                             │
│  α = 1/8, β = 1/4, K = 4, G = 클럭 단위                   │
│                                                             │
│  초기 RTO: 1초 (RFC 6298에서 업데이트)                     │
│  SYN/SYN-ACK 손실 시: 3초로 복귀                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

재전송 타임아웃 계산 관련 섹션:
- 4.2.3.1: Retransmission Timeout Calculation

##### 혼잡 제어 (Congestion Control)

TCP는 슬로우 스타트(slow start) 와 혼잡 회피(congestion avoidance) 를 구현해야 합니다 (MUST).

```
┌─────────────────────────────────────────────────────────────┐
│                   슬로우 스타트 알고리즘                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  재전송 타임아웃 후:                                        │
│  cwnd = 1 MSS (패킷 1개)                                   │
│                                                             │
│  ACK 수신 시:                                               │
│  cwnd = cwnd + MSS (지수적 증가)                           │
│                                                             │
│  cwnd >= ssthresh 도달 시:                                  │
│  혼잡 회피 모드로 전환                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   혼잡 회피 알고리즘                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  각 ACK 수신 시:                                            │
│  cwnd = cwnd + MSS × MSS / cwnd                            │
│                                                             │
│  → 대략 매 RTT마다 약 1 세그먼트 증가                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

중요: 타임아웃 시 슬로우 스타트에 들어가는 것은 인터넷 혼잡 안정성의 초석 입니다. TCP가 이를 따르지 않으면 네트워크는 "혼잡 붕괴(congestion collapse)" 위험에 처합니다.

##### 흐름 제어 (Flow Control)

| 섹션 | 주제 |
|------|------|
| 4.2.3.2 | When to Send an ACK Segment |
| 4.2.3.3 | When to Send a Window Update |
| 4.2.3.4 | When to Send Data |

요구사항:
- 윈도우 관리 (Window management)
- 제로 윈도우 프로빙 (Zero-window probing)
- 세그먼트 확인응답 타이밍 (Segment acknowledgment timing)

##### Silly Window Syndrome (SWS) 회피

Silly Window Syndrome은 송신자와 수신자가 매우 작은 세그먼트를 교환하여 효율성이 크게 저하되는 현상입니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│              Silly Window Syndrome 발생 시나리오                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  문제 상황:                                                          │
│  1. 수신자의 버퍼가 거의 가득 찬 상태                               │
│  2. 애플리케이션이 1바이트씩 읽음                                   │
│  3. 1바이트 공간이 생길 때마다 윈도우 업데이트 전송                 │
│  4. 송신자가 1바이트씩 전송 → 40바이트 헤더 + 1바이트 데이터       │
│                                                                      │
│  결과: 네트워크 대역폭의 극심한 낭비                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### 수신측 SWS 회피 (Receiver-side SWS Avoidance)

```
┌─────────────────────────────────────────────────────────────────────┐
│                수신측 SWS 회피 알고리즘 (MUST)                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  윈도우 업데이트 전송 조건 (둘 중 하나를 만족해야 함):              │
│                                                                      │
│  조건 1: 사용 가능한 공간 >= min(버퍼 크기의 50%, MSS)              │
│                                                                      │
│  조건 2: 이전에 광고한 윈도우가 0이었고, 이제 전체 세그먼트를       │
│          수신할 수 있는 공간이 생긴 경우                            │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  RCV.BUFF: 수신 버퍼 크기                                            │
│  RCV.USER: 애플리케이션이 읽어간 바이트                             │
│  RCV.WND: 현재 광고 윈도우                                           │
│                                                                      │
│  if (RCV.USER >= min(RCV.BUFF/2, MSS))                              │
│      then 윈도우 업데이트 전송                                       │
│  else                                                                │
│      윈도우 업데이트 지연                                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### 송신측 SWS 회피 (Sender-side SWS Avoidance)

```
┌─────────────────────────────────────────────────────────────────────┐
│                송신측 SWS 회피 알고리즘 (SHOULD)                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  데이터 전송 조건 (다음 중 하나를 만족해야 함):                     │
│                                                                      │
│  1. 전체 MSS 크기의 세그먼트를 전송할 수 있는 경우                  │
│                                                                      │
│  2. 미확인 데이터가 없고 (SND.NXT == SND.UNA):                      │
│     송신 버퍼의 모든 데이터를 전송할 수 있는 경우                   │
│     또는 Nagle 알고리즘이 비활성화된 경우                           │
│                                                                      │
│  3. 수신 윈도우가 max(SND.WND/2, MSS)보다 큰 경우                   │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  이 조건들은 작은 세그먼트의 전송을 방지하고,                       │
│  효율적인 대역폭 사용을 보장합니다.                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

| SWS 회피 요구사항 | 수준 | 설명 |
|-------------------|------|------|
| 수신측 SWS 회피 | MUST | 작은 윈도우 광고 방지 |
| 송신측 SWS 회피 | SHOULD | 작은 세그먼트 전송 방지 |
| Nagle 알고리즘과 함께 사용 | SHOULD | 효율적인 전송 보장 |

##### 데이터 전송 (Data Transmission)

| 요구사항 | 수준 |
|----------|------|
| PUSH 플래그 처리 | MUST |
| 최대 세그먼트 크기(MSS) 협상 | MUST |
| Nagle 알고리즘 구현 | SHOULD |

##### Nagle 알고리즘 (Nagle Algorithm)

Nagle 알고리즘은 작은 패킷의 과도한 전송을 방지하여 네트워크 효율성을 높이는 알고리즘입니다. RFC 896에서 처음 제안되었습니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Nagle 알고리즘 개요                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  문제: 작은 패킷 문제 (Small Packet Problem)                        │
│  ├─ Telnet과 같은 대화형 애플리케이션에서 발생                      │
│  ├─ 1바이트 데이터에 40바이트 헤더 (IP 20 + TCP 20)                │
│  └─ 네트워크에 "Tinygram" 홍수 발생                                 │
│                                                                      │
│  해결: 작은 세그먼트를 모아서 전송                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Nagle 알고리즘 동작 원리

```
┌─────────────────────────────────────────────────────────────────────┐
│                   Nagle 알고리즘 의사코드                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  if (전송할 데이터가 있음) {                                        │
│      if (데이터 크기 >= MSS) {                                      │
│          즉시 전체 MSS 세그먼트 전송                                │
│      }                                                               │
│      else if (미확인(unacknowledged) 데이터가 없음) {               │
│          즉시 작은 세그먼트 전송                                    │
│      }                                                               │
│      else {                                                          │
│          데이터를 버퍼에 축적                                       │
│          ACK 수신 시까지 전송 대기                                  │
│      }                                                               │
│  }                                                                   │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  핵심 원리:                                                          │
│  "미확인 데이터가 있는 동안에는 작은 세그먼트를 전송하지 않는다"   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Nagle 알고리즘 효과

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Nagle 알고리즘 비교                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Nagle 비활성화 시 (매 키 입력마다):                                │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ 'H' → [41 bytes] → 'e' → [41 bytes] → 'l' → [41 bytes] → ...│   │
│  │ 총 5글자 = 5 패킷 × 41 bytes = 205 bytes                     │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  Nagle 활성화 시 (축적 후 전송):                                    │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ 'H' → [41 bytes] → ACK 대기 중 'e','l','l','o' 축적          │   │
│  │ ACK 수신 → 'ello' → [44 bytes]                                │   │
│  │ 총 5글자 = 2 패킷 = 85 bytes                                  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Nagle 알고리즘 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| Nagle 알고리즘 구현 | SHOULD | 작은 세그먼트 통합 |
| 비활성화 옵션 제공 | MUST | TCP_NODELAY 소켓 옵션 |
| 연결별로 구성 가능 | SHOULD | 일부 애플리케이션은 비활성화 필요 |

###### Nagle 알고리즘을 비활성화해야 하는 경우

```
┌─────────────────────────────────────────────────────────────────────┐
│             Nagle 알고리즘 비활성화가 필요한 경우                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 실시간 응답이 중요한 애플리케이션                               │
│     ├─ 온라인 게임 (지연 시간에 민감)                               │
│     ├─ 실시간 금융 거래 시스템                                      │
│     └─ 원격 데스크톱 프로토콜                                       │
│                                                                      │
│  2. 요청-응답 패턴의 프로토콜                                       │
│     ├─ HTTP/1.1 파이프라이닝                                        │
│     └─ 일부 RPC 프로토콜                                            │
│                                                                      │
│  3. 작은 메시지가 독립적인 의미를 가지는 경우                       │
│     └─ 마우스 이동 이벤트, 센서 데이터                              │
│                                                                      │
│  비활성화 방법: setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, 1)       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Nagle 알고리즘과 지연 ACK의 상호작용

```
┌─────────────────────────────────────────────────────────────────────┐
│           Nagle 알고리즘 + 지연 ACK 문제                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  잠재적 문제 시나리오:                                               │
│                                                                      │
│  송신자 (Nagle)              수신자 (Delayed ACK)                   │
│       │                            │                                 │
│       │── 작은 데이터 ──────────▶ │                                 │
│       │                            │ (더 많은 데이터 기대하며       │
│       │  (ACK 대기 중)             │  ACK 지연, 보통 200ms)         │
│       │                            │                                 │
│       │◀──────── 지연 ACK ─────── │ (200ms 후)                      │
│       │                            │                                 │
│       │── 다음 데이터 ──────────▶ │                                 │
│       │                            │                                 │
│                                                                      │
│  결과: 각 전송마다 ~200ms 지연 발생                                 │
│                                                                      │
│  해결책:                                                             │
│  ├─ TCP_NODELAY 설정 (Nagle 비활성화)                               │
│  ├─ TCP_QUICKACK 설정 (지연 ACK 비활성화, Linux)                    │
│  └─ 애플리케이션 레벨에서 버퍼링 후 한 번에 전송                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

##### 연결 유지 (Keep-Alives)

| 요구사항 | 수준 |
|----------|------|
| Keep-alive 메커니즘 | MAY (선택적) |
| 죽은 연결 탐지 목적 | - |

섹션 4.2.3.6: TCP Keep-Alives - 연결이 아직 유효한지 확인하는 선택적 메커니즘

##### TCP Keep-Alive 메커니즘 상세

TCP Keep-Alive는 유휴(idle) 연결이 아직 유효한지 확인하는 선택적 메커니즘입니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│                   TCP Keep-Alive 개요                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  목적:                                                               │
│  ├─ 죽은 피어(dead peer) 탐지                                       │
│  ├─ 유휴 연결이 끊어졌는지 확인                                     │
│  └─ 중간 장비(NAT, 방화벽)의 연결 상태 유지                         │
│                                                                      │
│  구현:                                                               │
│  ├─ 일정 시간 동안 데이터 교환이 없으면                             │
│  ├─ Keep-Alive 프로브 세그먼트 전송                                 │
│  └─ 응답에 따라 연결 유지 또는 종료                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Keep-Alive 프로브 형식

```
┌─────────────────────────────────────────────────────────────────────┐
│                 Keep-Alive 프로브 세그먼트                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Keep-Alive 프로브:                                                  │
│  ├─ SEQ = SND.NXT - 1 (마지막 전송 시퀀스보다 1 작음)               │
│  ├─ 데이터 0바이트 또는 1바이트 (쓰레기 값)                         │
│  └─ 수신자는 이미 받은 데이터이므로 무시하고 ACK만 응답            │
│                                                                      │
│  정상 응답:                                                          │
│  ├─ ACK 세그먼트 수신                                               │
│  └─ 연결 정상으로 판단                                              │
│                                                                      │
│  비정상 응답:                                                        │
│  ├─ RST 수신: 피어가 재부팅됨 → 연결 종료                          │
│  ├─ 응답 없음: 피어 도달 불가 → 여러 번 재시도 후 종료             │
│  └─ ICMP 오류 수신: 네트워크 문제 → 연결 종료                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Keep-Alive 타이밍 파라미터

| 파라미터 | 기본값 | 설명 |
|----------|--------|------|
| Keep-Alive 시간 | 2시간 (7200초) | 유휴 상태 후 첫 프로브까지 대기 시간 |
| Keep-Alive 간격 | 75초 | 프로브 재전송 간격 |
| Keep-Alive 횟수 | 9 | 최대 프로브 재전송 횟수 |

```
┌─────────────────────────────────────────────────────────────────────┐
│                Keep-Alive 시퀀스 다이어그램                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  시간                 호스트 A                    호스트 B           │
│    │                    │                           │                │
│    │  ← 2시간 유휴 →    │                           │                │
│    │                    │                           │                │
│    │                    │──── Keep-Alive ─────────▶│                │
│    │                    │     (SEQ=X-1)             │                │
│    │                    │                           │                │
│    │                    │◀─────── ACK ──────────── │                │
│    │                    │     (ACK=X)               │                │
│    │                    │                           │                │
│    │  연결 유효 확인    │                           │                │
│    │                    │                           │                │
│    ▼                    ▼                           ▼                │
│                                                                      │
│  응답 없는 경우 (피어 다운):                                        │
│    │                    │                           │                │
│    │                    │──── Keep-Alive ─────────▶│ ✗              │
│    │  ← 75초 대기 →     │                           │                │
│    │                    │──── Keep-Alive ─────────▶│ ✗              │
│    │  ← 75초 대기 →     │                           │                │
│    │                    │──── Keep-Alive ─────────▶│ ✗              │
│    │       ...          │          ...              │                │
│    │  (9회 시도 후)     │                           │                │
│    │                    │                           │                │
│    │  연결 종료         │                           │                │
│    ▼                    ▼                           ▼                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Keep-Alive 요구사항

| 요구사항 | 수준 | 설명 |
|----------|------|------|
| Keep-Alive 구현 | MAY | 선택적 기능 |
| 기본값은 비활성화 | MUST | 명시적으로 활성화해야 함 |
| 애플리케이션별 제어 가능 | MUST | SO_KEEPALIVE 소켓 옵션 |
| 최소 2시간 유휴 후 프로브 | MUST | 구성 가능해야 함 |
| 프로브에 대한 응답 적절히 처리 | MUST | ACK, RST, 무응답 |

###### Keep-Alive 사용 시 고려사항

```
┌─────────────────────────────────────────────────────────────────────┐
│                Keep-Alive 장단점                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  장점:                                                               │
│  ├─ 죽은 연결 자원 해제                                             │
│  ├─ 연결 상태를 정확히 반영                                         │
│  ├─ NAT/방화벽 테이블 유지                                          │
│  └─ 애플리케이션 레벨 감지보다 효율적                               │
│                                                                      │
│  단점:                                                               │
│  ├─ 일시적 네트워크 장애 시 정상 연결 종료 가능                     │
│  ├─ 저전력 장치에서 전력 소모                                       │
│  ├─ 네트워크 트래픽 증가 (미미함)                                   │
│  └─ 종단간 원칙(end-to-end principle) 위반 논란                     │
│                                                                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                      │
│  RFC 1122 권고:                                                      │
│  "Keep-Alive는 매우 주의해서 사용해야 합니다.                       │
│   일시적인 네트워크 장애로 인해 정상적인 연결이                     │
│   끊어질 수 있기 때문입니다."                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

###### Linux에서의 Keep-Alive 설정

```
┌─────────────────────────────────────────────────────────────────────┐
│              Linux Keep-Alive 소켓 옵션                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  // Keep-Alive 활성화                                                │
│  int optval = 1;                                                     │
│  setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(int));  │
│                                                                      │
│  // 유휴 시간 설정 (기본 7200초)                                    │
│  int idle = 60;  // 60초 후 첫 프로브                               │
│  setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(int));   │
│                                                                      │
│  // 프로브 간격 설정 (기본 75초)                                    │
│  int interval = 10;  // 10초 간격                                    │
│  setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof);   │
│                                                                      │
│  // 최대 프로브 횟수 설정 (기본 9회)                                │
│  int count = 5;  // 5회 시도                                         │
│  setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(int));   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

##### 연결 실패 처리

섹션 4.2.3.5: TCP Connection Failures

| 요구사항 | 수준 |
|----------|------|
| ICMP 메시지에 대한 응답 | MUST |
| 연결 실패 처리 | MUST |

##### 멀티홈 지원 (Multihoming Support)

| 요구사항 | 수준 |
|----------|------|
| 적절한 소스 주소 선택 | MUST |
| 여러 인터페이스 지원 | SHOULD |

---

## 요구사항 요약 테이블

### Link Layer

| 기능 | MUST | SHOULD | MAY |
|------|:----:|:------:|:---:|
| RFC-894 Ethernet 캡슐화 송수신 | ✓ | | |
| RFC-1042 캡슐화 수신 | | ✓ | |
| RFC-1042 캡슐화 송신 | | | ✓ |
| ARP 캐시 타임아웃 | ✓ | | |
| ARP 요청 속도 제한 | ✓ | | |

### Internet Layer (IP/ICMP/IGMP)

| 기능 | MUST | SHOULD | MAY | MUST NOT |
|------|:----:|:------:|:---:|:--------:|
| 헤더 체크섬 검증 | ✓ | | | |
| 유효하지 않은 데이터그램 폐기 | ✓ | | | |
| 서브넷 주소 마스크 지원 | ✓ | | | |
| 소스 라우트 발신/목적지 | ✓ | | | |
| Record Route 옵션 | | ✓ | | |
| Timestamp 옵션 | | ✓ | | |
| Stream Identifier 전송 | | | | ✓ |
| 자동 게이트웨이 모드 | | | | ✓ |
| ICMP Echo Reply 응답 | ✓ | | | |
| ICMP Destination Unreachable 처리 | ✓ | | | |
| ICMP Redirect 처리 | ✓ | | | |
| ICMP 오류 메시지에 대한 ICMP 응답 금지 | | | | ✓ |
| 브로드캐스트 주소 인식 | ✓ | | | |
| 브로드캐스트 소스 주소 사용 금지 | | | | ✓ |
| IP 멀티캐스트 지원 | | ✓ | | |
| IGMP 구현 (멀티캐스트 지원 시) | | ✓ | | |
| 멀티캐스트 그룹 224.0.0.1 참가 | ✓ | | | |

### Transport Layer (TCP)

| 기능 | MUST | SHOULD | MAY |
|------|:----:|:------:|:---:|
| 슬로우 스타트 구현 | ✓ | | |
| 혼잡 회피 구현 | ✓ | | |
| MSS 협상 | ✓ | | |
| 재전송 타이머 계산 | ✓ | | |
| Nagle 알고리즘 | | ✓ | |
| Keep-Alive | | | ✓ |

---

## 관련 RFC 문서

| RFC | 제목 | 관계 |
|-----|------|------|
| RFC 1123 | Requirements for Internet Hosts - Application and Support | 동반 문서 |
| RFC 2119 | Key words for use in RFCs to Indicate Requirement Levels | 용어 정의 |
| RFC 6298 | Computing TCP's Retransmission Timer | RFC 1122의 RTO 요구사항 업데이트 |
| RFC 9293 | Transmission Control Protocol (TCP) | TCP 부분 대체 |
| RFC 2001 | TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery | 혼잡 제어 알고리즘 |

---

## 주요 용어

| 용어 | 설명 |
|------|------|
| MTU | Maximum Transmission Unit - 전송 가능한 최대 패킷 크기 |
| MSS | Maximum Segment Size - TCP 세그먼트의 최대 데이터 크기 |
| RTT | Round-Trip Time - 왕복 시간 |
| RTO | Retransmission Timeout - 재전송 타임아웃 |
| cwnd | Congestion Window - 혼잡 윈도우 |
| ssthresh | Slow Start Threshold - 슬로우 스타트 임계값 |
| TOS | Type of Service - 서비스 유형 |
| TTL | Time to Live - 생존 시간 |

---

## 참고 자료

- [RFC 1122 원문 (RFC Editor)](https://www.rfc-editor.org/rfc/rfc1122)
- [RFC 1122 (IETF Tools)](https://tools.ietf.org/html/rfc1122)
- [RFC 1122 상세 설명 (FreeSoft)](https://www.freesoft.org/CIE/RFC/1122/index.htm)
- [RFC 1122 요약 (Tech-Invite)](https://www.tech-invite.com/y10/tinv-ietf-rfc-1122.html)

---

*이 문서는 RFC 1122의 한국어 번역 및 정리본입니다.*
