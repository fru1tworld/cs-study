Network Working Group                                   David C. Plummer
Request For Comments:  826                                  (DCP@MIT-MC)
                                                           November 1982


             이더넷 주소 해석 프로토콜
                            -- 또는 --
              네트워크 프로토콜 주소를
                   48비트 이더넷 주소로 변환하여
                       이더넷 하드웨어에서
                        전송하기




                            초록

프로토콜 P의 구현이 송신 호스트 S에서, 프로토콜 P의 라우팅 메커니즘을
통해, 연결된 10Mbit 이더넷 케이블 어딘가에 위치한 대상 호스트 T에게
전송하고자 한다고 결정한다. 실제로 이더넷 패킷을 전송하려면 48비트
이더넷 주소가 생성되어야 한다. 프로토콜 P 내에서 호스트의 주소는 대응하는
이더넷 주소와 항상 호환되지는 않는다 (길이나 값이 다르기 때문이다).
여기에서는 프로토콜 P의 주소 공간에 있는 주소 A를 48비트 이더넷 주소로
변환하는 테이블을 구축하는 데 필요한 정보를 동적으로 배포할 수 있는
프로토콜을 제시한다.

10Mbit 이더넷이 아닌 하드웨어에서도 이 프로토콜을 사용할 수 있도록
일반화가 이루어졌다. 일부 패킷 라디오 네트워크가 그러한 하드웨어의
예이다.


여기에서 제안하는 프로토콜은 여러 사람들, 특히 J. Noel Chiappa,
Yogen Dalal, James E. Kulp와의 많은 논의와 David Moon의 유용한
의견의 결과이다.




[이 RFC의 목적은 프로토콜 주소(예: IP 주소)를 로컬 네트워크
주소(예: 이더넷 주소)로 변환하는 방법을 제시하는 것이다. 이것은
현재 ARPA 인터넷 커뮤니티에서 일반적으로 관심을 가지고 있는
사안이다. 여기에서 제안하는 방법은 검토와 의견을 위해
제시된 것이다. 이것은 인터넷 표준의 명세가 아니다.]

참고사항:
---------

이 프로토콜은 원래 DEC/Intel/Xerox 10Mbit 이더넷용으로 설계되었다.
다른 유형의 네트워크에서도 사용할 수 있도록 일반화되었다. 논의의
많은 부분은 10Mbit 이더넷을 대상으로 할 것이다. 해당되는 경우
이더넷 특정 논의 뒤에 일반화가 이어질 것이다.

DOD Internet Protocol은 Internet으로 지칭할 것이다.

여기서의 숫자들은 이더넷 표준을 따르며, 상위 바이트가 먼저 온다.
이것은 PDP-11이나 VAX 같은 기계의 바이트 주소 지정과 반대이다.
따라서 아래에 설명하는 opcode 필드(ar$op)에 대해 특별한 주의가
필요하다.

하드웨어 이름 공간 값을 관리할 합의된 권한이 필요하다 (아래 참조).
공식 권한이 존재할 때까지, 요청은 다음으로 제출되어야 한다:
	David C. Plummer
	Symbolics, Inc.
	243 Vassar Street
	Cambridge, Massachusetts  02139
또는 네트워크 메일을 DCP@MIT-MC로 보낼 수 있다.

문제:
-----

세상은 일반적으로 정글이며, 네트워킹 게임은 많은 동물들을
기여한다. 네트워크 아키텍처의 거의 모든 계층에는 사용될 수 있는
여러 잠재적 프로토콜이 있다. 예를 들어, 높은 수준에는 원격
로그인을 위한 TELNET과 SUPDUP이 있다. 그 아래 어딘가에는
신뢰성 있는 바이트 스트림 프로토콜이 있는데, CHAOS 프로토콜,
DOD TCP, Xerox BSP 또는 DECnet일 수 있다. 하드웨어에 더 가까운
곳에는 논리적 전송 계층이 있는데, CHAOS, DOD Internet, Xerox PUP
또는 DECnet일 수 있다. 10Mbit 이더넷은 이더넷 패킷 헤더의 타입
필드를 통해 이 모든 프로토콜(및 그 이상)이 단일 케이블에 공존할 수
있게 한다. 그러나 10Mbit 이더넷은 물리적 케이블에서 48비트 주소를
요구하지만, 대부분의 프로토콜 주소는 48비트 길이가 아니며,
하드웨어의 48비트 이더넷 주소와 반드시 어떤 관계를 가지는 것도
아니다. 예를 들어, CHAOS 주소는 16비트이고, DOD Internet 주소는
32비트이며, Xerox PUP 주소는 8비트이다. <프로토콜, 주소> 쌍과
48비트 이더넷 주소 간의 대응 관계를 동적으로 배포하는 프로토콜이
필요하다.

동기:
-----

DEC, Intel, Xerox가 발표한 사양에 맞는 인터페이스를 더 많은
제조사가 공급함에 따라 10Mbit 이더넷의 사용이 증가하고 있다.
이러한 가용성의 증가와 함께 이 인터페이스를 위한 소프트웨어가
점점 더 많이 작성되고 있다. 두 가지 대안이 있다: (1) 모든
구현자가 어떤 형태의 주소 해석을 수행하기 위해 자신만의 방법을
발명하거나, (2) 모든 구현자가 표준을 사용하여 자신의 코드가
수정 없이 다른 시스템에 배포될 수 있도록 한다. 이 제안은 그
표준을 설정하려는 것이다.

정의:
-----

이더넷 패킷 헤더의 TYPE 필드에 넣는 값을 참조하기 위해
다음을 정의한다:
	ether_type$XEROX_PUP,
	ether_type$DOD_INTERNET,
	ether_type$CHAOS,
그리고 새로운 것:
	ether_type$ADDRESS_RESOLUTION.
또한 다음 값을 정의한다 (나중에 논의할 것이다):
	ares_op$REQUEST (= 1, 상위 바이트가 먼저 전송됨) 및
	ares_op$REPLY   (= 2),
그리고
	ares_hrd$Ethernet (= 1).

패킷 형식:
----------

<프로토콜, 주소> 쌍에서 48비트 이더넷 주소로의 매핑을 전달하기
위해, Address Resolution 프로토콜을 구현하는 패킷 형식이 필요하다.
패킷의 형식은 다음과 같다.

    이더넷 전송 계층 (사용자가 반드시 접근할 수 있는 것은 아님):
	48.bit: 목적지의 이더넷 주소
	48.bit: 송신자의 이더넷 주소
	16.bit: 프로토콜 타입 = ether_type$ADDRESS_RESOLUTION
    이더넷 패킷 데이터:
	16.bit: (ar$hrd) 하드웨어 주소 공간 (예: Ethernet,
			 Packet Radio Net.)
	16.bit: (ar$pro) 프로토콜 주소 공간. 이더넷
			 하드웨어의 경우, 이것은 타입 필드
			 ether_type$<프로토콜> 집합에서 가져온다.
	 8.bit: (ar$hln) 각 하드웨어 주소의 바이트 길이
	 8.bit: (ar$pln) 각 프로토콜 주소의 바이트 길이
	16.bit: (ar$op)  opcode (ares_op$REQUEST | ares_op$REPLY)
	nbytes: (ar$sha) 이 패킷 송신자의 하드웨어 주소,
			 n은 ar$hln 필드에서 가져옴.
	mbytes: (ar$spa) 이 패킷 송신자의 프로토콜 주소,
			 m은 ar$pln 필드에서 가져옴.
	nbytes: (ar$tha) 이 패킷 대상의 하드웨어 주소
			 (알려진 경우).
	mbytes: (ar$tpa) 대상의 프로토콜 주소.

패킷 생성:
----------

패킷이 네트워크 계층을 통해 내려가면서, 라우팅은 패킷의 다음 홉의
프로토콜 주소와 즉각적인 대상 프로토콜 주소를 가진 스테이션을 찾을
것으로 예상되는 하드웨어 조각을 결정한다. 10Mbit 이더넷의 경우,
주소 해석이 필요하며 어떤 하위 계층(아마도 하드웨어 드라이버)이
Address Resolution 모듈(아마도 이더넷 지원 모듈에 구현됨)에 문의하여
<프로토콜 타입, 대상 프로토콜 주소> 쌍을 48비트 이더넷 주소로
변환해야 한다. Address Resolution 모듈은 이 쌍을 테이블에서 찾으려
시도한다. 쌍을 찾으면 대응하는 48비트 이더넷 주소를 호출자
(하드웨어 드라이버)에게 돌려주고, 호출자는 패킷을 전송한다. 찾지
못하면, 아마도 호출자에게 패킷을 폐기한다고 알린다 (상위 네트워크
계층에서 패킷이 재전송될 것이라는 가정 하에), 그리고 타입 필드가
ether_type$ADDRESS_RESOLUTION인 이더넷 패킷을 생성한다. 그러면
Address Resolution 모듈은 ar$hrd 필드를 ares_hrd$Ethernet으로,
ar$pro를 해석 중인 프로토콜 타입으로, ar$hln을 6으로 (48비트
이더넷 주소의 바이트 수), ar$pln을 해당 프로토콜에서 주소의 길이로,
ar$op을 ares_op$REQUEST로, ar$sha에 자신의 48비트 이더넷 주소를,
ar$spa에 자신의 프로토콜 주소를, ar$tpa에 접근하려는 기계의
프로토콜 주소를 설정한다. ar$tha는 특별히 어떤 값으로 설정하지
않는데, 이것이 바로 결정하려는 값이기 때문이다. 구현의 어떤
측면에서 편리하다면 ar$tha를 하드웨어의 브로드캐스트 주소(10Mbit
이더넷의 경우 모두 1)로 설정할 수 있다. 그런 다음 이 패킷을
라우팅 메커니즘에 의해 원래 결정된 이더넷 케이블의 모든
스테이션에 브로드캐스트하게 한다.

패킷 수신:
----------

주소 해석 패킷이 수신되면, 수신하는 이더넷 모듈은 패킷을 Address
Resolution 모듈에 전달하고, 이 모듈은 다음과 유사한 알고리즘을
수행한다. 부정 조건문은 처리의 종료와 패킷의 폐기를 나타낸다.

?나는 ar$hrd에 있는 하드웨어 타입을 가지고 있는가?
예: (거의 확실하게)
  [선택적으로 하드웨어 길이 ar$hln을 확인]
  ?나는 ar$pro에 있는 프로토콜을 사용하는가?
  예:
    [선택적으로 프로토콜 길이 ar$pln을 확인]
    Merge_flag := false
    만약 <프로토콜 타입, 송신자 프로토콜 주소> 쌍이 이미
        나의 변환 테이블에 있다면, 패킷의 새로운 정보로
        항목의 송신자 하드웨어 주소 필드를 갱신하고
        Merge_flag를 true로 설정한다.
    ?나는 대상 프로토콜 주소인가?
    예:
      만약 Merge_flag가 false이면, <프로토콜 타입,
          송신자 프로토콜 주소, 송신자 하드웨어 주소> 삼중항을
          변환 테이블에 추가한다.
      ?opcode가 ares_op$REQUEST인가?  (이제 opcode를 본다!!)
      예:
        하드웨어와 프로토콜 필드를 교환하여, 로컬
            하드웨어 및 프로토콜 주소를 송신자 필드에 넣는다.
        ar$op 필드를 ares_op$REPLY로 설정한다.
        요청이 수신된 것과 동일한 하드웨어에서 (새로운) 대상
            하드웨어 주소로 패킷을 전송한다.

<프로토콜 타입, 송신자 프로토콜 주소, 송신자 하드웨어 주소>
삼중항이 opcode를 확인하기 전에 테이블에 병합된다는 점에
주목하라. 이것은 다음과 같은 현상의 정당성이다: 만약 호스트 A에서
호스트 B로의 매핑이 이미 있고 B가 A로의 매핑 없이 또는 오래된
매핑으로 주소 해석을 시도하고 있다면, A가 B의 패킷의 opcode를
볼 때, A는 B의 새로운 하드웨어 주소를 이미 테이블에 입력해
둔 것이다. 또한 <프로토콜 타입, 대상 프로토콜 주소>가 일치할 경우에만
삼중항이 변환 테이블에 추가된다는 점에도 주목하라. 이것은
모든 기계의 변환 테이블이 네트워크의 모든 기계에 대한 항목으로
채워지는 것을 방지하기 위함이다; 또한 관련 없는 정보가 테이블에
들어가는 것도 방지한다. 대상 프로토콜 주소가 자신의 것과 일치하고
이미 알려져 있는 <프로토콜 타입, 송신자 프로토콜 주소>의 경우,
테이블에 대한 수정이 이루어지는 것이 중요하다는 점에 유의하라.
기존 항목의 하드웨어 주소를 갱신해야 한다. 주소 교환이 일어나면
(호스트가 이사하거나, 프로토콜 주소 재할당 또는 NIC 교체 등)
원래 주소의 매핑은 유효하지 않게 된다. 이 알고리즘은 새 정보를
받아들이는 것을 선호하며, 이러한 상황을 감지하는 어려운 문제를
피한다.

왜 이렇게 하는가??
-------------------

주기적 브로드캐스팅은 확실히 바람직하지 않다. 단일 이더넷에 100개의
워크스테이션이 있고, 각각이 10분에 한 번씩 주소 해석 정보를
브로드캐스트한다고 상상해 보라 (가능한 매개변수 집합의 하나로서).
이것은 6초에 하나의 패킷이다. 이것은 거의 합리적이지만, 무슨
소용이 있는가? 워크스테이션들은 일반적으로 서로 통신하지 않을
것이고 (따라서 테이블에 100개의 쓸모없는 항목을 갖게 됨);
주로 메인프레임, 파일 서버 또는 브리지와 통신할 것이지만,
소수의 다른 워크스테이션과만 통신할 것이다 (예를 들어 대화형
대화를 위해). 이 논문에서 설명하는 프로토콜은 필요할 때 정보를
배포하며, 기계 부팅당 한 번만 (아마도) 배포한다.

이 형식은 같은 패킷에서 하나 이상의 해석을 허용하지 않는다. 이것은
단순성을 위해서이다. 다중화가 이루어진다면 패킷 형식은 상당히
소화하기 어려워질 것이고, 정보의 많은 부분이 불필요할 수 있다.
네 가지 프로토콜을 사용하는 브리지가 워크스테이션에 네 개의
프로토콜 주소를 모두 알려주는데, 그 중 세 개는 워크스테이션이
아마도 절대 사용하지 않을 것이라고 생각해 보라.

이 형식은 응답이 생성될 때 패킷 버퍼를 재사용할 수 있게 한다;
응답은 요청과 동일한 길이를 가지며, 여러 필드가 동일하다.

하드웨어 필드(ar$hrd)의 값은 이 목적을 위한 목록에서 가져온다.
현재 정의된 유일한 값은 10Mbit 이더넷용이다
(ares_hrd$Ethernet = 1). 이 프로토콜을 Packet Radio Network에도
사용하려는 논의가 있었으며, 이 프로토콜을 사용하려는 다른 미래의
하드웨어 매체와 마찬가지로 또 다른 값이 필요할 것이다.

10Mbit 이더넷의 경우, 프로토콜 필드(ar$pro)의 값은 ether_type$
집합에서 가져온다. 이것은 할당된 프로토콜 타입의 자연스러운
재사용이다. 이것을 opcode(ar$op)와 결합하면 이 프로토콜 하에서
해석할 수 있는 프로토콜의 수를 사실상 반으로 줄이게 되며
모니터/디버거를 더 복잡하게 만들 것이다 (아래의 네트워크 모니터링
및 디버깅 참조). 32768개의 프로토콜을 볼 일은 없기를 바라지만,
Murphy의 법칙이 이런 가정을 허용하지 않는다.

이론적으로, 길이 필드(ar$hln과 ar$pln)는 중복되는데, 프로토콜
주소의 길이는 하드웨어 타입(ar$hrd에서 찾을 수 있음)과 프로토콜
타입(ar$pro에서 찾을 수 있음)에 의해 결정되어야 하기 때문이다.
선택적 일관성 검사와 네트워크 모니터링 및 디버깅(아래 참조)을
위해 포함되었다.

opcode는 이것이 요청(응답을 유발할 수 있음)인지 이전 요청에 대한
응답인지를 결정하기 위한 것이다. 이를 위해 16비트는 과도하지만,
플래그(필드)가 필요하다.

송신자 하드웨어 주소와 송신자 프로토콜 주소는 절대적으로 필요하다.
변환 테이블에 넣어지는 것이 바로 이 필드들이다.

대상 프로토콜 주소는 패킷의 요청 형식에서 기계가 송신자 정보를
테이블에 입력할지 또는 응답을 보낼지 여부를 결정할 수 있도록
필요하다. 응답이 요청에 의해서만 유발된다고 가정한다면 응답 형식에서
반드시 필요하지는 않다. 완전성, 네트워크 모니터링, 그리고 위에서
설명한 제안된 처리 알고리즘의 단순화를 위해 포함되었다 (이
알고리즘은 송신자 정보를 테이블에 넣은 후에야 opcode를 확인한다).

대상 하드웨어 주소는 완전성과 네트워크 모니터링을 위해 포함되었다.
요청 형식에서는 의미가 없는데, 기계가 요청하는 것이 바로 이
번호이기 때문이다. 응답 형식에서의 의미는 요청을 한 기계의
주소이다. 일부 구현에서는 (예를 들어 14바이트 이더넷 헤더를 볼 수
없는 경우) 이 필드를 패킷의 하드웨어 목적지 주소로 하드웨어
드라이버에 전송함으로써 일부 레지스터 셔플링이나 스택 공간을
절약할 수 있다.

주소 사이에 패딩 바이트가 없다. 패킷 데이터는 오직 3개의 바이트
쌍만이 워드로 정의된 바이트 스트림으로 보아야 하며 (ar$hrd, ar$pro
그리고 ar$op), 이들은 최상위 바이트가 먼저 전송된다
(Ethernet/PDP-10 바이트 스타일).

네트워크 모니터링 및 디버깅:
----------------------------

위의 Address Resolution 프로토콜은 기계가 이더넷 케이블에서의
상위 수준 프로토콜 활동(예: CHAOS, Internet, PUP, DECnet)에 대한
지식을 얻을 수 있게 한다. 어떤 이더넷 프로토콜 타입 필드가
사용되고 있는지(값에 의해)와 각 프로토콜 타입 내의 프로토콜
주소를 결정할 수 있다. 사실, 모니터가 관련된 상위 수준 프로토콜을
사용할 필요조차 없다. 대략 다음과 같이 동작한다:

모니터가 Address Resolution 패킷을 수신하면, 항상 <프로토콜 타입,
송신자 프로토콜 주소, 송신자 하드웨어 주소>를 테이블에 입력한다.
패킷의 ar$hln과 ar$pln 필드에서 하드웨어와 프로토콜 주소의 길이를
결정할 수 있다. opcode가 REPLY이면 모니터는 패킷을 폐기할 수
있다. opcode가 REQUEST이고 대상 프로토콜 주소가 모니터의 프로토콜
주소와 일치하면, 모니터는 정상적으로 REPLY를 보낸다. 모니터는 이
방법으로 하나의 매핑만 얻게 되는데, REQUEST에 대한 REPLY가
요청하는 호스트에게 직접 전송되기 때문이다. 모니터가 자체
REQUEST를 보내볼 수도 있지만, 이는 두 모니터가 REQUEST 전송
루프에 빠질 수 있으므로 주의가 필요하다.

프로토콜과 opcode가 하나의 필드로 결합되지 않았기 때문에,
모니터는 동일한 상위 수준 프로토콜에 대해 어떤 요청 opcode가
어떤 응답 opcode와 연관되는지 알 필요가 없다. 길이 필드도
프로토콜 주소를 "파싱"하기에 충분한 정보를 제공해야 하지만,
프로토콜 주소가 무엇을 의미하는지에 대한 지식은 없다.

Address Resolution 프로토콜의 동작하는 구현은 동작하지 않는
구현을 디버그하는 데에도 사용될 수 있다. 아마도 하드웨어
드라이버는 이더넷 타입 필드가 ether_type$ADDRESS_RESOLUTION인
패킷을 성공적으로 브로드캐스트할 것이다. 초기 구현에 버그가
있을 수 있고 테이블 관리가 약간 까다로울 수 있기 때문에
패킷의 형식이 완전히 올바르지 않을 수 있다. 요청은
브로드캐스트되므로 모니터가 패킷을 수신하여 원하는 경우
디버깅을 위해 표시할 수 있다.

예시:
-----

같은 10Mbit 이더넷 케이블에 기계 X와 Y가 있다고 하자. 이들은
이더넷 주소 EA(X)와 EA(Y), 그리고 DOD Internet 주소 IPA(X)와
IPA(Y)를 가진다. Internet의 이더넷 타입을 ET(IP)라 하자. 기계 X가
방금 시작되었고, 조만간 같은 케이블의 기계 Y에 Internet 패킷을
보내려 한다. X는 IPA(Y)로 보내려 한다는 것을 알고 하드웨어
드라이버(여기서는 이더넷 드라이버)에게 IPA(Y)를 알려준다. 드라이버는
<ET(IP), IPA(Y)>를 48비트 이더넷 주소로 변환하기 위해 Address
Resolution 모듈에 문의하지만, X가 방금 시작되었으므로 이 정보를
가지고 있지 않다. Internet 패킷을 폐기하고 대신 다음과 같이
ADDRESS RESOLUTION 패킷을 생성한다:
	(ar$hrd) = ares_hrd$Ethernet
	(ar$pro) = ET(IP)
	(ar$hln) = length(EA(X))
	(ar$pln) = length(IPA(X))
	(ar$op)  = ares_op$REQUEST
	(ar$sha) = EA(X)
	(ar$spa) = IPA(X)
	(ar$tha) = 상관없음
	(ar$tpa) = IPA(Y)
그리고 이 패킷을 케이블의 모든 사람에게 브로드캐스트한다.

기계 Y가 이 패킷을 받고, 하드웨어 타입(Ethernet)을 이해하며,
표시된 프로토콜(Internet)을 사용하고, 패킷이 자신을 위한 것임을
확인한다 ((ar$tpa)=IPA(Y)). <ET(IP), IPA(X)>가 EA(X)에 매핑된다는
정보를 (아마도 기존 항목을 대체하여) 입력한다. 그런 다음 이것이
요청임을 알아차리고, 필드를 교환하여 EA(Y)를 새로운 송신자 이더넷
주소 필드(ar$sha)에 넣고, opcode를 응답으로 설정하고, 패킷을
EA(X)에 직접 (브로드캐스트가 아닌) 전송한다. 이 시점에서 Y는 X에게
보내는 방법을 알지만, X는 아직 Y에게 보내는 방법을 모른다.

기계 X가 Y로부터 응답 패킷을 받고, <ET(IP), IPA(Y)>에서 EA(Y)로의
매핑을 형성하고, 패킷이 응답임을 알아차리고 폐기한다. 다음에 X의
Internet 모듈이 이더넷에서 Y에게 패킷을 보내려 하면, 변환이
성공하고 패킷이 (바라건대) 도착할 것이다. Y의 Internet 모듈이
그 후 X와 통신하려 하면, Y가 X의 Address Resolution 요청에서
정보를 기억하고 있으므로 이것도 성공할 것이다.

관련 문제:
----------

테이블 에이징 및/또는 타임아웃을 두는 것이 바람직할 수 있다. 이들의
구현은 이 프로토콜의 범위 밖이다. 여기에 더 자세한 설명이 있다
(MOON@SCRC@MIT-MC에게 감사한다).

만약 호스트가 이동하면, 그 호스트가 시작한 모든 연결은 동작할
것이며, 이동 시 자체 주소 해석 테이블이 지워진다고 가정한다.
그러나 다른 호스트들이 그 호스트에게 시작한 연결은 이전 주소를
폐기해야 할 특별한 이유를 알지 못할 것이다. 그러나 48비트 이더넷
주소는 고유하고 영구적으로 고정되어야 하므로 변경되어서는 안 된다.
호스트 이름(및 다른 프로토콜의 주소)이 다른 물리적 하드웨어에
재할당되면 호스트가 "이동"할 수 있다. 또한 경험에서 알 수 있듯이,
하드웨어나 소프트웨어 오류를 통해 잘못된 라우팅 정보가 실수로
전송될 위험이 항상 있다; 이것이 영원히 지속되도록 허용해서는 안
된다. 아마도 연결 시작 실패는 Address Resolution 모듈에 해당
정보를 삭제하도록 알려야 할 것이며, 이는 호스트가 도달할 수
없기 때문이며, 아마도 호스트가 다운되었거나 이전 변환이 더 이상
유효하지 않기 때문일 것이다. 또는 아마도 호스트로부터 패킷을
수신하면 그 호스트에게 패킷을 전송하는 데 사용되는 주소 해석
항목의 타임아웃을 재설정해야 할 것이다; 적절한 시간 동안
호스트로부터 패킷이 수신되지 않으면, 주소 해석 항목은 잊혀진다.
이것은 들어오는 각 패킷에 대해 테이블을 스캔하는 추가 오버헤드를
유발할 수 있다. 아마도 해시나 인덱스가 이것을 더 빠르게 만들 수
있을 것이다.

주소 해석 패킷을 수신하기 위한 제안된 알고리즘은 호스트가
이동하는 경우 복구에 걸리는 시간을 줄이려고 시도한다.
<프로토콜 타입, 송신자 프로토콜 주소>가 이미 변환 테이블에 있으면
송신자 하드웨어 주소가 기존 항목을 대체한다는 것을 상기하라.
따라서 브로드캐스트 REQUEST가 케이블의 모든 스테이션에 도달하는
완벽한 이더넷에서, 각 스테이션은 새로운 하드웨어 주소를 얻게
될 것이다.

또 다른 대안은 데몬이 타임아웃을 수행하는 것이다. 적절한 시간이
지난 후 데몬은 항목 제거를 고려한다. 먼저 테이블의 이더넷
주소로 직접 opcode REQUEST가 있는 주소 해석 패킷을 (필요한 경우
소수의 재전송과 함께) 전송한다. 짧은 시간 내에 REPLY가 보이지
않으면 항목이 삭제된다. 이더넷의 모든 스테이션을 방해하지 않도록
요청은 직접 전송된다. 단순히 항목을 잊어버리면 유용한 정보가
잊혀질 가능성이 높으며, 이 정보를 다시 얻어야 한다.

호스트는 자기 자신에 대한 정보만 전송하므로, 호스트를 재부팅하면
주소 매핑 테이블이 최신 상태가 된다. 잘못된 정보는 기계에서
기계로 전달되어 영원히 지속될 수 없다; 존재할 수 있는 유일한
잘못된 정보는 다른 기계가 48비트 이더넷 주소를 변경했다는 것을
모르는 기계에 있다. 아마도 주소 매핑 테이블을 수동으로 재설정
(또는 지우기)하면 충분할 것이다.

이 문제가 중요하다고 여겨진다면 분명히 더 많은 생각이 필요하다.
이것은 주소 해석과 유사한 모든 프로토콜에 의해 야기된다.
