# RFC 6819 - OAuth 2.0 Threat Model and Security Considerations

> 발행일: 2013년 1월
> 상태: Informational

---

## 1. 소개 (Introduction)

이 문서는 OAuth 2.0 프로토콜 [RFC6749]에 대한 포괄적인 위협 모델(Threat Model)을 기반으로, OAuth 사양에 명시된 것 이상의 추가적인 보안 고려사항을 제공합니다. 이 문서는 다음과 같은 내용을 포함합니다:

- 위협 모델을 작성할 때 고려한 가정(assumptions)과 범위(scope)를 문서화합니다.
- OAuth 프로토콜에 내장된 보안 기능(security features)과 이러한 기능이 공격을 어떻게 차단하는지 설명합니다.
- OAuth에 대한 포괄적인 위협 모델을 제시하고, 해당 위협에 대한 대응 조치(countermeasures)를 설명합니다.

위협(Threats)에는 OAuth 토큰 및 OAuth 토큰으로 보호되는 리소스에 대한 의도적인 공격뿐만 아니라, 적절한 보안 조치가 마련되지 않은 경우 발생하는 보안 위험도 포함됩니다. 위협은 프로토콜 구조에 따라 구조화되어 있어, 개발 팀이 프로토콜의 각 부분을 안전하게 구현하는 데 도움이 됩니다. 예를 들어, 접근 권한 부여와 관련된 모든 위협, 특정 권한 부여 유형(grant type)에 대한 모든 위협, 또는 리소스 서버 보호와 관련된 모든 위협 등이 있습니다.

> 참고: 이 문서는 특정 위협에 대한 발생 확률이나 위험도를 평가할 수 없습니다. 이러한 측면은 OAuth가 보호하는 특정 애플리케이션 및 배포 환경에 크게 의존하기 때문입니다. 마찬가지로, 영향(impact)도 다소 추상적인 수준에서 제시됩니다. 그러나 여기에 제공된 정보는 배포 환경에 특화된 위협 모델의 기반으로 활용될 수 있습니다. 구현자들은 자신의 배포 환경의 특정 속성을 고려하기 위해 추상적인 위협 모델을 정제하고 구체화하여 위험 분석(risk analysis)을 도출할 수 있습니다. 이 문서는 기본 OAuth 2.0 사양을 기반으로 하므로, 클라이언트 등록(client registration)이나 디스커버리(discovery)와 같이 아직 논의 중인 확장 제안은 고려하지 않습니다.

---

## 2. 개요 (Overview)

### 2.1 범위 (Scope)

이 보안 고려사항 문서는 [RFC6749]에서 지원하는 특정 배포 환경에 바인딩된 클라이언트만을 고려합니다. 이러한 배포 환경은 다음과 같은 특성을 가집니다:

- 리소스 서버 URL은 개발 시점에 정적(static)이며 잘 알려져 있습니다. 인가 서버 URL은 정적이거나 동적으로 발견(discover)될 수 있습니다.
- 토큰 스코프(scope) 값 (예: 적용 가능한 URL 및 메서드)은 개발 시점에 잘 알려져 있습니다.
- 클라이언트 등록(client registration)은 현재 핵심 사양의 범위 밖입니다. 따라서 이 문서는 개발 시점의 정적 등록부터 런타임의 동적 등록까지 다양한 옵션을 가정합니다.

다음 항목은 범위 밖(out of scope)으로 간주됩니다:

- 인가 서버와 리소스 서버 간의 통신
- 토큰 형식(Token formats)
- 리소스 소유자 비밀번호 자격 증명 권한 부여 유형(Resource Owner Password Credentials grant type, [RFC6749] Section 4.3 참조)을 제외한, 인가 서버가 사용자를 인증하는 메커니즘
- 사용자가 어서션(assertion)을 획득한 메커니즘 및 어서션이 거짓인 경우 발생하는 공격
- 특정 배포 환경에 바인딩되지 않은 클라이언트: 예를 들어, Portable Contacts API([Portable-Contacts] 참조)를 통한 연락처 목록 접근을 지원하는 메일 클라이언트가 있습니다. 이러한 클라이언트는 특정 배포 환경에 사전 등록할 수 없으며, OAuth 프로토콜에 관련된 URL을 동적으로 발견해야 합니다.

### 2.2 공격 가정 (Attack Assumptions)

다음 가정은 공격자와 공격자가 사용할 수 있는 리소스에 관한 것입니다. 다음을 가정합니다:

- 공격자는 클라이언트와 인가 서버 간, 그리고 클라이언트와 리소스 서버 간의 네트워크에 대한 전체 접근 권한을 가집니다. 공격자는 해당 당사자 간의 모든 통신을 도청(eavesdrop)할 수 있습니다. 그러나 공격자가 인가 서버와 리소스 서버 간의 통신에 접근할 수 있는 것으로는 가정하지 않습니다.
- 공격자는 공격을 수행하기 위해 무제한의 리소스를 가집니다.
- OAuth 프로토콜에 관여하는 세 당사자 중 두 당사자가 공모(collude)하여 나머지 한 당사자에 대한 공격을 수행할 수 있습니다. 예를 들어, 클라이언트와 인가 서버가 공격자의 통제 하에 있으며, 리소스에 대한 접근 권한을 얻기 위해 사용자를 속이도록 공모할 수 있습니다.

### 2.3 아키텍처 가정 (Architectural Assumptions)

이 섹션은 OAuth 배포의 다양한 엔티티(entity)의 기능, 제한사항 및 설계 옵션에 대한 가정과, 해당 엔티티가 관리하는 보안 민감 데이터 요소를 문서화합니다. 이러한 가정은 위협 분석의 기반이 됩니다.

OAuth 프로토콜은 배포 환경에 표준을 구현하고 적용하는 방법에 대해 어느 정도의 자유도를 부여합니다. 핵심 사양은 인가 서버(Authorization Server)와 리소스 서버(Resource Server)의 핵심 개념을 정의합니다. 두 서버는 동일한 서버 엔티티에 구현될 수도 있고, 별도의 엔티티일 수도 있습니다. 후자의 경우는 일반적으로 단일 인증 및 인가 시스템을 가진 멀티 서비스 제공자에서 나타나며, 미들웨어 아키텍처에서 더 일반적입니다.

#### 2.3.1 인가 서버 (Authorization Servers)

인가 서버에 저장되거나 접근 가능한 데이터 요소는 다음과 같습니다:

| 데이터 요소 | 설명 |
|-------------|------|
| 사용자 이름 및 비밀번호 (usernames and passwords) | 리소스 소유자의 자격 증명 |
| 클라이언트 ID 및 시크릿 (client ids and secrets) | 클라이언트 인증 정보 |
| 클라이언트별 리프레시 토큰 (client-specific refresh tokens) | 장기 인가 토큰 |
| 클라이언트별 액세스 토큰 (client-specific access tokens) | 핸들 기반 설계(handle-based design)의 경우 (Section 3.1 참조) |
| HTTPS 인증서/키 (HTTPS certificate/key) | TLS 통신을 위한 인증서 |
| 인가 프로세스별 데이터 | 핸들 기반 설계의 경우: `redirect_uri`, `client_id`, 인가 `code` |

#### 2.3.2 리소스 서버 (Resource Server)

리소스 서버에 저장되거나 접근 가능한 데이터 요소는 다음과 같습니다:

| 데이터 요소 | 설명 |
|-------------|------|
| 사용자 데이터 (user data) | 범위 밖 (out of scope) |
| HTTPS 인증서/키 (HTTPS certificate/key) | TLS 통신을 위한 인증서 |
| 인가 서버 자격 증명 또는 공유 비밀/공개 키 | 핸들 기반 설계의 경우 인가 서버 자격 증명(Section 3.1 참조), 어서션 기반 설계의 경우 인가 서버 공유 비밀/공개 키(Section 3.1 참조) |
| 액세스 토큰 (access tokens) | 요청별 (per request) |

> 리소스 서버는 리프레시 토큰, 사용자 비밀번호 또는 클라이언트 시크릿에 대한 정보를 가지고 있지 않다고 가정합니다.

#### 2.3.3 클라이언트 (Client)

OAuth에서 클라이언트는 리소스 소유자를 대신하여 그리고 리소스 소유자의 인가를 받아 보호된 리소스 요청을 수행하는 애플리케이션입니다. 웹(web), 사용자 에이전트 기반(user-agent-based), 네이티브(native) 애플리케이션 등 다양한 구현 및 보안 특성을 가진 여러 유형의 클라이언트가 있습니다. 다양한 클라이언트 유형 및 프로파일에 대한 전체 정의는 [RFC6749] Section 2.1에 제공됩니다.

클라이언트에 저장되거나 접근 가능한 데이터 요소는 다음과 같습니다:

| 데이터 요소 | 설명 |
|-------------|------|
| 클라이언트 ID (client id) | 클라이언트 시크릿 또는 해당 클라이언트 자격 증명 포함 |
| 리프레시 토큰 및 액세스 토큰 | 최종 사용자 또는 기타 보안 컨텍스트/위임 컨텍스트별로 하나 이상의 리프레시 토큰(영속적)과 액세스 토큰(일시적) |
| 신뢰할 수 있는 CA 인증서 (trusted CA certificates) | HTTPS 통신을 위한 인증 기관 인증서 |
| 인가 프로세스별 데이터 | `redirect_uri`, 인가 `code` |

---

## 3. 보안 기능 (Security Features)

다음은 공격과 보안 문제를 완화하기 위해 OAuth 2.0 프로토콜에 내장된 보안 기능들입니다.

### 3.1 토큰 (Tokens)

OAuth는 다양한 종류의 토큰(액세스 토큰, 리프레시 토큰, 인가 "코드")을 광범위하게 사용합니다. 토큰의 정보 내용은 다음 두 가지 방식으로 표현될 수 있습니다:

#### 토큰 표현 방식

| 방식 | 설명 |
|------|------|
| 핸들 (Handle, 또는 아티팩트) | 인가 서버 내부 데이터 구조에 대한 참조(reference)입니다. 내부 데이터 구조에는 사용자 ID(UID), 스코프(scope) 등 토큰의 속성이 포함됩니다. 핸들은 간단한 해지(revocation)를 가능하게 하며, 토큰 내용이 변경되는 것을 방지하기 위한 암호화 메커니즘이 필요하지 않습니다. 반면, 토큰을 검증하고 토큰에 바인딩된 데이터를 얻기 위해 발행 엔티티와 소비 엔티티(예: 인가 서버와 리소스 서버) 간의 통신이 필요합니다. 두 엔티티가 서로 다른 시스템에 있는 경우 이 통신은 성능과 확장성에 부정적인 영향을 미칠 수 있습니다. 따라서 핸들은 일반적으로 발행 엔티티와 소비 엔티티가 동일한 경우에 사용됩니다. 핸들 토큰은 리소스 서버가 토큰을 직접 해석할 필요가 없고 단순히 사용하기만 하므로 종종 불투명(opaque) 토큰이라고 불립니다. |
| 어서션 (Assertion, 자체 포함 토큰) | 파싱 가능한(parseable) 토큰입니다. 어서션은 일반적으로 유효 기간(duration)과 대상(audience)을 가지며, 데이터 무결성과 출처 인증을 보장하기 위해 디지털 서명됩니다. 사용자와 클라이언트에 대한 정보를 포함합니다. 어서션 형식의 예로는 SAML(Security Assertion Markup Language) 어서션 [OASIS.saml-core-2.0-os]과 Kerberos 티켓 [RFC4120]이 있습니다. 어서션은 일반적으로 인가 서버와의 상호작용 없이 리소스 서버에서 직접 검증하고 사용할 수 있습니다. 이로 인해 발행 엔티티와 소비 엔티티가 서로 다른 시스템에 있는 배포 환경에서 더 나은 성능과 확장성을 제공합니다. 어서션의 경우 토큰 해지(revocation) 구현이 핸들보다 더 어렵습니다. |

#### 토큰 사용 방식

토큰은 리소스 서버에 대한 요청을 수행하기 위해 다음 두 가지 방식으로 사용될 수 있습니다:

| 방식 | 설명 |
|------|------|
| 베어러 토큰 (Bearer Token) | 토큰을 수신한 모든 클라이언트가 사용할 수 있는 토큰입니다 (예: [RFC6750]). 단순한 소유만으로 토큰을 사용할 수 있으므로, 인가된 엔드포인트만 토큰을 캡처할 수 있도록 엔드포인트 간 통신을 보호하는 것이 중요합니다. 베어러 토큰은 클라이언트 애플리케이션이 사용하기 위해 별도의 작업(예: 신원 증명)을 수행할 필요가 없어 편리합니다. 베어러 토큰은 브라우저에서 사용되는 웹 SSO(Single Sign-On) 쿠키와 유사한 특성을 가집니다. |
| 증명 토큰 (Proof Token) | 특정 클라이언트만 사용할 수 있는 토큰입니다. 토큰을 사용할 때마다 클라이언트는 자신이 토큰의 인가된 사용자임을 증명하는 작업을 수행해야 합니다. 예를 들어, MAC 유형 액세스 토큰은 클라이언트가 요청과 함께 전송되는 특정 토큰에 해당하는 시크릿으로 리소스 요청에 디지털 서명하도록 요구합니다 (예: [OAuth-HTTP-MAC]). |

#### 3.1.1 스코프 (Scope)

스코프(scope)는 리소스 서버, 리소스 및 해당 리소스에 대한 메서드와 관련하여 특정 토큰에 연결된 접근 인가를 나타냅니다. 스코프는 액세스 토큰에 연결된 권한을 명시적으로 관리하는 OAuth의 방식입니다. 스코프는 인가 서버 및/또는 최종 사용자가 제어하여 보안성이 낮거나 신뢰할 수 없다고 판단되는 OAuth 클라이언트의 리소스 접근을 제한할 수 있습니다. 선택적으로, 클라이언트는 토큰에 적용할 스코프를 요청할 수 있지만, 그렇지 않을 경우 부여될 범위보다 작은 스코프만 요청할 수 있습니다. 예를 들어, 이 토큰이 비보안 채널을 통해 전송될 경우의 잠재적 영향을 줄이기 위해서입니다. 스코프는 일반적으로 토큰의 수명(lifetime) 제한으로 보완됩니다.

#### 3.1.2 제한된 액세스 토큰 수명 (Limited Access Token Lifetime)

프로토콜 파라미터 `expires_in`은 인가 서버가 (자체 정책 또는 최종 사용자를 대신하여) 액세스 토큰의 수명을 제한하고 이 정보를 클라이언트에 전달할 수 있게 합니다. 이 메커니즘은 인가 서버가 보안성이 낮다고 판단하는 OAuth 클라이언트에게 짧은 수명의 토큰을 발급하거나, 토큰이 비보안 채널을 통해 전송되는 경우에 사용될 수 있습니다.

### 3.2 액세스 토큰 (Access Token)

액세스 토큰은 클라이언트가 리소스에 접근하기 위해 사용합니다. 액세스 토큰은 일반적으로 일반적인 세션 수명을 커버하는 짧은 수명(분 또는 시간)을 가집니다. 액세스 토큰은 리프레시 토큰을 사용하여 갱신(refresh)될 수 있습니다. 액세스 토큰의 짧은 수명은 리프레시 토큰의 사용과 결합되어, 현재 액세스 토큰이 만료될 때 접근 인가의 수동적 해지(passive revocation)를 가능하게 합니다.

### 3.3 리프레시 토큰 (Refresh Token)

리프레시 토큰은 특정 클라이언트가 리소스 소유자를 대신하여 리소스에 접근할 수 있는 장기 인가(long-lasting authorization)를 나타냅니다. 이러한 토큰은 클라이언트와 인가 서버 간에서만 교환됩니다. 클라이언트는 이 종류의 토큰을 사용하여 리소스 서버 호출에 사용되는 새로운 액세스 토큰을 획득("갱신")합니다.

리프레시 토큰은 짧은 액세스 토큰 수명과 결합되어, 최종 사용자의 인가 없이 리소스에 대한 더 긴 접근을 부여하는 데 사용될 수 있습니다. 이는 리소스 서버와 인가 서버가 동일한 엔티티가 아닌 경우, 예를 들어 분산 환경에서, 리프레시 토큰이 항상 인가 서버에서 교환되므로 장점을 제공합니다. 인가 서버는 언제든지 리프레시 토큰을 해지할 수 있으며, 현재 액세스 토큰이 만료되면 부여된 접근이 해지됩니다. 이 때문에, 적시 해지(timely revocation)가 높은 우선순위인 경우 짧은 액세스 토큰 수명이 중요합니다.

리프레시 토큰은 또한 원래 인가를 요청한 클라이언트 식별자 및 클라이언트 인스턴스에 바인딩된 비밀(secret)이며, 원래의 리소스 소유자 권한 부여를 나타냅니다. 이는 인가 프로세스에 의해 다음과 같이 보장됩니다:

1. 리소스 소유자와 사용자 에이전트가 인가 "코드"를 클라이언트 인스턴스에 안전하게 전달합니다.
2. 클라이언트는 즉시 인가 서버와의 안전한 전송 계층(transport-level) 통신에서 이를 사용하고, 장기 리프레시 토큰을 안전하게 저장합니다.
3. 클라이언트는 항상 인가 서버와의 안전한 전송 계층 통신에서 리프레시 토큰을 사용하여 액세스 토큰을 얻습니다 (그리고 선택적으로 리프레시 토큰을 교체(roll over)합니다).

따라서, 클라이언트가 특정 토큰의 기밀성(confidentiality)을 보장할 수 있는 한, 리프레시 토큰은 클라이언트 인스턴스 자체를 인증하는 대체 수단으로도 사용될 수 있습니다.

### 3.4 인가 "코드" (Authorization "code")

인가 "코드"는 성공적인 최종 사용자 인가 프로세스의 중간 결과(intermediate result)를 나타내며, 클라이언트가 액세스 토큰과 리프레시 토큰을 획득하는 데 사용됩니다. 인가 "코드"는 토큰 대신 클라이언트의 리다이렉트 URI로 전송되며, 이는 두 가지 목적을 위해서입니다:

1. 브라우저 기반 흐름은 URI 쿼리 파라미터(HTTP Referrer), 브라우저 캐시 또는 로그 파일 항목을 통해 프로토콜 파라미터를 잠재적 공격자에게 노출시키며, 재생(replay)될 수 있습니다. 이 위협을 줄이기 위해, 토큰 대신 짧은 수명의 인가 "코드"가 전달되고, 클라이언트와 인가 서버 간의 보다 안전한 직접 연결을 통해 토큰으로 교환됩니다.

2. 간접적인 인가 요청(indirect authorization request) 컨텍스트보다 클라이언트와 인가 서버 간의 직접 요청에서 클라이언트를 인증하는 것이 훨씬 간단합니다. 후자는 디지털 서명이 필요하기 때문입니다.

### 3.5 리다이렉트 URI (Redirect URI)

리다이렉트 URI는 악의적인 클라이언트를 감지하고, 클라이언트가 사용자를 속여 피싱 공격자(phisher)를 클라이언트로 믿게 하는 피싱 공격을 방지하는 데 도움이 됩니다. 인가 요청에서 사용된 실제 리다이렉트 URI의 값은 인가 "코드"가 토큰으로 교환될 때 제시되고 검증되어야 합니다. 이는 리다이렉터(redirector)와 위조 웹 애플리케이션 클라이언트를 통해 인가 "코드"가 노출되는 공격을 방지하는 데 도움이 됩니다. 인가 서버는 퍼블릭 클라이언트(public clients)와 암시적 권한 부여 유형(implicit grant type)을 사용하는 기밀 클라이언트(confidential clients)에게 리다이렉트 URI를 사전 등록하도록 요구하고, 인가 요청에서 등록된 리다이렉트 URI와 비교 검증해야 합니다.

### 3.6 "state" 파라미터 ("state" Parameter)

`state` 파라미터는 요청과 콜백을 연결하여 교차 사이트 요청 위조(Cross-Site Request Forgery, CSRF) 공격을 방지하는 데 사용됩니다 (Section 4.4.1.8 참조). CSRF 공격에서 공격자는 자신의 리소스에 대한 접근을 인가한 다음, 공격자의 토큰이 포함된 리다이렉트를 따르도록 사용자를 속입니다. 이 파라미터는 사용자 에이전트의 인증된 상태(authenticated state)에 바인딩되어야 하며, 핵심 OAuth 사양에 따라 사용자 에이전트는 클라이언트와 사용자 에이전트만 접근할 수 있는 위치, 즉 동일 출처 정책(same-origin policy)에 의해 보호되는 위치에 이를 보관할 수 있어야 합니다.

### 3.7 클라이언트 식별자 (Client Identifier)

인증 프로토콜은 일반적으로 최종 사용자를 대신하여 동작하는 소프트웨어 컴포넌트의 신원(identity)을 고려하지 않았습니다. OAuth는 위임된 인가(delegated authorization) 시나리오에서 보안 수준을 높이고, 클라이언트가 사용자 없이 동작할 수 있기 때문에 이를 수행합니다.

OAuth는 클라이언트 식별자를 사용하여 동일한 출처의 관련 요청을 대조(collate)합니다. 예를 들어:

- 특정 최종 사용자 인가 프로세스와, 인가 "코드"를 토큰으로 교환하기 위한 토큰 엔드포인트에서의 해당 요청
- 최종 사용자에 의한 특정 클라이언트로의 초기 인가 및 토큰 발행과, 해당 클라이언트에 의한 사용자 동의 없이 토큰을 획득하기 위한 후속 요청 (반복 인가의 자동 처리)

이 식별자는 또한 인가 서버가 특정 클라이언트가 요청하는 스코프에 대해 사용자에게 동의를 요청할 때 관련 등록 정보를 표시하는 데 사용될 수 있습니다. 클라이언트 식별자는 특정 클라이언트의 요청 수를 제한하거나 요청당 클라이언트에 비용을 청구하는 데 사용될 수 있습니다. 또한 서버 로그 파일 등에서 서로 다른 클라이언트의 접근을 구별하는 데에도 유용할 수 있습니다.

---

## 참고 자료

- [RFC 6819 원문](https://www.rfc-editor.org/rfc/rfc6819)
- [RFC 6749 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc6749)
- [RFC 6750 Bearer Token](https://www.rfc-editor.org/rfc/rfc6750)
## 4. 위협 모델 (Threat Model)

이 섹션은 OAuth 2.0에 대한 포괄적인 위협 모델을 제시한다. 위협은 먼저 OAuth 구성 요소(클라이언트, 인가 서버, 리소스 서버)에 대한 공격별로 분류된다. 이후 토큰 획득이나 보호된 리소스 접근 등 흐름(flow)별로 분류된다. 모든 대응 방안 설명은 섹션 5의 상세 설명을 참조한다.

### 4.1. 클라이언트 (Clients)

이 섹션은 OAuth 클라이언트를 대상으로 한 가능한 위협을 설명한다.

#### 4.1.1. 위협: 클라이언트 비밀 획득 (Obtaining Client Secrets)

공격자는 다음을 목적으로 특정 클라이언트의 비밀(secret)에 접근하려 시도할 수 있다:

- 리프레시 토큰(refresh token)과 인가 "코드(code)"를 재생(replay)하거나,
- 해당 "client_id"의 권한으로 공격 대상 클라이언트를 대신하여 토큰을 획득하고, 해당 클라이언트의 인스턴스로 행동하는 것.

> 영향(Impact): 인가 서버에 대한 클라이언트 인증이 우회될 수 있다. 탈취된 리프레시 토큰 또는 인가 "코드"가 재생될 수 있다.

클라이언트 유형에 따라, 다음과 같은 공격이 클라이언트 비밀을 획득하는 데 활용될 수 있다.

공격: 소스 코드 또는 바이너리에서 비밀 획득 (Obtain Secret From Source Code or Binary)

이 공격은 모든 클라이언트 유형에 적용된다. 오픈 소스 프로젝트의 경우, 비밀은 공개 저장소의 소스 코드에서 직접 추출할 수 있다. 공개된 소스 코드가 공격자에게 제공되지 않더라도, 애플리케이션 바이너리에서 비밀을 동일하게 쉽게 추출할 수 있다. 애플리케이션이 배포 시 비밀을 난독화하기 위해 상당한 조치를 취하더라도, 완전한 기능의 애플리케이션 번들이나 바이너리에 접근할 수 있는 사람이라면 누구나 비밀을 리버스 엔지니어링할 수 있다고 간주해야 한다.

대응 방안 (Countermeasures):

- 공개 클라이언트(public client) 또는 부적절한 보안 정책을 가진 클라이언트에게 비밀을 발급하지 않는다 (섹션 5.2.3.1).
- 공개 클라이언트에 대해 사용자 동의를 요구한다 (섹션 5.2.3.2).
- 배포별 클라이언트 비밀(deployment-specific client secrets)을 사용한다 (섹션 5.2.3.4).
- 클라이언트 비밀을 폐기(revoke)한다 (섹션 5.2.3.6).

공격: 배포별 비밀 획득 (Obtain a Deployment-Specific Secret)

공격자는 웹 사이트(웹 서버) 또는 특정 기기(네이티브 애플리케이션)의 클라이언트 설치에서 비밀을 획득하려 시도할 수 있다.

대응 방안 (Countermeasures):

- 웹 서버: 구성 파일 및 데이터베이스에 대해 표준 웹 서버 보호 조치를 적용한다 (섹션 5.3.2 참조).
- 네이티브 애플리케이션: 안전한 로컬 저장소에 비밀을 저장한다 (섹션 5.3.3).
- 클라이언트 비밀을 폐기(revoke)한다 (섹션 5.2.3.6).

#### 4.1.2. 위협: 리프레시 토큰 획득 (Obtaining Refresh Tokens)

클라이언트 유형에 따라, 리프레시 토큰이 공격자에게 노출될 수 있는 다양한 방법이 존재한다. 다음 하위 섹션들은 각기 다른 클라이언트 유형에 대한 다양한 공격과 추가적인 특화된 대응 방안에 대해 더 상세한 설명을 제공한다. 이러한 위협을 상세히 설명하기에 앞서, 일반적으로 적용 가능한 대응 방안은 다음과 같다:

- 인가 서버는 모든 갱신 요청 시 특정 리프레시 토큰과 연관된 클라이언트 ID를 검증해야 한다 (섹션 5.2.2.2).
- 토큰 범위(scope)를 제한한다 (섹션 5.1.5.1).
- 리프레시 토큰을 폐기(revoke)한다 (섹션 5.2.2.4).
- 클라이언트 비밀을 폐기(revoke)한다 (섹션 5.2.3.6).
- 리프레시 토큰은 다른 당사자에 의한 무단 토큰 사용을 감지하기 위해 자동으로 교체될 수 있다 ("리프레시 토큰 순환(Refresh Token Rotation)", 섹션 5.2.2.3 참조).

공격: 웹 애플리케이션에서 리프레시 토큰 획득 (Obtain Refresh Token from Web Application)

공격자는 웹 서버의 보안 제어를 극복하여 웹 애플리케이션에 발급된 리프레시 토큰을 획득할 수 있다.

> 영향(Impact): 웹 애플리케이션은 특정 사이트의 사용자 계정을 관리하므로, 이러한 공격은 해당 사이트의 모든 리프레시 토큰이 공격자에게 노출되는 결과를 초래한다.

대응 방안 (Countermeasures):

- 표준 웹 서버 보호 조치를 적용한다 (섹션 5.3.2).
- 강력한 클라이언트 인증(예: client_assertion/client_token)을 사용하여 공격자가 토큰을 교환하는 데 필요한 클라이언트 비밀을 획득할 수 없도록 한다 (섹션 5.2.3.7).

공격: 네이티브 클라이언트에서 리프레시 토큰 획득 (Obtain Refresh Token from Native Clients)

네이티브 클라이언트에서 리프레시 토큰의 유출은 일반적으로 단일 사용자에게만 영향을 미친다.

로컬 파일 시스템에서 읽기: 공격자는 기기의 파일 시스템 접근 권한을 얻어 리프레시 토큰을 읽으려 시도할 수 있다. 공격자는 이를 위해 악성 애플리케이션을 활용할 수 있다.

대응 방안 (Countermeasures):

- 안전한 저장소에 비밀을 저장한다 (섹션 5.3.3).
- 무단 기기 접근을 방지하기 위해 기기 잠금(device lock)을 활용한다 (섹션 5.3.4).

공격: 기기 도난 (Steal Device)

호스트 기기(예: 휴대전화)가 도난될 수 있다. 이 경우, 공격자는 정당한 사용자의 신원으로 모든 애플리케이션에 접근할 수 있다.

대응 방안 (Countermeasures):

- 무단 기기 접근을 방지하기 위해 기기 잠금(device lock)을 활용한다 (섹션 5.3.4).
- 사용자가 기기가 도난되었음을 인지한 경우, 영향을 받는 토큰을 폐기(revoke)할 수 있다 (섹션 5.2.2.4).

공격: 기기 복제 (Clone Device)

모든 기기 데이터와 애플리케이션이 다른 기기로 복사된다. 애플리케이션은 대상 기기에서 그대로 사용된다.

대응 방안 (Countermeasures):

- 무단 기기 접근을 방지하기 위해 기기 잠금(device lock)을 활용한다 (섹션 5.3.4).
- 리프레시 토큰 요청을 기기 식별(device identification)과 결합한다 (섹션 5.2.2.5).
- 리프레시 토큰 순환(Refresh Token Rotation)을 적용한다 (섹션 5.2.2.3).
- 사용자가 기기가 복제되었음을 인지한 경우, 리프레시 토큰 폐기(refresh token revocation)를 사용할 수 있다 (섹션 5.2.2.4).

#### 4.1.3. 위협: 액세스 토큰 획득 (Obtaining Access Tokens)

클라이언트 유형에 따라, 액세스 토큰이 공격자에게 노출될 수 있는 다양한 방법이 존재한다. 애플리케이션이 다른 애플리케이션이 접근할 수 있는 저장소에 액세스 토큰을 저장하는 경우, 기기에서 토큰이 탈취될 수 있다.

> 영향(Impact): 토큰이 무기명 토큰(bearer token)이고 클라이언트를 식별하기 위한 추가 메커니즘이 사용되지 않는 경우, 공격자는 해당 토큰과 그 범위(scope)에 연관된 모든 리소스에 접근할 수 있다.

대응 방안 (Countermeasures):

- 액세스 토큰을 임시 메모리(transient memory)에 보관하고 권한 부여를 제한한다 (섹션 5.1.6).
- 토큰 범위(scope)를 제한한다 (섹션 5.1.5.1).
- 액세스 토큰을 사적 메모리(private memory)에 보관하거나 리프레시 토큰과 동일한 보호 수단을 적용한다 (섹션 5.2.2).
- 액세스 토큰의 수명을 짧게 유지한다 (섹션 5.1.5.3).

#### 4.1.4. 위협: 손상되거나 내장된 브라우저를 이용한 최종 사용자 자격 증명 피싱 (End-User Credentials Phished Using Compromised or Embedded Browser)

악성 애플리케이션은 최종 사용자 인가 과정에서 내장 브라우저(embedded browser)를 악용하거나, 신뢰할 수 있는 시스템 브라우저가 인가 사용자 인터페이스를 렌더링하도록 허용하는 대신 자체 사용자 인터페이스를 제시하여 최종 사용자의 비밀번호를 피싱하려 시도할 수 있다. 이렇게 함으로써, 일반적인 시각적 신뢰 메커니즘(예: TLS(전송 계층 보안) 확인, 웹 사이트 메커니즘)이 우회될 수 있다. 내장된 또는 내부 클라이언트 애플리케이션 사용자 인터페이스를 사용함으로써, 클라이언트 애플리케이션은 접근해서는 안 되는 추가 정보(예: UID/비밀번호)에 접근할 수 있다.

> 영향(Impact): 클라이언트 애플리케이션 또는 통신이 손상된 경우, 사용자는 이를 인지하지 못하며, 사용자 이름과 비밀번호 등 인가 교환의 모든 정보가 캡처될 수 있다.

대응 방안 (Countermeasures):

- OAuth 흐름은 클라이언트 애플리케이션이 사용자 비밀번호를 알 필요가 없도록 설계되어 있다. 클라이언트 애플리케이션은 사용자에게 직접 자격 증명을 요청하는 것을 피해야 한다. 또한, OAuth는 악성 애플리케이션에 대한 보호를 제공하지 않으며 설치된 네이티브 애플리케이션의 신뢰성에 대한 책임은 전적으로 최종 사용자에게 있으므로, 최종 사용자는 피싱 공격과 신뢰할 수 있는 클라이언트에만 접근하는 것과 같은 모범 사례에 대해 교육받을 수 있다.
- 클라이언트 애플리케이션은 사용자가 접근할 수 있도록 애플리케이션 마켓에 게시되기 전에 검증될 수 있다. 이러한 검증은 OAuth의 범위 밖이지만, 클라이언트 애플리케이션이 적절한 방식으로 사용자 인증을 처리하는지 검증하는 것을 포함할 수 있다.
- 클라이언트 개발자는 사용자로부터 직접 인증 정보를 수집하는 클라이언트 애플리케이션을 작성해서는 안 되며, 대신 이 작업을 시스템 브라우저와 같은 신뢰할 수 있는 시스템 구성 요소에 위임해야 한다.

#### 4.1.5. 위협: 클라이언트의 오픈 리다이렉터 (Open Redirectors on Client)

오픈 리다이렉터(open redirector)는 파라미터를 사용하여 어떠한 검증도 없이 해당 파라미터 값으로 지정된 위치로 사용자 에이전트를 자동 리다이렉트하는 엔드포인트이다. 인가 서버가 클라이언트에게 리다이렉트 URI의 일부만 등록하도록 허용하는 경우, 공격자는 클라이언트가 운영하는 오픈 리다이렉터를 이용하여 인가 서버 검증을 통과하지만 인가 "코드" 또는 액세스 토큰을 공격자가 제어하는 엔드포인트로 전송하는 리다이렉트 URI를 구성할 수 있다.

> 영향(Impact): 공격자가 인가 "코드" 또는 액세스 토큰에 접근할 수 있다.

대응 방안 (Countermeasures):

- 클라이언트가 전체 리다이렉트 URI(full redirect URI)를 등록하도록 요구한다 (섹션 5.2.3.5).

### 4.2. 인가 엔드포인트 (Authorization Endpoint)

#### 4.2.1. 위협: 위조된 인가 서버를 이용한 비밀번호 피싱 (Password Phishing by Counterfeit Authorization Server)

OAuth는 인가 서버의 진위를 검증하려는 시도를 하지 않는다. 적대적인 당사자는 클라이언트의 요청을 가로채고 오해의 소지가 있거나 부정확한 응답을 반환함으로써 이를 악용할 수 있다. 이는 DNS 또는 ARP(주소 결정 프로토콜) 스푸핑을 사용하여 달성될 수 있다. OAuth 및 유사 프로토콜의 광범위한 배포는 사용자가 비밀번호를 입력하라는 웹 사이트로 리다이렉트되는 관행에 무감각해지도록 만들 수 있다. 사용자가 자격 증명을 입력하기 전에 이러한 웹 사이트의 진위를 주의 깊게 확인하지 않는 경우, 공격자가 이 관행을 악용하여 사용자의 비밀번호를 탈취하는 것이 가능해진다.

대응 방안 (Countermeasures):

- 인가 서버는 OAuth 기반 서비스를 개발할 때 이러한 공격을 고려해야 하며, 인가 서버의 진위 또는 요청 응답의 진위가 문제가 되는 모든 요청에 대해 전송 계층 보안(transport-layer security)의 사용을 요구해야 한다 (섹션 5.1.2 참조).
- 인가 서버는 피싱 공격이 제기하는 위험에 대해 사용자를 교육하도록 노력해야 하며, 사용자가 사이트의 진위를 확인하기 쉽게 해주는 메커니즘을 제공해야 한다.

#### 4.2.2. 위협: 사용자가 의도치 않게 과도한 접근 범위를 부여 (User Unintentionally Grants Too Much Access Scope)

최종 사용자 인가를 획득할 때, 최종 사용자는 부여되는 접근의 범위(scope)와 그 대상이 누구인지 이해하지 못할 수 있으며, 허용되어서는 안 되는 리소스에 대한 접근을 클라이언트에게 제공하게 될 수 있다.

대응 방안 (Countermeasures):

- 사용자가 부여하려는 범위(리소스 및 권한)를 이해하기 쉬운 방식으로 설명한다 (섹션 5.2.4.2).
- 클라이언트에 기반하여 범위를 좁힌다. 최종 사용자 인가를 획득할 때 클라이언트가 범위를 요청하는 경우, 인가 서버는 클라이언트 식별자에 기반하여 해당 범위를 존중할지 여부를 고려할 수 있다. 이 결정은 클라이언트와 인가 서버 간의 문제이며 이 사양의 범위 밖이다. 인가 서버는 또한 클라이언트 유형에 기반하여 어떤 범위를 부여할지 고려할 수 있다. 예를 들어, 공개 클라이언트(public client)에게 더 낮은 범위를 제공하는 것이다 (섹션 5.1.5.1).

#### 4.2.3. 위협: 악성 클라이언트가 사기를 통해 기존 인가를 획득 (Malicious Client Obtains Existing Authorization by Fraud)

인가 서버는 사용자가 이전에 인가한 클라이언트의 인가 요청을 자동으로 처리하고자 할 수 있다. 사용자가 접근 권한을 부여하기 위해 인가 서버의 최종 사용자 인가 엔드포인트로 리다이렉트되면, 인가 서버는 사용자가 이미 해당 특정 클라이언트에 접근 권한을 부여했음을 감지한다. 사용자에게 승인을 요청하는 대신, 인가 서버는 자동으로 사용자를 클라이언트로 다시 리다이렉트한다.

악성 클라이언트는 이 기능을 악용하여 정당한 클라이언트 대신 인가 "코드"를 획득하려 시도할 수 있다.

대응 방안 (Countermeasures):

- 인가 서버는 사전 등록된 리다이렉트 URI(pre-registered redirect URI)를 사용하여 클라이언트가 검증되지 않는 한, 공개 클라이언트에 대한 반복 인가를 자동으로 처리해서는 안 된다 (섹션 5.2.3.5).
- 인가 서버는 자동 승인을 통해 획득된 액세스 토큰의 범위를 제한하여 자동 처리와 관련된 위험을 완화할 수 있다 (섹션 5.1.5.1).

#### 4.2.4. 위협: 오픈 리다이렉터 (Open Redirector)

공격자는 최종 사용자 인가 엔드포인트와 리다이렉트 URI 파라미터를 사용하여 인가 서버를 오픈 리다이렉터로 악용할 수 있다. 오픈 리다이렉터는 파라미터를 사용하여 어떠한 검증도 없이 해당 파라미터 값으로 지정된 위치로 사용자 에이전트를 자동 리다이렉트하는 엔드포인트이다.

> 영향(Impact): 공격자가 인가 서버에 대한 사용자의 신뢰를 이용하여 피싱 공격을 시작할 수 있다.

대응 방안 (Countermeasures):

- 클라이언트가 전체 리다이렉트 URI(full redirect URI)를 등록하도록 요구한다 (섹션 5.2.3.5).
- 클라이언트 식별자 또는 리다이렉트 URI를 검증할 수 없는 경우, 리다이렉트 URI로 리다이렉트하지 않는다 (섹션 5.2.3.5).

### 4.3. 토큰 엔드포인트 (Token Endpoint)

#### 4.3.1. 위협: 액세스 토큰 도청 (Eavesdropping Access Tokens)

공격자는 인가 서버에서 클라이언트로 전송 중인 액세스 토큰을 도청하려 시도할 수 있다.

> 영향(Impact): 공격자는 해당 특정 액세스 토큰의 범위(scope)에 포함된 권한으로 모든 리소스에 접근할 수 있다.

대응 방안 (Countermeasures):

- 핵심 OAuth 사양에 따라, 인가 서버는 이러한 전송이 TLS와 같은 전송 계층 메커니즘(transport-layer mechanism)을 사용하여 보호되도록 해야 한다 (섹션 5.1.1 참조).
- 종단 간 기밀성(end-to-end confidentiality)을 보장할 수 없는 경우, 유출 시 피해를 줄이기 위해 액세스 토큰의 범위 축소(섹션 5.1.5.1 참조)와 만료 시간 단축(섹션 5.1.5.3)을 사용할 수 있다.

#### 4.3.2. 위협: 인가 서버 데이터베이스에서 액세스 토큰 획득 (Obtaining Access Tokens from Authorization Server Database)

이 위협은 인가 서버가 액세스 토큰을 핸들(handle) 형태로 데이터베이스에 저장하는 경우에 해당한다. 공격자는 데이터베이스에 접근하거나 SQL 인젝션 공격을 시작하여 인가 서버의 데이터베이스에서 액세스 토큰을 획득할 수 있다.

> 영향(Impact): 모든 액세스 토큰이 노출된다.

대응 방안 (Countermeasures):

- 시스템 보안 조치를 시행한다 (섹션 5.1.4.1.1).
- 액세스 토큰의 해시(hash)만 저장한다 (섹션 5.1.4.1.3).
- 표준 SQL 인젝션 대응 방안을 시행한다 (섹션 5.1.4.1.2).

#### 4.3.3. 위협: 전송 중 클라이언트 자격 증명 노출 (Disclosure of Client Credentials during Transmission)

공격자는 클라이언트 인증 과정 또는 OAuth 토큰 요청 중에 클라이언트와 서버 간의 클라이언트 자격 증명 전송을 도청하려 시도할 수 있다.

> 영향(Impact): 클라이언트 자격 증명이 노출되어 클라이언트 서비스의 피싱 또는 사칭이 가능해진다.

대응 방안 (Countermeasures):

- 클라이언트 자격 증명의 전송은 TLS와 같은 전송 계층 메커니즘(transport-layer mechanism)을 사용하여 보호되어야 한다 (섹션 5.1.1 참조).
- 평문 자격 증명을 네트워크를 통해 전송할 필요가 없는 대체 인증 수단(예: 해시 기반 메시지 인증 코드(Hash-based Message Authentication Code))을 사용한다.

#### 4.3.4. 위협: 인가 서버 데이터베이스에서 클라이언트 비밀 획득 (Obtaining Client Secret from Authorization Server Database)

공격자는 데이터베이스에 접근하거나 SQL 인젝션 공격을 시작하여 인가 서버의 데이터베이스에서 유효한 "client_id"/비밀(secret) 조합을 획득할 수 있다.

> 영향(Impact): 모든 "client_id"/비밀 조합이 노출된다. 이를 통해 공격자가 정당한 클라이언트를 대신하여 행동할 수 있다.

대응 방안 (Countermeasures):

- 시스템 보안 조치를 시행한다 (섹션 5.1.4.1.1).
- 표준 SQL 인젝션 대응 방안을 시행한다 (섹션 5.1.4.1.2).
- "자격 증명 저장소 보호 모범 사례 시행(Enforce Credential Storage Protection Best Practices)"에 따라 자격 증명을 적절히 처리한다 (섹션 5.1.4.1).

#### 4.3.5. 위협: 온라인 추측을 통한 클라이언트 비밀 획득 (Obtaining Client Secret by Online Guessing)

공격자는 유효한 "client_id"/비밀(secret) 쌍을 추측하려 시도할 수 있다.

> 영향(Impact): 단일 "client_id"/비밀 쌍이 노출된다.

대응 방안 (Countermeasures):

- 비밀에 높은 엔트로피(high entropy)를 사용한다 (섹션 5.1.4.2.2).
- 계정을 잠금(lock) 처리한다 (섹션 5.1.4.2.3).
- 강력한 클라이언트 인증(strong client authentication)을 사용한다 (섹션 5.2.3.7).
### 4.4. 인가 획득 (Obtaining Authorization)

이 섹션은 액세스 토큰(access token)을 획득하는 데 사용되는 특정 플로우(flow)에 고유한 위협을 다룬다. 각 플로우는 최종 사용자 인가 및 토큰 엔드포인트(endpoint)에서의 응답 유형(response type) 및/또는 권한 부여 유형(grant type)으로 특성화된다.

#### 4.4.1. 인가 "코드" (Authorization "code")

##### 4.4.1.1. 위협: 인가 "코드"의 도청 또는 유출 (Threat: Eavesdropping or Leaking Authorization "codes")

공격자는 인가 서버(authorization server)와 클라이언트(client) 간의 인가 "코드" 전송을 도청하려고 시도할 수 있다. 또한, 인가 "코드"는 브라우저를 통해 전달되므로, 다양한 방식으로 신뢰할 수 없는 웹사이트 및 공격자에게 의도치 않게 해당 코드가 유출될 수 있다:

- Referrer 헤더: 브라우저는 웹 페이지가 콘텐츠를 포함하거나 사용자가 한 웹 페이지에서 다른 웹 페이지로 이동할 때 "referer" 헤더를 자주 전달한다. 이러한 referrer 헤더는 출발지 사이트가 목적지 사이트를 신뢰하지 않는 경우에도 전송될 수 있다. referrer 헤더는 일반적으로 트래픽 분석 목적으로 기록된다.

- 요청 로그(Request logs): 웹 서버 요청 로그는 일반적으로 요청의 쿼리 매개변수(query parameter)를 포함한다.

- 오픈 리다이렉터(Open redirectors): 웹사이트는 때때로 리다이렉터를 통해 사용자를 다른 목적지로 보내야 한다. 오픈 리다이렉터는 웹 기반 위임 프로토콜에 특별한 위험을 초래하는데, 리다이렉터가 신뢰할 수 없는 목적지 사이트로 인증 코드를 유출할 수 있기 때문이다.

- 브라우저 히스토리(Browser history): 웹 브라우저는 일반적으로 방문한 URL을 브라우저 히스토리에 기록한다. 같은 웹 브라우저의 다른 사용자가 이전 사용자가 방문한 URL을 볼 수 있을 수 있다.

참고: SAML 프로토콜에 대한 유사한 공격에 대한 설명은 [OASIS.sstc-saml-bindings-1.1], 섹션 4.1.1.9.1; [Sec-Analysis]; 및 [OASIS.sstc-sec-analysis-response-01]에서 찾을 수 있다.

대응 방안 (Countermeasures):

- 핵심 OAuth 사양에 따라, 인가 서버와 클라이언트는 TLS와 같은 전송 계층 메커니즘을 사용하여 이러한 전송이 보호되도록 해야 한다(섹션 5.1.1 참조).

- 인가 서버는 가능한 한 클라이언트를 인증하도록 요구하여, 인가 "코드"와 특정 클라이언트의 바인딩을 신뢰할 수 있는 방식으로 검증할 수 있도록 해야 한다(섹션 5.2.4.4 참조).

- 인가 "코드"에 짧은 만료 시간을 사용한다(섹션 5.1.5.3).

- 인가 서버는 일회성 사용 제한을 적용해야 한다(섹션 5.1.5.4 참조).

- 인가 서버가 인가 "코드"를 교환하려는 여러 시도를 관찰하면, 인가 서버는 해당 인가 "코드"를 기반으로 부여된 모든 토큰을 취소하는 것을 고려할 수 있다(섹션 5.2.1.1 참조).

- 이러한 대응 방안이 없는 경우, 액세스 토큰의 범위 축소(섹션 5.1.5.1) 및 만료 시간 단축(섹션 5.1.5.3)을 사용하여 유출 시 피해를 줄일 수 있다.

- 클라이언트 서버는 브라우저 캐시를 자동으로 정리하기 위해 리다이렉트 URI의 대상 페이지를 다시 로드할 수 있다.

##### 4.4.1.2. 위협: 인가 서버 데이터베이스에서 인가 "코드" 획득 (Threat: Obtaining Authorization "codes" from Authorization Server Database)

이 위협은 인가 서버가 인가 "코드"를 데이터베이스에 핸들(handle)로 저장하는 경우에 적용된다. 공격자는 데이터베이스에 대한 접근 권한을 얻거나 SQL 인젝션 공격을 실행하여 인가 서버의 데이터베이스에서 인가 "코드"를 획득할 수 있다.

영향 (Impact): 모든 인가 "코드"가 노출되며, 대부분의 경우 각각의 "redirect_uri" 및 "client_id" 값도 함께 노출된다.

대응 방안 (Countermeasures):

- 자격 증명 저장소 보호를 위한 모범 사례를 적용해야 한다(섹션 5.1.4.1).

- 시스템 보안 조치를 시행한다(섹션 5.1.4.1.1).

- 액세스 토큰 해시만 저장한다(섹션 5.1.4.1.3).

- 표준 SQL 인젝션 대응 방안을 시행한다(섹션 5.1.4.1.2).

##### 4.4.1.3. 위협: 인가 "코드"의 온라인 추측 (Threat: Online Guessing of Authorization "codes")

공격자는 유효한 인가 "코드" 값을 추측하려고 시도하고, 유효한 액세스 토큰을 획득하기 위해 권한 부여 유형 "code"를 사용하여 추측한 코드 값을 전송할 수 있다.

영향 (Impact): 단일 액세스 토큰이 노출되며, 관련 갱신 토큰(refresh token)도 함께 노출될 가능성이 있다.

대응 방안 (Countermeasures):

- 핸들 기반 토큰은 높은 엔트로피(high entropy)를 사용해야 한다(섹션 5.1.4.2.2).

- 어설션 기반 토큰(assertion-based token)은 서명되어야 한다(섹션 5.1.5.9).

- 클라이언트를 인증한다; 이는 공격자가 추측해야 할 또 다른 값을 추가한다(섹션 5.2.3.4).

- 인가 "코드"를 리다이렉트 URI에 바인딩한다; 이는 공격자가 추측해야 할 또 다른 값을 추가한다(섹션 5.2.4.5).

- 토큰에 짧은 만료 시간을 사용한다(섹션 5.1.5.3).

##### 4.4.1.4. 위협: 악성 클라이언트가 인가 획득 (Threat: Malicious Client Obtains Authorization)

악성 클라이언트는 유효한 클라이언트인 것처럼 위장하여 이러한 방식으로 액세스 인가를 획득할 수 있다. 악성 클라이언트는 인가 플로우에서 사용자의 동의를 시뮬레이션하기 위해 화면 스크래핑(screen-scraping) 기술까지 활용할 수 있다.

가정 (Assumption): 최종 사용자의 장치를 악성 소프트웨어로부터 보호하는 것은 인가 서버의 작업이 아니다. 이는 특정 장치에서 실행되는 플랫폼의 책임이며, 아마도 해당 에코시스템의 다른 구성 요소(예: 애플리케이션 관리 인프라)와 협력하여 이루어진다. 인가 서버의 유일한 책임은 리소스 서버에 유지되는 최종 사용자의 리소스에 대한 접근을 제어하고 OAuth 프로토콜을 통한 무단 접근을 방지하는 것이다. 이 가정을 기반으로, 다음과 같은 대응 방안을 사용하여 위협에 대처할 수 있다.

대응 방안 (Countermeasures):

- 인가 서버는 가능한 경우 클라이언트를 인증해야 한다(섹션 5.2.3.4 참조). 참고: 인증은 최종 사용자가 접근을 승인한 후에 이루어진다.

- 인가 서버는 사전 등록된 리다이렉트 URI가 있는 경우 클라이언트의 리다이렉트 URI를 사전 등록된 리다이렉트 URI와 비교하여 검증해야 한다(섹션 5.2.3.5 참조). 참고: 유효하지 않은 리다이렉트 URI는 유효하지 않은 클라이언트를 나타내지만, 유효한 리다이렉트 URI가 반드시 유효한 클라이언트를 나타내는 것은 아니다. 신뢰 수준은 클라이언트 유형에 따라 다르다. 웹 애플리케이션의 경우, 리다이렉트 URI가 이 애플리케이션의 전역적으로 고유한 네트워크 엔드포인트를 참조하고, 그 정규화된 도메인 이름(FQDN)은 사용자 에이전트에 의해 HTTPS 서버 인증을 사용하여 검증되므로 신뢰 수준이 높다. 반면, 네이티브 클라이언트의 경우, 리다이렉트 URI는 일반적으로 장치 로컬 리소스(예: 사용자 지정 스킴)를 참조한다. 따라서, 특정 장치의 악성 클라이언트는 합법적인 클라이언트가 다른 모든 장치에서 사용하는 유효한 리다이렉트 URI를 사용할 수 있다.

- 최종 사용자를 인증한 후, 인가 서버는 사용자에게 동의를 요청해야 한다. 이 맥락에서, 인가 서버는 클라이언트가 요청한 인가의 목적, 범위 및 기간을 최종 사용자에게 설명해야 한다. 또한, 인가 서버는 해당 클라이언트에 대해 보유하고 있는 모든 신원 정보를 사용자에게 표시해야 한다. 이 데이터와 특정 애플리케이션(예: 이름)의 바인딩을 검증하고 인가 요청을 승인하는 것은 사용자의 몫이다(섹션 5.2.4.3 참조).

- 인가 서버는 신뢰성 있게 인증하거나 검증할 수 없는 클라이언트에 대해 자동 재인가를 수행해서는 안 된다(섹션 5.2.4.1 참조).

- 인가 서버가 최종 사용자를 자동으로 인증하는 경우에도, 화면 스크래핑을 방지하기 위해 일부 사용자 입력을 요구할 수 있다. 예를 들어, CAPTCHA(컴퓨터와 인간을 구별하기 위한 완전 자동화된 공개 튜링 테스트) 또는 무작위 질문, 토큰 코드 생성기 등과 같은 다른 다중 요소 인증(multi-factor authentication) 기술이 있다.

- 인가 서버는 또한 신뢰성 있게 인증할 수 없는 클라이언트에 발급하는 토큰의 범위를 제한할 수 있다(섹션 5.1.5.1 참조).

##### 4.4.1.5. 위협: 인가 "코드" 피싱 (Threat: Authorization "code" Phishing)

적대적인 당사자가 클라이언트 사이트를 위장하고 인가 "코드"에 대한 접근을 획득할 수 있다. 이는 DNS 또는 ARP 스푸핑(spoofing)을 사용하여 달성할 수 있다. 이는 웹 애플리케이션인 클라이언트에 적용되며, 따라서 리다이렉트 URI는 사용자의 브라우저가 실행되는 호스트에 로컬이 아니다.

영향 (Impact): 이는 웹 애플리케이션에 영향을 미치며 인가 "코드"의 노출과, 잠재적으로 해당하는 액세스 토큰 및 갱신 토큰의 노출로 이어질 수 있다.

대응 방안 (Countermeasures):

이 공격을 방지하기 위해 다음 대응 방안 중 하나를 활용하는 것이 강력히 권장된다:

- 클라이언트의 리다이렉트 URI는 HTTPS로 보호되는 엔드포인트를 가리켜야 하며, 브라우저는 서버 인증을 사용하여 이 리다이렉트 URI를 인증하는 데 활용되어야 한다(섹션 5.1.2 참조).

- 인가 서버는 클라이언트가 인증되도록 요구해야 한다. 즉, 기밀 클라이언트(confidential client)여야 하며, 인가 "코드"와 특정 클라이언트의 바인딩을 신뢰할 수 있는 방식으로 검증할 수 있어야 한다(섹션 5.2.4.4 참조).

##### 4.4.1.6. 위협: 사용자 세션 위장 (Threat: User Session Impersonation)

적대적인 당사자가 클라이언트 사이트를 위장하고 이 클라이언트에서 사용자의 세션을 위장할 수 있다. 이는 DNS 또는 ARP 스푸핑을 사용하여 달성할 수 있다. 이는 웹 애플리케이션인 클라이언트에 적용되며, 따라서 리다이렉트 URI는 사용자의 브라우저가 실행되는 호스트에 로컬이 아니다.

영향 (Impact): 브라우저가 콜백 엔드포인트로 인가 "코드"를 전송할 때 이를 가로채는 공격자는 해당 인가 "코드"를 클라이언트에 제출하여 보호된 리소스에 대한 접근을 획득할 수 있다. 클라이언트는 인가 "코드"를 액세스 토큰으로 교환하고, 공격자의 이익을 위해 보호된 리소스에 접근하는 데 액세스 토큰을 사용하여, 공격자에게 보호된 리소스를 전달하거나 공격자가 지시한 대로 보호된 리소스를 수정한다. OAuth가 소셜 사이트에 대한 인증을 위임하기 위해 클라이언트에 의해 사용되는 경우(예: 제3자 소셜 네트워크 사이트에서 "로그인" 버튼의 구현과 같이), 공격자는 가로챈 인가 "코드"를 사용하여 해당 사용자로서 클라이언트에 로그인할 수 있다.

참고: 인가 "코드" 교환 중 클라이언트를 인증하는 것은 이러한 공격을 감지하는 데 도움이 되지 않는데, 토큰을 획득하는 것이 합법적인 클라이언트이기 때문이다.

대응 방안 (Countermeasures):

- 공격자가 최종 사용자의 세션을 위장하는 것을 방지하기 위해, 클라이언트의 리다이렉트 URI는 HTTPS로 보호되는 엔드포인트를 가리켜야 하며, 브라우저는 서버 인증을 사용하여 이 리다이렉트 URI를 인증하는 데 활용되어야 한다(섹션 5.1.2 참조).

##### 4.4.1.7. 위협: 위조 클라이언트를 통한 인가 "코드" 유출 (Threat: Authorization "code" Leakage through Counterfeit Client)

공격자는 인가 "코드" 권한 부여 유형을 이용하여 다른 사용자(피해자)가 로그인하고, 자신의 리소스에 대한 접근을 인가하고, 이후 인가 "코드"를 획득하여 공격자의 계정을 사용하는 클라이언트 애플리케이션에 주입하려고 시도한다. 목표는 피해자의 리소스에 대한 접근 인가를 클라이언트 사이트에서 공격자의 사용자 계정과 연결하는 것이다.

공격자는 기존 클라이언트 애플리케이션을 악용하고 자신의 위조 클라이언트 웹사이트와 결합한다. 공격자는 피해자가 클라이언트 애플리케이션이 특정 리소스 서버에 대한 접근을 요청할 것으로 기대하는 것에 의존한다. 피해자는 예상된 애플리케이션의 정상적인 요청만 보고 요청을 승인한다. 그런 다음 공격자는 피해자가 모르게 인가한 정보에 접근하기 위해 피해자의 인가를 사용한다.

공격자는 다음과 같은 플로우를 수행한다:

1. 공격자는 클라이언트 웹사이트(또는 애플리케이션)에 접근하고 특정 리소스 서버에 대한 데이터 접근을 시작한다. 클라이언트 웹사이트는 이에 따라 리소스 서버의 인가 서버에 인가 요청을 시작한다. 인가 프로세스를 진행하는 대신, 공격자는 클라이언트가 구성한 인가 서버 최종 사용자 인가 URL을 수정하여 자신의 제어 하에 있는 웹사이트(공격자의 웹사이트)를 참조하는 리다이렉트 URI 매개변수를 포함시킨다.

2. 공격자는 다른 사용자(피해자)를 속여서 수정된 최종 사용자 인가 URI를 열고 접근을 인가하도록 한다(예: 이메일 링크 또는 블로그 링크를 통해). 공격자가 이 목표를 달성하는 방법은 범위 밖이다.

3. 링크를 클릭하면, 피해자는 인증을 요청받고 클라이언트 사이트에 접근 권한을 인가하도록 요청받는다.

4. 인가 프로세스가 완료된 후, 인가 서버는 원래 클라이언트 웹사이트 대신 공격자의 웹사이트로 사용자 에이전트를 리다이렉트한다.

5. 공격자는 이 문서의 범위 밖의 수단을 통해 자신의 웹사이트에서 인가 "코드"를 획득한다.

6. 그런 다음 공격자는 원래 인가 요청의 리다이렉트 URI와 새로 획득한 인가 "코드"를 기반으로 대상 웹사이트(또는 애플리케이션)에 대한 리다이렉트 URI를 구성하고, 자신의 사용자 에이전트를 이 URL로 보낸다. 인가 "코드"는 원래 클라이언트 사이트(또는 애플리케이션)에 주입된다.

7. 클라이언트 사이트는 인가 "코드"를 사용하여 인가 서버에서 토큰을 가져오고, 이 토큰을 이 사이트에서 공격자의 사용자 계정과 연결한다.

8. 공격자는 이제 클라이언트 사이트를 사용하여 피해자의 리소스에 접근할 수 있다.

영향 (Impact): 공격자는 클라이언트 사이트에서 자신의 계정과 연결된 피해자의 리소스에 대한 접근을 획득한다.

대응 방안 (Countermeasures):

- 공격자는 플로우를 가로채야 하므로 대상 웹사이트가 아닌 다른 리다이렉트 URI를 인가 프로세스에 사용해야 한다. 따라서, 인가 서버가 인가 "코드"를 특정 최종 사용자 인가의 리다이렉트 URI와 연결하고 이 리다이렉트 URI를 토큰 엔드포인트에 전달된 리다이렉트 URI와 검증하면, 이러한 공격이 감지된다(섹션 5.2.4.5 참조).

- 인가 서버는 또한 사전 등록된 리다이렉트 URI의 사용 및 검증을 강제할 수 있다(섹션 5.2.3.5 참조). 이를 통해 위조 클라이언트에 대한 인가 "코드" 노출을 조기에 인식할 수 있다.

- 네이티브 애플리케이션의 경우, 배포별 클라이언트 ID 및 시크릿(secret)을 사용하는 것(섹션 5.2.3.4 참조)과 인가 "코드"와 "client_id"의 바인딩(섹션 5.2.4.4 참조)을 함께 고려하여 이러한 공격을 감지할 수 있는데, 공격자가 배포별 시크릿에 대한 접근 권한이 없기 때문이다. 따라서, 공격자는 인가 "코드"를 교환할 수 없게 된다.

- 클라이언트는 이러한 종류의 공격에 취약하지 않은 다른 플로우를 사용하는 것을 고려할 수 있다. 예를 들어, 암묵적 권한 부여 유형(implicit grant type)(섹션 4.4.2 참조) 또는 리소스 소유자 비밀번호 자격 증명(resource owner password credentials)(섹션 4.4.3 참조)이 있다.

##### 4.4.1.8. 위협: 리다이렉트 URI에 대한 CSRF 공격 (Threat: CSRF Attack against redirect-uri)

교차 사이트 요청 위조(Cross-site request forgery, CSRF)는 웹사이트가 신뢰하거나 인증한 사용자로부터 HTTP 요청이 전송되는 웹 기반 공격이다(예: HTTP 리다이렉트 또는 HTML 폼을 통해). OAuth 승인에 대한 CSRF 공격은 공격자가 사용자의 동의 없이 OAuth로 보호된 리소스에 대한 인가를 획득할 수 있게 한다.

이 공격은 인가 "코드" 플로우에서 사용되는 리다이렉트 URI에 대해 작동한다. 공격자는 인가 서버에서 자신의 보호된 리소스에 대한 인가 "코드"를 인가할 수 있다. 그런 다음 자신의 장치에서 클라이언트로의 리다이렉트 플로우를 중단하고 피해자를 속여 클라이언트로의 리다이렉트를 실행하게 한다. 클라이언트는 리다이렉트를 수신하고, 인가 서버에서 토큰을 가져오고, 피해자의 클라이언트 세션을 토큰을 사용하여 접근 가능한 리소스와 연결한다.

영향 (Impact): 사용자가 공격자를 대신하여 리소스에 접근한다. 실질적인 영향은 접근되는 리소스의 유형에 따라 다르다. 예를 들어, 사용자가 공격자의 리소스에 개인 항목을 업로드할 수 있다. 또는, 제3자 로그인 시나리오에서 OAuth를 사용할 때, 사용자가 자신의 클라이언트 계정을 외부 ID 제공자(Identity Provider)에서 공격자의 신원과 연결할 수 있다. 이러한 방식으로, 공격자는 외부 ID 제공자에서 자신의 자격 증명으로 다른 장치에서 로그인하여 클라이언트에서 피해자의 데이터에 쉽게 접근할 수 있다.

대응 방안 (Countermeasures):

- "state" 매개변수를 사용하여 인가 요청과 액세스 토큰을 전달하는 데 사용되는 리다이렉트 URI를 연결해야 한다(섹션 5.3.5).

- 클라이언트 개발자와 최종 사용자는 신뢰할 수 없는 URL을 따르지 않도록 교육받을 수 있다.

##### 4.4.1.9. 위협: 인가에 대한 클릭재킹 공격 (Threat: Clickjacking Attack against Authorization)

클릭재킹(clickjacking)에서, 악성 사이트는 대상 사이트를 투명한 iFrame([iFrame] 참조)에 로드하여 대상 사이트의 중요한 버튼 바로 아래에 정확히 배치되도록 신중하게 구성된 가짜 버튼 세트 위에 겹쳐 놓는다. 사용자가 보이는 버튼을 클릭하면, 실제로는 숨겨진 페이지의 버튼(예: "인가" 버튼)을 클릭하는 것이다.

영향 (Impact): 공격자는 사용자의 인증 자격 증명을 탈취하고 그들의 리소스에 접근할 수 있다.

대응 방안 (Countermeasures):

- 최신 브라우저의 경우, X-FRAME-OPTIONS 헤더를 사용하여 인가 중 iFrame의 회피를 서버 측에서 강제할 수 있다(섹션 5.2.2.6).

- 이전 브라우저의 경우, JavaScript 프레임 버스팅(frame-busting)([Framebusting] 참조) 기술을 사용할 수 있지만 모든 브라우저에서 효과적이지 않을 수 있다.

##### 4.4.1.10. 위협: 리소스 소유자 위장 (Threat: Resource Owner Impersonation)

클라이언트가 보호된 리소스에 대한 접근을 요청할 때, 인가 플로우는 일반적으로 보호된 리소스에 대한 접근을 부여하거나 거부하는 리소스 소유자의 명시적 응답을 포함한다. 악성 클라이언트는 이 플로우의 구조에 대한 지식을 악용하여, 필요한 요청을 프로그래밍 방식으로 전송하고 인가 서버에 대해 플로우를 시뮬레이션함으로써 리소스 소유자의 동의 없이 인가를 획득할 수 있다. 이렇게 하면, 클라이언트는 피해자의 승인 없이 피해자의 리소스에 접근할 수 있다. 인가 서버가 비대화형 인증 메커니즘을 사용하거나 인가 플로우를 여러 페이지에 걸쳐 분할하는 경우 이 위협에 취약하다.

악성 클라이언트는 숨겨진 HTML 사용자 에이전트를 포함하고, 인가 서버가 보낸 HTML 폼을 해석하고, 해당하는 폼 HTTP POST 요청을 자동으로 전송할 수 있다. 전제 조건으로, 공격자는 인가 서버와 리소스 소유자의 이미 인증된 세션 컨텍스트에서 인가 프로세스를 실행할 수 있어야 한다. 이를 달성하는 다양한 방법이 있다:

- 악성 클라이언트는 특정 장치의 외부 브라우저에 있는 기존 세션 또는 교차 브라우저 쿠키를 악용할 수 있다.

- 악성 클라이언트는 또한 사용자에게 수용 가능한 초기 범위에 대한 인가를 요청한 다음, 자신의 브라우저 인스턴스에서 결과 세션을 조용히 악용하여 다른 범위를 "조용히" 요청할 수 있다.

- 대안적으로, 공격자는 인가 서버가 리소스 소유자를 자동으로 사용자 상호 작용 없이 인증하는 능력을 악용할 수 있다. 예를 들어, 인증서(certificate)를 기반으로 한다.

모든 경우에, 이러한 공격은 사용자 에이전트 내에서 또는 네이티브 앱으로서 피해자의 장치에서 실행되는 클라이언트로 제한된다.

참고: 이러한 공격은 CSRF 대응 방안을 사용하여 방지할 수 없는데, 공격자가 논스(nonce) 등을 포함하여 인가 서버가 준비한 URL을 그대로 "실행"하기 때문이다.

대응 방안 (Countermeasures):

인가 서버는 이 위협과 관련된 위험 분석에 기반하여, 이 위협을 감지하고 방지할 것인지 결정해야 한다.

이러한 공격을 방지하기 위해, 인가 서버는 사용자 동의 승인의 일부로서 예측 불가능한 입력 값에 기반한 사용자 상호 작용을 강제할 수 있다. 인가 서버는 다음과 같이 할 수 있다:

- 비밀번호 인증과 사용자 동의를 단일 폼에 결합한다.

- CAPTCHA를 사용한다.

- 대역 외(out of band)로 리소스 소유자에게 전송되는 일회용 비밀(one-time secret)을 사용한다(예: 문자 메시지 또는 인스턴트 메시지를 통해).

대안적으로, 리소스 소유자가 남용을 감지할 수 있도록, 인가 서버는 적절한 수단(예: 문자 또는 인스턴트 메시지, 또는 이메일)을 통해 리소스 소유자에게 모든 승인을 알릴 수 있다.

##### 4.4.1.11. 위협: 리소스를 소진하는 DoS 공격 (Threat: DoS Attacks That Exhaust Resources)

인가 서버가 인가 "코드" 또는 액세스 토큰에 사소하지 않은 양의 엔트로피를 포함하고(가능한 코드/토큰의 수를 제한), 사용자 개입 없이 자동으로 부여하며, 사용자당 코드 또는 액세스 토큰에 대한 제한이 없는 경우, 공격자는 사용자의 브라우저를 반복적으로 인가 "코드" 또는 액세스 토큰을 요청하도록 유도하여 인가 "코드" 풀을 소진시킬 수 있다.

대응 방안 (Countermeasures):

- 인가 서버는 사용자당 부여되는 액세스 토큰의 수를 제한하는 것을 고려해야 한다.

- 인가 서버는 인가 "코드"에 사소하지 않은 양의 엔트로피를 포함해야 한다.

##### 4.4.1.12. 위협: 제조된 인가 "코드"를 사용한 DoS (Threat: DoS Using Manufactured Authorization "codes")

봇넷을 소유한 공격자는 HTTP에서 수신 대기하는 클라이언트의 리다이렉트 URI를 찾아, 무작위 인가 "코드"로 접근하고, 대량의 HTTPS 연결이 인가 서버에 집중되도록 할 수 있다. 이는 인가 서버에 대한 서비스 거부(DoS) 공격을 초래할 수 있다.

이 공격은 클라이언트 측에 CSRF 방어/"state" 매개변수(섹션 4.4.1.8 참조)가 배포된 경우에도 여전히 효과적일 수 있다. 이러한 방어를 사용하면, 공격자는 유효한 CSRF 코드/"state" 매개변수를 획득하기 위해 추가 HTTP 요청을 발생시켜야 할 수 있다. 이는 분명히 공격의 효과를 2배 줄인다. 그러나 HTTPS/HTTP 비용 비율이 2보다 높으면([SSL-Latency]에서 비용 계수는 약 3.5배로 추정됨), 공격자는 여전히 인가 서버의 비용으로 리소스 활용의 증폭을 달성한다.

영향 (Impact): 공격자가 이 OAuth 플로우로 달성할 수 있는 몇 가지 효과가 있으며, 이는 다른 방법으로는 쉽게 달성할 수 없는 것들이다.

1. 연결 세탁(Connection laundering): 클라이언트가 공격자와 인가 서버 사이의 중계 역할을 하므로, 인가 서버는 공격자의 신원에 대한 정보를 거의 또는 전혀 알 수 없다. 공격 머신에 대한 속도 제한과 같은 방어는 공격 머신을 식별하기 어렵기 때문에 덜 효과적이다. 공격자는 Tor와 같은 익명화 시스템을 통해 연결을 세탁할 수도 있지만, 그 접근 방식의 효과는 익명화 시스템의 용량에 따라 다르다. 반면, 잠재적으로 많은 수의 OAuth 클라이언트가 이 공격에 활용될 수 있다.

2. 비대칭 리소스 활용(Asymmetric resource utilization): 공격자는 HTTP 연결 비용을 부담하고 인가 서버에서 HTTPS 연결이 이루어지게 한다; 공격자는 여러 클라이언트에 걸쳐 이러한 HTTPS 연결의 타이밍을 비교적 쉽게 조정할 수 있다. 공격자는 예를 들어, HTTP 웹 페이지에 인가 서버의 HTTPS URL을 가리키는 iFrame을 포함하고 웹 사용자를 해당 페이지 방문으로 유인하여 유사한 것을 달성할 수 있지만, 이러한 방식을 사용한 타이밍 공격은 공격자의 통제 하에 있는 특정 사이트를 많은 수의 사용자가 동시에 방문하도록 동기화하는 것이 사소하지 않아 보이므로 더 어려울 수 있다.

대응 방안 (Countermeasures):

- 그 자체로 완전한 대응 방안은 아니지만, CSRF 방어와 안전한 난수 코드로 생성된 "state" 매개변수가 클라이언트 측에 배포되어야 한다. 클라이언트는 CSRF 토큰과 "state" 매개변수가 모두 검증된 후에만 인가 "코드"를 인가 서버에 전달해야 한다.

- 클라이언트가 싱글 사인온(single-sign-on) 프로토콜 또는 로컬 인증을 통해 사용자를 인증하는 경우, 이 사용자가 제출한 유효하지 않은 인가 "코드"의 수가 특정 임계값을 초과하면 클라이언트는 사용자 계정에 의한 접근을 중단해야 한다.

- 인가 서버는 유효하지 않은 인가 "코드"를 보고하는 오류 응답을 클라이언트에 전송해야 하며, 유효하지 않은 요청 수가 임계값을 초과하는 클라이언트의 연결을 속도 제한하거나 차단해야 한다.

##### 4.4.1.13. 위협: 코드 치환 (OAuth 로그인) (Threat: Code Substitution (OAuth Login))

공격자는 피해자의 신원을 사용하여 애플리케이션 또는 웹사이트에 로그인하려고 시도할 수 있다. 사용자를 로그인시키기 위해 OAuth로 보호된 서비스 API가 제공하는 신원 데이터에 의존하는 애플리케이션은 이 위협에 취약하다. 이 패턴은 소위 "소셜 로그인(social login)" 시나리오에서 찾을 수 있다.

전제 조건으로, 리소스 서버는 사용자 신원을 획득한 것으로 해석될 수 있는 사용자에 대한 개인 정보를 획득하기 위한 API를 제공한다. 이러한 의미에서, 클라이언트는 리소스 서버 API를 "신원(identity)" API로 취급한다. 클라이언트는 OAuth를 활용하여 신원 API에 대한 액세스 토큰을 획득한다. 그런 다음 신원 API에 식별자를 조회하고 이를 사용하여 내부 사용자 계정 데이터를 조회한다(로그인). 클라이언트는 사용자에 대한 정보를 획득할 수 있었기 때문에 사용자가 인증되었다고 가정한다.

클라이언트가 권한 부여 유형 "code"를 사용하는 경우, 공격자는 대상 클라이언트 애플리케이션이 사용하는 것과 동일한 ID 제공자(Identity Provider)로부터 해당 피해자의 유효한 인가 "코드"를 수집해야 한다. 공격자는 피해자를 속여 대상 애플리케이션과 동일한 ID 제공자를 사용하여 악성 앱(ID 제공자에게 합법적으로 보일 수 있음)에 로그인하게 한다. 이로 인해 ID 제공자의 인가 서버가 해당 신원 API에 대한 인가 "코드"를 발급한다. 악성 앱은 이 코드를 공격자에게 전송하고, 이는 다시 대상 애플리케이션 내에서 로그인 프로세스를 트리거한다. 공격자는 이제 인가 응답을 조작하고 자신의 코드(자신의 신원에 바인딩된)를 피해자의 코드로 치환한다. 이 코드는 클라이언트에 의해 액세스 토큰으로 교환되며, 이 토큰은 리소스 서버에 대한 대상(audience)이 올바르므로 신원 API에 의해 수락된다. 그러나 신원 API가 반환하는 식별자는 액세스 토큰(피해자의 코드를 기반으로 발급된)의 신원에 의해 결정되므로, 공격자는 피해자의 신원으로 대상 애플리케이션에 로그인된다.

영향 (Impact): 공격자는 애플리케이션 및 애플리케이션 내의 사용자별 데이터에 대한 접근을 획득한다.

대응 방안 (Countermeasures):

- 모든 클라이언트는 인가 "코드"를 액세스 토큰으로 교환하는 모든 요청에 클라이언트 ID를 표시해야 한다. 인가 서버는 특정 인가 "코드"가 특정 클라이언트에 발급되었는지 검증해야 한다. 가능한 경우, 클라이언트는 사전에 인증되어야 한다.

- 클라이언트는 사용자 로그인을 구현하기 위해 OpenID([OPENID] 참조) 또는 SAML([OASIS.sstc-saml-bindings-1.1] 참조)과 같은 적절한 프로토콜을 사용해야 한다. 두 프로토콜 모두 클라이언트에 대한 대상 제한(audience restriction)을 지원한다.

#### 4.4.2. 암묵적 권한 부여 (Implicit Grant)

암묵적 권한 부여 유형(implicit grant type) 플로우에서, 액세스 토큰은 리다이렉트 URI의 프래그먼트(fragment) 부분으로 클라이언트에 직접 반환된다. HTTP 사용자 에이전트가 URI의 프래그먼트 부분을 HTTP 서버에 전송하지 않으므로 토큰이 리다이렉트 URI 대상으로 전송되지 않는다고 가정한다. 따라서, 공격자는 이 통신 경로에서 액세스 토큰을 도청할 수 없으며, HTTP referrer 헤더를 통해 토큰이 유출될 수 없다.

##### 4.4.2.1. 위협: 전송/엔드포인트에서의 액세스 토큰 유출 (Threat: Access Token Leak in Transport/Endpoints)

이 토큰은 공격자에 의해 도청될 수 있다. 토큰은 리다이렉트 URI의 URI 프래그먼트를 통해 서버에서 클라이언트로 전송된다. 통신이 보안되지 않거나 엔드포인트가 보안되지 않으면, 반환된 URI를 파싱하여 토큰이 유출될 수 있다.

영향 (Impact): 공격자는 토큰에 의해 부여된 것과 동일한 권한을 행사할 수 있다.

대응 방안 (Countermeasures):

- 인가 서버는 인가 서버에서 클라이언트로의 응답의 기밀성을 보장해야 한다(예: TLS 사용)(섹션 5.1.1 참조).

##### 4.4.2.2. 위협: 브라우저 히스토리에서의 액세스 토큰 유출 (Threat: Access Token Leak in Browser History)

공격자는 브라우저의 히스토리에서 토큰을 획득할 수 있다. 이는 공격자가 특정 장치에 대한 접근이 필요하다는 것을 의미한다.

대응 방안 (Countermeasures):

- 토큰에 짧은 만료 시간을 사용한다(섹션 5.1.5.3 참조). 토큰의 범위를 줄이면 해당 공격의 영향을 줄일 수 있다(섹션 5.1.5.1 참조).

- 응답을 캐시할 수 없도록(non-cacheable) 만든다.

##### 4.4.2.3. 위협: 악성 클라이언트가 인가 획득 (Threat: Malicious Client Obtains Authorization)

악성 클라이언트가 사기를 통해 토큰을 획득하려고 시도할 수 있다.

클라이언트 인증을 제외하고 섹션 4.4.1.4와 동일한 대응 방안이 적용된다.

##### 4.4.2.4. 위협: 스크립트 조작 (Threat: Manipulation of Scripts)

적대적인 당사자가 클라이언트 웹 서버 역할을 하고 클라이언트의 실제 구현(스크립트)을 교체하거나 수정할 수 있다. 이는 DNS 또는 ARP 스푸핑을 사용하여 달성할 수 있다. 이는 웹 브라우저 내에서 스크립팅 언어로 구현된 클라이언트에 적용된다.

영향 (Impact): 공격자는 사용자 자격 증명 정보를 획득하고 사용자의 전체 신원을 가정할 수 있다.

대응 방안 (Countermeasures):

- 인가 서버는 스크립트가 획득되는 서버를 인증해야 한다(섹션 5.1.2 참조).

- 클라이언트는 획득된 스크립트가 전송 중에 변경되지 않았는지 확인해야 한다(섹션 5.1.1 참조).

- 서버에서 로드된 후 작은 시간 창에서만 스크립트에 의해 사용될 수 있는 일회성, 사용별 비밀(예: "client_secret") 값을 도입한다. 이는 공격자의 수정된 코드에서 재사용하기 위해 클라이언트 측 스크립트를 복사하는 것의 효과를 줄이기 위한 것이다.

##### 4.4.2.5. 위협: 리다이렉트 URI에 대한 CSRF 공격 (Threat: CSRF Attack against redirect-uri)

CSRF 공격(섹션 4.4.1.8 참조)은 암묵적 권한 부여 플로우에서 사용되는 리다이렉트 URI에 대해서도 작동한다. 공격자는 자신의 보호된 리소스에 대한 액세스 토큰을 획득할 수 있다. 그런 다음 리다이렉트 URI를 구성하고 해당 URI에 자신의 액세스 토큰을 포함시킬 수 있다. 공격자가 사용자를 속여 리다이렉트 URI를 따르게 하고 클라이언트가 이 공격에 대한 보호가 없는 경우, 사용자는 자신의 클라이언트 내에서 공격자의 액세스 토큰이 인가될 수 있다.

영향 (Impact): 사용자가 공격자를 대신하여 리소스에 접근한다. 실질적인 영향은 접근되는 리소스의 유형에 따라 다르다. 예를 들어, 사용자가 공격자의 리소스에 개인 항목을 업로드할 수 있다. 또는, 제3자 로그인 시나리오에서 OAuth를 사용할 때, 사용자가 자신의 클라이언트 계정을 외부 ID 제공자에서 공격자의 신원과 연결할 수 있다. 이러한 방식으로, 공격자는 외부 ID 제공자에서 자신의 자격 증명으로 다른 장치에서 로그인하여 클라이언트에서 피해자의 데이터에 쉽게 접근할 수 있다.

대응 방안 (Countermeasures):

- "state" 매개변수를 사용하여 인가 요청과 액세스 토큰을 전달하는 데 사용되는 리다이렉트 URI를 연결해야 한다. 이는 클라이언트가 시작한 인가 요청과 연결되지 않은 한 클라이언트가 리다이렉트 콜백을 완료하도록 속지 않도록 보장한다. "state" 매개변수는 추측 가능해서는 안 되며, 클라이언트는 "state" 매개변수를 비밀로 유지할 수 있어야 한다.

- 클라이언트 개발자와 최종 사용자는 신뢰할 수 없는 URL을 따르지 않도록 교육받을 수 있다.

##### 4.4.2.6. 위협: 토큰 치환 (OAuth 로그인) (Threat: Token Substitution (OAuth Login))

공격자는 피해자의 신원을 사용하여 애플리케이션 또는 웹사이트에 로그인하려고 시도할 수 있다. 사용자를 로그인시키기 위해 OAuth로 보호된 서비스 API가 제공하는 신원 데이터에 의존하는 애플리케이션은 이 위협에 취약하다. 이 패턴은 소위 "소셜 로그인" 시나리오에서 찾을 수 있다.

전제 조건으로, 리소스 서버는 사용자 신원을 획득한 것으로 해석될 수 있는 사용자에 대한 개인 정보를 획득하기 위한 API를 제공한다. 이러한 의미에서, 클라이언트는 리소스 서버 API를 "신원" API로 취급한다. 클라이언트는 OAuth를 활용하여 신원 API에 대한 액세스 토큰을 획득한다. 그런 다음 신원 API에 식별자를 조회하고 이를 사용하여 내부 사용자 계정 데이터를 조회한다(로그인). 클라이언트는 사용자에 대한 정보를 획득할 수 있었기 때문에 사용자가 인증되었다고 가정한다.

성공하기 위해, 공격자는 대상 클라이언트 애플리케이션이 사용하는 것과 동일한 ID 제공자로부터 해당 피해자의 유효한 액세스 토큰을 수집해야 한다. 공격자는 피해자를 속여 대상 애플리케이션과 동일한 ID 제공자를 사용하여 악성 앱(ID 제공자에게 합법적으로 보일 수 있음)에 로그인하게 한다. 이로 인해 ID 제공자의 인가 서버가 해당 신원 API에 대한 액세스 토큰을 발급한다. 악성 앱은 이 액세스 토큰을 공격자에게 전송하고, 이는 다시 대상 애플리케이션 내에서 로그인 프로세스를 트리거한다. 공격자는 이제 인가 응답을 조작하고 자신의 액세스 토큰(자신의 신원에 바인딩된)을 피해자의 액세스 토큰으로 치환한다. 이 토큰은 리소스 서버에 대한 대상이 올바르므로 신원 API에 의해 수락된다. 그러나 신원 API가 반환하는 식별자는 액세스 토큰의 신원에 의해 결정되므로, 공격자는 피해자의 신원으로 대상 애플리케이션에 로그인된다.

영향 (Impact): 공격자는 애플리케이션 및 애플리케이션 내의 사용자별 데이터에 대한 접근을 획득한다.

대응 방안 (Countermeasures):

- 클라이언트는 사용자 로그인을 구현하기 위해 OpenID([OPENID] 참조) 또는 SAML([OASIS.sstc-saml-bindings-1.1] 참조)과 같은 적절한 프로토콜을 사용해야 한다. 두 프로토콜 모두 클라이언트에 대한 대상 제한(audience restriction)을 지원한다.

#### 4.4.3. 리소스 소유자 비밀번호 자격 증명 (Resource Owner Password Credentials)

리소스 소유자 비밀번호 자격 증명 권한 부여 유형([RFC6749], 섹션 4.3 참조)은 레거시/마이그레이션 이유로 자주 사용되며, 클라이언트가 최종 사용자의 사용자 ID 및 비밀번호와 함께 자체 자격 증명을 사용하여 액세스 토큰을 요청할 수 있게 한다. 이 권한 부여 유형은 UID/비밀번호 안티패턴(anti-pattern)을 유지하기 때문에 위험이 더 높다. 또한, 사용자가 인가 프로세스를 제어할 수 없기 때문에, 이 권한 부여 유형을 사용하는 클라이언트는 범위에 의해 제한되지 않고 대신 잠재적으로 사용자 자신과 동일한 능력을 가진다. 인가 단계가 없으므로, 토큰 취소를 제공하는 능력이 우회된다.

비밀번호는 종종 둘 이상의 서비스에 사용되므로, 이 안티패턴은 제공된 자격 증명으로 접근 가능한 다른 모든 것도 위험에 빠뜨릴 수 있다. 또한, 쉽게 유도할 수 있는 동등물(예: joe@example.com과 joe@example.net)은 동일한 비밀번호가 다른 곳에서도 사용될 수 있다는 것을 쉽게 추측하게 할 수 있다.

영향 (Impact): 리소스 서버는 특정 클라이언트와 연결된 액세스 토큰을 기반으로만 범위를 구분할 수 있다. 클라이언트는 또한 장기 토큰을 획득하여 추가 남용을 위해 공격자의 웹 서비스로 전달할 수 있다. 클라이언트, 도청자 또는 엔드포인트가 사용자 ID 및 비밀번호를 도청할 수 있다.

대응 방안 (Countermeasures):

- 마이그레이션 이유를 제외하고, 이 권한 부여 유형의 사용을 최소화한다.

- 인가 서버는 모든 갱신 요청 시 특정 갱신 토큰과 연결된 클라이언트 ID를 검증해야 한다(섹션 5.2.2.2).

- 핵심 OAuth 사양에 따라, 인가 서버는 TLS와 같은 전송 계층 메커니즘을 사용하여 이러한 전송이 보호되도록 해야 한다(섹션 5.1.1 참조).

- 사용자에게 UID와 비밀번호를 사용하도록 권장하는 대신, 서비스 제공자는 사용자에게 여러 서비스에 동일한 비밀번호를 사용하지 않도록 권장해야 한다.

- 리소스 소유자 비밀번호 자격 증명 부여의 사용을 클라이언트 애플리케이션과 인가 서비스가 동일한 조직에 속한 시나리오로 제한한다.

##### 4.4.3.1. 위협: 클라이언트 사이트에서의 비밀번호 우발적 노출 (Threat: Accidental Exposure of Passwords at Client Site)

클라이언트가 충분한 보호를 제공하지 않으면, 공격자 또는 불만을 품은 직원이 사용자의 비밀번호를 검색할 수 있다.

대응 방안 (Countermeasures):

- 안전한 리소스 소유자 자격 증명 처리를 위해 클라이언트의 협조에 의존하지 않는 다른 플로우를 사용한다.

- 평문 자격 증명 처리 대신 다이제스트 인증(digest authentication)을 사용한다.

- 로그에서 비밀번호를 난독화(obfuscate)한다.

##### 4.4.3.2. 위협: 클라이언트가 최종 사용자 인가 없이 범위 획득 (Threat: Client Obtains Scopes without End-User Authorization)

리소스 소유자와의 모든 상호 작용은 클라이언트에 의해 수행된다. 따라서 클라이언트가 의도적으로 또는 비의도적으로 리소스 소유자가 알지 못하거나 의도하지 않은 범위의 토큰을 획득할 수 있다. 예를 들어, 리소스 소유자는 클라이언트가 자신의 미디어 저장소에 대한 읽기 전용 접근만 필요로 하고 획득한다고 생각할 수 있지만, 클라이언트는 전체 접근 권한이 있는 액세스 토큰을 획득하려고 시도한다.

대응 방안 (Countermeasures):

- 리소스 소유자 상호 작용을 위해 클라이언트의 협조에 의존하지 않는 다른 플로우를 사용한다.

- 인가 서버는 이 플로우에 의해 발급되는 액세스 토큰의 범위를 일반적으로 제한할 수 있다(섹션 5.1.5.1). 특정 클라이언트가 신뢰할 수 있고 신뢰할 수 있는 방식으로 인증될 수 있는 경우, 인가 서버는 해당 제한을 완화할 수 있다. 리소스 소유자는 이 플로우를 사용하는 클라이언트의 최대 범위가 무엇인지(예: 기본 설정에서) 지정할 수 있다.

- 인가 서버는 적절한 매체(예: 이메일)를 통해 발급된 부여에 대해 리소스 소유자에게 알릴 수 있다(섹션 5.1.3 참조).

##### 4.4.3.3. 위협: 자동 인가를 통한 클라이언트의 갱신 토큰 획득 (Threat: Client Obtains Refresh Token through Automatic Authorization)

리소스 소유자와의 모든 상호 작용은 클라이언트에 의해 수행된다. 따라서 클라이언트가 의도적으로 또는 비의도적으로 리소스 소유자가 의도하지 않았더라도 갱신 토큰으로 대표되는 장기 인가를 획득할 수 있다.

대응 방안 (Countermeasures):

- 리소스 소유자 상호 작용을 위해 클라이언트의 협조에 의존하지 않는 다른 플로우를 사용한다.

- 인가 서버는 이 플로우에서 갱신 토큰의 발급을 일반적으로 거부할 수 있다(섹션 5.2.2.1 참조). 특정 클라이언트가 신뢰할 수 있고 신뢰할 수 있는 방식으로 인증될 수 있는 경우(클라이언트 인증 참조), 인가 서버는 해당 제한을 완화할 수 있다. 리소스 소유자는 이 플로우를 사용하여 갱신 토큰의 발급을 허용하거나 거부할 수 있다(예: 기본 설정에서).

- 인가 서버는 적절한 매체(예: 이메일)를 통해 발급된 갱신 토큰에 대해 리소스 소유자에게 알릴 수 있다(섹션 5.1.3 참조).

##### 4.4.3.4. 위협: 전송 중 사용자 비밀번호 획득 (Threat: Obtaining User Passwords on Transport)

공격자는 클라이언트와 서버 간에 권한 부여 유형 "password"로 최종 사용자 자격 증명의 전송을 도청하려고 시도할 수 있다.

영향 (Impact): 단일 최종 사용자의 비밀번호가 노출된다.

대응 방안 (Countermeasures):

- 요청의 기밀성을 보장한다(섹션 5.1.1).

- 유선을 통해 평문 자격 증명을 전송할 필요가 없는 대체 인증 수단을 사용한다(예: 해시 기반 메시지 인증 코드(Hash-based Message Authentication Code)).

##### 4.4.3.5. 위협: 인가 서버 데이터베이스에서 사용자 비밀번호 획득 (Threat: Obtaining User Passwords from Authorization Server Database)

공격자는 데이터베이스에 대한 접근 권한을 얻거나 SQL 인젝션 공격을 실행하여 인가 서버의 데이터베이스에서 유효한 사용자 이름/비밀번호 조합을 획득할 수 있다.

영향 (Impact): 모든 사용자 이름/비밀번호 조합이 노출된다. 많은 사용자가 다른 서비스에서 동일한 자격 증명을 사용하는 경향이 있으므로, 영향은 인가 서버의 도메인을 초과할 수 있다.

대응 방안 (Countermeasures):

- 자격 증명 저장소 보호 모범 사례를 시행한다(섹션 5.1.4.1).

##### 4.4.3.6. 위협: 온라인 추측 (Threat: Online Guessing)

공격자는 권한 부여 유형 "password"를 사용하여 유효한 사용자 이름/비밀번호 조합을 추측하려고 시도할 수 있다.

영향 (Impact): 단일 사용자 이름/비밀번호 조합이 노출된다.

대응 방안 (Countermeasures):

- 안전한 비밀번호 정책을 활용한다(섹션 5.1.4.2.1).

- 계정을 잠근다(섹션 5.1.4.2.3).

- 타르 피트(tar pit)를 사용한다(섹션 5.1.4.2.4).

- CAPTCHA를 사용한다(섹션 5.1.4.2.5).

- 권한 부여 유형 "password"를 사용하지 않는 것을 고려한다.

- 클라이언트 인증(섹션 5.2.3 참조)은 또 다른 인증 요소를 제공하여 공격을 방해한다.

#### 4.4.4. 클라이언트 자격 증명 (Client Credentials)

클라이언트 자격 증명([RFC6749], 섹션 3 참조)은 식별자(비밀이 아님)와 클라이언트를 인증하기 위한 추가 수단(예: 일치하는 클라이언트 시크릿)의 조합으로 구성된다. 이 권한 부여 유형에 대한 위협은 섹션 4.4.3에서 설명한 것과 유사하다.
### 4.5. 액세스 토큰 갱신 (Refreshing an Access Token)

#### 4.5.1. 위협: 인가 서버로부터 갱신 토큰 도청 (Eavesdropping Refresh Tokens from Authorization Server)

공격자는 갱신 토큰(refresh token)이 인가 서버(authorization server)에서 클라이언트(client)로 전송될 때 이를 도청할 수 있다.

대응책:

- 핵심 OAuth 사양에 따라, 인가 서버는 TLS와 같은 전송 계층 메커니즘(transport-layer mechanism)을 사용하여 이러한 전송이 보호되도록 해야 한다 (섹션 5.1.1 참조).

- 종단 간 기밀성(end-to-end confidentiality)이 보장될 수 없는 경우, 발급된 액세스 토큰의 범위 축소(reducing scope, 섹션 5.1.5.1 참조) 및 만료 시간 단축(reducing expiry time, 섹션 5.1.5.3 참조)을 사용하여 유출 시 피해를 줄일 수 있다.

#### 4.5.2. 위협: 인가 서버 데이터베이스에서 갱신 토큰 탈취 (Obtaining Refresh Token from Authorization Server Database)

이 위협은 인가 서버가 갱신 토큰을 데이터베이스에 핸들(handle)로 저장하는 경우에 해당된다. 공격자는 데이터베이스에 대한 접근 권한을 획득하거나 SQL 인젝션(SQL injection) 공격을 실행하여 인가 서버의 데이터베이스에서 갱신 토큰을 탈취할 수 있다.

영향: 모든 갱신 토큰의 노출.

대응책:

- 자격 증명 저장소 보호 모범 사례를 적용한다 (섹션 5.1.4.1 참조).

- 토큰을 클라이언트 ID(client id)에 바인딩한다. 공격자가 필요한 ID와 비밀값(secret)을 획득할 수 없는 경우에 효과적이다 (섹션 5.1.5.8 참조).

#### 4.5.3. 위협: 온라인 추측을 통한 갱신 토큰 탈취 (Obtaining Refresh Token by Online Guessing)

공격자는 유효한 갱신 토큰 값을 추측하고, 유효한 액세스 토큰을 얻기 위해 권한 부여 유형(grant type) "refresh_token"을 사용하여 전송을 시도할 수 있다.

영향: 단일 갱신 토큰 및 이로부터 파생 가능한 액세스 토큰의 노출.

대응책:

- 핸들 기반 설계의 경우 (섹션 5.1.4.2.2 참조).

- 어설션 기반 설계의 경우 (섹션 5.1.5.9 참조).

- 토큰을 클라이언트 ID에 바인딩한다. 공격자가 일치하는 클라이언트 ID도 함께 추측해야 하기 때문이다 (섹션 5.1.5.8 참조).

- 클라이언트를 인증한다. 이는 공격자가 추측해야 할 또 다른 요소를 추가한다 (섹션 5.2.3.4 참조).

#### 4.5.4. 위협: 위조된 인가 서버를 통한 갱신 토큰 피싱 (Refresh Token Phishing by Counterfeit Authorization Server)

공격자는 인가 서버에 대한 요청을 프록시(proxy)하여 유효한 갱신 토큰을 탈취하려고 시도할 수 있다. 인가 서버 URL이 개발 시점에 잘 알려져 있거나 최소한 잘 알려진 리소스 서버(resource server)로부터 얻을 수 있다는 가정하에, 공격자는 성공하기 위해 일종의 스푸핑(spoofing)을 활용해야 한다.

대응책:

- 서버 인증(server authentication)을 활용한다 (섹션 5.1.2에 설명된 바와 같이).

### 4.6. 보호된 리소스에 접근 (Accessing Protected Resources)

#### 4.6.1. 위협: 전송 중 액세스 토큰 도청 (Eavesdropping Access Tokens on Transport)

공격자는 클라이언트와 리소스 서버 간의 전송 과정에서 유효한 액세스 토큰을 탈취하려고 시도할 수 있다. 액세스 토큰은 인가 서버와 리소스 서버 간의 공유 비밀(shared secret)이므로, 다른 자격 증명(credential)(예: 최종 사용자 비밀번호)과 동일한 수준으로 주의하여 다루어야 한다.

대응책:

- 무기명 토큰(bearer token)으로 전송되는 액세스 토큰은 안전하지 않은 채널(insecure channel)을 통해 평문으로 전송해서는 안 된다. 핵심 OAuth 사양에 따라, 액세스 토큰의 전송은 TLS와 같은 전송 계층 메커니즘을 사용하여 보호되어야 한다 (섹션 5.1.1 참조).

- 토큰이 손상된 경우 짧은 수명(short lifetime)을 통해 영향을 줄일 수 있다 (섹션 5.1.5.3 참조).

- 액세스 토큰을 클라이언트의 식별자(identifier)에 바인딩하고, 클라이언트가 리소스 서버에 토큰의 합법적 소유권을 증명하도록 요구할 수 있다 (섹션 5.4.2 참조).

#### 4.6.2. 위협: 인가된 리소스 서버 요청의 재전송 (Replay of Authorized Resource Server Requests)

공격자는 사용자 데이터를 획득하거나 수정/파괴하기 위해 유효한 요청을 재전송(replay)하려고 시도할 수 있다.

대응책:

- 리소스 서버는 이러한 공격을 방지하기 위해 전송 보안 수단(transport security measure)(예: TLS)을 활용해야 한다 (섹션 5.1.1 참조). 이렇게 하면 공격자가 유효한 요청을 캡처하는 것을 방지할 수 있다.

- 또는 리소스 서버가 요청을 고유하게 식별하기 위해 논스(nonce)와 타임스탬프(timestamp)와 함께 서명된 요청(signed request)을 사용할 수 있다 (섹션 5.4.3 참조). 리소스 서버는 모든 재전송된 요청을 탐지하고 거부해야 한다.

#### 4.6.3. 위협: 액세스 토큰 추측 (Guessing Access Tokens)

토큰이 핸들(handle)인 경우, 공격자는 다른 액세스 토큰에서 얻은 지식을 기반으로 액세스 토큰 값을 추측하려고 시도할 수 있다.

영향: 단일 사용자의 데이터에 대한 접근.

대응책:

- 핸들 토큰은 유효한 토큰 값의 추측을 불가능하게 만들기 위해 합리적인 수준의 엔트로피(entropy)를 가져야 한다 (섹션 5.1.4.2.2 참조).

- 어설션(assertion) 또는 자체 포함 토큰(self-contained token)의 내용은 디지털 서명(digital signature)으로 보호되어야 한다 (섹션 5.1.5.9 참조).

- 짧은 액세스 토큰 유효 기간(short access token duration)을 사용하여 보안을 더욱 강화할 수 있다 (섹션 5.1.5.2 및 5.1.5.3 참조).

#### 4.6.4. 위협: 위조된 리소스 서버를 통한 액세스 토큰 피싱 (Access Token Phishing by Counterfeit Resource Server)

공격자는 특정 리소스 서버인 것처럼 가장하고 특정 인가 서버의 토큰을 수락할 수 있다. 클라이언트가 이 위조된 리소스 서버에 유효한 액세스 토큰을 보내면, 해당 서버는 리소스 소유자(resource owner)를 대신하여 다른 서비스에 접근하기 위해 해당 토큰을 사용할 수 있다.

대응책:

- 클라이언트는 보안 채널(secure channel)의 존재 여부에 관계없이, 익숙하지 않은 리소스 서버에 액세스 토큰을 사용한 인증된 요청을 해서는 안 된다. 리소스 서버 URL이 클라이언트에 잘 알려져 있는 경우, 리소스 서버를 인증할 수 있다 (섹션 5.1.2 참조).

- 클라이언트가 통신한 리소스 서버의 엔드포인트 URL(endpoint URL)을 액세스 토큰에 연결하고(예: 대상(audience) 필드에), 합법적인 리소스 서버에서 해당 연결을 검증한다. 엔드포인트 URL 검증 정책은 엄격(정확한 일치)하거나 좀 더 완화된(예: 동일한 호스트) 형태일 수 있다. 이를 위해서는 인가 과정에서 인가 서버에 리소스 서버 엔드포인트 URL을 알려야 한다.

- 액세스 토큰을 클라이언트와 연결하고, 리소스 서버 요청 시 클라이언트를 인증한다(일반적으로 잠재적 공격자에게 비밀을 노출하지 않기 위해 서명을 통해). 이는 위조된 서버가 합법적인 클라이언트를 대신하여 리소스 서버에 올바르게 인증할 능력이 없다고 가정하기 때문에 공격을 방지한다 (섹션 5.4.2 참조).

- 토큰 범위를 제한하고(섹션 5.1.5.1 참조) 그리고/또는 토큰을 특정 리소스 서버로 제한한다 (섹션 5.1.5.5 참조).

#### 4.6.5. 위협: 합법적인 리소스 서버 또는 클라이언트에 의한 토큰 남용 (Abuse of Token by Legitimate Resource Server or Client)

합법적인 리소스 서버가 다른 리소스 서버에 접근하기 위해 액세스 토큰을 사용하려고 시도할 수 있다. 마찬가지로, 클라이언트가 한 서버용으로 획득한 토큰을 다른 리소스 서버에서 사용하려고 시도할 수 있다.

대응책:

- 토큰은 특정 리소스 서버로 제한되어야 한다 (섹션 5.1.5.5 참조).

#### 4.6.6. 위협: HTTP 프록시에서의 기밀 데이터 유출 (Leak of Confidential Data in HTTP Proxies)

[RFC6749]에서 논의된 OAuth HTTP 인증 체계(authentication scheme)는 선택 사항이다. 그러나 [RFC2616]은 인증된 콘텐츠를 구분하여 보호할 수 있도록 Authorization 및 WWW-Authenticate 헤더에 의존한다. 프록시(proxy)와 캐시(cache)는 특히 이러한 헤더를 사용하지 않는 요청을 적절히 보호하지 못할 수 있다. 예를 들어, 비공개 인증된 콘텐츠가 공개적으로 접근 가능한 캐시에 저장되어 검색될 수 있다.

대응책:

- OAuth HTTP 인증 체계를 사용하지 않는 클라이언트와 리소스 서버는 (섹션 5.4.1 참조) 인증된 콘텐츠가 보호되지 않는 위험을 최소화하기 위해 Cache-Control 헤더를 주의하여 사용해야 한다. 이러한 클라이언트는 "no-store" 옵션을 포함하는 Cache-Control 헤더를 전송해야 한다 [RFC2616]. 이러한 요청에 대한 리소스 서버의 성공 응답(2XX 상태)은 "private" 옵션이 포함된 Cache-Control 헤더를 포함해야 한다 [RFC2616].

- 액세스 토큰의 범위 축소(섹션 5.1.5.1 참조) 및 만료 시간 단축(섹션 5.1.5.3 참조)을 사용하여 유출 시 피해를 줄일 수 있다.

#### 4.6.7. 위협: 로그 파일 및 HTTP 리퍼러를 통한 토큰 유출 (Token Leakage via Log Files and HTTP Referrers)

액세스 토큰이 URI 쿼리 매개변수(URI query parameter)를 통해 전송되는 경우, 해당 토큰은 로그 파일(log file)과 HTTP "referer"를 통해 유출될 수 있다.

대응책:

- URI 요청 매개변수 대신 Authorization 헤더 또는 POST 매개변수를 사용한다 (섹션 5.4.1 참조).

- 로깅 구성을 적절하게 설정한다.

- 권한이 없는 사람이 시스템 로그 파일에 접근하는 것을 방지한다 (섹션 5.1.4.1.1 참조).

- 인증된 요청(authenticated request)을 강제하여 유출된 액세스 토큰의 남용을 방지할 수 있다 (섹션 5.4.2 참조).

- 범위 제한(섹션 5.1.5.1 참조) 및 유효 기간 제한(섹션 5.1.5.3 참조), 그리고 일회성 토큰 사용 강제(섹션 5.1.5.4 참조)를 통해 토큰 유출의 영향을 줄일 수 있다.
## 5. 보안 고려사항 (Security Considerations)

이 섹션에서는 섹션 4에서 설명한 위협을 완화하기 위해 권장되는 대응 방안을 설명한다.

### 5.1. 일반 (General)

이 섹션에서는 모든 OAuth 구성 요소(클라이언트, 리소스 서버, 토큰 서버, 사용자 에이전트)에 일반적으로 적용되는 고려사항을 다룬다.

#### 5.1.1. 요청의 기밀성 보장 (Ensure Confidentiality of Requests)

이 사항은 클라이언트에서 인가 서버 또는 리소스 서버로 전송되는 모든 요청에 적용된다. OAuth는 요청의 무결성을 검증하는 메커니즘을 제공하지만, 요청의 기밀성에 대한 보장은 제공하지 않는다. 추가적인 예방 조치를 취하지 않으면, 도청자가 요청 내용에 완전히 접근할 수 있으며, 요청의 내용(예: 비밀 정보 또는 토큰)을 사용하여 가로채기 또는 재전송 공격을 수행할 수 있다.

TLS [RFC5246]와 같은 전송 계층 메커니즘을 사용하여 공격을 완화할 수 있다. IPsec VPN [RFC4301]에 기반한 가상 사설 네트워크(VPN)도 고려할 수 있다.

참고: 이 문서는 각 프로토콜 엔티티 간의 종단 간 TLS 보호 연결을 가정한다. 이 가정에서 벗어나 중간에서 TLS를 오프로딩하는 배포(예: 데이터 센터 에지에서)는 이로 인해 발생할 수 있는 추가적인(주로 내부자) 위협을 고려하기 위해 이 위협 모델을 정교화해야 한다.

이것은 다음 위협에 대한 대응 방안이다:

- 토큰 엔드포인트 또는 리소스 서버 엔드포인트에서 획득한 액세스 토큰의 재전송
- 토큰 엔드포인트에서 획득한 리프레시 토큰의 재전송
- 토큰 엔드포인트에서 획득한 인가 "코드"의 재전송 (리다이렉트?)
- 사용자 비밀번호 및 클라이언트 시크릿의 재전송

#### 5.1.2. 서버 인증 활용 (Utilize Server Authentication)

HTTPS 서버 인증 또는 유사한 수단을 사용하여 서버의 신원을 인증할 수 있다. 목표는 연결 설정 중 서버가 제시하는 공개 키에 서버의 정규화된 도메인 이름을 신뢰성 있게 바인딩하는 것이다([RFC2818] 참조).

클라이언트는 서버와 해당 도메인 이름의 바인딩을 검증해야 한다. 서버가 해당 바인딩을 증명하지 못하면, 통신은 중간자 공격으로 간주된다. 이 보안 조치는 해당 목적을 위해 클라이언트가 신뢰하는 인증 기관에 의존한다. 클라이언트는 신뢰할 수 있는 CA를 신중하게 선택하고, 신뢰할 수 있는 CA 인증서의 저장소를 수정으로부터 보호해야 한다.

이것은 다음 위협에 대한 대응 방안이다:

- 스푸핑
- 프록시
- 위조 서버에 의한 피싱

#### 5.1.3. 리소스 소유자에게 항상 정보 제공 (Always Keep the Resource Owner Informed)

리소스 소유자에 대한 투명성은 OAuth 프로토콜의 핵심 요소이다. 사용자는 항상 인가 프로세스를 통제하고 정보에 입각한 결정을 내리기 위해 필요한 정보를 받아야 한다. 또한, 사용자 참여는 추가적인 보안 대응 방안이다. 사용자는 인가 서버보다 특정 종류의 공격을 더 잘 인식할 수 있다. 정보는 다음과 같은 기술을 사용하여 인가 프로세스 중, 인가 프로세스 후, 그리고 사용자가 정보를 원할 때마다 제공/교환될 수 있다:

- 사용자 동의 양식.
- 알림 메시지(예: 이메일, SMS, ...). 알림은 피싱 벡터가 될 수 있다는 점에 유의해야 한다. 메시지는 유사한 피싱 메시지가 도출될 수 없는 형태여야 한다.
- 활동/이벤트 로그.
- 사용자 셀프 케어 애플리케이션 또는 포털.

#### 5.1.4. 자격 증명 (Credentials)

이 섹션에서는 모든 종류의 자격 증명을 무단 접근 및 남용으로부터 보호하기 위해 사용되는 대응 방안을 설명한다. 자격 증명은 클라이언트 시크릿 및 사용자 비밀번호와 같은 장기 비밀 정보뿐만 아니라 모든 종류의 토큰(리프레시 및 액세스 토큰) 또는 인가 "코드"를 포함한다.

##### 5.1.4.1. 자격 증명 저장소 보호 모범 사례 시행 (Enforce Credential Storage Protection Best Practices)

관리자는 자격 증명의 저장소를 보호하기 위해 업계 모범 사례를 따라야 한다(예: [OWASP] 참조). 이러한 관행에는 다음 하위 섹션에 포함되지만 이에 국한되지 않는 사항이 포함될 수 있다.

##### 5.1.4.1.1. 표준 시스템 보안 수단 시행 (Enforce Standard System Security Means)

서버 시스템은 공격자가 민감한 구성 파일 및 데이터베이스에 접근할 수 없도록 잠글 수 있다.

##### 5.1.4.1.2. 표준 SQL 인젝션 대응 방안 시행 (Enforce Standard SQL Injection Countermeasures)

클라이언트 식별자 또는 기타 인증 구성 요소가 SQL 데이터베이스에 대해 쿼리되거나 비교되는 경우, 수신된 매개변수가 데이터베이스에 제출되기 전에 검증되지 않으면 인젝션 공격이 발생할 수 있다.

- 가능한 공격의 "표면"을 줄이기 위해 서버 코드가 최소한의 데이터베이스 권한을 사용하도록 보장한다.
- 연결된 입력을 사용하는 동적 SQL을 피한다. 가능하면 정적 SQL을 사용한다.
- 동적 SQL을 사용할 때는 바인드 인수를 사용하여 쿼리를 매개변수화한다. 바인드 인수는 SQL 인젝션의 가능성을 제거한다.
- 입력을 필터링하고 정제한다. 예를 들어, 식별자에 알려진 형식이 있는 경우, 제공된 값이 식별자 구문 규칙과 일치하는지 확인한다.

##### 5.1.4.1.3. 자격 증명의 평문 저장 금지 (No Cleartext Storage of Credentials)

인가 서버는 자격 증명을 평문으로 저장해서는 안 된다. 일반적인 접근 방식은 해시를 대신 저장하거나 자격 증명을 암호화하는 것이다. 자격 증명이 합리적인 엔트로피 수준이 부족한 경우(사용자 비밀번호이기 때문에), 추가적인 솔트가 저장소를 강화하여 오프라인 사전 공격을 더 어렵게 만든다.

참고: 일부 인증 프로토콜은 인가 서버가 비밀에 평문으로 접근할 수 있어야 한다. 서버가 해시에만 접근할 수 있는 경우 해당 프로토콜을 구현할 수 없다. 이러한 경우 자격 증명은 강력하게 암호화되어야 한다.

##### 5.1.4.1.4. 자격 증명 암호화 (Encryption of Credentials)

클라이언트 애플리케이션의 경우, 안전하지 않게 지속된 클라이언트 자격 증명은 공격자가 쉽게 획득할 수 있는 대상이다. 키스토어 또는 데이터베이스와 같은 암호화된 지속성 메커니즘을 사용하여 클라이언트 자격 증명을 저장해야 한다. 클라이언트 자격 증명을 클라이언트 코드에 직접 컴파일하면, 클라이언트 애플리케이션이 스캐닝에 취약해지고, 시간이 지남에 따라 클라이언트 자격 증명이 변경되는 경우 관리하기 어려워진다는 점에 유의해야 한다.

##### 5.1.4.1.5. 비대칭 암호화 사용 (Use of Asymmetric Cryptography)

비대칭 암호화를 사용하면 인가 서버가 자격 증명을 관리해야 하는 의무에서 벗어날 수 있다.

##### 5.1.4.2. 비밀 정보에 대한 온라인 공격 (Online Attacks on Secrets)

##### 5.1.4.2.1. 안전한 비밀번호 정책 활용 (Utilize Secure Password Policy)

인가 서버는 온라인 비밀번호 공격을 방해하기 위해 사용자 비밀번호의 엔트로피를 증가시키기 위해 복잡한 사용자 비밀번호 정책을 시행할 수 있다. 너무 많은 복잡성은 사용자가 비밀번호를 재사용하거나 기록하거나 안전하지 않게 저장할 가능성을 높일 수 있다는 점에 유의해야 한다.

##### 5.1.4.2.2. 비밀 정보에 높은 엔트로피 사용 (Use High Entropy for Secrets)

인간 사용자가 사용하지 않는 비밀 정보(예: 클라이언트 시크릿 또는 토큰 핸들)를 생성할 때, 인가 서버는 추측 공격의 위험을 완화하기 위해 합리적인 수준의 엔트로피를 포함해야 한다. 토큰 값은 128비트 이상이어야 하며, 인가 서버가 생성한 암호학적으로 강력한 난수 또는 의사 난수 시퀀스로 구성되어야 한다(모범 사례는 [RFC4086] 참조).

##### 5.1.4.2.3. 계정 잠금 (Lock Accounts)

비밀번호에 대한 온라인 공격은 일정 횟수의 실패한 시도 후 해당 계정을 잠금으로써 완화할 수 있다.

참고: 이 조치는 합법적인 서비스 사용자를 잠그는 데 악용될 수 있다.

##### 5.1.4.2.4. 타르 피트 사용 (Use Tar Pit)

인가 서버는 사용자 이름/비밀번호로 인증하려는 실패한 시도에 대해 해당 계정을 일시적으로 잠그고 일정 기간 동안 응답을 지연시킬 수 있다. 이 기간은 실패한 시도 횟수에 따라 증가할 수 있다. 목표는 특정 사용자 이름에 대한 공격자의 시도를 늦추는 것이다.

참고: 이를 위해 인가 서버의 더 복잡하고 상태를 유지하는 설계가 필요할 수 있다.

##### 5.1.4.2.5. CAPTCHA 사용 (Use CAPTCHAs)

이 아이디어는 인간의 상호작용을 요구함으로써 프로그램이 자동으로 대량의 비밀번호를 확인하는 것을 방지하는 것이다.

참고: 이는 사용자 경험에 부정적인 영향을 미친다.

#### 5.1.5. 토큰 (액세스, 리프레시, 코드) (Tokens (Access, Refresh, Code))

##### 5.1.5.1. 토큰 범위 제한 (Limit Token Scope)

인가 서버는 토큰과 관련된 범위를 축소하거나 제한할 수 있다. 이 결정의 근거는 이 문서의 범위 밖이며, 예시는 다음과 같다:

- 클라이언트별 정책, 예: 공개 클라이언트에게는 덜 강력한 토큰만 발급
- 서비스별 정책, 예: 매우 민감한 서비스인 경우
- 리소스 소유자별 설정, 또는
- 이러한 정책 및 선호도의 조합

인가 서버는 부여 유형에 따라 다른 범위를 허용할 수 있다. 예를 들어, 최종 사용자와의 직접 상호작용을 통한 최종 사용자 인가(인가 "코드")는 부여 유형 "사용자 이름"/"비밀번호"를 통한 직접 인가보다 더 신뢰할 수 있는 것으로 간주될 수 있다. 이 수단은 다음 위협의 영향을 줄인다:

- 토큰 유출
- 악성 소프트웨어에 대한 토큰 발급
- 리소스 소유자 자격 증명 흐름에서 강력한 토큰의 의도하지 않은 발급

##### 5.1.5.2. 만료 시간 결정 (Determine Expiration Time)

토큰은 일반적으로 합리적인 기간 후에 만료되어야 한다. 이는 다른 보안 조치(예: 서명)를 보완하고 강화하며, 모든 종류의 토큰 유출의 영향을 줄인다. 토큰 유출과 관련된 위험에 따라, 토큰은 몇 분 후에 만료되거나(예: 결제 거래의 경우) 몇 시간 동안 유효할 수 있다(예: 연락처에 대한 읽기 접근).

만료 시간은 다음을 포함한 여러 요인에 의해 결정된다:

- 토큰 유출과 관련된 위험
- 기본 접근 권한 부여의 기간
- 접근 권한 부여 수정이 적용되어야 하는 시간
- 공격자가 유효한 토큰을 추측하거나 생성하는 데 필요한 시간

##### 5.1.5.3. 짧은 만료 시간 사용 (Use Short Expiration Time)

토큰의 짧은 만료 시간은 다음 위협에 대한 보호 수단이다:

- 재전송
- 토큰 유출 (짧은 만료 시간이 영향을 줄인다)
- 온라인 추측 (짧은 만료 시간이 성공 가능성을 줄인다)

참고: 짧은 토큰 유효 기간은 인가 서버와 리소스 서버 간의 더 정밀한 클록 동기화를 필요로 한다. 또한, 더 짧은 유효 기간은 더 많은 토큰 갱신(액세스 토큰) 또는 반복적인 최종 사용자 인가 프로세스(인가 "코드" 및 리프레시 토큰)를 필요로 할 수 있다.

##### 5.1.5.4. 사용 횟수 제한 또는 일회용 사용 (Limit Number of Usages or One-Time Usage)

인가 서버는 특정 토큰으로 수행할 수 있는 요청 또는 작업의 수를 제한할 수 있다. 이 메커니즘은 다음 위협을 완화하는 데 사용할 수 있다:

- 토큰의 재전송
- 추측

예를 들어, 인가 서버가 인가 "코드"를 교환하려는 두 번 이상의 시도를 관찰하면, 인가 서버는 해당 인가 "코드"를 기반으로 부여된 모든 액세스 토큰을 취소하고 현재 요청을 거부할 수 있다.

인가 "코드"와 마찬가지로, 액세스 토큰에도 제한된 수의 작업이 있을 수 있다. 이는 클라이언트 애플리케이션이 재인증하고 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻도록 강제하거나, 사용자를 포함시켜 액세스 토큰을 재인가하도록 강제한다.

##### 5.1.5.5. 특정 리소스 서버(대상)에 토큰 바인딩 (Bind Tokens to a Particular Resource Server (Audience))

다중 서비스 환경의 인가 서버는 다른 리소스 서버에 다른 내용의 토큰을 발급하고, 토큰이 전송되도록 의도된 대상 서버를 토큰에 명시적으로 표시하는 것을 고려할 수 있다. SAML 어설션([OASIS.saml-core-2.0-os] 참조)은 이 목적을 위해 Audience 요소를 사용한다. 이 대응 방안은 다음 상황에서 사용될 수 있다:

- 토큰이 단일 리소스 서버에만 적용되므로, 성공적인 재전송 시도의 영향을 줄인다.
- 토큰이 해당 서버에서만 사용할 수 있으므로, 악의적인 리소스 서버나 클라이언트에 의한 토큰 남용을 방지한다. 다른 서버에서는 거부된다.
- 유효한 토큰이 위조 리소스 서버에 유출되는 영향을 줄인다.

##### 5.1.5.6. 엔드포인트 주소를 토큰 대상으로 사용 (Use Endpoint Address as Token Audience)

이는 토큰을 얻는 데 사용된 엔드포인트 URL을 리소스 서버에 표시하는 데 사용할 수 있다. 이 조치는 위조 리소스 서버로부터의 요청을 감지할 수 있게 해주는데, 그러한 토큰에는 해당 서버의 엔드포인트 URL이 포함되어 있기 때문이다.

##### 5.1.5.7. 대상 및 토큰에 대해 명시적으로 정의된 범위 사용 (Use Explicitly Defined Scopes for Audience and Tokens)

배포 시 명시적으로 정의된 범위만 가진 토큰만 사용하는 것을 고려할 수 있으며, 모든 범위는 특정 리소스 서버와 연관된다. 이 접근 방식은 리소스 서버 또는 클라이언트가 의도된 것과 다른 목적으로 토큰을 사용하는 공격을 완화하는 데 사용할 수 있다.

##### 5.1.5.8. 토큰을 클라이언트 ID에 바인딩 (Bind Token to Client id)

인가 서버는 토큰을 특정 클라이언트 식별자에 바인딩할 수 있다. 이 식별자는 해당 토큰으로 이루어지는 모든 요청에 대해 검증되어야 한다. 이 기술은 다음을 위해 사용할 수 있다:

- 토큰 유출 감지 및
- 토큰 남용 방지.

참고: 클라이언트 식별자를 검증하려면 대상 서버가 클라이언트의 식별자를 인증해야 할 수 있다. 이 인증은 토큰과 독립적으로 관리되는 비밀(예: 인가 서버에 사전 등록된 클라이언트 ID/시크릿)에 기반하거나 토큰 자체와 함께 전송될 수 있다(예: 암호화된 토큰 내용의 일부로).

##### 5.1.5.9. 자체 포함 토큰 서명 (Sign Self-Contained Tokens)

자체 포함 토큰은 토큰을 수정하거나 위조하려는 시도를 감지하기 위해 서명되어야 한다(예: 해시 기반 메시지 인증 코드 또는 디지털 서명).

##### 5.1.5.10. 토큰 내용 암호화 (Encrypt Token Content)

자체 포함 토큰은 기밀성 이유 또는 시스템 내부 데이터를 보호하기 위해 암호화될 수 있다. 토큰 형식에 따라, 키(예: 대칭 키)가 서버 노드 간에 배포되어야 할 수 있다. 배포 방법은 사용되는 토큰과 암호화에 의해 정의되어야 한다.

##### 5.1.5.11. 표준 어설션 형식 채택 (Adopt a Standard Assertion Format)

어설션 기반 토큰 설계를 구현하려는 서비스 제공자의 경우, 표준 어설션 형식(예: SAML [OASIS.saml-core-2.0-os] 또는 JavaScript Object Notation Web Token (JWT) [OAuth-JWT])을 채택하는 것이 강력히 권장된다.

#### 5.1.6. 액세스 토큰 (Access Tokens)

액세스 토큰을 보호하기 위해 다음 조치를 사용해야 한다:

- 임시 메모리에 보관한다(클라이언트 애플리케이션만 접근 가능).
- 안전한 전송(TLS)을 사용하여 토큰을 안전하게 전달한다.
- 클라이언트 애플리케이션이 제3자와 토큰을 공유하지 않도록 보장한다.

### 5.2. 인가 서버 (Authorization Server)

이 섹션에서는 OAuth 인가 서버 엔드포인트와 관련된 고려사항을 설명한다.

#### 5.2.1. 인가 "코드" (Authorization "codes")

##### 5.2.1.1. 남용 감지 시 파생 토큰의 자동 취소 (Automatic Revocation of Derived Tokens If Abuse Is Detected)

인가 서버가 인가 권한 부여(예: 인가 "코드")를 교환하려는 여러 번의 시도를 관찰하는 경우, 인가 서버는 해당 인가 권한 부여를 기반으로 부여된 모든 토큰을 취소할 수 있다.

#### 5.2.2. 리프레시 토큰 (Refresh Tokens)

##### 5.2.2.1. 리프레시 토큰의 제한적 발급 (Restricted Issuance of Refresh Tokens)

인가 서버는 적절한 정책에 따라 리프레시 토큰을 발급하지 않기로 결정할 수 있다. 리프레시 토큰은 장기 자격 증명이므로 도난의 대상이 될 수 있다. 예를 들어, 인가 서버가 클라이언트가 이러한 토큰을 안전하게 저장할 수 있다고 신뢰하지 않는 경우, 해당 클라이언트에게 리프레시 토큰 발급을 거부할 수 있다.

##### 5.2.2.2. 리프레시 토큰과 "client_id"의 바인딩 (Binding of Refresh Token to "client_id")

인가 서버는 모든 리프레시 토큰을 발급된 클라이언트의 식별자와 매칭해야 한다. 인가 서버는 액세스 토큰 갱신 요청마다 동일한 "client_id"가 있는지 확인해야 한다. 가능한 경우(예: 기밀 클라이언트), 인가 서버는 해당 클라이언트를 인증해야 한다.

이것은 리프레시 토큰 도난 또는 유출에 대한 대응 방안이다.

참고: 이 바인딩은 무단 수정으로부터 보호되어야 한다.

##### 5.2.2.3. 리프레시 토큰 순환 (Refresh Token Rotation)

리프레시 토큰 순환은 다른 앱/디바이스에서 동일한 리프레시 토큰을 병렬로 사용하려는 시도를 자동으로 감지하고 방지하기 위한 것이다. 이는 토큰이 클라이언트에서 도난당하고 이후 공격자와 합법적인 클라이언트 모두가 사용하는 경우에 발생한다. 기본 아이디어는 이전 리프레시 토큰을 사용하여 액세스 토큰을 얻으려는 시도를 감지하기 위해 매 갱신 요청마다 리프레시 토큰 값을 변경하는 것이다. 인가 서버는 공격자인지 합법적인 클라이언트인지 판별할 수 없으므로, 이러한 접근 시도가 있는 경우 유효한 리프레시 토큰과 이에 관련된 접근 권한 모두가 취소된다.

OAuth 사양은 토큰 응답에서 인가 서버가 부여 유형 "refresh_token"을 사용한 요청에 대해서도 새로운 리프레시 토큰을 반환할 수 있도록 허용함으로써 이 조치를 지원한다.

참고: 이 조치는 현재 유효한 리프레시 토큰의 사용이 보장되어야 하므로 클러스터 환경에서 문제를 일으킬 수 있다. 이러한 환경에서는 다른 조치가 더 적절할 수 있다.

##### 5.2.2.4. 리프레시 토큰 취소 (Revocation of Refresh Tokens)

인가 서버는 클라이언트 또는 최종 사용자가 리프레시 토큰의 무효화를 명시적으로 요청할 수 있도록 허용할 수 있다. 토큰을 취소하는 메커니즘은 [OAuth-REVOCATION]에 명시되어 있다.

이것은 다음에 대한 대응 방안이다:

- 디바이스 도난,
- 리소스 소유자의 사칭, 또는
- 손상이 의심되는 클라이언트 애플리케이션.

##### 5.2.2.5. 디바이스 식별 (Device Identification)

인가 서버는 인증 자격 증명을 디바이스 식별자에 바인딩하도록 요구할 수 있다. 국제 모바일 단말기 식별 번호 [IMEI]는 이러한 식별자의 한 예이며, 운영 체제별 식별자도 있다. 인가 서버는 특정 디바이스에서의 토큰 도난을 감지하기 위해 사용자 자격 증명을 인증할 때 이러한 식별자를 포함할 수 있다.

참고: 모든 구현은 디바이스 식별자 사용의 잠재적인 개인정보 보호 영향을 고려해야 한다.

##### 5.2.2.6. X-FRAME-OPTIONS 헤더 (X-FRAME-OPTIONS Header)

최신 브라우저의 경우, X-FRAME-OPTIONS 헤더([X-Frame-Options] 참조)를 사용하여 서버 측에서 iFrame의 회피를 강제할 수 있다. 이 헤더에는 "DENY"와 "SAMEORIGIN" 두 가지 값이 있을 수 있으며, 각각 모든 프레이밍 또는 다른 출처의 사이트에 의한 프레이밍을 차단한다. "ALLOW-FROM" 값은 iFrame이 허용되는 신뢰할 수 있는 출처의 목록을 지정한다.

이것은 다음 위협에 대한 대응 방안이다:

- 클릭재킹 공격

#### 5.2.3. 클라이언트 인증 및 인가 (Client Authentication and Authorization)

섹션 3(보안 기능)에서 설명한 바와 같이, 클라이언트는 다음과 같은 여러 목적을 위해 식별, 인증 및 인가된다:

- 동일한 클라이언트에 대한 요청 정리,
- 사용자에게 클라이언트가 인가 서버에 의해 인식되고 있음을 표시,
- 인가 서버 또는 리소스 서버의 특정 기능에 대한 클라이언트의 접근 인가, 그리고
- 분석 또는 통계를 위해 로그 파일에 클라이언트 식별자 기록.

다양한 클라이언트 유형의 서로 다른 기능과 특성으로 인해, 이러한 목표를 지원하는 다양한 방법이 있으며, 이 섹션에서 설명된다. 인가 서버 제공자는 특정 클라이언트의 보안 정책 및 배포를 인식하고 그에 따라 처리를 조정해야 한다. 예를 들어, 한 가지 접근 방식은 모든 클라이언트를 덜 신뢰할 수 있고 안전하지 않은 것으로 취급하는 것이다. 다른 극단에서는, 서비스 제공자가 관리자에 의해 각 클라이언트 설치를 개별적으로 활성화하고, 그렇게 함으로써 소프트웨어 패키지의 신원과 클라이언트가 설치된 환경의 보안에 대한 확신을 얻을 수 있다. 그 사이에는 여러 가지 접근 방식이 있다.

##### 5.2.3.1. 부적절한 보안 정책을 가진 클라이언트에게 시크릿 발급 금지 (Don't Issue Secrets to Clients with Inappropriate Security Policy)

인가 서버는 시크릿을 보호할 수 없는 클라이언트("공개" 클라이언트)에게 시크릿을 발급해서는 안 된다. 이는 서버가 클라이언트를 강력하게 인증된 것으로 취급할 확률을 줄인다.

예를 들어, 네이티브 애플리케이션의 모든 설치에서 공유되는 단일 클라이언트 ID와 시크릿을 만드는 것은 제한된 이점이 있다. 이러한 시나리오에서는 이 시크릿이 개발자로부터 해당 배포 채널(예: 애플리케이션 마켓)을 통해 최종 사용자 디바이스의 모든 애플리케이션 설치로 전송되어야 한다. 애플리케이션의 소스 코드 또는 관련 리소스 번들에 내장된 시크릿은 리버스 엔지니어링으로부터 보호되지 않는다. 둘째, 이러한 시크릿은 취소할 수 없는데, 취소하면 즉시 모든 설치가 작동하지 않게 되기 때문이다. 또한, 인가 서버가 클라이언트의 식별자를 실제로 신뢰할 수 없기 때문에, 최종 사용자에게 클라이언트의 신뢰성을 나타내는 것은 위험하다.

합리적인 보안 수준을 달성하는 다른 방법이 있으며, 다음 섹션에서 설명한다.

##### 5.2.3.2. 시크릿 없는 공개 클라이언트에 대한 사용자 동의 요구 (Require User Consent for Public Clients without Secret)

인가 서버는 공개 클라이언트에 대해 자동 인가를 허용해서는 안 된다. 인가 서버는 개별 클라이언트 ID를 발급할 수 있지만, 모든 인가가 최종 사용자의 승인을 받아야 한다. 시크릿이 없는 클라이언트의 경우, 이것은 다음 위협에 대한 대응 방안이다:

- 공개 클라이언트 애플리케이션의 사칭.

##### 5.2.3.3. "redirect_uri"와 결합해서만 "client_id" 발급 (Issue a "client_id" Only in Combination with "redirect_uri")

인가 서버는 "client_id"를 발급하고 "client_id"를 특정 사전 구성된 "redirect_uri"에 바인딩할 수 있다. 다른 리다이렉트 URI를 가진 모든 인가 요청은 자동으로 거부된다. 또는, 인가 서버는 이러한 "client_id"에 대해 동적 리다이렉트 URI를 수락하지 않고 항상 잘 알려진 사전 구성된 리다이렉트 URI로 리다이렉트해야 한다. 이것은 시크릿이 없는 클라이언트에 대한 다음 위협에 대한 대응 방안이다:

- 크로스 사이트 스크립팅 공격
- 공개 클라이언트 애플리케이션의 사칭

##### 5.2.3.4. 설치별 클라이언트 시크릿 발급 (Issue Installation-Specific Client Secrets)

인가 서버는 특정 클라이언트(즉, 소프트웨어 패키지)의 다양한 설치에 별도의 클라이언트 식별자와 해당 시크릿을 발급할 수 있다. 이러한 접근 방식의 효과는 그렇지 않으면 "공개" 클라이언트를 다시 "기밀" 클라이언트로 전환하는 것이다.

웹 애플리케이션의 경우, 이는 소프트웨어 패키지가 설치된 각 웹 사이트에 대해 하나의 "client_id"와 "client_secret"을 생성하는 것을 의미할 수 있다. 따라서, 해당 특정 사이트의 제공자는 웹 사이트 설정 중에 인가 서버로부터 클라이언트 ID와 시크릿을 요청할 수 있다. 이는 또한 리다이렉트 URI, 웹 사이트 URL 등 유용한 것으로 입증되는 해당 웹 사이트의 일부 속성의 검증을 허용할 것이다. 웹 사이트 제공자는 사이트에서 클라이언트 시크릿의 보안을 보장해야 한다.

네이티브 애플리케이션의 경우, 모든 디바이스의 특정 애플리케이션 사본이 다른 설치이기 때문에 상황이 더 복잡하다. 이 시나리오에서 설치별 시크릿은 다음 중 하나의 방법으로 "client_id"와 "client_secret"을 얻어야 한다:

1. 애플리케이션 마켓에서 다운로드 프로세스 중, 또는
2. 디바이스에 설치하는 동안.

두 접근 방식 모두 현재 OAuth에서 정의되지 않은 클라이언트 ID와 시크릿을 발급하기 위한 자동화된 메커니즘을 필요로 한다.

첫 번째 접근 방식은 애플리케이션의 진위성에 대한 일정 수준의 신뢰를 달성할 수 있게 하는 반면, 두 번째 옵션은 설치의 인증만 허용하고 클라이언트의 속성 검증은 허용하지 않는다. 그러나 이것은 최소한 여러 재전송 공격을 방지하는 데 도움이 된다. 또한, 설치별 "client_id"와 시크릿을 사용하면 특정 설치의 모든 리프레시 토큰을 한 번에 선택적으로 취소할 수 있다.

##### 5.2.3.5. 사전 등록된 "redirect_uri" 검증 (Validate Pre-Registered "redirect_uri")

인가 서버는 모든 클라이언트에게 "redirect_uri"를 등록하도록 요구해야 하며, "redirect_uri"는 [RFC6749]에 정의된 전체 URI여야 한다. 이 등록이 수행되는 방식은 이 문서의 범위 밖이다. 코어 사양에 따라, 최종 사용자 인가 엔드포인트로 해당 "client_id"와 함께 전송되는 모든 실제 리다이렉트 URI는 등록된 리다이렉트 URI와 일치해야 한다. 일치하지 않는 경우, 인가 서버는 인바운드 GET 요청이 공격자에 의해 전송된 것으로 간주하고 거부해야 한다. 참고: 인가 서버는 사용자 에이전트를 이러한 인가 요청의 리다이렉트 URI로 다시 리다이렉트해서는 안 된다. 사전 등록된 "redirect_uri"의 검증은 다음 위협에 대한 대응 방안이다:

- 위조 웹 사이트를 통한 인가 "코드" 유출: 최종 사용자 인가 엔드포인트로의 첫 번째 리다이렉트 후 인가 서버가 공격 시도를 감지할 수 있게 한다 (섹션 4.4.1.7).
- 클라이언트 리다이렉션 엔드포인트를 통한 오픈 리다이렉터 공격 (섹션 4.1.5).
- 인가 서버 리다이렉션 엔드포인트를 통한 오픈 리다이렉터 피싱 공격 (섹션 4.2.4).

이 조치의 기본 가정은 공격자가 인가 "코드"에 접근하기 위해 다른 리다이렉트 URI를 사용해야 한다는 것이다. 배포 시 공격자가 이 보안 조치를 우회하기 위해 피해자의 디바이스에 대한 스푸핑 공격을 사용할 가능성을 고려할 수 있다.

참고: 클라이언트 사전 등록은 일부 배포에서 확장되지 않을 수 있거나(수동 프로세스) 동적 클라이언트 등록(아직 명시되지 않음)을 필요로 할 수 있다. 동적 클라이언트 등록이 없으면, 사전 등록된 "redirect_uri"는 개발/구성 시점에 특정 배포에 바인딩된 클라이언트에 대해서만 작동한다. 동적 리소스 서버 검색이 필요해지면, 사전 등록된 "redirect_uri"는 더 이상 실현 가능하지 않을 수 있다.

##### 5.2.3.6. 클라이언트 시크릿 취소 (Revoke Client Secrets)

인가 서버는 노출된 시크릿의 남용을 방지하기 위해 클라이언트의 시크릿을 취소할 수 있다.

참고: 이 조치는 해당 클라이언트에 발급된 모든 인가 "코드" 또는 리프레시 토큰을 즉시 무효화한다. 이는 특정 네이티브 또는 웹 애플리케이션의 여러 배포에서 사용되는 클라이언트 식별자 및 시크릿에 의도치 않게 영향을 줄 수 있다.

이것은 다음에 대한 대응 방안이다:

- 비공개 클라이언트의 노출된 클라이언트 시크릿 남용

##### 5.2.3.7. 강력한 클라이언트 인증 사용 (예: client_assertion/client_token) (Use Strong Client Authentication (e.g., client_assertion/client_token))

클라이언트 어설션 [OAuth-ASSERTIONS]과 같은 대체 인증 형식을 사용하면, "client_secret"을 배포할 필요가 없어진다. 이는 클라이언트 어설션 발급자가 인증 프로세스에서 지정한 대로 안전한 개인 키 저장소 또는 기타 보조 인증 시스템의 사용을 필요로 할 수 있다.

#### 5.2.4. 최종 사용자 인가 (End-User Authorization)

이 섹션에서는 최종 사용자를 포함하는 인가 흐름에 대한 고려사항을 포함한다.

##### 5.2.4.1. 반복 인가의 자동 처리에는 클라이언트 검증 필요 (Automatic Processing of Repeated Authorizations Requires Client Validation)

인가 서버는 클라이언트가 클라이언트 시크릿 또는 서명된 인증 어설션 인증서(섹션 5.2.3.7)나 사전 등록된 리다이렉트 URI 검증(섹션 5.2.3.5)과 같은 다른 인증 메커니즘을 통해 인증되지 않은 경우, 반복 인가를 자동으로 처리해서는 안 된다.

##### 5.2.4.2. 투명성에 기반한 정보에 입각한 결정 (Informed Decisions Based on Transparency)

인가 서버는 인가 프로세스에서 무슨 일이 일어나는지, 그리고 그 결과가 무엇인지 최종 사용자에게 명확하게 설명해야 한다. 예를 들어, 사용자는 어떤 클라이언트에게 어떤 기간 동안 어떤 접근 권한을 부여하려고 하는지 이해해야 한다. 서버가 특정 클라이언트 속성(웹 사이트 URL, 보안 정책)을 신뢰성 있게 인증할 수 있는지 여부도 사용자에게 명확해야 한다.

##### 5.2.4.3. 최종 사용자에 의한 클라이언트 속성 검증 (Validation of Client Properties by End User)

인가 프로세스에서, 사용자는 일반적으로 인가에 대한 클라이언트의 요청을 승인하도록 요청받는다. 이것은 그 자체로 중요한 보안 메커니즘인데, 최종 사용자가 클라이언트 속성의 검증에 참여할 수 있기 때문이다. 예를 들어, 인가 서버에 알려진 클라이언트 이름이 최종 사용자가 사용하고 있는 웹 사이트 또는 애플리케이션의 이름과 일치하는지 여부 등이다. 이 조치는 인가 서버가 클라이언트를 인증할 수 없는 상황에서 특히 유용하다. 이것은 다음에 대한 대응 방안이다:

- 악성 애플리케이션
- 다른 클라이언트로 가장하는 클라이언트 애플리케이션

##### 5.2.4.4. 인가 "코드"와 "client_id"의 바인딩 (Binding of Authorization "code" to "client_id")

인가 서버는 모든 인가 "코드"를 최종 사용자 인가 프로세스를 시작한 해당 클라이언트의 ID에 바인딩해야 한다. 이 조치는 다음에 대한 대응 방안이다:

- 다른 클라이언트 자격 증명으로 인가 "코드"를 재전송하는 것, 공격자가 다른 "client_id"를 사용하여 인가 "코드"를 토큰으로 교환할 수 없기 때문이다
- 인가 "코드"의 온라인 추측

참고: 이 바인딩은 무단 수정으로부터 보호되어야 한다(예: 보호된 메모리 및/또는 안전한 데이터베이스 사용).

##### 5.2.4.5. 인가 "코드"와 "redirect_uri"의 바인딩 (Binding of Authorization "code" to "redirect_uri")

인가 서버는 모든 인가 "코드"를 최종 사용자 인가 프로세스에서 클라이언트의 리다이렉트 대상으로 사용된 실제 리다이렉트 URI에 바인딩할 수 있어야 한다. 이 바인딩은 클라이언트가 해당 인가 "코드"를 액세스 토큰으로 교환하려고 시도할 때 검증되어야 한다. 이 조치는 위조 웹 사이트를 통한 인가 "코드" 유출에 대한 대응 방안이며, 공격자가 다른 리다이렉트 URI를 사용하여 인가 "코드"를 토큰으로 교환할 수 없기 때문이다.

### 5.3. 클라이언트 앱 보안 (Client App Security)

이 섹션에서는 클라이언트 애플리케이션에 대한 고려사항을 다룬다.

#### 5.3.1. 소프트웨어 패키지에 번들된 코드 또는 리소스에 자격 증명 저장 금지 (Don't Store Credentials in Code or Resources Bundled with Software Packages)

클라이언트 소프트웨어의 사본 수가 많기 때문에, 애플리케이션의 모든 설치에서 공유되는 단일 클라이언트 ID와 시크릿을 만드는 것은 제한된 이점이 있다. 이러한 애플리케이션 자체는 클라이언트 시크릿을 유지할 수 있다고 추정할 수 없으므로 "공개" 클라이언트로 간주된다. 애플리케이션의 소스 코드 또는 관련 리소스 번들에 내장된 시크릿은 리버스 엔지니어링으로부터 보호될 수 없다. 둘째, 이러한 시크릿은 취소할 수 없는데, 취소하면 즉시 모든 설치가 작동하지 않게 되기 때문이다. 또한, 인가 서버가 클라이언트의 식별자를 실제로 신뢰할 수 없기 때문에, 최종 사용자에게 클라이언트의 신뢰성을 나타내는 것은 위험하다.

#### 5.3.2. 표준 웹 서버 보호 조치 사용 (구성 파일 및 데이터베이스용) (Use Standard Web Server Protection Measures (for Config Files and Databases))

서버, 데이터베이스, 구성 파일 및 서버의 기타 운영 구성 요소의 무결성을 보호하기 위해 표준 웹 서버 보호 및 구성 조치를 사용한다.

#### 5.3.3. 보안 저장소에 시크릿 저장 (Store Secrets in Secure Storage)

디바이스나 서버에 모든 종류의 시크릿(토큰, 클라이언트 시크릿)을 안전하게 저장하는 다양한 방법이 있다.

대부분의 다중 사용자 운영 체제는 서로 다른 시스템 사용자의 개인 저장소를 분리한다. 또한, 대부분의 현대 스마트폰 운영 체제는 파일 시스템의 별도 영역에 애플리케이션별 데이터 저장을 지원하고 다른 애플리케이션의 접근으로부터 데이터를 보호한다. 추가로, 애플리케이션은 PIN이나 비밀번호와 같은 사용자 제공 시크릿을 사용하여 기밀 데이터를 구현할 수 있다.

또 다른 옵션은 리프레시 토큰 저장소를 신뢰할 수 있는 백엔드 서버로 교체하는 것이다. 이 옵션은 클라이언트와 백엔드 서버 간의 탄력적인 인증 메커니즘을 필요로 한다. 참고: 애플리케이션은 보안 저장소에서 읽은 후에도 기밀 데이터가 기밀로 유지되도록 보장해야 하며, 이는 일반적으로 이 데이터를 애플리케이션의 로컬 메모리에 유지하는 것을 의미한다.

#### 5.3.4. 무단 디바이스 접근을 방지하기 위한 디바이스 잠금 활용 (Utilize Device Lock to Prevent Unauthorized Device Access)

일반적인 현대 스마트폰에는 디바이스를 도난당하거나 분실했을 때 추가 보호를 제공하기 위해 활용할 수 있는 많은 "디바이스 잠금" 옵션이 있다. 여기에는 PIN, 비밀번호 및 "안면 인식"과 같은 기타 생체 인식 기능이 포함된다. 이들이 제공하는 보안 수준은 동일하지 않다.

#### 5.3.5. "state" 매개변수를 사용자 에이전트 세션에 연결 (Link the "state" Parameter to User Agent Session)

"state" 매개변수는 클라이언트 요청을 연결하고 CSRF 공격(예: 리다이렉트 URI에 대한 공격)을 방지하는 데 사용된다. 공격자는 자신의 인가 "코드" 또는 액세스 토큰을 주입할 수 있으며, 이로 인해 클라이언트가 피해자의 것이 아닌 공격자의 보호된 리소스와 관련된 액세스 토큰을 사용하게 될 수 있다(예: 피해자의 은행 계좌 정보를 공격자가 제어하는 보호된 리소스에 저장).

클라이언트는 인가 요청 시 "state" 요청 매개변수를 사용하여 인가 서버에 사용자 에이전트의 인증된 상태에 요청을 바인딩하는 값(예: 사용자 에이전트를 인증하는 데 사용되는 세션 쿠키의 해시)을 전송해야 한다. 최종 사용자로부터 인가가 획득되면, 인가 서버는 "state" 매개변수에 포함된 필요한 바인딩 값과 함께 최종 사용자의 사용자 에이전트를 클라이언트로 다시 리다이렉트한다.

바인딩 값은 클라이언트가 바인딩 값을 사용자 에이전트의 인증된 상태와 매칭하여 요청의 유효성을 검증할 수 있게 한다.

### 5.4. 리소스 서버 (Resource Servers)

다음 섹션에서는 리소스 서버에 대한 보안 고려사항을 상세히 설명한다.

#### 5.4.1. 인가 헤더 (Authorization Headers)

인가 헤더는 HTTP 프록시 및 서버에 의해 인식되고 특별하게 처리된다. 따라서, 리소스 서버에 액세스 토큰을 전송하기 위해 이러한 헤더를 사용하면 일반적으로, 특히 인가 헤더에서 인증된 요청의 유출 또는 의도하지 않은 저장의 가능성을 줄인다.

#### 5.4.2. 인증된 요청 (Authenticated Requests)

인가 서버는 토큰을 특정 클라이언트 식별자에 바인딩하고 리소스 서버가 리소스 접근 시 해당 연관을 검증할 수 있게 할 수 있다. 이를 위해 리소스 서버는 요청의 발신자를 특정 토큰의 합법적인 소유자로 인증해야 한다. 이 대응 방안을 구현하는 여러 옵션이 있다:

- 인가 서버는 클라이언트 식별자를 토큰과 연관시킬 수 있다(내부적으로 또는 자체 포함 토큰의 페이로드에). 그런 다음 클라이언트는 리소스 서버의 엔드포인트에서 클라이언트 인증서 기반 HTTP 인증을 사용하여 신원을 인증하고, 리소스 서버는 이름이 토큰에서 참조된 이름과 일치하는지 검증한다.
- 위 옵션과 동일하지만, 클라이언트가 개인 키를 사용하여 리소스 서버에 대한 요청에 서명한다(공개 키는 토큰에 포함되거나 요청과 함께 전송됨).
- 또는, 인가 서버가 토큰에 바인딩된 키를 발급하고, 클라이언트가 토큰 사용을 인증하기 위해 소유 증명(Holder-of-Key proof)에서 이를 사용할 수 있다. 리소스 서버는 인가 서버로부터 직접 시크릿을 얻거나, 시크릿이 토큰의 암호화된 섹션에 포함된다. 이렇게 하면 리소스 서버는 클라이언트를 "알지" 못하지만, 인가 서버가 해당 클라이언트에게 토큰을 발급했는지 검증할 수 있다.

인증된 요청은 위조 리소스 서버에 의한 토큰 남용에 대한 대응 방안이다.

#### 5.4.3. 서명된 요청 (Signed Requests)

리소스 서버는 전송 계층 보안 조치를 대체하거나 보완하기 위해 서명된 요청만 수락하기로 결정할 수 있다. 모든 서명된 요청은 고유하게 식별할 수 있어야 하며, 리소스 서버에서 두 번 처리되어서는 안 된다. 이 대응 방안은 다음을 완화하는 데 도움이 된다:

- 메시지의 수정 및
- 재전송 시도

### 5.5. 사용자 상호작용과 사용자 설치 앱에 대한 한마디 (A Word on User Interaction and User-Installed Apps)

OAuth는 보안 프로토콜로서, 그 흐름이 일반적으로 상당한 사용자 상호작용을 포함하여 최종 사용자를 보안 모델의 일부로 만든다는 점에서 독특하다. 이로 인해 위에서 논의한 일부 위협에 대한 방어에서 몇 가지 중요한 어려움이 발생한다. 이러한 점들 중 일부는 이미 언급되었지만, 여기서 반복하고 강조할 가치가 있다.

- 최종 사용자는 자신이 무엇을 승인하도록 요청받고 있는지 이해해야 한다(섹션 5.2.4.2 참조). 사용자들은 인가 요청에 "예"라고 말하는 것의 영향을 이해하는 전문 지식이 없는 경우가 많으며, 요청의 미묘한 문구 차이를 볼 수 없을 가능성이 높다. 악성 소프트웨어는 사용자를 혼란시켜 거의 모든 것을 승인하도록 속일 수 있다.

- 최종 사용자 디바이스는 소프트웨어 손상에 취약하다. 이는 웹 브라우저 및 사용자 시스템의 다른 부분에 대한 빈번한 공격과 함께 오래된 문제이다. 그러나 사용자가 설치하는 "앱"의 증가하는 인기와 함께, 손상되거나 악의적인 최종 사용자 소프트웨어에 의한 위협은 매우 강력하며 완화하기 매우 어려운 것이다.

- 사용자들이 이러한 앱을 설치하고 실행하기를 요구할 것이며, 손상되거나 악의적인 앱이 데이터 흐름의 많은 지점에서 자격 증명을 훔칠 수 있다는 것을 인식해야 한다. 이들은 OAuth가 보호하도록 설계된 바로 그 사용자 로그인 자격 증명을 가로챌 수 있다. 사용자가 이해하고 승인한 것 이상의 인가를 요청할 수 있다. 사용자를 대신하여 응답을 자동화하여 전체 프로세스를 숨길 수 있다. 여기서 해결책이 제시되지 않는데, 알려진 것이 없기 때문이다; 이는 더 나은 보안과 더 나은 사용성 사이의 영역에 남아 있다.

- 사용자가 설치한 소프트웨어의 사용을 제한하여 이러한 문제를 해결하는 것은 일부 제한된 환경에서는 실용적일 수 있으며, 이러한 경우 대응 방안으로 사용될 수 있다. 이러한 제한은 일반적인 경우에는 실용적이지 않으며, 사후 복구 메커니즘이 마련되어 있어야 한다.

- 최종 사용자는 대부분 디바이스에 로드하는 애플리케이션을 제대로 검증할 능력이 없지만, 인가 서버를 배포하는 사람들은 악의적인 클라이언트를 완화할 수 있는 도구를 가지고 있을 수 있다. 예를 들어, 잘 운영되는 인가 서버는 효과적으로 검증할 수 있는 클라이언트 속성만 최종 사용자에게 주장해야 하고, 검증할 수 없는 속성을 명시적으로 지적해야 하며, 특정 클라이언트에 접근 권한을 부여하는 것과 관련된 위험을 최종 사용자에게 표시해야 한다.
