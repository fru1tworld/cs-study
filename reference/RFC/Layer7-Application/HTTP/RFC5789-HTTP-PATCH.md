
Internet Engineering Task Force (IETF)                     L. Dusseault
Request for Comments: 5789                          Linden Lab
Category: Standards Track                                     J. Snell
ISSN: 2070-1721                                           2010년 3월


                       HTTP를 위한 PATCH 메서드

초록

   여러 애플리케이션에서 리소스의 부분 수정을 수행하기 위한 기능이 필요하며,
   기존 HTTP PUT 메서드는 문서의 완전한 교체만 허용합니다. 이 제안은 기존
   HTTP 리소스를 수정하기 위한 새로운 HTTP 메서드인 PATCH를 추가합니다.

이 메모의 상태

   이 문서는 인터넷 표준 트랙 문서입니다.

   이 문서는 Internet Engineering Task Force (IETF)의 산출물입니다. 이 문서는
   IETF 커뮤니티의 합의를 나타냅니다. 이 문서는 공개 검토를 받았으며 Internet
   Engineering Steering Group (IESG)에 의해 출판이 승인되었습니다. 인터넷
   표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

   이 문서의 현재 상태, 정오표, 그리고 피드백을 제공하는 방법에 대한 정보는
   http://www.rfc-editor.org/info/rfc5789 에서 확인할 수 있습니다.

저작권 고지

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors. All rights reserved.

   이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF
   Trust의 법적 조항 (http://trustee.ietf.org/license-info)의 적용을 받습니다.
   이 문서에 관한 귀하의 권리와 제한사항이 기술되어 있으므로 이 문서들을
   주의 깊게 검토하시기 바랍니다. 이 문서에서 추출된 코드 구성요소는
   Trust Legal Provisions의 섹션 4.e에 기술된 대로 Simplified BSD License
   텍스트를 포함해야 하며, Simplified BSD License에 기술된 대로 보증 없이
   제공됩니다.

목차

   1. 소개 ............................................................. 2
   2. PATCH 메서드 ..................................................... 2
      2.1. 간단한 PATCH 예시 ........................................... 4
      2.2. 오류 처리 ................................................... 5
   3. OPTIONS에서 지원 알림 ............................................ 7
      3.1. Accept-Patch 헤더 ........................................... 7
      3.2. OPTIONS 요청 및 응답 예시 ................................... 7
   4. IANA 고려사항 .................................................... 7
      4.1. Accept-Patch 응답 헤더 등록 ................................. 7
      4.2. HTTP 상태 코드 허용 ......................................... 8
   5. 보안 고려사항 .................................................... 8
   6. 참조 ............................................................ 9
      6.1. 규범적 참조 ................................................ 9
      6.2. 정보적 참조 ................................................ 9
   부록 A. 감사의 말 .................................................. 10

1. 소개

   이 명세는 기존 리소스에 부분 수정을 적용하기 위한 새로운 HTTP/1.1
   ([RFC2616]) 메서드인 PATCH를 정의합니다.

   새로운 메서드는 기존 HTTP 인프라의 상호운용성을 개선하고
   리소스를 부분적으로 수정하기 위한 다른 HTTP 메서드의 사용으로 인한
   혼란을 방지하기 위해 필요합니다. 기존 HTTP PUT 메서드는 문서의 완전한
   교체만 허용하는 등의 다양한 이유가 있습니다. PATCH라는 메서드는
   이전에 HTTP에 사용된 적이 있지만 완전하게 정의되지 않았습니다.

   부분 PUT이 아닌 이 메커니즘의 정의는 정확한 의미가 재정의하는 것이
   어렵고 기존의 파이프라인된 PUT과의 상호운용이 어려운 경우를 피하기
   위해 필요했습니다.

   이 문서에서 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL" 키워드는
   [RFC2119]에 기술된 대로 해석되어야 합니다.

   또한, 이 문서는 [RFC2616] 섹션 2.1의 ABNF 구문 표기법을 사용합니다.

2. PATCH 메서드

   PATCH 메서드는 요청 엔티티에 기술된 변경 사항 집합을 Request-URI로
   식별되는 리소스에 적용하도록 요청합니다. 변경 사항 집합은 미디어
   타입으로 식별되는 "패치 문서"라는 형식으로 표현됩니다. Request-URI가
   기존 리소스를 가리키지 않는 경우, 서버는 패치 문서 유형(논리적으로
   존재하지 않는 리소스를 수정할 수 있는지 여부)과 권한 등에 따라 새
   리소스를 생성할 수 있습니다(MAY).

   PUT 요청과 PATCH 요청의 차이점은 서버가 동봉된 엔티티를 처리하여
   Request-URI로 식별되는 리소스를 수정하는 방식에 반영됩니다. PUT
   요청에서 동봉된 엔티티는 원본 서버에 저장된 리소스의 수정된 버전으로
   간주되며, 클라이언트는 저장된 버전의 교체를 요청합니다. 그러나
   PATCH에서 동봉된 엔티티는 원본 서버에 현재 존재하는 리소스가 새
   버전을 생성하기 위해 어떻게 수정되어야 하는지를 설명하는 명령어
   집합을 포함합니다. PATCH 메서드는 Request-URI로 식별되는 리소스에
   영향을 미치며, 다른 리소스에도 부수적인 영향을 미칠 수 있습니다(MAY).
   즉, PATCH의 적용에 의해 새로운 리소스가 생성되거나 기존 리소스가
   수정될 수 있습니다.

   PATCH는 [RFC2616] 섹션 9.1에 정의된 대로 안전하지도 않고 멱등하지도
   않습니다.

   PATCH 요청은 그것이 적용되는 리소스에 영향을 미치는 방식으로 발행될
   수 있지만, 일반적으로 멱등한 방식은 아닙니다. 그러나 멱등한 패치
   요청을 발행하는 것이 가능하며, 이는 또한 유사한 시간대에 동일
   리소스에 대한 두 PATCH 요청 간의 충돌로 인한 나쁜 결과를 방지하는
   데 도움이 됩니다.

   여러 PATCH 요청의 충돌은 PUT 충돌보다 위험할 수 있습니다. 왜냐하면
   일부 패치 형식은 알려진 기준점에서 작동해야 하기 때문입니다. 그렇지
   않으면 리소스가 손상될 수 있습니다. 이 유형의 패치 애플리케이션을
   사용하는 클라이언트는 클라이언트가 마지막으로 리소스에 접근한 이후
   리소스가 업데이트된 경우 요청이 실패하도록 조건부 요청을 사용해야
   합니다(SHOULD). 예를 들어, 클라이언트는 패치 요청의 If-Match 헤더에
   ETag를 사용할 수 있습니다.

   서버가 전체 변경 사항 집합을 원자적으로 적용하고 변경 사항의 일부만
   적용된 결과를 절대로 제공하지 않아야 한다는 것 외에 PATCH를 사용한
   리소스 생성 또는 수정에 대한 기본적인 제한은 없습니다(MUST NOT).
   Request-URI의 리소스에 대한 원자성은 향후 규격에 의해 여전히 부분적으로
   정의될 수 있습니다.

   PATCH에 대한 "성공적" 응답은 적절한 것만을 의미합니다 -- 이전 또는
   이후에 적용되는 다른 (패치가 아닌) 작업의 결과가 아닌, 전체 패치가
   적용되었음을 의미합니다. 어떤 서버 상태를 확인하기 위해 패치를
   적용한 후 클라이언트의 GET 요청은 중간에 다른 요청을 발행한 다른
   사용자가 있을 수 있으므 보장되지 않습니다.

   서버는 수신된 패치 문서가 Request-URI로 식별된 리소스 유형에 적합한지
   확인해야 합니다(MUST). 관련성이 없는 패치 문서를 잘못 적용하는 것은
   리소스를 손상시키거나 보안 취약점을 도입할 수 있으므로 서버가 이를
   방지해야 합니다.

   적용 가능한 PATCH의 대체 형식이 있는지 여부의 결정은 전적으로 서버에
   의해 이루어집니다. 서버가 단일 유형의 패치 문서만 수락하도록 선택
   하더라도 이는 완전히 수용 가능합니다. 유사하게, 패치 문서 크기와 전체
   교체될 문서의 크기를 비교하는 PATCH를 사용할지 PUT을 사용할지에 대한
   결정을 하는 사람은 궁극적으로 클라이언트이지만, 리소스를 지원하는
   비디오 저장소에 대해 PATCH만 지원할지 PUT만 지원할지에 대한 결정을
   내리는 것은 서버입니다.

   이 문서에서 정의되지 않은 부분에서 PATCH에 대한 서버의 처리는
   PUT과 유사해야 합니다. 여기에는 성공 및 오류에 대한 응답 의미론,
   인가, 그리고 요청 헤더의 상호작용이 포함됩니다. 특히, 특정 패치
   문서 형식에서 명시적으로 허용하지 않는 한 PATCH 요청의 엔티티
   헤더는 PATCH 문서에만 적용되어야 하며(SHOULD) 생성 또는 수정되는
   리소스에 적용되어서는 안 됩니다.

   단일 기본 패치 문서 형식은 존재하지 않습니다. 그러나
   application/json-patch+json [RFC6902]와 같은 새로운 패치 문서 형식이
   등록되어야 합니다(SHOULD).

   PATCH 요청에 의해 생성된 응답은 캐시할 수 없습니다. 단, 응답에
   Content-Location 헤더와 같은 명시적 신선도 정보가 포함된 경우는
   예외입니다. PATCH 응답에 Content-Location 헤더가 있고 그 값이
   Request-URI와 동일한 경우, 응답 본문은 해당 URL에 대한 후속
   GET의 결과로 사용될 수 있습니다. 다만, 해당 GET 요청이 동시에
   발생하고, PATCH 응답의 ETag가 GET 응답의 ETag와 정확히 일치하는
   경우에 한합니다.

2.1. 간단한 PATCH 예시

   PATCH /file.txt HTTP/1.1
   Host: www.example.com
   Content-Type: application/example
   If-Match: "e0023aa4e"
   Content-Length: 100

   [변경 사항 설명]

   성공적인 PATCH에 대한 응답:

   HTTP/1.1 204 No Content
   Content-Location: /file.txt
   ETag: "e0023aa4f"

   [RFC2616] 섹션 10.2.1에 정의된 대로 200 응답 코드도 사용될 수
   있습니다.

   100 바이트의 패치 문서가 파일 하나에 적용되었습니다. 가상적인
   "application/example" 패치 형식은 패치가 완전히 적용되거나 전혀
   적용되지 않도록 의미가 정의되어 서버의 원자성 요구사항을 강제합니다.

   응답에서 ETag를 확인하여 리소스의 현재 내용 식별이 가능하며 이를
   통해 리소스의 상태를 추적하고 향후 PATCH에 사용할 수 있습니다. ETag를
   사용하는 경우 PATCH 응답에서 수신된 ETag 값이 리소스의 현재 상태에
   대한 유일한 신뢰할 수 있는 정보가 됩니다. PATCH 이후 리소스의 전체
   표현이 응답에 포함되지 않을 수 있으므로 Content-MD5와 같은 다른
   헤더는 패치 문서에만 적용되고 리소스에는 적용되지 않습니다.

2.2. 오류 처리

   PATCH에서 발생할 수 있는 여러 알려진 조건이 있습니다:

   잘못된 형식의 패치 문서: 서버가 패치 문서가 적절하게 형식화되지
   않았다고 판단하면, 서버는 400 (Bad Request) 응답을 반환해야 합니다
   (SHOULD). "적절한 형식"의 정의는 패치 문서가 선택한 미디어 유형에
   따라 다릅니다.

   지원되지 않는 패치 문서: 클라이언트가 서버가 지원하지 않는 형식의
   패치 문서를 보낸 경우 415 (Unsupported Media Type) 응답으로
   지정할 수 있습니다. 이러한 응답에는 [RFC2616] 섹션 3.7에 따라
   Accept-Patch 응답 헤더를 포함하여 서버가 지원하는 패치 문서 미디어
   유형을 알려야 합니다(SHOULD).

   처리할 수 없는 요청: 패치 문서의 형식은 유효하지만, 서버가 요청을
   처리할 수 없는 경우 422 (Unprocessable Entity) 응답을 사용할 수
   있습니다 ([RFC4918], 섹션 11.2). 예를 들어, 수정이 리소스를 유효하지
   않은 상태로 만드는 경우가 있을 수 있습니다.

   리소스를 찾을 수 없음: 패치 문서를 존재하지 않는 리소스에 적용할 수
   없는 경우(예: 새 리소스 생성을 지원하지 않는 패치 문서 유형에서),
   서버는 404 (Not Found) 상태 코드로 응답해야 합니다(SHOULD).

   충돌 상태: 리소스의 현재 상태로 인해 요청이 적용될 수 없는 특정
   상황(예: 삭제하라는 부분이 이미 리소스에 없는 경우처럼 패치에 의해
   가정된 구조가 존재하지 않음)에서 서버는 409 (Conflict) 상태 코드로
   표시해야 합니다(SHOULD).

   동시 수정 충돌: 서버가 동일한 리소스에 대해 동시에 두 개의 PATCH
   요청(또는 PATCH 요청과 PUT/POST)을 수신하고 큐에 넣을 수 없는 경우
   409 (Conflict) 오류 응답을 사용해야 합니다(SHOULD).

   전제조건 실패: 조건부 요청의 전제조건이 실패한 경우 412
   (Precondition Failed) 응답을 통해 표시해야 합니다(SHOULD).

   위 오류 목록은 완전하지 않습니다 -- 서버는 적절한 경우 다른 상태
   코드를 사용해야 합니다(MUST). HTTP 오류 응답 본문은 클라이언트가
   실패한 요청에 대한 후속 조치를 취하기에 충분한 정보를 포함해야
   합니다(SHOULD).

   클라이언트는 실패한 요청을 처리하기 위해 GET 요청을 발행하여
   리소스의 현재 상태를 가져올 수 있습니다. 예를 들어, 위의 409 Conflict
   응답에 대해 클라이언트는 리소스의 현재 사본을 가져와서 오류가
   포함된 차이점 보고서를 사용하여 새 패치를 구성하거나 리소스의 현재
   사본에 대해 변환하여 패치를 재구성할 수 있습니다.

3. OPTIONS에서 지원 알림

   서버는 특정 리소스에 대한 OPTIONS 응답의 Allow 헤더에 PATCH를
   포함하여 PATCH를 지원함을 알릴 수 있습니다. OPTIONS의 Accept-Patch
   헤더가 있으면 PATCH가 허용됨을 나타내므로 Allow 헤더를 사실상
   불필요하게 만들지만, 하위 호환성을 위해 PATCH를 지원할 때 Allow
   헤더에 포함되어야 합니다(SHOULD).

3.1. Accept-Patch 헤더

   이 명세는 서버가 수락하는 패치 문서 미디어 유형을 지정하기 위한 새로운
   응답 헤더 Accept-Patch를 도입합니다. Accept-Patch는 반드시 PATCH를
   지원하는 모든 리소스에 대한 OPTIONS 응답에 나타나야 합니다(MUST).
   OPTIONS 응답에 이 헤더가 있으면 해당 리소스에 PATCH가 허용됨을
   암시합니다. 이 헤더가 없다고 해서 PATCH가 허용되지 않음을 의미하지는
   않습니다. 왜냐하면 Accept-Patch에 대한 지원이 필수가 아닐 수
   있기 때문입니다.

   Accept-Patch의 구문은 다음과 같습니다:

     Accept-Patch = "Accept-Patch" ":" 1#media-type

   media-type의 구문은 [RFC2616] 섹션 3.7에 정의되어 있습니다.

3.2. OPTIONS 요청 및 응답 예시

   OPTIONS /example/buddies.xml HTTP/1.1
   Host: www.example.com

   위에 대한 예시 응답에서 PATCH가 지원됨을 나타냅니다:

   HTTP/1.1 200 OK
   Allow: GET, PUT, POST, OPTIONS, HEAD, DELETE, PATCH
   Accept-Patch: application/example, text/example

   실제 패치 문서 형식은 RFC에 의해 정의되지 않으며, 두 개의 가상
   패치 문서 형식이 예시를 위해 사용되었습니다.

4. IANA 고려사항

4.1. Accept-Patch 응답 헤더 등록

   Accept-Patch 응답 헤더가 [RFC3864]에 정의된 영구 등록소에
   추가되었습니다.

      헤더 필드 이름: Accept-Patch

      적용 프로토콜: HTTP

      저자/변경 관리자: IETF

      명세 문서: 이 명세

4.2. HTTP 상태 코드 허용

   이 명세는 [RFC4918] 섹션 11.2에 정의된 HTTP 상태 코드 422
   (Unprocessable Entity)의 사용을 예상하며, IANA HTTP 상태 코드
   등록소에 아직 포함되지 않았기 때문에 여기서 이 등록이 수행됩니다.

   IANA HTTP 상태 코드 등록소에 추가된 상태 코드:

      상태 코드: 422

      설명: Unprocessable Entity

      참조: [RFC4918]

5. 보안 고려사항

   PATCH 요청에 대한 보안 고려사항은 PUT([RFC2616], 섹션 9.6)에 대한
   것과 거의 동일합니다. 여기에는 접근 제어 및 인증을 통한 요청 인가,
   우발적인 덮어쓰기에 대한 보호, 그리고 전송 오류에 대한 데이터
   무결성 보호가 포함됩니다.

   PUT을 사용하여 완전히 교체된 문서와 비교할 때, 패치 문서를 사용하여
   패치된 문서가 손상될 수 있다는 우려가 있을 수 있습니다. 이것이
   위험이라면 ETag와 If-Match 요청 헤더를 사용한 조건부 요청을 사용하여
   완화할 수 있습니다. PATCH가 실패한 경우, 클라이언트는 리소스가
   올바른 상태에 있는지 확인하기 위해 GET 요청을 발행할 수 있습니다.
   어떤 경우에는, PATCH 응답이 수신되기 전에 전송 연결이 실패하면
   클라이언트는 캐시를 우회하는 GET 요청을 발행하여 애플리케이션
   상태를 확인할 수 있습니다.

   악성 콘텐츠를 검사하는 중개자 (예: 바이러스를 검사하는 HTTP 중개자)는
   PATCH 작업에 특별한 어려움이 있습니다. 소스 문서도, 패치 문서도
   개별적으로는 악성이 아닐 수 있지만, 서버가 패치를 적용한 결과
   악성인 리소스를 생성할 수 있습니다. 바이트 범위 다운로드, 패치 문서,
   압축 파일 업로드 및 유사한 메커니즘에서 이 우려는 기존의 위험과
   유사합니다. 이러한 유형의 콘텐츠 포함을 탐지하는 중개자는 이 특정
   우려에 대해 개별 데이터 조각보다는 조립된 콘텐츠를 확인하는 방식
   외에는 할 수 있는 것이 없습니다.

   개별 패치 문서는 수정될 리소스의 유형에 따라 고유한 보안 고려사항을
   가질 수 있습니다. 서버는 악의적인 클라이언트가 PATCH 작업을
   통해 과도한 서버 리소스(예: CPU, 메모리, 디스크 I/O)를 소비하지
   않도록 적절한 예방 조치를 취해야 합니다(MUST).

6. 참조

6.1. 규범적 참조

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC3864]  Klyne, G., Nottingham, M., and J. Mogul, "Registration
              Procedures for Message Header Fields", BCP 90, RFC 3864,
              September 2004.

6.2. 정보적 참조

   [RFC4918]  Dusseault, L., "HTTP Extensions for Web Distributed
              Authoring and Versioning (WebDAV)", RFC 4918, June 2007.

부록 A. 감사의 말

   PATCH는 Roy Fielding과 Henrik Frystyk이 작성한 HTTP/1.1 초안의
   이전 버전에 포함되었습니다; 이를 인용한 문서는 RFC 2068입니다.

   이 문서에 대해 검토하고 제안해 주신 분들께 감사드립니다: Adam Roach,
   Chris Sharp, Julian Reschke, Geoff Clemm, Scott Lawrence, Jeffrey
   Mogul, Roy Fielding, Greg Stein, Jim Luther, Alex Rousskov, Jamie
   Lokier, Joe Hildebrand, Mark Nottingham, Michael Balloni, Cyrus
   Daboo, Brian Carpenter, John Klensin, Eliot Lear, SM, 그리고 Bernie
   Hoeneisen.

   특히, Julian Reschke는 반복적인 검토, 논의, 그리고 출판에 대한
   조언으로 크게 기여했습니다.

저자 주소

   Lisa Dusseault
   Linden Lab

   EMail: lisa.dusseault@gmail.com


   James M. Snell

   EMail: jasnell@gmail.com
   URI:   http://www.snellspace.com
