Internet Engineering Task Force (IETF)                          A. Barth
Request for Comments: 6454                                  Google, Inc.
Category: Standards Track                                  December 2011
ISSN: 2070-1721


                         웹 출처(Origin) 개념

초록

   이 문서는 사용자 에이전트가 권한 또는 특권의 범위로 자주 사용하는
   "출처(origin)"의 개념을 정의한다. 일반적으로 사용자 에이전트는
   악의적인 웹 사이트 운영자가 정상적인 웹 사이트의 작동을 방해하는 것을
   방지하기 위해 서로 다른 출처에서 가져온 콘텐츠를 격리한다. 출처 개념의
   기반이 되는 원칙을 설명하는 것 외에도, 이 문서는 URI의 출처를 결정하는
   방법과 출처를 문자열로 직렬화하는 방법을 상세히 기술한다. 또한 HTTP
   요청과 연관된 출처를 나타내는 "Origin"이라는 이름의 HTTP 헤더 필드를
   정의한다.

이 메모의 상태

   이것은 인터넷 표준 트랙 문서이다.

   이 문서는 Internet Engineering Task Force (IETF)의 산출물이다. 이것은
   IETF 커뮤니티의 합의를 나타낸다. 공개 검토를 받았으며 Internet
   Engineering Steering Group (IESG)의 출판 승인을 받았다. 인터넷 표준에
   대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있다.

   이 문서의 현재 상태, 정오표, 그리고 이에 대한 피드백을 제공하는 방법에
   대한 정보는 http://www.rfc-editor.org/info/rfc6454 에서 얻을 수 있다.

저작권 고지

   Copyright (c) 2011 IETF Trust 및 문서 저자로 식별된 사람들.
   모든 권리 보유.

   이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF Trust의 IETF
   문서에 관한 법적 조항(http://trustee.ietf.org/license-info)의 적용을
   받는다. 이 문서에 관한 귀하의 권리와 제한 사항을 설명하고 있으므로
   이러한 문서를 주의 깊게 검토하기 바란다. 이 문서에서 추출된 코드
   구성 요소는 Trust 법적 조항의 섹션 4.e에 설명된 대로 Simplified BSD
   License 텍스트를 포함해야 하며, Simplified BSD License에 설명된 대로
   보증 없이 제공된다.


목차

   1.  소개 . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  규약 . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
     2.1.  적합성 기준 . . . . . . . . . . . . . . . . . . . . . . .  3
     2.2.  구문 표기법 . . . . . . . . . . . . . . . . . . . . . . .  4
     2.3.  용어 . . . . . . . . . . . . . . . . . . . . . . . . . .  4
   3.  동일 출처 정책의 원칙 . . . . . . . . . . . . . . . . . . . .  4
     3.1.  신뢰 . . . . . . . . . . . . . . . . . . . . . . . . . .  5
       3.1.1.  함정 . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.2.  출처 . . . . . . . . . . . . . . . . . . . . . . . . . .  6
       3.2.1.  예제 . . . . . . . . . . . . . . . . . . . . . . . .  7
     3.3.  권한 . . . . . . . . . . . . . . . . . . . . . . . . . .  7
       3.3.1.  함정 . . . . . . . . . . . . . . . . . . . . . . . .  8
     3.4.  정책 . . . . . . . . . . . . . . . . . . . . . . . . . .  8
       3.4.1.  객체 접근 . . . . . . . . . . . . . . . . . . . . . .  8
       3.4.2.  네트워크 접근 . . . . . . . . . . . . . . . . . . . .  9
       3.4.3.  함정 . . . . . . . . . . . . . . . . . . . . . . . .  9
     3.5.  결론 . . . . . . . . . . . . . . . . . . . . . . . . . . 10
   4.  URI의 출처 . . . . . . . . . . . . . . . . . . . . . . . . . 10
   5.  출처 비교 . . . . . . . . . . . . . . . . . . . . . . . . .  11
   6.  출처 직렬화 . . . . . . . . . . . . . . . . . . . . . . . .  11
     6.1.  출처의 유니코드 직렬화 . . . . . . . . . . . . . . . . .  12
     6.2.  출처의 ASCII 직렬화 . . . . . . . . . . . . . . . . . .  12
   7.  HTTP Origin 헤더 필드 . . . . . . . . . . . . . . . . . . .  13
     7.1.  구문 . . . . . . . . . . . . . . . . . . . . . . . . . .  13
     7.2.  의미 . . . . . . . . . . . . . . . . . . . . . . . . . .  13
     7.3.  사용자 에이전트 요구사항 . . . . . . . . . . . . . . . .  14
   8.  보안 고려사항 . . . . . . . . . . . . . . . . . . . . . . .  14
     8.1.  DNS에 대한 의존 . . . . . . . . . . . . . . . . . . . .  15
     8.2.  상이한 격리 단위 . . . . . . . . . . . . . . . . . . . .  15
     8.3.  환경 권한 . . . . . . . . . . . . . . . . . . . . . . .  16
     8.4.  IDNA 의존성 및 마이그레이션 . . . . . . . . . . . . . .  16
   9.  IANA 고려사항 . . . . . . . . . . . . . . . . . . . . . . .  17
   10. 참고문헌 . . . . . . . . . . . . . . . . . . . . . . . . . . 17
     10.1. 규범적 참고문헌 . . . . . . . . . . . . . . . . . . . .  17
     10.2. 참고적 참고문헌 . . . . . . . . . . . . . . . . . . . .  18
   부록 A.  감사의 글 . . . . . . . . . . . . . . . . . . . . . . . 20


1.  소개

   사용자 에이전트는 다수의 저자가 만든 콘텐츠와 상호작용한다. 이러한
   저자 중 많은 수가 선의를 가지고 있지만, 일부 저자는 악의적일 수 있다.
   사용자 에이전트가 처리하는 콘텐츠를 기반으로 작업을 수행하는 한,
   사용자 에이전트 구현자는 악의적인 저자가 다른 콘텐츠나 서버의 기밀성
   또는 무결성을 훼손하는 능력을 제한하고자 할 수 있다.

   예를 들어, 다양한 서버에서 가져온 HTML 콘텐츠를 렌더링하는 HTTP 사용자
   에이전트를 생각해 보자. 사용자 에이전트가 해당 문서에 포함된 스크립트를
   실행하는 경우, 사용자 에이전트 구현자는 악의적인 서버에서 가져온
   스크립트가 정직한 서버에 저장된 문서를 읽는 것을 방지하고자 할 수
   있다. 해당 정직한 서버는 예를 들어 방화벽 뒤에 있을 수 있다.

   전통적으로 사용자 에이전트는 콘텐츠를 "출처"에 따라 분류해 왔다. 더
   구체적으로, 사용자 에이전트는 하나의 출처에서 가져온 콘텐츠가 같은
   출처에서 가져온 다른 콘텐츠와 자유롭게 상호작용하는 것을 허용하지만,
   해당 콘텐츠가 다른 출처의 콘텐츠와 상호작용하는 방식은 제한한다.

   이 문서는 소위 동일 출처 정책의 배경이 되는 원칙과 출처의 비교 및
   직렬화의 "핵심 메커니즘"을 설명한다. 이 문서는 동일 출처 정책의 모든
   측면을 기술하지는 않으며, 세부 사항은 HTML [HTML] 및 WebSocket
   [RFC6455]과 같은 다른 명세에 맡긴다. 이는 세부 사항이 종종
   애플리케이션에 특화되어 있기 때문이다.

2.  규약

2.1.  적합성 기준

   이 문서에서 핵심어 "MUST", "MUST NOT", "REQUIRED", "SHALL",
   "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
   "OPTIONAL"은 [RFC2119]에 기술된 대로 해석되어야 한다.

   알고리즘의 일부로서 명령형으로 표현된 요구사항(예: "선행 공백 문자를
   제거하라" 또는 "false를 반환하고 이 단계를 중단하라")은 해당 알고리즘을
   소개할 때 사용된 핵심어("MUST", "SHOULD", "MAY" 등)의 의미로
   해석되어야 한다.

   알고리즘이나 특정 단계로 표현된 적합성 요구사항은 최종 결과가 동등한
   한 어떤 방식으로든 구현될 수 있다. 특히, 이 명세에서 정의된 알고리즘은
   이해하기 쉽도록 의도된 것이며 성능을 위해 의도된 것이 아니다.

2.2.  구문 표기법

   이 명세는 [RFC5234]의 Augmented Backus-Naur Form (ABNF) 표기법을
   사용한다.

   다음의 핵심 규칙은 [RFC5234] 부록 B.1에 정의된 대로 참조에 의해
   포함된다: ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어
   문자), DIGIT (십진수 0-9), DQUOTE (큰따옴표), HEXDIG (16진수
   0-9/A-F/a-f), LF (줄 바꿈), OCTET (임의의 8비트 데이터 시퀀스), SP
   (공백), HTAB (수평 탭), CHAR (임의의 US-ASCII 문자), VCHAR (임의의
   가시적 US-ASCII 문자), WSP (공백 문자).

   OWS 규칙은 0개 이상의 선형 공백 옥텟이 나타날 수 있는 곳에서
   사용된다. OWS는 생성되지 않거나 단일 SP로 생성되어야 한다(SHOULD).
   필드 내용 내에 나타나는 여러 OWS 옥텟은 필드 값을 해석하거나 메시지를
   다운스트림으로 전달하기 전에 단일 SP로 대체되거나 모든 SP 옥텟으로
   변환되어야 한다(SHOULD) (SP가 아닌 각 옥텟을 SP로 대체).

   OWS            = *( SP / HTAB / obs-fold )
                  ; "선택적" 공백
   obs-fold       = CRLF ( SP / HTAB )
                  ; 사용되지 않는 줄 접기

2.3.  용어

   "사용자 에이전트", "클라이언트", "서버", "프록시", "출처 서버"라는
   용어는 HTTP/1.1 명세([RFC2616], 섹션 1.3)에서와 동일한 의미를 갖는다.

   전역적으로 고유한 식별자는 이전에 존재하는 모든 다른 값과 다른 값이다.
   예를 들어, 충분히 긴 임의 문자열은 전역적으로 고유한 식별자가 될
   가능성이 높다. 출처 값이 사용자 에이전트를 벗어나지 않는 경우, 사용자
   에이전트에 로컬인 단조 증가 카운터도 전역적으로 고유한 식별자로 사용될
   수 있다.

3.  동일 출처 정책의 원칙

   많은 사용자 에이전트가 원격 당사자를 대신하여 작업을 수행한다. 예를
   들어, HTTP 사용자 에이전트는 원격 서버의 지시인 리다이렉트를 따르며,
   HTML 사용자 에이전트는 원격 서버에서 가져온 스크립트에 풍부한 Document
   Object Model (DOM) 인터페이스를 노출한다.

   보안 모델이 없다면, 사용자 에이전트는 사용자나 다른 당사자에게 해로운
   작업을 수행할 수 있다. 시간이 지남에 따라 많은 웹 관련 기술이 통칭
   "동일 출처 정책"이라고 알려진 공통 보안 모델로 수렴되었다. 이 보안
   모델은 대부분 유기적으로 발전했지만, 동일 출처 정책은 몇 가지 핵심
   개념으로 이해될 수 있다. 이 섹션에서는 이러한 개념을 제시하고 이러한
   개념을 안전하게 사용하는 방법에 대한 조언을 제공한다.

3.1.  신뢰

   동일 출처 정책은 URI로 신뢰를 지정한다. 예를 들어, HTML 문서는
   실행할 스크립트를 URI로 지정한다:

   <script src="https://example.com/library.js"></script>

   사용자 에이전트가 이 요소를 처리할 때, 사용자 에이전트는 지정된 URI의
   스크립트를 가져와서 해당 문서의 권한으로 스크립트를 실행한다. 이런
   방식으로 문서는 자신이 가진 모든 권한을 URI로 지정된 리소스에 부여한다.
   본질적으로, 문서는 해당 URI에서 가져온 정보의 무결성을 신뢰한다고
   선언하는 것이다.

   URI에서 라이브러리를 가져오는 것 외에도, 사용자 에이전트는 URI로
   지정된 원격 당사자에게 정보를 보내기도 한다. 예를 들어, HTML form
   요소를 생각해 보자:

   <form method="POST" action="https://example.com/login">
    ... <input type="password"> ...
   </form>

   사용자가 비밀번호를 입력하고 양식을 제출하면, 사용자 에이전트는 URI로
   지정된 네트워크 엔드포인트로 비밀번호를 보낸다. 이런 방식으로 문서는
   자신의 비밀 데이터를 해당 URI로 내보내며, 본질적으로 해당 URI로 보낸
   정보의 기밀성을 신뢰한다고 선언하는 것이다.

3.1.1.  함정

   동일 출처 정책을 사용하는 새로운 프로토콜을 설계할 때, 중요한 신뢰
   구분이 URI에 보이도록 해야 한다. 예를 들어, Transport Layer Security
   (TLS)로 보호되는 리소스와 TLS로 보호되지 않는 리소스가 모두 "http"
   URI 스킴을 사용하는 경우([RFC2817]에서처럼), 문서는 TLS를 통해서만
   스크립트를 가져오고 싶다고 지정할 수 없게 된다. "https" URI 스킴을
   사용함으로써, 문서는 능동적 네트워크 공격자로부터 보호되는 리소스와
   상호작용하기를 원한다고 나타낼 수 있다.

3.2.  출처

   원칙적으로, 사용자 에이전트는 모든 URI를 별도의 보호 도메인으로
   취급하고, 하나의 URI에서 가져온 콘텐츠가 다른 URI와 상호작용하려면
   명시적 동의를 요구할 수 있다. 불행히도, 이 설계는 웹 애플리케이션이
   종종 협력하여 작동하는 여러 리소스로 구성되기 때문에 개발자에게
   번거롭다.

   대신, 사용자 에이전트는 URI를 "출처"라고 불리는 보호 도메인으로
   그룹화한다. 대략적으로 말하면, 두 URI가 동일한 스킴, 호스트, 포트를
   가지고 있으면 동일한 출처에 속한다(즉, 동일한 주체를 나타낸다).
   (전체 세부 사항은 섹션 4를 참조하라.)

   질문: 왜 호스트만 사용하지 않는가?

   답변: 출처 튜플에 스킴을 포함하는 것은 보안에 필수적이다. 사용자
   에이전트가 스킴을 포함하지 않으면, http://example.com 과
   https://example.com 사이에 격리가 없게 된다. 둘이 동일한 호스트를
   가지고 있기 때문이다. 그러나 이러한 격리가 없으면, 능동적 네트워크
   공격자가 http://example.com 에서 가져온 콘텐츠를 변조하고, 해당
   콘텐츠가 사용자 에이전트에게 https://example.com 에서 가져온 콘텐츠의
   기밀성과 무결성을 침해하도록 지시하게 하여, TLS [RFC5246]가 제공하는
   보호를 우회할 수 있다.

   질문: 왜 "최상위" 도메인 대신 정규화된 호스트 이름을 사용하는가?

   답변: DNS가 계층적 위임을 가지고 있지만, 호스트 이름 간의 신뢰 관계는
   배포에 따라 다르다. 예를 들어, 많은 교육 기관에서 학생들은
   https://example.edu/~student/ 에 콘텐츠를 호스팅할 수 있지만, 이것이
   학생이 작성한 문서가 https://grades.example.edu/ 에 호스팅된 성적 관리
   웹 애플리케이션과 동일한 출처(즉, 동일한 보호 도메인에 존재)여야 한다는
   것을 의미하지는 않는다.

   example.edu 배포는 리소스를 출처별로 그룹화하는 것이 항상 모든 배포
   시나리오와 완벽하게 일치하지는 않는다는 것을 보여준다. 이 배포에서는
   모든 학생의 웹 사이트가 동일한 출처에 속하게 되며, 이는 바람직하지
   않을 수 있다. 어떤 의미에서, 출처 세분화는 보안 모델이 발전한 역사적
   산물이다.

3.2.1.  예제

   다음의 모든 리소스는 동일한 출처를 갖는다:

   http://example.com/
   http://example.com:80/
   http://example.com/path/file

   이 리소스들 각각은 동일한 스킴, 호스트, 포트 구성 요소를 가진다.

   다음의 각 리소스는 서로 다른 출처를 갖는다.

   http://example.com/
   http://example.com:8080/
   http://www.example.com/
   https://example.com:80/
   https://example.com/
   http://example.org/
   http://ietf.org/

   각 경우에, 스킴, 호스트, 포트 구성 요소 중 적어도 하나가 목록의
   나머지와 다르다.

3.3.  권한

   사용자 에이전트가 URI를 출처로 그룹화하지만, 출처 내의 모든 리소스가
   동일한 권한을 가지는 것은 아니다(보안의 의미에서의 "권한"이며,
   [RFC3986]의 의미에서가 아니다). 예를 들어, 이미지는 수동적 콘텐츠이므로
   권한을 가지지 않는다. 이는 이미지가 자신의 출처에서 사용할 수 있는
   객체와 리소스에 대한 접근 권한이 없다는 것을 의미한다. 반면에 HTML
   문서는 자신의 출처의 전체 권한을 가지며, 문서 내의(또는 문서로
   가져온) 스크립트는 출처의 모든 리소스에 접근할 수 있다.

   사용자 에이전트는 리소스의 미디어 타입을 검사하여 리소스에 얼마나 많은
   권한을 부여할지 결정한다. 예를 들어, 미디어 타입이 image/png인
   리소스는 이미지로 취급되고, 미디어 타입이 text/html인 리소스는 HTML
   문서로 취급된다.

   신뢰할 수 없는 콘텐츠(예: 사용자 생성 콘텐츠)를 호스팅할 때, 웹
   애플리케이션은 해당 콘텐츠의 미디어 타입을 제한하여 권한을 제한할 수
   있다. 예를 들어, 사용자 생성 콘텐츠를 image/png로 제공하는 것은
   사용자 생성 콘텐츠를 text/html로 제공하는 것보다 덜 위험하다. 물론
   많은 웹 애플리케이션이 신뢰할 수 없는 콘텐츠를 HTML 문서에
   통합한다. 주의 깊게 수행되지 않으면, 이러한 애플리케이션은 출처의
   권한을 신뢰할 수 없는 콘텐츠에 누출할 위험이 있으며, 이는 흔히
   크로스 사이트 스크립팅으로 알려진 취약점이다.

3.3.1.  함정

   웹 플랫폼의 새로운 요소를 설계할 때, 미디어 타입에 관계없이 리소스에
   권한을 부여하지 않도록 주의해야 한다. 많은 웹 애플리케이션이 제한된
   미디어 타입으로 신뢰할 수 없는 콘텐츠를 제공한다. 이러한 콘텐츠
   조각에 권한을 부여하는 새로운 웹 플랫폼 기능은 기존 애플리케이션에
   취약점을 도입할 위험이 있다. 대신, 이미 출처의 전체 권한을 소유하고
   있는 미디어 타입이나 새로운 권한을 전달하도록 특별히 설계된 새로운
   미디어 타입에 권한을 부여하는 것이 바람직하다.

   잘못된 미디어 타입을 제공하는 서버와의 호환성을 유지하기 위해, 일부
   사용자 에이전트는 "콘텐츠 스니핑"을 사용하여 콘텐츠를 서버가 제공한
   미디어 타입과 다른 미디어 타입인 것처럼 취급한다. 주의 깊게 수행되지
   않으면, 콘텐츠 스니핑은 사용자 에이전트가 이미지와 같은 낮은 권한의
   미디어 타입에 HTML 문서와 같은 높은 권한의 미디어 타입의 특권을 부여할
   수 있기 때문에 보안 취약점으로 이어질 수 있다 [SNIFF].

3.4.  정책

   일반적으로 사용자 에이전트는 서로 다른 출처를 격리하고 출처 간에
   통제된 통신을 허용한다. 사용자 에이전트가 격리와 통신을 제공하는 방법의
   세부 사항은 여러 요인에 따라 다르다.

3.4.1.  객체 접근

   사용자 에이전트가 노출하는 대부분의 객체(애플리케이션 프로그래밍
   인터페이스 또는 API라고도 함)는 동일한 출처에서만 사용할 수 있다.
   구체적으로, 하나의 URI에서 가져온 콘텐츠는 다른 URI에서 가져온
   콘텐츠와 연관된 객체에 접근할 수 있으며, 이는 두 URI가 동일한
   출처(예: 동일한 스킴, 호스트, 포트)에 속하는 경우에만 해당된다.

   이 일반 규칙에는 몇 가지 예외가 있다. 예를 들어, HTML의 Location
   인터페이스의 일부 부분은 출처 간에 사용할 수 있다(예: 다른 브라우징
   컨텍스트의 탐색을 허용하기 위해). 다른 예로, HTML의 postMessage
   인터페이스는 크로스 출처 통신을 촉진하기 위해 명시적으로 출처 간에
   보인다. 외부 출처에 객체를 노출하는 것은 위험하며, 이러한 객체를
   잠재적 공격자에게 노출하므로 매우 주의 깊게 수행되어야 한다.

3.4.2.  네트워크 접근

   네트워크 리소스에 대한 접근은 해당 리소스가 접근을 시도하는 콘텐츠와
   동일한 출처에 있는지 여부에 따라 달라진다.

   일반적으로, 다른 출처에서 정보를 읽는 것은 금지된다. 그러나 출처는
   다른 출처에서 가져온 일부 종류의 리소스를 사용하는 것이 허용된다. 예를
   들어, 출처는 모든 출처의 스크립트를 실행하고, 이미지를 렌더링하고,
   스타일 시트를 적용하는 것이 허용된다. 마찬가지로, 출처는 HTML 프레임
   내의 HTML 문서와 같은 다른 출처의 콘텐츠를 표시할 수 있다. 네트워크
   리소스는 또한 다른 출처가 자신의 정보를 읽도록 선택할 수 있는데,
   예를 들어 Cross-Origin Resource Sharing [CORS]을 사용한다. 이러한
   경우, 접근은 일반적으로 출처별로 부여된다.

   다른 출처로 정보를 보내는 것은 허용된다. 그러나 임의의 형식으로
   네트워크를 통해 정보를 보내는 것은 위험하다. 이러한 이유로, 사용자
   에이전트는 문서가 사용자 정의 헤더 없는 HTTP 요청과 같은 특정
   프로토콜을 사용하여 정보를 보내도록 제한한다. 허용된 프로토콜 집합을
   확장하는 것, 예를 들어 WebSocket 지원을 추가하는 것은 취약점 도입을
   피하기 위해 신중하게 수행되어야 한다 [RFC6455].

3.4.3.  함정

   사용자 에이전트가 하나의 출처가 다른 출처의 리소스와 상호작용하는 것을
   허용할 때마다, 보안 문제를 초래한다. 예를 들어, 다른 출처의 이미지를
   표시하는 기능은 이미지의 높이와 너비를 누출한다. 마찬가지로, 다른
   출처로 네트워크 요청을 보내는 기능은 크로스 사이트 요청 위조 취약점을
   발생시킨다 [CSRF]. 그러나 사용자 에이전트 구현자는 종종 이러한 위험과
   크로스 출처 상호작용을 허용하는 이점 사이에서 균형을 맞춘다. 예를 들어,
   크로스 출처 네트워크 요청을 차단하는 HTML 사용자 에이전트는 사용자가
   웹의 핵심 기능인 하이퍼링크를 따라가는 것을 방해하게 될 것이다.

   웹 플랫폼에 새로운 기능을 추가할 때, 하나의 리소스에 특권을 부여하되
   동일한 출처의 다른 리소스에는 해당 특권을 보류하고 싶을 수 있다.
   그러나 이런 방식으로 특권을 보류하는 것은 효과적이지 않다. 특권이
   없는 리소스가 일반적으로 어쨌든 특권을 얻을 수 있기 때문이다. 사용자
   에이전트가 출처 내의 리소스를 격리하지 않기 때문이다. 대신, 특권은
   (출처 내의 개별 리소스를 차별하기보다는) 출처 전체에 부여하거나
   보류해야 한다 [BOFGO].

3.5.  결론

   동일 출처 정책은 URI를 사용하여 신뢰 관계를 지정한다. URI는 보호
   도메인을 나타내는 출처로 그룹화된다. 출처의 일부 리소스(예: 능동적
   콘텐츠)에는 출처의 전체 권한이 부여되는 반면, 출처의 다른 리소스(예:
   수동적 콘텐츠)에는 출처의 권한이 부여되지 않는다. 출처의 권한을
   전달하는 콘텐츠는 자신의 출처 내의 객체와 네트워크 리소스에 대한
   접근이 부여된다. 이 콘텐츠에는 또한 다른 출처의 객체와 네트워크
   리소스에 대한 제한된 접근이 부여되지만, 이러한 크로스 출처 특권은
   보안 취약점을 피하기 위해 신중하게 설계되어야 한다.

4.  URI의 출처

   URI의 출처는 다음 알고리즘에 의해 계산된 값이다:

   1.  URI가 이름 지정 권한으로 계층적 요소를 사용하지 않거나
       ([RFC3986], 섹션 3.2 참조) URI가 절대 URI가 아닌 경우, 새로운
       전역적으로 고유한 식별자를 생성하고 해당 값을 반환한다.

          참고: 동일한 URI에 대해 이 알고리즘을 여러 번 실행하면 매번
          다른 값을 생성할 수 있다. 일반적으로 사용자 에이전트는 예를
          들어 HTML 문서의 출처를 한 번 계산하고, 각 보안 검사마다 출처를
          재계산하는 대신 이후 보안 검사에 해당 출처를 사용한다.

   2.  uri-scheme을 URI의 스킴 구성 요소로 하되, 소문자로 변환한다.

   3.  구현이 uri-scheme으로 주어진 프로토콜을 지원하지 않는 경우, 새로운
       전역적으로 고유한 식별자를 생성하고 해당 값을 반환한다.

   4.  uri-scheme이 "file"인 경우, 구현은 구현 정의 값을 반환할 수
       있다(MAY).

          참고: 역사적으로 사용자 에이전트는 file 스킴의 콘텐츠에 엄청난
          양의 특권을 부여해 왔다. 그러나 모든 로컬 파일에 이러한 넓은
          특권을 부여하면 권한 상승 공격으로 이어질 수 있다. 일부 사용자
          에이전트는 로컬 파일에 디렉터리 기반 특권을 부여하는 데
          성공했지만, 이 접근 방식은 널리 채택되지 않았다. 다른 사용자
          에이전트는 각 file URI에 전역적으로 고유한 식별자를 사용하며,
          이것이 가장 안전한 옵션이다.

   5.  uri-host를 URI의 호스트 구성 요소로 하되, 소문자로 변환한다
       ([RFC4790]에 정의된 i;ascii-casemap 대조를 사용).

          참고: 이 문서는 사용자 에이전트가 URI를 구성할 때
          Internationalizing Domain Names in Applications (IDNA) 처리 및
          검증을 수행한다고 가정한다. 특히, 이 문서는 사용자 에이전트가
          이미 비ASCII 레이블을 해당하는 A-레이블로 변환했기 때문에
          uri-host가 LDH 레이블만 포함할 것이라고 가정한다([RFC5890]
          참조). 이러한 이유로, 출처 기반 보안 정책은 사용자 에이전트가
          사용하는 IDNA 알고리즘에 민감하다. 추가 논의는 섹션 8.4를
          참조하라.

   6.  URI의 포트 구성 요소가 없는 경우:

       1.  uri-port를 uri-scheme으로 주어진 프로토콜의 기본 포트로 한다.

       그렇지 않으면:

       2.  uri-port를 URI의 포트 구성 요소로 한다.

   7.  트리플 (uri-scheme, uri-host, uri-port)을 반환한다.

5.  출처 비교

   두 출처는 동일한 경우에만 "같다". 특히:

   o  두 출처가 스킴/호스트/포트 트리플인 경우, 두 출처는 동일한 스킴,
      호스트, 포트를 가지고 있는 경우에만 같다.

   o  전역적으로 고유한 식별자인 출처는 스킴/호스트/포트 트리플인 출처와
      같을 수 없다.

   두 URI는 출처가 같으면 동일 출처이다.

      참고: URI가 반드시 자기 자신과 동일 출처인 것은 아니다. 예를 들어,
      data URI [RFC2397]는 data URI가 서버 기반 이름 지정 권한을 사용하지
      않아 전역적으로 고유한 식별자를 출처로 가지기 때문에 자기 자신과
      동일 출처가 아니다.

6.  출처 직렬화

   이 섹션은 출처를 유니코드 [Unicode6] 문자열과 ASCII [RFC20] 문자열로
   직렬화하는 방법을 정의한다.

6.1.  출처의 유니코드 직렬화

   출처의 유니코드 직렬화는 다음 알고리즘에 의해 반환되는 값이다:

   1.  출처가 스킴/호스트/포트 트리플이 아닌 경우, 문자열

          null

       (즉, 코드 포인트 시퀀스 U+006E, U+0075, U+006C, U+006C)을
       반환하고 이 단계를 중단한다.

   2.  그렇지 않으면, result를 출처 트리플의 스킴 부분으로 한다.

   3.  문자열 "://"를 result에 추가한다.

   4.  출처 트리플의 호스트 부분의 각 구성 요소를 (다음과 같이 변환하여)
       U+002E FULL STOP 코드 포인트(".")로 구분하여 result에 추가한다:

       1.  구성 요소가 A-레이블인 경우, 대신 해당하는 U-레이블을 사용한다
           ([RFC5890] 및 [RFC5891] 참조).

       2.  그렇지 않으면, 구성 요소를 그대로 사용한다.

   5.  출처 트리플의 포트 부분이 출처 트리플의 스킴 부분으로 주어진
       프로토콜의 기본 포트와 다른 경우:

       1.  U+003A COLON 코드 포인트(":")와 주어진 포트를 10진수로
           result에 추가한다.

   6.  result를 반환한다.

6.2.  출처의 ASCII 직렬화

   출처의 ASCII 직렬화는 다음 알고리즘에 의해 반환되는 값이다:

   1.  출처가 스킴/호스트/포트 트리플이 아닌 경우, 문자열

          null

       (즉, 코드 포인트 시퀀스 U+006E, U+0075, U+006C, U+006C)을
       반환하고 이 단계를 중단한다.

   2.  그렇지 않으면, result를 출처 트리플의 스킴 부분으로 한다.

   3.  문자열 "://"를 result에 추가한다.

   4.  출처 트리플의 호스트 부분을 result에 추가한다.

   5.  출처 트리플의 포트 부분이 출처 트리플의 스킴 부분으로 주어진
       프로토콜의 기본 포트와 다른 경우:

       1.  U+003A COLON 코드 포인트(":")와 주어진 포트를 10진수로
           result에 추가한다.

   6.  result를 반환한다.

7.  HTTP Origin 헤더 필드

   이 섹션은 HTTP Origin 헤더 필드를 정의한다.

7.1.  구문

   Origin 헤더 필드는 다음 구문을 갖는다:

   origin              = "Origin:" OWS origin-list-or-null OWS
   origin-list-or-null = %x6E %x75 %x6C %x6C / origin-list
   origin-list         = serialized-origin *( SP serialized-origin )
   serialized-origin   = scheme "://" host [ ":" port ]
                       ; <scheme>, <host>, <port> from RFC 3986

7.2.  의미

   HTTP 요청에 포함될 때, Origin 헤더 필드는 사용자 에이전트가 요청을
   발행하게 "원인이 된" 출처를 나타내며, 사용자 에이전트가 요청을
   발행하도록 트리거한 API에 의해 정의된다.

   예를 들어, 출처를 대신하여 스크립트를 실행하는 사용자 에이전트를
   생각해 보자. 해당 스크립트 중 하나가 사용자 에이전트에게 HTTP 요청을
   발행하게 하는 경우, 사용자 에이전트는 Origin 헤더 필드를 사용하여
   스크립트가 사용자 에이전트에게 요청을 발행하게 했을 때 실행되고 있던
   보안 컨텍스트를 서버에 알릴 수 있다(MAY).

   경우에 따라, 여러 출처가 사용자 에이전트에게 HTTP 요청을 발행하게
   하는 데 기여한다. 이러한 경우, 사용자 에이전트는 Origin 헤더 필드에
   모든 출처를 나열할 수 있다(MAY). 예를 들어, HTTP 요청이 처음에 하나의
   출처에 의해 발행되었지만 이후 다른 출처에 의해 리다이렉트된 경우,
   사용자 에이전트는 두 출처가 사용자 에이전트에게 요청을 발행하게 하는
   데 관여했음을 서버에 알릴 수 있다(MAY).

7.3.  사용자 에이전트 요구사항

   사용자 에이전트는 모든 HTTP 요청에 Origin 헤더 필드를 포함할 수
   있다(MAY).

   사용자 에이전트는 어떤 HTTP 요청에도 하나 이상의 Origin 헤더 필드를
   포함해서는 안 된다(MUST NOT).

   사용자 에이전트가 "개인정보에 민감한" 컨텍스트에서 HTTP 요청을
   발행할 때마다, 사용자 에이전트는 Origin 헤더 필드에 "null" 값을
   보내야 한다(MUST).

      참고: 이 문서는 개인정보에 민감한 컨텍스트의 개념을 정의하지
      않는다. HTTP 요청을 생성하는 애플리케이션은 사용자 에이전트가
      Origin 헤더 필드를 생성하는 방식에 제한을 부과하기 위해 컨텍스트를
      개인정보에 민감한 것으로 지정할 수 있다.

   Origin 헤더 필드를 생성할 때, 사용자 에이전트는 다음 요구사항을
   충족해야 한다(MUST):

   o  문법에서 serialized-origin 생성의 각각은 출처의 ASCII 직렬화여야
      한다(MUST).

   o  문법에서 연속된 두 개의 serialized-origin 생성이 동일할 수 없다.
      특히, 사용자 에이전트가 연속된 두 개의 serialized-origin을
      생성하려는 경우, 사용자 에이전트는 두 번째 것을 생성해서는 안
      된다(MUST NOT).

8.  보안 고려사항

   동일 출처 정책은 웹 브라우저를 포함한 많은 사용자 에이전트의 보안
   초석 중 하나이다. 역사적으로, 일부 사용자 에이전트는 오염 추적 및
   유출 방지를 포함한 다른 보안 모델을 시도했지만, 이러한 모델은 당시에
   구현하기 어려운 것으로 판명되었다(최근 이러한 아이디어 중 일부를
   되살리려는 관심이 있긴 하지만).

   동일 출처 정책의 보안을 평가하는 것은 어렵다. 출처 개념 자체가 보안
   환경에서 매우 중심적인 역할을 하기 때문이다. 명목상 출처 자체는 격리
   단위에 불과하며, 대부분의 하나의 크기에 모든 것을 맞추려는 개념이
   그렇듯 불완전하다. 그렇긴 하지만, 아래에서 논의하는 몇 가지 체계적
   약점이 있다.

8.1.  DNS에 대한 의존

   실제로, 동일 출처 정책은 보안을 위해 Domain Name System (DNS)에
   의존한다. http와 같이 일반적으로 사용되는 많은 URI 스킴이 DNS 기반
   이름 지정 권한을 사용하기 때문이다. DNS가 부분적으로 또는 완전히
   침해되면, 동일 출처 정책은 애플리케이션이 요구하는 보안 속성을
   제공하지 못할 수 있다.

   https와 같은 일부 URI 스킴은 사용자 에이전트가 인증서와 같은 다른
   메커니즘을 사용하여 이러한 URI에서 가져온 콘텐츠의 출처를 확인하기
   때문에 DNS 침해에 더 강하다. chrome-extension URI 스킴([CRX]의 섹션
   4.3 참조)과 같은 다른 URI 스킴은 공개 키 기반 이름 지정 권한을
   사용하며 DNS 침해에 대해 완전히 안전하다.

   웹 출처 개념은 서로 다른 URI 스킴에서 가져온 콘텐츠를 격리한다;
   이것은 DNS 침해의 영향을 억제하는 데 필수적이다.

8.2.  상이한 격리 단위

   시간이 지남에 따라, 여러 기술이 편리한 격리 단위로서 웹 출처 개념에
   수렴되었다. 그러나 쿠키 [RFC6265]와 같이 오늘날 사용 중인 많은
   기술은 현대의 웹 출처 개념보다 앞서 있다. 이러한 기술은 종종 다른
   격리 단위를 가지고 있어 취약점으로 이어진다.

   한 가지 대안은 정규화된 도메인 이름 대신 "레지스트리 제어" 도메인만을
   격리 단위로 사용하는 것이다(예: "www.example.com" 대신
   "example.com"). 이 관행은 여러 가지 이유로 문제가 있으며 권장되지
   않는다(NOT RECOMMENDED):

   1.  "레지스트리 제어" 도메인의 개념은 DNS 자체의 속성이 아니라 DNS를
       둘러싼 인간의 관행의 함수이다. 예를 들어, 일본의 많은 지자체가
       DNS 계층 구조에서 상당히 깊은 곳에서 공개 레지스트리를 운영한다.
       널리 사용되는 "공개 접미사 목록"이 있지만, 이러한 목록은 최신
       상태로 유지하기 어렵고 구현 간에 다르다.

   2.  이 관행은 DNS 기반 이름 지정 권한을 사용하지 않는 URI 스킴과
       호환되지 않는다. 예를 들어, 주어진 URI 스킴이 공개 키를 이름 지정
       권한으로 사용하는 경우, "레지스트리 제어" 공개 키의 개념은 다소
       일관성이 없다. 더 나쁘게는, nntp와 같은 일부 URI 스킴은 DNS와
       반대 방향으로 점으로 구분된 위임을 사용하고(예:
       alt.usenet.kooks), 다른 것들은 DNS를 사용하지만 일반적인 순서의
       역순으로 레이블을 제시한다(예: com.example.www).

   기껏해야, "레지스트리 제어" 도메인을 사용하는 것은 URI 스킴 및 구현에
   특화된 것이다. 최악의 경우, URI 스킴과 구현 간의 차이가 취약점으로
   이어질 수 있다.

8.3.  환경 권한

   동일 출처 정책을 사용할 때, 사용자 에이전트는 콘텐츠가 지정할 수 있는
   객체를 기반으로 하지 않고 URI를 기반으로 콘텐츠에 권한을 부여한다.
   지정과 권한의 이러한 분리는 환경 권한의 한 예이며 취약점으로 이어질
   수 있다.

   예를 들어, HTML 문서의 크로스 사이트 스크립팅을 생각해 보자. 공격자가
   HTML 문서에 스크립트 콘텐츠를 주입할 수 있다면, 해당 스크립트는 문서
   출처의 권한으로 실행되어, 스크립트가 사용자의 의료 기록과 같은 민감한
   정보에 접근할 수 있게 될 수 있다. 그러나 스크립트의 권한이 스크립트가
   지정할 수 있는 객체로 제한된다면, 공격자는 제3자가 호스팅하는 HTML
   문서에 스크립트를 주입해도 어떤 이점도 얻지 못할 것이다.

8.4.  IDNA 의존성 및 마이그레이션

   동일 출처 정책의 보안 속성은 사용자 에이전트가 사용하는 IDNA
   알고리즘의 세부 사항에 결정적으로 의존할 수 있다. 특히, 사용자
   에이전트는 IDNA2003 [RFC3490]을 사용하는지 IDNA2008 [RFC5890]을
   사용하는지에 따라 일부 국제 도메인 이름(예: U+00DF 문자를 포함하는
   것)을 다른 ASCII 표현으로 매핑할 수 있다.

   하나의 IDNA 알고리즘에서 다른 알고리즘으로 마이그레이션하면 여러
   보안 경계가 다시 그려질 수 있으며, 잠재적으로 새로운 보안 경계를
   세우거나, 더 나쁘게는 서로 불신하는 두 엔티티 사이의 보안 경계를
   허물 수 있다. 보안 경계를 변경하는 것은 위험하다. 서로 불신하는 두
   엔티티를 동일한 출처로 결합하면 한쪽이 다른 쪽을 공격할 수 있게 될
   수 있기 때문이다.

9.  IANA 고려사항

   영구 메시지 헤더 필드 레지스트리([RFC3864] 참조)가 다음 등록으로
   업데이트되었다:

   헤더 필드 이름: Origin

   적용 프로토콜: http

   상태: standard

   저자/변경 관리자: IETF

   명세 문서: 이 명세 (섹션 7)

10.  참고문헌

10.1.  규범적 참고문헌

   [RFC20]     Cerf, V., "ASCII format for network interchange", RFC 20,
               October 1969.

   [RFC2119]   Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2616]   Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
               Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
               Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC3864]   Klyne, G., Nottingham, M., and J. Mogul, "Registration
               Procedures for Message Header Fields", BCP 90, RFC 3864,
               September 2004.

   [RFC3986]   Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
               Resource Identifier (URI): Generic Syntax", STD 66,
               RFC 3986, January 2005.

   [RFC4790]   Newman, C., Duerst, M., and A. Gulbrandsen, "Internet
               Application Protocol Collation Registry", RFC 4790,
               March 2007.

   [RFC5234]   Crocker, D., Ed. and P. Overell, "Augmented BNF for
               Syntax Specifications: ABNF", STD 68, RFC 5234,
               January 2008.

   [RFC5890]   Klensin, J., "Internationalized Domain Names for
               Applications (IDNA): Definitions and Document Framework",
               RFC 5890, August 2010.

   [RFC5891]   Klensin, J., "Internationalized Domain Names in
               Applications (IDNA): Protocol", RFC 5891, August 2010.

   [Unicode6]  The Unicode Consortium, "The Unicode Standard, Version
               6.0.0", 2011,
               <http://www.unicode.org/versions/Unicode6.0.0/>.

10.2.  참고적 참고문헌

   [BOFGO]     Jackson, C. and A. Barth, "Beware of Finer-Grained
               Origins", 2008,
               <http://w2spconf.com/2008/papers/s2p1.pdf>.

   [CORS]      van Kesteren, A., "Cross-Origin Resource Sharing", W3C
               Working Draft WD-cors-20100727, July 2010,
               <http://www.w3.org/TR/2010/WD-cors-20100727/>.

               Latest version available at <http://www.w3.org/TR/cors/>.

   [CRX]       Barth, A., Felt, A., Saxena, P., and A. Boodman,
               "Protecting Browsers from Extension Vulnerabilities",
               2010, <http://www.isoc.org/isoc/conferences/ndss/10/pdf/
               04.pdf>.

   [CSRF]      Barth, A., Jackson, C., and J. Mitchell, "Robust Defenses
               for Cross-Site Request Forgery", 2008,
               <http://portal.acm.org/citation.cfm?id=1455770.1455782>.

   [HTML]      Hickson, I., "HTML5", W3C Working Draft WD-html5-
               20110525, May 2011,
               <http://www.w3.org/TR/2011/WD-html5-20110525/>.

               Latest version available at
               <http://www.w3.org/TR/html5/>.

   [RFC2397]   Masinter, L., "The "data" URL scheme", RFC 2397,
               August 1998.

   [RFC2817]   Khare, R. and S. Lawrence, "Upgrading to TLS Within
               HTTP/1.1", RFC 2817, May 2000.

   [RFC3490]   Faltstrom, P., Hoffman, P., and A. Costello,
               "Internationalizing Domain Names in Applications (IDNA)",
               RFC 3490, March 2003.

   [RFC5246]   Dierks, T. and E. Rescorla, "The Transport Layer Security
               (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC6265]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
               April 2011.

   [RFC6455]   Fette, I. and A. Melnikov, "The WebSocket Protocol",
               RFC 6455, December 2011.

   [SNIFF]     Barth, A. and I. Hickson, "Media Type Sniffing", Work
               in Progress, May 2011.


부록 A.  감사의 글

   이 문서에 대한 귀중한 피드백을 제공해 주신 Lucas Adamski, Stephen
   Farrell, Miguel A. Garcia, Tobias Gondrom, Ian Hickson, Anne van
   Kesteren, Jeff Hodges, Collin Jackson, Larry Masinter, Alexey
   Melnikov, Mark Nottingham, Julian Reschke, Peter Saint-Andre, Jonas
   Sicking, Sid Stamm, Daniel Veditz, Chris Weber에게 감사드린다.

저자 주소

   Adam Barth
   Google, Inc.

   EMail: ietf@adambarth.com
   URI:   http://www.adambarth.com/
