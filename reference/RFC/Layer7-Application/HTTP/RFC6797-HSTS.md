# RFC 6797 - HTTP Strict Transport Security (HSTS)

```
Internet Engineering Task Force (IETF)                         J. Hodges
Request for Comments: 6797                                        PayPal
Category: Standards Track                                     C. Jackson
ISSN: 2070-1721                               Carnegie Mellon University
                                                                A. Barth
                                                            Google, Inc.
                                                           November 2012
```

## 초록

이 규격은 웹사이트가 보안 연결을 통해서만 접근 가능함을 선언할 수 있게 하고/또는 사용자가 자신의 사용자 에이전트(들)가 주어진 사이트와 보안 연결을 통해서만 상호작용하도록 지시할 수 있게 하는 메커니즘을 정의한다. 이 전체 정책은 HTTP Strict Transport Security (HSTS)로 지칭된다. 정책은 Strict-Transport-Security HTTP 응답 헤더 필드를 통해 그리고/또는 예를 들어 사용자 에이전트 구성과 같은 다른 수단으로 웹사이트에 의해 선언된다.

## 이 메모의 상태

이것은 인터넷 표준 트랙 문서이다.

이 문서는 인터넷 엔지니어링 태스크 포스(IETF)의 산출물이다. 이것은 IETF 커뮤니티의 합의를 나타낸다. 이것은 공개 검토를 받았으며 인터넷 엔지니어링 운영 그룹(IESG)에 의해 발행 승인되었다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있다.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6797에서 얻을 수 있다.

## 저작권 고지

Copyright (c) 2012 IETF Trust 및 문서 저자로 식별된 사람들. 모든 권리 보유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF Trust의 법적 조항(http://trustee.ietf.org/license-info)의 적용을 받는다. 이 문서에 대한 귀하의 권리와 제한 사항을 설명하므로 이 문서들을 주의 깊게 검토하라. 이 문서에서 추출된 코드 구성요소는 Trust 법적 조항의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공된다.

## 목차

```
1. 소개 ....................................................4
   1.1. 이 규격의 구성 .........................................6
   1.2. 문서 규약 .............................................6
2. 개요 ......................................................6
   2.1. 사용 사례 .............................................6
   2.2. HTTP Strict Transport Security 정책 효과 ................6
   2.3. 위협 모델 .............................................6
        2.3.1. 대응되는 위협 ...................................7
               2.3.1.1. 수동적 네트워크 공격자 ..................7
               2.3.1.2. 능동적 네트워크 공격자 ..................7
               2.3.1.3. 웹사이트 개발 및 배포 버그 ..............8
        2.3.2. 대응되지 않는 위협 ...............................8
               2.3.2.1. 피싱 ..................................8
               2.3.2.2. 악성 소프트웨어 및 브라우저 취약점 .......8
   2.4. 요구사항 ..............................................9
        2.4.1. 전체 요구사항 ...................................9
               2.4.1.1. 상세 핵심 요구사항 ......................9
               2.4.1.2. 상세 부수적 요구사항 ...................10
3. 적합성 기준 ...............................................10
4. 용어 .....................................................11
5. HSTS 메커니즘 개요 .........................................13
   5.1. HSTS 호스트 선언 ......................................13
   5.2. HSTS 정책 ............................................13
   5.3. 사용자 에이전트에 의한 HSTS 정책 저장 및 유지 관리 ......14
   5.4. 사용자 에이전트 HSTS 정책 시행 .........................14
6. 구문 .....................................................14
   6.1. Strict-Transport-Security HTTP 응답 헤더 필드 ..........15
        6.1.1. max-age 지시문 .................................16
        6.1.2. includeSubDomains 지시문 .......................16
   6.2. 예제 .................................................16
7. 서버 처리 모델 ............................................17
   7.1. HTTP-over-Secure-Transport 요청 유형 ...................17
   7.2. HTTP 요청 유형 ........................................18
8. 사용자 에이전트 처리 모델 ..................................18
   8.1. Strict-Transport-Security 응답 헤더 필드 처리 ..........19
        8.1.1. HSTS 호스트 기록 - 저장 모델 ....................20
   8.2. 알려진 HSTS 호스트 도메인 이름 매칭 ....................20
   8.3. URI 로딩 및 포트 매핑 .................................21
   8.4. 보안 전송 설정 오류 ...................................22
   8.5. HTTP-Equiv <Meta> 요소 속성 ............................22
   8.6. 누락된 Strict-Transport-Security 응답 헤더 필드 ........23
9. 유효 요청 URI 구성 .........................................23
   9.1. ERU 기본 정의 .........................................23
   9.2. 유효 요청 URI 결정 ....................................24
        9.2.1. 유효 요청 URI 예제 ..............................24
10. 도메인 이름 IDNA 정규화 ...................................25
11. 서버 구현 및 배포 조언 ....................................26
    11.1. 비적합 사용자 에이전트 고려사항 ......................26
    11.2. HSTS 정책 만료 시간 고려사항 .........................26
    11.3. 자체 서명 공개키 인증서와 HSTS 함께 사용 .............27
    11.4. includeSubDomains의 영향 ............................28
          11.4.1. HSTS 호스트의 대체 포트 또는 서브도메인에서
                  비보안 HTTP 서비스 제공 시 고려사항 ..........28
          11.4.2. HSTS 호스트의 서브도메인에서 웹
                  애플리케이션 제공 시 고려사항 ................29
12. 사용자 에이전트 구현 조언 .................................30
    12.1. 사용자 회피 불가 ....................................30
    12.2. 사용자 선언 HSTS 정책 ...............................30
    12.3. HSTS 사전 로드 목록 .................................31
    12.4. 혼합 보안 컨텍스트 로드 금지 .........................31
    12.5. HSTS 정책 삭제 ......................................31
13. 국제화된 애플리케이션 도메인 이름(IDNA): 의존성 및 마이그레이션 ..32
14. 보안 고려사항 ............................................32
    14.1. 기반 보안 전송 고려사항 .............................32
    14.2. 비적합 사용자 에이전트 영향 .........................33
    14.3. 오류 없는 보안 전송을 통해서만 HSTS 정책 설정의 결과 ..33
    14.4. includeSubDomains의 필요성 ..........................34
    14.5. 서비스 거부 ........................................35
    14.6. 부트스트랩 MITM 취약점 ..............................36
    14.7. 네트워크 시간 공격 ..................................37
    14.8. 가짜 루트 CA 인증서 피싱 + DNS 캐시 오염 공격 ........37
    14.9. HSTS 정책 저장소의 창의적 조작 ......................37
    14.10. 국제화된 도메인 이름 ...............................38
15. IANA 고려사항 ............................................39
16. 참고문헌 .................................................39
    16.1. 규범적 참고문헌 ....................................39
    16.2. 정보적 참고문헌 ....................................40
부록 A. 설계 결정 노트 .......................................44
부록 B. HSTS 정책과 동일 출처 정책의 차이점 ....................45
부록 C. 감사의 글 ............................................46
```

## 1. 소개

HTTP [RFC2616]는 다양한 전송 위에서 사용될 수 있으며, 일반적으로 전송 제어 프로토콜(TCP)이다. 그러나 TCP는 채널 무결성 보호, 기밀성 또는 안전한 호스트 식별을 제공하지 않는다. 따라서 Secure Sockets Layer (SSL) 프로토콜 [RFC6101]과 그 후속인 Transport Layer Security (TLS) [RFC5246]가 채널 지향 보안을 제공하기 위해 개발되었으며 일반적으로 애플리케이션 프로토콜과 TCP 사이에 계층화된다. [RFC2818]은 HTTP가 TLS 위에 계층화되는 방법을 지정하고 "https"의 Uniform Resource Identifier (URI) 스킴을 정의한다 (그러나 실제로 HTTP 사용자 에이전트(UA)는 일반적으로 서버와의 협상 및 사용자 기본 설정의 조합에 따라 TLS 또는 SSL3를 사용한다).

UA는 웹 리소스와의 상호작용 특성에 관해 다양한 로컬 보안 정책을 적용하며, 이는 (부분적으로) 주어진 웹 리소스의 호스트와 HTTP를 사용하여 통신하는지 또는 HTTP-over-Secure-Transport를 사용하여 통신하는지에 따라 달라진다. 예를 들어, 쿠키([RFC6265])는 Secure로 플래그 지정될 수 있다. UA는 이러한 Secure 쿠키를 보안 전송을 통해서만 주소 지정된 호스트로 전송해야 한다. 이것은 전송에 관계없이(다른 규칙의 적용을 받지만) 호스트로 반환되는 non-Secure 쿠키와 대조적이다.

UA는 일반적으로 TLS 서버 인증서 신뢰 체인을 검증할 수 없거나, TLS 서버 인증서가 만료되었거나, TLS 호스트의 도메인 이름이 TLS 서버 인증서에 잘못 표시된 경우([RFC2818]의 섹션 3.1 참조)와 같은 보안 연결 설정 관련 문제를 사용자에게 알린다. 종종 UA는 그러한 문제에 직면하여 사용자가 웹 리소스의 호스트와 계속 상호작용하도록 선택할 수 있게 한다. 이 동작은 때때로 보안을 "클릭 통과"한다고 지칭된다 [GoodDhamijaEtAl05] [SunshineEgelmanEtAl09]; 따라서 "클릭 통과 불안정"으로 설명될 수 있다.

클릭 통과 불안정에 의해 가능해지는 주요 취약점은 웹 리소스가 사용자 세션 관리에 사용할 수 있는 모든 쿠키의 누출이다. 여기서의 위협은 공격자가 쿠키를 획득한 다음 사용자를 가장하면서 합법적인 웹 리소스와 상호작용할 수 있다는 것이다.

Jackson과 Barth는 [ForceHTTPS]에서 웹 리소스가 UA와의 모든 상호작용이 안전하게 수행되어야 하며 보안 전송 세션 설정과 관련된 모든 문제는 치명적이고 직접적인 사용자 개입 없이 처리되어야 함을 선언할 수 있도록 하는 접근 방식을 제안했다. 목표는 클릭 통과 불안정을 방지하고 다른 잠재적 위협을 해결하는 것이다.

이 규격은 [ForceHTTPS]에서 제안된 접근 방식을 구현하고 개선한다. 예를 들어, 쿠키를 사용하여 웹 리소스의 호스트에서 UA로 정책을 전달하는 대신 이 목적을 위한 HTTP 응답 헤더 필드를 정의한다. 추가적으로, 웹 리소스의 호스트는 해당 정책이 호스트 이름을 루트로 하는 전체 도메인 이름 하위 트리에 적용됨을 선언할 수 있다. 이를 통해 HTTP Strict Transport Security (HSTS)는 주어진 웹 리소스의 호스트 이름의 모든 서브도메인에 적용되는 소위 "도메인 쿠키"를 보호할 수 있다.

이 규격은 또한 [JacksonBarth2008]의 개념을 통합하여 정책이 "전체 호스트" 기반으로 적용된다: 발행 호스트의 모든 TCP 포트에서 HTTP(만)에 적용된다.

이 규격에 의해 정의된 정책은 "The Web Origin Concept" [RFC6454]에 정의된 "동일 출처 정책"과 명확히 다르다는 점에 유의하라. 이러한 차이점은 부록 B에 요약되어 있다.

### 1.1. 이 규격의 구성

이 규격은 HSTS에 대한 사용 사례, 정책 효과, 위협 모델 및 요구사항의 개요로 시작한다(섹션 2). 그런 다음, 섹션 3은 적합성 요구사항을 정의한다. 섹션 4는 이 문서와 관련된 용어를 정의한다. HSTS 메커니즘 자체는 섹션 5부터 15까지에서 공식적으로 지정된다.

### 1.2. 문서 규약

참고: 이것은 독자를 위한 노트이다. 명시적으로 염두에 두고/또는 고려해야 할 사항이다.

## 2. 개요

이 섹션은 사용 사례를 논의하고, HSTS 정책을 요약하며, 위협 모델, 대응되지 않는 위협 및 파생된 요구사항에 대한 논의를 계속한다.

### 2.1. 사용 사례

고수준 사용 사례는 다음의 조합이다:

- 웹 브라우저 사용자는 다양한 웹사이트(일부는 임의적이고 일부는 알려진)와 안전한 방식으로 상호작용하기를 원한다.

- 웹사이트 배포자는 자신과 사용자의 이익을 위해 명시적으로 안전한 방식으로 사이트를 제공하기를 원한다.

### 2.2. HTTP Strict Transport Security 정책 효과

HSTS 정책의 효과는, 적합한 UA가 그러한 정책을 적용하는 웹 리소스 호스트(HSTS 호스트로 알려진)와의 상호작용에 적용될 때, 다음과 같이 요약된다:

1. UA는 HSTS 호스트에 대한 비보안 URI 참조를 역참조하기 전에 보안 URI 참조로 변환한다.

2. UA는 모든 보안 전송 오류 또는 경고에 대해 보안 전송 연결 시도를 종료한다.

### 2.3. 위협 모델

HSTS는 세 가지 위협 클래스와 관련된다: 수동적 네트워크 공격자, 능동적 네트워크 공격자 및 불완전한 웹 개발자. 그러나 명시적으로 두 가지 다른 위협 클래스에 대한 해결책은 아니다: 피싱과 악성 소프트웨어. 대응되는 위협과 대응되지 않는 위협은 아래에서 간략히 논의된다.

독자는 세부사항과 관련 인용에 대해 [ForceHTTPS]의 섹션 2를 참조할 수 있다.

#### 2.3.1. 대응되는 위협

##### 2.3.1.1. 수동적 네트워크 공격자

사용자가 로컬 무선 네트워크(예: 802.11 기반 무선 근거리 통신망)에서 웹을 탐색할 때, 근처의 공격자는 로컬 무선 네트워크 자체가 보안되어 있는지 여부에 관계없이 HTTP와 같은 사용자의 암호화되지 않은 인터넷 프로토콜 기반 연결을 잠재적으로 도청할 수 있다 [BeckTews09]. 무료로 이용 가능한 무선 스니핑 툴킷(예: [Aircrack-ng])은 로컬 무선 네트워크가 안전한 방식으로 운영되더라도 이러한 수동적 도청 공격을 가능하게 한다. 그러한 도구를 사용하는 수동적 네트워크 공격자는 세션 식별자/쿠키를 훔치고 인증 자격 증명이 포함된 쿠키를 획득하여 사용자의 웹 세션을 하이재킹할 수 있다 [ForceHTTPS]. 예를 들어, Firesheep(웹 브라우저 확장) [Firesheep]과 같이 널리 사용 가능한 도구가 있어 사용자가 다양한 웹 애플리케이션에 대한 다른 로컬 사용자의 세션 쿠키를 획득할 수 있게 한다.

이러한 위협을 완화하기 위해, 일부 웹사이트는 종단 간 보안 전송을 사용한 접근을 지원하지만 일반적으로 강제하지는 않는다 -- 예를 들어, "https" 스킴 [RFC2818]으로 구성된 URI를 통해 신호된다. 이로 인해 사용자는 보안 전송을 사용하여 그러한 서비스에 접근하면 수동적 네트워크 공격자로부터 보호된다고 믿을 수 있다. 불행히도, 세션 식별자는 종종 비보안 전송을 통해 제공되는 서비스 버전과의 상호 운용성을 허용하기 위해 non-Secure 쿠키에 저장되므로 실제 배포에서는 이것이 종종 사실이 아니다("Secure 쿠키"는 "Secure" 속성 [RFC6265]을 포함하는 쿠키이다). 예를 들어, 웹사이트(예: 이메일 서비스)의 세션 식별자가 non-Secure 쿠키에 저장된 경우, 사용자의 UA가 사이트에 대한 단일 비보안 HTTP 요청을 하면 공격자가 사용자의 세션을 하이재킹할 수 있다.

##### 2.3.1.2. 능동적 네트워크 공격자

결심한 공격자는 사용자의 DNS 서버를 가장하거나, 무선 네트워크에서 네트워크 프레임을 스푸핑하거나 유사한 이름의 악성 쌍둥이 액세스 포인트를 제공하여 능동적 공격을 가할 수 있다. 사용자가 무선 홈 라우터 뒤에 있는 경우, 공격자는 기본 암호와 기타 취약점을 사용하여 라우터를 재구성하려고 시도할 수 있다. 은행과 같은 일부 사이트는 자신과 사용자를 그러한 능동적 공격자로부터 보호하기 위해 종단 간 보안 전송에 의존한다. 불행히도, 브라우저는 보안 전송을 잘못 배포하는 사이트(예: 자체 인증서를 생성하고 자체 서명하여 사용하는 경우(사용자 브라우저에 해당 인증 기관(CA) 인증서를 배포하지 않고))에 사용할 수 있도록 사용자가 이러한 보호를 쉽게 선택 해제할 수 있게 한다.

##### 2.3.1.3. 웹사이트 개발 및 배포 버그

그렇지 않으면 균일하게 보안된 사이트(즉, 모든 콘텐츠가 "https" URI를 통해 구체화되는)의 보안은 비보안 연결을 통해 캐스케이딩 스타일 시트 또는 SWF(Shockwave Flash) 영화를 로딩하는 것과 같은 단순한 실수를 악용하는 능동적 공격자에 의해 완전히 손상될 수 있다(캐스케이딩 스타일 시트와 SWF 영화는 모두 많은 웹 개발자들의 놀라움에도 불구하고 임베딩 페이지를 스크립팅할 수 있으며, 일부 브라우저는 SWF 파일이 비보안 연결을 통해 임베드될 때 소위 "혼합 콘텐츠 경고"를 발행하지 않는다). 사이트 개발자가 로그인 페이지에서 "혼합 콘텐츠"를 주의 깊게 검토하더라도, 전체 사이트 어디에서나 단일 비보안 임베딩은 공격자가 다른 비보안으로 로드된 사이트 페이지에 코드(예: 스크립트)를 주입하여 로그인 페이지를 스크립팅(즉, 제어)할 수 있기 때문에 로그인 페이지의 보안을 손상시킨다.

참고: 위에서 사용된 "혼합 콘텐츠"([W3C.REC-wsc-ui-20100812]의 섹션 5.3도 참조)는 이 규격에서 "혼합 보안 컨텍스트"라고 불리는 개념을 지칭하며 XML과 HTML과 같은 마크업 언어의 컨텍스트에서 사용되는 동일한 "혼합 콘텐츠" 용어와 혼동해서는 안 된다.

#### 2.3.2. 대응되지 않는 위협

##### 2.3.2.1. 피싱

피싱 공격은 공격자가 실제 사이트와 다른 도메인에 위치한 가짜 사이트를 호스팅하여 사용자로부터 인증 자격 증명을 요청할 때 발생하며, 아마도 이메일 메시지에 링크를 보내 가짜 사이트로 트래픽을 유도한다. 피싱 공격은 사용자가 실제 사이트와 가짜 사이트를 구별하기 어렵기 때문에 매우 효과적일 수 있다. HSTS는 그 자체로 피싱에 대한 방어가 아니다; 오히려, 세션 무결성과 장기 인증 토큰을 보호하도록 브라우저에 지시함으로써 많은 기존 피싱 방어를 보완한다 [ForceHTTPS].

##### 2.3.2.2. 악성 소프트웨어 및 브라우저 취약점

HSTS는 브라우저 보안 메커니즘으로 구현되므로, 세션을 보호하기 위해 사용자 시스템의 신뢰성에 의존한다. 사용자 시스템에서 실행되는 악성 코드는 HSTS 사용 여부에 관계없이 브라우저 세션을 손상시킬 수 있다.

### 2.4. 요구사항

이 섹션은 위에서 논의된 사용 사례와 위협에서 파생된 다양한 요구사항을 식별하고 열거하며, HTTP Strict Transport Security가 해결하는 상세 핵심 요구사항과 직접 해결되지 않는 부수적 요구사항도 나열한다.

#### 2.4.1. 전체 요구사항

- 웹 브라우저 사용자와 웹사이트 배포자를 위해, 수동적 및 능동적 네트워크 공격자, 웹사이트 개발 및 배포 버그, 불안전한 사용자 행동에서 파생되는 위험을 최소화한다.

##### 2.4.1.1. 상세 핵심 요구사항

이러한 핵심 요구사항은 전체 요구사항에서 파생되며 이 규격에 의해 해결된다.

1. 웹사이트는 UA에 엄격한 보안 정책을 사용하여 접근해야 함을 선언할 수 있어야 한다.

2. 웹사이트는 비보안으로 연락하는 UA에게 보안으로 그렇게 하도록 지시할 수 있어야 한다.

3. UA는 엄격한 보안 정책 활성화를 신호하는 웹사이트에 대한 영구적인 데이터를 웹사이트가 선언한 시간 범위 동안 유지해야 한다. 추가적으로, UA는 웹사이트가 정보를 업데이트할 수 있도록 "가장 신선한" 엄격한 보안 정책 정보를 캐시해야 한다.

4. UA는 보안 정책이 활성화된 웹사이트에 대해 모든 비보안 UA "http" URI 로드를 "https" 보안 스킴을 사용하도록 다시 작성해야 한다.

5. 웹사이트 관리자는 엄격한 보안 정책이 활성화된 상위 수준 도메인의 서브도메인에 엄격한 보안 정책 적용을 신호할 수 있어야 하며, UA는 그러한 정책을 시행해야 한다.

   예를 들어, example.com과 foo.example.com 모두 bar.foo.example.com에 대한 정책을 설정할 수 있다.

6. UA는 엄격한 보안 정책이 활성화된 도메인에 의해 피어 도메인 및/또는 상위 수준 도메인에 대한 보안 정책 적용을 허용하지 않아야 한다.

   예를 들어, bar.foo.example.com이나 foo.example.com 모두 example.com에 대한 정책을 설정할 수 없으며, bar.foo.example.com도 foo.example.com에 대한 정책을 설정할 수 없다. 또한, foo.example.com은 sibling.example.com에 대한 정책을 설정할 수 없다.

7. UA는 사용자가 보안 경고를 "클릭 통과"하는 것을 방지해야 한다. 보안 전송 예외에 직면하여 연결 시도를 중단하는 것은 허용된다. 섹션 12.1("사용자 회피 불가")도 참조하라.

참고: 위의 첫 번째 핵심 요구사항을 균일하게 안전하게 충족하는 수단은 이 규격에 의해 구체적으로 다루어지지 않는다(섹션 14.6("부트스트랩 MITM 취약점") 참조). 이 규격의 향후 개정 또는 다른 규격에 의해 다루어질 수 있다. 또한 UA 구현이 첫 번째 핵심 요구사항을 보다 완전히 충족할 수 있는 수단이 있음에 유의하라; 섹션 12("사용자 에이전트 구현 조언")를 참조하라.

##### 2.4.1.2. 상세 부수적 요구사항

이러한 부수적 요구사항도 전체 요구사항에서 파생된다. 이 규격에서 규범적으로 다루어지지 않지만 UA 구현자의 재량에 따라 UA 구현에 의해 충족될 수 있지만, 이러한 요구사항을 충족하는 것은 복잡할 수 있다.

1. "혼합 보안 컨텍스트" 로드 금지(섹션 2.3.1.3 참조).

2. 사이트가 HSTS 정책을 신호하는지 여부에 관계없이 사용자가 엄격한 보안 정책이 활성화된 웹사이트를 선언하는 것을 용이하게 한다.

## 3. 적합성 기준

이 규격은 호스트와 사용자 에이전트를 위해 작성되었다.

적합 호스트는 호스트에 적용 가능한 이 규격에 나열된 모든 요구사항을 구현하는 것이다.

적합 사용자 에이전트는 사용자 에이전트에 적용 가능한 이 규격에 나열된 모든 요구사항을 구현하는 것이다.

이 문서의 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL"은 [RFC2119]에 설명된 대로 해석되어야 한다.

## 4. 용어

용어는 이 섹션에서 정의된다.

ASCII 대소문자 구분 없는 비교:

   두 문자열을 코드포인트별로 정확히 비교하는 것을 의미하지만, U+0041 .. U+005A 범위의 문자(즉, 라틴 대문자 A부터 라틴 대문자 Z까지)와 U+0061 .. U+007A 범위의 해당 문자(즉, 라틴 소문자 a부터 라틴 소문자 z까지)도 일치하는 것으로 간주된다. 자세한 내용은 [Unicode]를 참조하라.

코드포인트:

   Code Point의 구어적 축약으로, 유니코드 코드스페이스의 모든 값이다; 즉, 0에서 10FFFF(16진수)까지의 정수 범위 [Unicode].

도메인 이름:

   "DNS 이름"으로도 지칭되며 [RFC1035]에서 DNS 프로토콜 자체(및 그 구현) 외부에서 점으로 구분된 일련의 레이블로 표현되도록 정의된다, 예: "example.com" 또는 "yet.another.example.org". 이 규격의 컨텍스트에서, 도메인 이름은 [RFC3986]의 "부록 A. URI에 대한 수집된 ABNF"의 reg-name 프로덕션을 충족하는 URI의 해당 부분과 [RFC2616]의 섹션 14.23에서 Host HTTP 헤더 필드 프로덕션의 host 컴포넌트에 나타난다.

   참고: 실제 URI 인스턴스에 나타나고 앞서 언급한 프로덕션 컴포넌트와 일치하는 도메인 이름은 완전한 정규화된 도메인 이름일 수도 있고 아닐 수도 있다.

도메인 이름 레이블:

   도메인 이름에서 "점 사이에" 나타나는 부분이다, 즉, "foo.example.com"을 고려하면: "foo", "example", "com"은 모두 도메인 이름 레이블이다.

유효 요청 URI:

   HTTP 호스트가 수신하는 모든 HTTP 요청에 대해 대상 리소스를 식별하여 추론할 수 있는 URI이다. HTTP 요청은 종종 대상 리소스를 식별하는 완전한 "절대" URI를 포함하지 않기 때문에 그러한 추론이 필요하다. 섹션 9("유효 요청 URI 구성")를 참조하라.

HTTP Strict Transport Security:

   이 규격에 의해 정의된 결합된 UA 및 서버 측 보안 정책의 전체 이름이다.

HTTP Strict Transport Security 호스트:

   HSTS 정책의 HTTP 서버 측면을 구현하는 적합 호스트이다. 이것은 HSTS 호스트가 보안 전송을 통해 전송된 HTTP 응답 메시지에 "Strict-Transport-Security" HTTP 응답 헤더 필드를 반환함을 의미한다.

HTTP Strict Transport Security 정책:

   이 규격에 정의된 동작의 결합된 전체 UA 및 서버 측 패싯의 이름이다.

HSTS:

   HTTP Strict Transport Security 참조.

HSTS 호스트:

   HTTP Strict Transport Security 호스트 참조.

HSTS 정책:

   HTTP Strict Transport Security 정책 참조.

알려진 HSTS 호스트:

   UA가 HSTS 정책이 적용 중인 HSTS 호스트이다; 즉, UA가 이 호스트를 알려진 HSTS 호스트로 기록했다. 세부사항은 섹션 8.1.1("HSTS 호스트 기록 - 저장 모델")을 참조하라.

로컬 정책:

   배포자가 지정하고 종종 구성 설정으로 나타나는 정책 규칙을 구성한다.

MITM:

   "man in the middle"의 약어이다. [RFC4949]의 "man-in-the-middle attack"을 참조하라.

요청 URI:

   UA가 HTTP 요청 메시지를 발행하게 하는 데 사용되는 URI이다. "유효 요청 URI"도 참조하라.

UA:

   "user agent"의 약어이다. 이 규격의 목적상, UA는 일반적으로 사용자에 의해 능동적으로 조작되는 HTTP 클라이언트 애플리케이션이다 [RFC2616].

알려지지 않은 HSTS 호스트:

   사용자 에이전트가 기록하지 않은 HSTS 호스트이다.

## 5. HSTS 메커니즘 개요

이 섹션은 HSTS 호스트가 자신의 HSTS 정책을 UA에 전달하는 메커니즘과 UA가 HSTS 호스트로부터 수신한 HSTS 정책을 처리하는 방법에 대한 개요를 제공한다. 메커니즘 세부사항은 섹션 6부터 15까지에 지정되어 있다.

### 5.1. HSTS 호스트 선언

HTTP 호스트는 보안 전송(예: TLS)을 통해 Strict-Transport-Security HTTP 응답 헤더 필드로 표현되고 전달되는 HSTS 정책을 UA에 발행함으로써 자신을 HSTS 호스트로 선언한다. 적합 UA가 이 헤더를 오류 없이 수신하고 처리하면, UA는 호스트를 알려진 HSTS 호스트로 간주한다.

### 5.2. HSTS 정책

HSTS 정책은 UA가 알려진 HSTS 호스트와 보안 전송을 통해서만 통신하도록 지시하고 정책 유지 기간을 지정한다.

HSTS 정책은 HSTS 정책이 없을 경우 UA가 알려진 HSTS 호스트와 비보안으로 통신하게 할 수 있는 URI 참조, 사용자 입력(예: "위치 표시줄"을 통해) 또는 기타 정보의 UA 처리를 명시적으로 재정의한다.

HSTS 정책은 이 HSTS 정책이 도메인 이름이 알려진 HSTS 호스트의 도메인 이름의 서브도메인인 모든 호스트에도 적용됨을 지정하는 선택적 지시문 -- includeSubDomains --을 포함할 수 있다.

### 5.3. 사용자 에이전트에 의한 HSTS 정책 저장 및 유지 관리

UA는 발행 HSTS 호스트의 도메인 이름에 엄격히 기반하여 HSTS 정책을 저장하고 인덱싱한다.

이것은 UA가 주어진 HSTS 호스트의 HSTS 정책을 도메인 이름이 주어진 HSTS 호스트의 도메인 이름의 슈퍼도메인 또는 서브도메인인 다른 모든 HSTS 호스트가 발행한 HSTS 정책과 별도로 유지함을 의미한다. 주어진 HSTS 호스트만이 발행된 HSTS 정책을 업데이트하거나 삭제할 수 있다. 정책 시간 기간 및 서브도메인 적용 가능성에 대한 새로운 값으로 Strict-Transport-Security HTTP 응답 헤더 필드를 UA에 보냄으로써 이를 달성한다. 따라서 UA는 HSTS 호스트를 대신하여 "가장 신선한" HSTS 정책 정보를 캐시한다. 0의 시간 기간을 지정하면 UA에 해당 HSTS 호스트에 대한 HSTS 정책(어떤 주장된 includeSubDomains 지시문 포함)을 삭제하도록 신호한다. 자세한 내용은 섹션 8.1("Strict-Transport-Security 응답 헤더 필드 처리")을 참조하라. 추가적으로, 섹션 6.2는 Strict-Transport-Security HTTP 응답 헤더 필드의 예를 제시한다.

### 5.4. 사용자 에이전트 HSTS 정책 시행

주어진 호스트에 대한 HTTP 연결을 설정할 때, 어떻게 촉발되었든, UA는 자신의 알려진 HSTS 호스트 캐시를 검사하여 주어진 호스트의 도메인 이름의 슈퍼도메인인 도메인 이름을 가진 것이 있는지 확인한다. 발견되면, 그리고 그 중 includeSubDomains 지시문이 주장된 것이 있으면, HSTS 정책이 주어진 호스트에 적용된다. 그렇지 않으면, 주어진 호스트가 그 자체로 UA에 HSTS 호스트로 알려진 경우에만 HSTS 정책이 주어진 호스트에 적용된다. 자세한 내용은 섹션 8.3("URI 로딩 및 포트 매핑")을 참조하라.

## 6. 구문

이 섹션은 Strict-Transport-Security HTTP 응답 헤더 필드와 그 지시문의 구문을 정의하고 몇 가지 예를 제시한다.

섹션 7("서버 처리 모델")은 호스트가 이 헤더 필드를 사용하여 HSTS 정책을 선언하는 방법을 자세히 설명하고, 섹션 8("사용자 에이전트 처리 모델")은 사용자 에이전트가 헤더 필드를 처리하고 HSTS 정책을 적용하는 방법을 자세히 설명한다.

### 6.1. Strict-Transport-Security HTTP 응답 헤더 필드

Strict-Transport-Security HTTP 응답 헤더 필드(STS 헤더 필드)는 UA에 이 헤더 필드를 포함하는 응답 메시지를 발행하는 호스트에 관해 HSTS 정책을 시행해야(MUST) 함을 나타낸다.

STS 헤더 필드의 ABNF(증강 배커스-나우어 형식) 구문은 아래에 주어진다. 이것은 [RFC2616]의 섹션 2에 정의된 Generic Grammar에 기반한다(여기에는 "암시적 선형 공백" 또는 "암시적 *LWS"로도 알려진 개념이 포함된다).

```
  Strict-Transport-Security = "Strict-Transport-Security" ":"
                              [ directive ]  *( ";" [ directive ] )

  directive                 = directive-name [ "=" directive-value ]
  directive-name            = token
  directive-value           = token | quoted-string
```

여기서:

```
  token          = <token, [RFC2616], 섹션 2.2에 정의됨>
  quoted-string  = <quoted-string, [RFC2616], 섹션 2.2에 정의됨>
```

이 규격에 정의된 두 지시문은 아래에 설명되어 있다. 지시문에 대한 전체 요구사항은:

1. 지시문 출현 순서는 중요하지 않다.

2. 모든 지시문은 STS 헤더 필드에 한 번만 나타나야(MUST) 한다. 지시문은 정의에 규정된 대로 선택 사항이거나 필수이다.

3. 지시문 이름은 대소문자를 구분하지 않는다.

4. UA는 이 규격에 정의된 구문을 따르지 않는 지시문 또는 기타 헤더 필드 값 데이터를 포함하는 모든 STS 헤더 필드를 무시해야(MUST) 한다.

5. STS 헤더 필드에 UA가 인식하지 못하는 지시문이 포함된 경우, UA는 인식되지 않은 지시문을 무시해야(MUST) 하며, STS 헤더 필드가 위의 요구사항(1부터 4까지)을 충족하는 경우, UA는 인식된 지시문을 처리해야(MUST) 한다.

STS 헤더 필드의 의미적 기능을 확장하는 추가 지시문은 다른 규격에서 정의될 수 있으며, 그때 IETF Review [RFC5226]의 IANA 정책 정의를 가진 레지스트리가 정의된다.

참고: 그러한 미래의 지시문은 이 규격만 구현하는 UA뿐만 아니라 일반적으로 비적합 UA에 의해서도 무시될 것이다. 추가 논의는 섹션 14.2("비적합 사용자 에이전트 영향")를 참조하라.

#### 6.1.1. max-age 지시문

필수(REQUIRED) "max-age" 지시문은 STS 헤더 필드 수신 후 UA가 호스트(메시지가 수신된 호스트)를 알려진 HSTS 호스트로 간주하는 초 단위 시간을 지정한다. 섹션 8.1.1("HSTS 호스트 기록 - 저장 모델")도 참조하라. delta-seconds 프로덕션은 [RFC2616]에 지정되어 있다.

max-age 지시문의 필수(REQUIRED) 값의 구문(필요한 경우 quoted-string 언이스케이프 후)은 다음과 같이 정의된다:

```
 max-age-value = delta-seconds

 delta-seconds = <1*DIGIT, [RFC2616], 섹션 3.3.2에 정의됨>
```

참고: 0의 max-age 값(즉, "max-age=0")은 UA에 호스트를 알려진 HSTS 호스트로 간주하는 것을 중단하도록 신호하며, includeSubDomains 지시문(해당 HSTS 호스트에 대해 주장된 경우)도 포함한다. 섹션 8.1("Strict-Transport-Security 응답 헤더 필드 처리")도 참조하라.

#### 6.1.2. includeSubDomains 지시문

선택적(OPTIONAL) "includeSubDomains" 지시문은 값이 없는 지시문으로, 존재하는 경우(즉, "주장된" 경우), UA에 HSTS 정책이 이 HSTS 호스트뿐만 아니라 호스트의 도메인 이름의 모든 서브도메인에도 적용됨을 신호한다.

### 6.2. 예제

아래 HSTS 헤더 필드는 HSTS 정책이 1년 동안 유효하도록 규정하며(1년에는 약 31536000초가 있다), 정책은 이를 발행하는 HSTS 호스트의 도메인에만 적용된다:

```
  Strict-Transport-Security: max-age=31536000
```

아래 HSTS 헤더 필드는 HSTS 정책이 약 6개월 동안 유효하도록 규정하며 정책이 발행 HSTS 호스트의 도메인과 그 모든 서브도메인에 적용됨을 규정한다:

```
  Strict-Transport-Security: max-age=15768000 ; includeSubDomains
```

max-age 지시문 값은 선택적으로 따옴표로 묶을 수 있다:

```
  Strict-Transport-Security: max-age="31536000"
```

아래 HSTS 헤더 필드는 UA가 헤더 필드를 보낸 HSTS 호스트와 연관된 전체 HSTS 정책을 삭제해야 함을 나타낸다:

```
  Strict-Transport-Security: max-age=0
```

아래 HSTS 헤더 필드는 max-age가 0일 때 HSTS 헤더 필드에 includeSubDomains 지시문의 존재가 무시되므로 바로 위의 것과 정확히 같은 효과를 가진다:

```
  Strict-Transport-Security: max-age=0; includeSubDomains
```

## 7. 서버 처리 모델

이 섹션은 HSTS 호스트가 구현하는 처리 모델을 설명한다. 모델은 두 가지 패싯으로 구성된다: 첫 번째는 보안 전송(TLS [RFC5246] 또는 SSL [RFC6101]; 섹션 14.1("기반 보안 전송 고려사항")도 참조)을 통해 수신된 HTTP 요청 메시지의 처리 규칙이고, 두 번째는 TCP와 같은 비보안 전송을 통해 수신된 HTTP 요청 메시지의 처리 규칙이다.

### 7.1. HTTP-over-Secure-Transport 요청 유형

보안 전송을 통해 전달된 HTTP 요청에 응답할 때, HSTS 호스트는 응답 메시지에 위의 섹션 6.1("Strict-Transport-Security HTTP 응답 헤더 필드")에 지정된 문법을 충족해야(MUST) 하는 STS 헤더 필드를 포함해야(SHOULD) 한다. STS 헤더 필드가 포함된 경우, HSTS 호스트는 그러한 헤더 필드를 하나만 포함해야(MUST) 한다.

주어진 UA의 컨텍스트에서 주어진 호스트를 알려진 HSTS 호스트로 설정하는 것은 (이 규격에 따라) 적어도 하나의 유효한 STS 헤더 필드를 UA에 올바르게 반환함으로써 보안 전송을 통해 실행되는 HTTP를 통해 달성될 수 있다(MAY). 클라이언트 측 사전 로드된 알려진 HSTS 호스트 목록과 같은 다른 메커니즘도 사용될 수 있다(MAY); 예: 섹션 12("사용자 에이전트 구현 조언")를 참조하라.

참고: STS 헤더 필드 포함은 주어진 HSTS 호스트를 대신하여 STS 헤더 필드를 균일하게 발행하기 어려울 수 있는 다양한 서버 및 네트워크 측 캐시와 로드 밸런싱 구성을 수용하기 위해 "SHOULD"로 규정되어 있다.

### 7.2. HTTP 요청 유형

HSTS 호스트가 비보안 전송을 통해 HTTP 요청 메시지를 수신하는 경우, 영구 리다이렉트를 나타내는 상태 코드(예: 상태 코드 301([RFC2616]의 섹션 10.3.2))를 포함하는 HTTP 응답 메시지와 HTTP 요청의 원래 유효 요청 URI(섹션 9("유효 요청 URI 구성") 참조)를 "https"의 URI 스킴으로 필요에 따라 변경한 것 또는 "https"의 URI 스킴을 가진 로컬 정책에 따라 생성된 URI를 포함하는 Location 헤더 필드 값을 보내야(SHOULD) 한다.

참고: 위의 동작은 다음으로 인해 "MUST"가 아닌 "SHOULD"이다:

   * 서버 측 비보안-보안 리다이렉트의 위험 [OWASP-TLSGuide].

   * 사이트 배포 특성. 예를 들어, 타사 구성요소를 통합하는 사이트는 비보안 전송을 통해 접근될 때 서버 측 비보안-보안 리다이렉트를 수행할 때 올바르게 동작하지 않을 수 있지만 보안 전송을 통해 균일하게 접근될 때는 올바르게 동작한다. 후자는 이미 사이트를 알려진 HSTS 호스트로 기록한 HSTS 지원 UA(어떤 수단으로든, 예: 사전 상호작용 또는 UA 구성)가 주어진 경우이다.

HSTS 호스트는 비보안 전송을 통해 전달된 HTTP 응답에 STS 헤더 필드를 포함해서는 안 된다(MUST NOT).

## 8. 사용자 에이전트 처리 모델

이 섹션은 UA에 대한 HTTP Strict Transport Security 처리 모델을 설명한다. 모델에는 다음 하위 섹션에 열거된 여러 패싯이 있다.

이 처리 모델은 UA가 섹션 13("국제화된 애플리케이션 도메인 이름(IDNA): 의존성 및 마이그레이션")에 언급된 대로 IDNA2008 [RFC5890] 또는 아마도 IDNA2003 [RFC3490]을 구현한다고 가정한다. 또한 이 규격의 컨텍스트에서 조작되는 모든 도메인 이름이 이 섹션에 지정된 처리 전에 섹션 10("도메인 이름 IDNA 정규화")에 설명된 대로 이미 IDNA 정규화되어 있다고 가정한다.

   참고: [RFC3490]은 가까운 미래에 실제 배포와의 지속적인 관련성으로 인해 참조된다.

위의 가정은 이 처리 모델이 또한 이 섹션에 지정된 처리 전에 도메인 이름의 IDNA 정규화와 함께 적절한 IDNA 및 유니코드 검증과 문자 목록 테스트가 도메인 이름에 대해 수행되었다고 구체적으로 가정함을 의미한다. 근거와 추가 세부사항은 섹션 14.10("국제화된 도메인 이름")의 IDNA 관련 보안 고려사항을 참조하라.

### 8.1. Strict-Transport-Security 응답 헤더 필드 처리

보안 전송을 통해 수신된 HTTP 응답이 섹션 6.1("Strict-Transport-Security HTTP 응답 헤더 필드")에 지정된 문법을 따르는 STS 헤더 필드를 포함하고, 기반 보안 전송 오류나 경고가 없는 경우(섹션 8.4 참조), UA는 반드시(MUST) 다음 중 하나를 해야 한다:

- 호스트를 아직 알려진 HSTS 호스트로 기록되지 않은 경우 알려진 HSTS 호스트로 기록한다(섹션 8.1.1("HSTS 호스트 기록 - 저장 모델") 참조),

또는

- max-age 및 includeSubDomains 헤더 필드 값 토큰 중 하나 또는 둘 다 UA가 이미 유지하고 있는 것과 다른 정보를 전달하는 경우 알려진 HSTS 호스트에 대해 UA의 캐시된 정보를 업데이트한다.

   max-age 값은 본질적으로 STS 헤더 필드 수신 시간에 상대적인 "수명" 값이다.

   max-age 헤더 필드 값 토큰이 0의 값을 가지는 경우, UA는 HSTS 호스트가 알려진 경우 캐시된 HSTS 정책 정보(주장된 경우 includeSubDomains 지시문 포함)를 제거해야(MUST) 하며, 아직 알려지지 않은 경우 UA는 이 HSTS 호스트를 기록해서는 안 된다(MUST NOT).

   UA가 보안 전송을 통한 HTTP 응답 메시지에서 둘 이상의 STS 헤더 필드를 수신하는 경우, UA는 첫 번째 그러한 헤더 필드만 처리해야(MUST) 한다.

그렇지 않으면:

- HTTP 응답이 비보안 전송을 통해 수신되는 경우, UA는 존재하는 모든 STS 헤더 필드를 무시해야(MUST) 한다.

- UA는 섹션 6.1("Strict-Transport-Security HTTP 응답 헤더 필드")에 지정된 문법을 따르지 않는 모든 STS 헤더 필드를 무시해야(MUST) 한다.

#### 8.1.1. HSTS 호스트 기록 - 저장 모델

Request-URI(호스트가 응답한 메시지의)에서 host 프로덕션과 일치하는 부분 문자열이 [RFC3986]의 섹션 3.2.2에서 IP-literal 또는 IPv4address 프로덕션과 구문적으로 일치하는 경우, UA는 이 호스트를 알려진 HSTS 호스트로 기록해서는 안 된다(MUST NOT).

그렇지 않으면, 부분 문자열이 섹션 8.2("알려진 HSTS 호스트 도메인 이름 매칭")에 지정된 매칭 절차에 따라 알려진 HSTS 호스트의 도메인 이름과 합동으로 일치하지 않는 경우, UA는 이 호스트를 알려진 HSTS 호스트로 기록해야(MUST) 하며, HSTS 호스트의 도메인 이름을 캐싱하고 주어진 max-age 값에 따라 효과적으로 규정된 대로 이 정보의 만료 시간을 기록하며, includeSubDomains 지시문이 주장되었는지 여부도 기록한다. 섹션 11.2("HSTS 정책 만료 시간 고려사항")도 참조하라.

UA는 슈퍼도메인 일치된 알려진 HSTS 호스트의 만료 시간이나 includeSubDomains 지시문을 수정해서는 안 된다(MUST NOT).

알려진 HSTS 호스트는 캐시 항목의 만료 날짜가 과거인 경우 "만료"된 것이다. UA는 어느 때든 만료된 알려진 HSTS 호스트가 캐시에 존재하면 모든 만료된 알려진 HSTS 호스트를 캐시에서 제거해야(MUST) 한다.

### 8.2. 알려진 HSTS 호스트 도메인 이름 매칭

주어진 도메인 이름은 알려진 HSTS 호스트의 도메인 이름과 두 가지 방식 중 하나 또는 둘 다로 일치할 수 있다: 합동 일치 또는 슈퍼도메인 일치. 대안적으로, 일치가 없을 수 있다.

아래 단계는 일치가 있는지, 그리고 있다면 어떤 방식인지 결정한다:

   주어진 도메인 이름을 UA의 만료되지 않은 각 알려진 HSTS 호스트의 도메인 이름과 비교한다. 각 알려진 HSTS 호스트의 도메인 이름에 대해, 비교는 가장 오른쪽 레이블부터 시작하여 오른쪽에서 왼쪽으로 계속하여 ASCII 대소문자 구분 없는 비교를 사용하여 레이블별로(레이블만 비교) 주어진 도메인 이름과 수행된다. [RFC5890]의 섹션 2.3.2.4도 참조하라.

   * 슈퍼도메인 일치

      전체 알려진 HSTS 호스트의 도메인 이름과 주어진 도메인 이름의 오른쪽 부분 사이의 레이블별 일치가 발견되면, 이 알려진 HSTS 호스트의 도메인 이름은 주어진 도메인 이름에 대한 슈퍼도메인 일치이다. 주어진 도메인 이름에 대해 여러 슈퍼도메인 일치가 있을 수 있다.

      예를 들어:

         주어진 도메인 이름(DN):   qaz.bar.foo.example.com

         슈퍼도메인 일치된
         알려진 HSTS 호스트 DN:           bar.foo.example.com

         슈퍼도메인 일치된
         알려진 HSTS 호스트 DN:               foo.example.com


   * 합동 일치

      알려진 HSTS 호스트의 도메인 이름과 주어진 도메인 이름 사이의 레이블별 일치가 발견되면 -- 즉, 비교할 추가 레이블이 없으면 -- 주어진 도메인 이름은 이 알려진 HSTS 호스트와 합동으로 일치한다.

      예를 들어:

         주어진 도메인 이름:                foo.example.com

         합동 일치된
         알려진 HSTS 호스트 DN:               foo.example.com


   * 그렇지 않으면, 일치가 발견되지 않으면, 주어진 도메인 이름은 알려진 HSTS 호스트를 나타내지 않는다.

### 8.3. URI 로딩 및 포트 매핑

UA가 모든 "http" URI [RFC3986](HTTP 리다이렉트 [RFC2616]를 따르는 경우 포함)를 "로드"(또는 "역참조")하려고 준비할 때마다, UA는 먼저 도메인 이름이 URI에 주어져 있는지와 알려진 HSTS 호스트와 일치하는지 결정해야(MUST) 하며, 다음 단계를 사용한다:

1. URI에서 URI의 authority 컴포넌트의 host 컴포넌트로 설명되는 모든 부분 문자열을 추출한다.

2. 부분 문자열이 null이면, 알려진 HSTS 호스트와 일치하지 않는다.

3. 그렇지 않으면, 부분 문자열이 non-null이고 [RFC3986]의 섹션 3.2.2에서 IP-literal 또는 IPv4address 프로덕션과 구문적으로 일치하면, 알려진 HSTS 호스트와 일치하지 않는다.

4. 그렇지 않으면, 부분 문자열은 주어진 도메인 이름이며, 섹션 8.2("알려진 HSTS 호스트 도메인 이름 매칭")의 절차를 사용하여 UA의 알려진 HSTS 호스트와 일치되어야(MUST) 한다.

5. 도메인 이름 매칭을 수행할 때 주장된 includeSubDomains 지시문을 가진 슈퍼도메인 일치가 발견되거나, 주장된 includeSubDomains 지시문을 가진 슈퍼도메인 일치가 발견되지 않고 합동 일치가 발견된 경우(주장된 includeSubDomains 지시문 유무에 관계없이), 로드를 진행하기 전에:

      UA는 URI 스킴을 "https" [RFC2818]로 교체해야(MUST) 하고,

      URI에 "80"의 명시적 포트 컴포넌트가 포함된 경우, UA는 포트 컴포넌트를 "443"으로 변환해야(MUST) 하며,

      URI에 "80"과 같지 않은 명시적 포트 컴포넌트가 포함된 경우, 포트 컴포넌트 값은 유지되어야(MUST) 한다; 그렇지 않으면,

      URI에 명시적 포트 컴포넌트가 포함되지 않은 경우, UA는 추가해서는 안 된다(MUST NOT).

      참고: 이 단계는 HSTS 정책이 HSTS 호스트의 모든 TCP 포트에서 HTTP에 적용되도록 보장한다.

참고: 명시적 포트가 제공된 경우(그리고 어느 정도 서브도메인의 경우), 실제로 지정된 포트에서 HTTP(즉, 비보안) 서버가 실행 중이고 따라서 HTTPS 요청이 실패할 가능성이 합리적으로 높다(부록 A("설계 결정 노트") 항목 6 참조).

### 8.4. 보안 전송 설정 오류

알려진 HSTS 호스트에 연결할 때, 기반 보안 전송과의 오류가 있으면, "경고"이든 "치명적"이든 또는 다른 오류 수준이든, UA는 연결을 종료해야(MUST) 한다(섹션 12("사용자 에이전트 구현 조언")도 참조). 예를 들어, 이것은 UA가 사용하는 인증서 유효성 검사에서 발견된 모든 오류를 포함하며, 예를 들어 인증서 해지 목록(CRL) [RFC5280]을 통해 또는 온라인 인증서 상태 프로토콜(OCSP) [RFC2560]을 통해, 그리고 TLS 서버 신원 확인 [RFC6125]을 통해서도 마찬가지이다.

### 8.5. HTTP-Equiv <Meta> 요소 속성

UA는 수신된 콘텐츠의 <meta> 요소 [W3C.REC-html401-19991224]에 대한 http-equiv="Strict-Transport-Security" 속성 설정에 주의를 기울여서는 안 된다(MUST NOT).

### 8.6. 누락된 Strict-Transport-Security 응답 헤더 필드

UA가 보안 채널을 통해 알려진 HSTS 호스트로부터 HTTP 응답을 수신하지만 응답에 STS 헤더 필드가 누락된 경우, UA는 해당 알려진 HSTS 호스트에 대한 지식의 max-age 값에 도달할 때까지 호스트를 알려진 HSTS 호스트로 계속 처리해야(MUST) 한다. max-age 값은 주어진 알려진 HSTS 호스트에 대해 효과적으로 무한할 수 있음에 유의하라. 예를 들어, 알려진 HSTS 호스트가 목록 항목이 "만료되지" 않도록 구현된 사전 구성된 목록의 일부인 경우 이것이 해당된다.
