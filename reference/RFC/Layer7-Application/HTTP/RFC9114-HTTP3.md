# RFC 9114 - HTTP/3

> 발행일: 2022년 6월
> 상태: Standards Track
> 작성자: M. Bishop (Akamai Technologies)

## 1. 개요

HTTP/3는 QUIC 전송 프로토콜 위에서 HTTP 시맨틱을 매핑하는 프로토콜입니다. HTTP/1.1 및 HTTP/2와 동일한 HTTP 시맨틱(메서드, 상태 코드, 헤더 필드)을 사용하면서 TCP 대신 QUIC을 전송 계층으로 사용합니다.

### 1.1 이전 HTTP 버전의 한계

#### HTTP/1.1의 문제점

```
HTTP/1.1: 공백으로 구분된 텍스트 필드 사용
→ 파싱 복잡성 증가
→ 변형 동작에 대한 과도한 허용
→ 멀티플렉싱 부재로 인한 다중 TCP 연결 필요
→ 연결 간 혼잡 제어 효과 감소
```

#### HTTP/2의 한계

HTTP/2는 바이너리 프레이밍과 멀티플렉싱을 도입하여 지연 시간을 개선했지만, 근본적인 문제가 남아있습니다:

```
HTTP/2의 Head-of-Line Blocking:

패킷 손실 또는 재정렬 발생 시
→ 해당 트랜잭션에 직접적인 영향이 없더라도
→ 모든 활성 트랜잭션이 지연됨
→ TCP의 손실 복구 메커니즘이 멀티플렉스된 스트림 구분 불가
```

### 1.2 QUIC으로의 위임

QUIC은 HTTP/2의 병목 현상을 근본적으로 해결합니다:

| 기능 | 설명 |
|------|------|
| 스트림 레벨 멀티플렉싱 | 전송 계층에서 스트림 독립성 보장 |
| 스트림별 흐름 제어 | 개별 스트림 단위 데이터 전송 관리 |
| 저지연 연결 설정 | 0-RTT, 1-RTT 핸드셰이크 지원 |
| 신뢰성 있는 스트림별 전달 | 스트림별 순서 보장 |
| 연결 수준 혼잡 제어 | 전체 연결의 혼잡 상태 관리 |

핵심 이점: HTTP/3는 기밀성 및 무결성 보호, 피어 인증을 위해 QUIC에 의존하며, TLS 1.3이 전송 계층에 직접 통합됩니다.

---

## 2. HTTP/3 프로토콜 개요

### 2.1 핵심 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                        HTTP/3 애플리케이션                        │
├─────────────────────────────────────────────────────────────────┤
│                        QPACK (헤더 압축)                          │
├─────────────────────────────────────────────────────────────────┤
│                      HTTP/3 프레이밍 계층                         │
├─────────────────────────────────────────────────────────────────┤
│                           QUIC 전송                              │
├─────────────────────────────────────────────────────────────────┤
│                        TLS 1.3 (암호화)                          │
├─────────────────────────────────────────────────────────────────┤
│                             UDP                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 연결 구조

HTTP/3 통신은 개별 스트림의 프레임을 통해 이루어집니다:

- 제어 프레임: 전체 연결에 영향을 미치는 프레임 (전용 제어 스트림에서 전송)
- 요청-응답 쌍: 단일 QUIC 스트림 사용

장점: 한 스트림에 영향을 미치는 패킷 손실이 다른 스트림의 진행을 방해하지 않습니다.

### 2.3 주요 기술적 특징

| 기능 | 설명 |
|------|------|
| 서버 푸시 | 고유 푸시 ID를 사용한 선제적 응답 전송 |
| QPACK 압축 | HTTP/2의 HPACK 대신 사용, 별도 단방향 스트림에서 테이블 상태 관리 |
| 스트림 독립성 | 패킷 손실이 개별 스트림에만 영향 |

### 2.4 문서 구성

| 섹션 | 내용 |
|------|------|
| 섹션 3 | 연결 설정 및 관리 |
| 섹션 4 | HTTP 시맨틱의 프레임 기반 표현 |
| 섹션 5 | 연결 종료 |
| 섹션 6-8 | 스트림 매핑, 프레이밍 계층, 오류 처리 |

---

## 3. 연결 설정 및 관리

### 3.1 HTTP/3 엔드포인트 발견

#### 3.1.1 인증서 검증 요구사항

```
HTTPS URI에 대한 서버 권한 설정:
1. TLS 핸드셰이크 중 서버가 인증서 제시
2. 클라이언트가 URI의 원본 서버에 대해 인증서 유효성 검증
3. 검증 실패 시 해당 원본에 대해 서버를 권한 있는 것으로 간주할 수 없음
```

#### 3.1.2 직접 접근 방식

클라이언트가 HTTPS 리소스에 접근하는 절차:

1. 호스트명을 IP 주소로 해석
2. 지정된 포트에 QUIC 연결 설정
3. 서버 인증서 검증
4. HTTP/3 요청 메시지 전송

ALPN 토큰: "h3"는 대체 메커니즘이 적용되지 않는 한 HTTP/3 선택을 나타냅니다.

#### 3.1.3 대체 서비스 (Alt-Svc)

원본 서버는 Alt-Svc 헤더 필드 또는 HTTP/2 ALTSVC 프레임을 통해 HTTP/3 엔드포인트 가용성을 알릴 수 있습니다:

```http
Alt-Svc: h3=":50781"
```

Alt-Svc 레코드를 수신하면 클라이언트는:
1. 지정된 호스트 및 포트로 QUIC 연결 시도
2. 연결 성공 시 HTTP/3 요청 전송 가능

#### 3.1.4 폴백 고려사항

```
UDP 차단 등 연결 문제 발생 가능
→ QUIC 연결 실패 시
→ TCP 기반 HTTP 버전으로 시도해야 함 (SHOULD)
```

#### 3.1.5 다른 스킴

| 스킴 | HTTP/3 직접 접근 | 대안 |
|------|------------------|------|
| https | 가능 | - |
| http | 불가 (TCP 연결 필요) | Alt-Svc를 통한 대체 서비스 |

### 3.2 연결 설정

HTTP/3는 QUIC 버전 1을 기본 전송으로 사용합니다.

#### TLS 요구사항

| 요구사항 | 설명 |
|----------|------|
| TLS 버전 | TLS 1.3 이상 |
| SNI 확장 | 도메인 식별 서버에 대해 필수 |
| ALPN 토큰 | "h3" |

#### 연결 프로세스

```
Client                                Server
   │                                     │
   │─── QUIC 초기 핸드셰이크 ───────────>│
   │    (TLS 1.3 + ALPN: h3)            │
   │                                     │
   │<── QUIC 핸드셰이크 완료 ────────────│
   │                                     │
   │─── SETTINGS 프레임 ────────────────>│
   │    (제어 스트림의 첫 프레임)         │
   │                                     │
   │<── SETTINGS 프레임 ─────────────────│
   │    (제어 스트림의 첫 프레임)         │
```

### 3.3 연결 재사용

HTTP/3 연결은 여러 요청에 걸쳐 유지됩니다.

#### 다중 원본 연결

설정된 서버 연결은 여러 URI 권한 구성요소에 재사용될 수 있습니다:

```
인증서 검증 요구사항:
1. 새 원본에 대한 서버 인증서 검증 필수
2. 서버 인증서 및 검증 정보 유지 필요
3. 정보가 없는 클라이언트는 추가 원본에 연결 재사용 불가
```

#### 인증서 거부 프로토콜

| 상황 | 조치 |
|------|------|
| 새 원본에 대한 인증서 검증 실패 | 연결 재사용 금지, 새 연결 설정 |
| 검증 실패 이유가 다른 원본에 영향 | 해당 원본들의 인증서 재검증 필요 |

#### 연결 제한 모범 사례

```
❌ 동일 IP 주소/UDP 포트 조합에 다중 HTTP/3 연결 열기
✅ 다른 전송 또는 TLS 구성의 다중 연결은 허용
✅ 동일 구성 연결이 존재하면 추가 연결 회피
```

#### 비재사용 신호

서버가 특정 원본에 대해 연결 재사용을 원하지 않는 경우:

```http
HTTP/1.1 421 Misdirected Request
```

---

## 4. HTTP/3에서 HTTP 시맨틱 표현

### 4.1 HTTP 메시지 프레이밍

#### 핵심 구조

클라이언트는 요청 스트림(클라이언트 시작 양방향 QUIC 스트림)에서 HTTP 요청을 전송하며, 스트림당 단일 요청을 사용합니다.

```
HTTP/3 메시지 구성:

┌─────────────────────────────┐
│   HEADERS 프레임 (헤더 섹션)  │  ← 필수
├─────────────────────────────┤
│   DATA 프레임들 (콘텐츠)      │  ← 선택
├─────────────────────────────┤
│   HEADERS 프레임 (트레일러)   │  ← 선택
└─────────────────────────────┘
```

#### 프레임 시퀀싱 규칙

| 규칙 | 위반 시 |
|------|---------|
| HEADERS 이전에 DATA 금지 | 연결 오류 (MUST) |
| 트레일러 HEADERS 이후 DATA/HEADERS 금지 | 연결 오류 (MUST) |
| 잘못된 프레임 시퀀스 수신 | H3_FRAME_UNEXPECTED 연결 오류 |

#### 요청 취소

```
클라이언트: 요청 취소 가능
서버: 처리 전 요청 거부 가능

구분:
- "거부됨(rejected)": 처리되지 않은 요청
- "취소됨(cancelled)": 처리 중 취소된 요청
→ 적절한 오류 코드로 구분 안내
```

#### 잘못된 형식 감지

다음은 잘못된 형식으로 처리됩니다:

| 위반 유형 | 설명 |
|-----------|------|
| 금지된 의사 헤더 필드 | 정의되지 않은 의사 헤더 사용 |
| 필수 의사 헤더 부재 | :method, :scheme, :path 누락 |
| 대문자 필드 이름 | 필드 이름은 소문자 필수 |
| 잘못된 문자 | 필드 이름/값의 유효하지 않은 문자 |
| Content-Length 불일치 | 선언된 길이와 실제 데이터 불일치 |

### 4.2 HTTP 필드

#### 필드 이름 처리

```
필드 이름 요구사항:
- ASCII 문자의 부분집합으로 구성
- 인코딩 전 소문자로 변환 필수 (MUST)
```

#### 연결 특정 헤더 제한

| 헤더 | 허용 여부 |
|------|----------|
| Connection | 금지 |
| Keep-Alive | 금지 |
| Proxy-Connection | 금지 |
| Transfer-Encoding | 금지 |
| Upgrade | 금지 |
| TE | "trailers" 값만 허용 |

#### QPACK 압축 전략

HTTP/3는 HPACK 대신 QPACK 압축을 사용합니다:

```
QPACK의 특징:
- 인코더가 압축 효율성 vs 지연 시간 트레이드오프 제어
- Head-of-Line 블로킹 관리 가능
- 별도 단방향 스트림에서 동적 테이블 업데이트 관리

쿠키 최적화:
- 압축 전 쿠키를 여러 필드 라인으로 분할 가능
- 비HTTP/2/3 애플리케이션 처리 전 "; " 구분자로 연결 필요
```

#### 크기 제한

```
서버는 SETTINGS_MAX_FIELD_SECTION_SIZE로 제한 신호
크기 계산: 각 필드당 32바이트 오버헤드 포함
```

### 4.3 HTTP 제어 데이터

#### 의사 헤더 필드

의사 헤더 필드는 콜론(`:`)으로 시작하며 제어 정보를 전달합니다.

```
규칙:
- 모든 의사 헤더 필드는 일반 헤더 필드 이전에 나타나야 함 (MUST)
- 일반 헤더 필드 사이 또는 이후에 의사 헤더 배치 금지
```

#### 요청 의사 헤더

| 의사 헤더 | 설명 | 필수 여부 |
|-----------|------|-----------|
| `:method` | HTTP 메서드 | 필수 |
| `:scheme` | URI 스킴 | 필수 (CONNECT 제외) |
| `:authority` | 권한 구성요소 (userinfo 제외) | - |
| `:path` | 경로 및 쿼리 구성요소 | 필수 (CONNECT 제외) |

#### 응답 의사 헤더

| 의사 헤더 | 설명 | 필수 여부 |
|-----------|------|-----------|
| `:status` | HTTP 상태 코드 | 모든 응답에 필수 (MUST) |

#### 요청 예시

```
:method = GET
:scheme = https
:authority = example.com
:path = /index.html
user-agent = Mozilla/5.0
accept = text/html
```

#### 응답 예시

```
:status = 200
content-type = text/html; charset=utf-8
content-length = 1234
```

### 4.4 CONNECT 메서드

HTTP/3에서 CONNECT 메서드는 전체 연결 대신 개별 스트림에 터널을 설정합니다.

```
CONNECT 터널 동작:

Client                 Proxy                  Target
   │                     │                       │
   │── CONNECT ────────>│                       │
   │   :method = CONNECT │                       │
   │   :authority = host │                       │
   │                     │── TCP 연결 ──────────>│
   │                     │                       │
   │<── :status = 200 ──│                       │
   │                     │                       │
   │<══ DATA 프레임 양방향 매핑 ═══>│<══ TCP ══>│
```

제한사항:
- 설정 후 DATA 및 확장 프레임만 허용
- TCP 오류 발생 시 `H3_CONNECT_ERROR` 스트림 오류

### 4.5 HTTP 업그레이드

```
HTTP/3는 HTTP 업그레이드 메커니즘을 지원하지 않음 (does not support)
101 (Switching Protocols) 응답 금지
```

### 4.6 서버 푸시

서버는 고유 푸시 ID를 할당하여 비동기 리소스 전달을 활성화합니다.

#### 푸시 제어 메커니즘

| 프레임 | 역할 |
|--------|------|
| MAX_PUSH_ID | 클라이언트가 허용 가능한 최대 푸시 ID 설정 |
| PUSH_PROMISE | 요청 스트림에서 약속된 리소스 알림 |
| CANCEL_PUSH | 약속된 리소스 취소 |

#### 푸시 가능한 요청 조건

```
✅ 캐시 가능한 요청
✅ 안전한(safe) 요청
✅ 콘텐츠 또는 트레일러 없음
✅ 서버가 약속된 원본에 대한 권한 주장 가능

❌ 조건 미충족 시 푸시 불가
```

#### 푸시 데이터 순서

```
주의: 재정렬로 인해 푸시 데이터가 PUSH_PROMISE 이전에 도착할 수 있음
→ 클라이언트는 적절히 버퍼링해야 함
→ 합리적인 시간 내에 약속이 나타나지 않으면 폐기
```

---

## 5. 연결 종료

### 5.1 유휴 연결

```
QUIC 연결이 유휴 상태(패킷 미수신)로 협상된 기간 이상 유지되면
→ 피어가 연결이 종료되었다고 가정

권장사항:
- 클라이언트/서버 모두 유휴 타임아웃 값 모니터링 (SHOULD)
- 기존 연결이 유휴 임계값 초과 시 새 연결 설정 필요
- 대기 중인 응답이 있는 클라이언트는 연결 활동 유지 (SHOULD)
```

### 5.2 연결 셧다운

정상적인 종료는 어느 한쪽이 GOAWAY 프레임을 전송하여 시작합니다.

#### GOAWAY 프레임 동작

```
┌─────────────────────────────────────────────────────────────┐
│                      GOAWAY 프레임                           │
├─────────────────────────────────────────────────────────────┤
│ 서버 → 클라이언트: 클라이언트 시작 스트림 ID                   │
│ 클라이언트 → 서버: 푸시 ID                                    │
├─────────────────────────────────────────────────────────────┤
│ 지정된 ID 이상의 요청/푸시는 거부됨                            │
│ GOAWAY 수신 후 새 요청/푸시 시작 불가                         │
└─────────────────────────────────────────────────────────────┘
```

#### 정상 드레이닝을 위한 최대값

| 엔드포인트 | 최대 ID 값 |
|------------|------------|
| 서버 | 2^62-4 |
| 클라이언트 | 2^62-1 |

#### 다중 GOAWAY 프레임

```
- 여러 GOAWAY 프레임 전송 가능
- ID 값은 감소하지 않아야 함 (비증가)
- GOAWAY 전송 후 지정된 ID 이상의 요청/푸시를 명시적으로 취소해야 함 (SHOULD)
```

### 5.3 즉시 애플리케이션 종료

```
HTTP/3 구현체는 언제든지 QUIC 연결을 즉시 종료 가능
→ QUIC CONNECTION_CLOSE 프레임 전송
→ 애플리케이션 오류 코드로 종료 사유 표시

선택적으로 종료 전 GOAWAY 전송하여 재시도 기회 개선 가능
```

### 5.4 전송 종료

```
GOAWAY 프레임 없이 연결이 종료되면:
→ 클라이언트는 전송된 모든 요청(전체 또는 일부)이
→ 처리되었을 수 있다고 가정해야 함 (MUST)
→ 신중한 요청 재시도 처리 필요
```

---

## 6. 스트림 매핑 및 사용

### 6.1 양방향 스트림

#### 주요 기능

```
모든 클라이언트 시작 양방향 스트림: HTTP 요청 및 응답에 사용
→ 양방향 스트림이 응답과 요청의 쉬운 상관관계 보장
```

#### 스트림 번호 지정

| 요청 순서 | QUIC 스트림 ID |
|-----------|----------------|
| 첫 번째 요청 | 스트림 0 |
| 두 번째 요청 | 스트림 4 |
| 세 번째 요청 | 스트림 8 |
| n번째 요청 | 스트림 4*(n-1) |

#### 서버 요구사항

```
HTTP/3 서버는 병렬성 지원을 위해 다음을 구성해야 함 (SHOULD):
- 최소 스트림 허용량
- 흐름 제어 윈도우

권장: 최소 100개의 요청 스트림 동시 허용
```

#### 서버 시작 양방향 스트림

```
HTTP/3는 서버 시작 양방향 스트림을 명시적으로 금지
→ 수신 시 H3_STREAM_CREATION_ERROR 연결 오류
→ 확장이 허용하지 않는 한 금지
```

### 6.2 단방향 스트림

#### 일반 구조

단방향 스트림은 가변 길이 정수로 스트림 타입 표시자로 시작합니다:

```
┌─────────────────────────────────────┐
│         Stream Type (i)             │
├─────────────────────────────────────┤
│         Type-specific data...       │
└─────────────────────────────────────┘
```

#### 스트림 타입

| 타입 | 값 | 설명 |
|------|-----|------|
| Control Stream | 0x00 | 연결 동작 관리 프레임 전송 |
| Push Stream | 0x01 | 서버 푸시 약속 이행 |
| QPACK Encoder | RFC 9204 | QPACK 인코더 스트림 |
| QPACK Decoder | RFC 9204 | QPACK 디코더 스트림 |
| Reserved | 0x1f * N + 0x21 | 애플리케이션 레이어 패딩 |

#### 알 수 없는 스트림 타입 처리

```
지원하지 않는 스트림 타입 수신 시:
→ 읽기 중단 또는 데이터 폐기 (추가 처리 없이)
→ 연결 오류 트리거 금지 (MUST NOT)
```

### 6.2.1 제어 스트림

스트림 타입 0x00으로 표시되며, HTTP/3 프레임을 전송하여 연결 동작을 관리합니다.

#### 초기화 요구사항

```
각 측은 연결 시작 시 단일 제어 스트림을 시작하고
SETTINGS 프레임을 이 스트림의 첫 프레임으로 전송해야 함 (MUST)
```

#### 중요 제약사항

| 제약 | 위반 시 |
|------|---------|
| 피어당 하나의 제어 스트림만 허용 | 연결 오류 |
| SETTINGS가 첫 프레임이어야 함 | H3_MISSING_SETTINGS 연결 오류 |
| 어느 엔드포인트도 제어 스트림 종료 불가 | H3_CLOSED_CRITICAL_STREAM 연결 오류 |

#### 흐름 제어

```
엔드포인트는 제어 스트림 블로킹 방지를 위해
적절한 흐름 제어 크레딧 제공해야 함 (SHOULD)
→ 이 스트림이 전체 연결 동작 관리
```

### 6.2.2 푸시 스트림

서버 시작 단방향 스트림으로 서버 푸시 약속을 이행합니다.

#### 스트림 헤더 형식

```
┌─────────────────────────────────────┐
│    Stream Type (i) = 0x01           │
├─────────────────────────────────────┤
│           Push ID (i)               │
├─────────────────────────────────────┤
│   HTTP Response (HEADERS + DATA)    │
└─────────────────────────────────────┘
```

#### 제한사항

| 제한 | 위반 시 |
|------|---------|
| 서버만 푸시 스트림 시작 가능 | H3_STREAM_CREATION_ERROR |
| 각 푸시 ID는 고유해야 함 | H3_ID_ERROR 연결 오류 |

#### 클라이언트 고려사항

```
클라이언트는 푸시 스트림 헤더 읽기 전 읽기 중단 금지 (SHOULD NOT)
→ 클라이언트-서버 간 소비된 푸시 ID 불일치 발생 가능
```

### 6.2.3 예약된 스트림 타입

#### 지정

```
스트림 타입 공식: 0x1f * N + 0x21 (N은 음이 아닌 정수)

예: N=0 → 0x21, N=1 → 0x40, N=2 → 0x5f...
```

#### 목적

```
- 알 수 없는 스트림 타입 무시 요구사항 연습
- 애플리케이션 레이어 패딩 기능 제공
- 엔드포인트는 예약된 스트림 타입에 의미 부여 금지 (MUST NOT)
```

#### 처리

```
예약된 스트림은 다음으로 종료 가능:
- 깨끗하게 종료
- H3_NO_ERROR로 리셋
- 예약된 오류 코드로 리셋
```

### 일반 단방향 스트림 요구사항

```
최소 스트림 할당:
- 구현체는 피어가 최소 3개의 단방향 스트림 생성 허용 필수 (MUST)
  (1개 제어 + 2개 QPACK)

흐름 제어 크레딧:
- 각 단방향 스트림에 최소 1,024바이트 (SHOULD)

생성 우선순위:
- 중요 단방향 스트림(제어, QPACK) 우선 생성 (SHOULD)
```

---

## 7. HTTP 프레이밍 계층

### 7.1 프레임 레이아웃

모든 HTTP/3 프레임은 일관된 구조를 따릅니다:

```
┌─────────────────────────────────────┐
│         Frame Type (i)              │  ← 가변 길이 정수
├─────────────────────────────────────┤
│         Frame Length (i)            │  ← 가변 길이 정수 (바이트)
├─────────────────────────────────────┤
│         Frame Payload (*)           │  ← 실제 페이로드
└─────────────────────────────────────┘
```

#### 프레임 무결성 요구사항

```
프레임은 지정된 필드만 정확히 포함해야 함
→ 식별된 필드 후 추가 바이트
→ 끝 전에 종료
→ H3_FRAME_ERROR 연결 오류로 처리 필수 (MUST)
```

### 7.2 프레임 타입

| 타입 | 값 | 설명 | 허용 스트림 |
|------|-----|------|------------|
| DATA | 0x00 | 요청/응답 콘텐츠 | 요청, 푸시 |
| HEADERS | 0x01 | QPACK 인코딩된 헤더 섹션 | 요청, 푸시 |
| CANCEL_PUSH | 0x03 | 서버 푸시 취소 요청 | 제어 |
| SETTINGS | 0x04 | 구성 파라미터 | 제어 (첫 프레임) |
| PUSH_PROMISE | 0x05 | 푸시 ID와 약속된 요청 연결 | 요청 |
| GOAWAY | 0x07 | 정상적인 연결 종료 시작 | 제어 |
| MAX_PUSH_ID | 0x07 | 최대 허용 서버 푸시 ID 제어 | 제어 |
| Reserved | 0x1f * N + 0x21 | 예약됨 | - |

### 7.2.1 DATA 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x00                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│           Data (*)                  │
└─────────────────────────────────────┘
```

제약사항:
- 요청 또는 응답과 연관되어야 함
- 제어 스트림에서 수신 시 `H3_FRAME_UNEXPECTED` 연결 오류

### 7.2.2 HEADERS 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x01                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│    Encoded Field Section (*)        │  ← QPACK 인코딩
└─────────────────────────────────────┘
```

허용: 요청 및 푸시 스트림에서만 허용, 제어 스트림에서 금지

### 7.2.3 CANCEL_PUSH 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x03                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│         Push ID (i)                 │
└─────────────────────────────────────┘
```

역할: 푸시 ID로 서버 푸시 취소 요청
위치: 제어 스트림에서만 전송; 다른 곳에서 수신 시 연결 오류

### 7.2.4 SETTINGS 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x04                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│    Setting 1 Identifier (i)         │
│    Setting 1 Value (i)              │
├─────────────────────────────────────┤
│    Setting 2 Identifier (i)         │
│    Setting 2 Value (i)              │
├─────────────────────────────────────┤
│              ...                    │
└─────────────────────────────────────┘
```

요구사항:
- 각 피어의 제어 스트림 첫 프레임으로 전송 필수 (MUST)
- 이후 전송 금지 (MUST NOT)
- 동일 설정 식별자 중복 시 수신자가 연결 오류로 처리 가능

#### 정의된 SETTINGS 파라미터

| 식별자 | 이름 | 기본값 | 설명 |
|--------|------|--------|------|
| 0x01 | SETTINGS_QPACK_MAX_TABLE_CAPACITY | 0 | QPACK 동적 테이블 최대 용량 |
| 0x06 | SETTINGS_MAX_FIELD_SECTION_SIZE | 무제한 | 수락할 최대 헤더 크기 |
| 0x07 | SETTINGS_QPACK_BLOCKED_STREAMS | 0 | 블로킹될 수 있는 스트림 수 |

#### 예약된 설정

```
예약된 설정 식별자 공식: 0x1f * N + 0x21

목적:
- 알 수 없는 식별자 무시 요구사항 연습
- SETTINGS 프레임에 최소 하나 포함 권장 (SHOULD)
```

#### HTTP/2 레거시 설정

```
HTTP/2에서 정의되었지만 HTTP/3에 해당 항목이 없는 설정:
→ 전송 금지 (MUST NOT)
→ 수신 시 H3_SETTINGS_ERROR 연결 오류
```

### 7.2.5 PUSH_PROMISE 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x05                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│         Push ID (i)                 │
├─────────────────────────────────────┤
│    Encoded Field Section (*)        │
└─────────────────────────────────────┘
```

역할: 푸시 ID를 약속된 요청과 연결
위치: 요청 스트림에서 전송

### 7.2.6 GOAWAY 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x07                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│       Stream ID / Push ID (i)       │
└─────────────────────────────────────┘
```

역할: 정상적인 연결 종료 시작, 처리된/처리될 수 있는 요청/푸시 표시

### 7.2.7 MAX_PUSH_ID 프레임

```
┌─────────────────────────────────────┐
│      Type (i) = 0x07                │
├─────────────────────────────────────┤
│          Length (i)                 │
├─────────────────────────────────────┤
│         Push ID (i)                 │
└─────────────────────────────────────┘
```

역할: 최대 허용 서버 푸시 ID 제어, 클라이언트가 푸시 동시성 관리

### 7.2.8 예약된 프레임 타입

```
예약된 프레임 타입 공식: 0x1f * N + 0x21

처리:
- 알 수 없는 프레임 타입은 자체 규칙에 따라 허용될 수 있음
- 요청 또는 푸시 스트림에서 전송 가능 (MAY)
```

---

## 8. 오류 처리

### 8.1 오류 범주

```
HTTP/3의 오류는 전체 연결에 영향을 미치거나
개별 스트림에만 영향을 미칠 수 있음

연결 오류: 전체 HTTP/3 연결 종료
          → QUIC CONNECTION_CLOSE 프레임으로 전달

스트림 오류: 개별 스트림에만 영향
          → 스트림 리셋 메커니즘으로 전달
```

### 8.2 HTTP/3 오류 코드

| 오류 코드 | 값 | 설명 |
|-----------|-----|------|
| H3_NO_ERROR | 0x0100 | 오류 없는 정상적인 종료 |
| H3_GENERAL_PROTOCOL_ERROR | 0x0101 | 일반 프로토콜 위반 |
| H3_INTERNAL_ERROR | 0x0102 | 내부 구현 오류 |
| H3_STREAM_CREATION_ERROR | 0x0103 | 승인되지 않은 스트림 생성 |
| H3_CLOSED_CRITICAL_STREAM | 0x0104 | 중요 스트림 부적절한 종료 |
| H3_FRAME_UNEXPECTED | 0x0105 | 잘못된 스트림 타입에서 프레임 수신 |
| H3_FRAME_ERROR | 0x0106 | 프레임 형식 또는 파싱 오류 |
| H3_EXCESSIVE_LOAD | 0x0107 | 피어 동작이 과도한 부하 유발 |
| H3_ID_ERROR | 0x0108 | 잘못된 식별자 사용 |
| H3_SETTINGS_ERROR | 0x0109 | 잘못된 SETTINGS 파라미터 |
| H3_MISSING_SETTINGS | 0x010a | SETTINGS 프레임 미수신 |
| H3_REQUEST_REJECTED | 0x010b | 처리 없이 서버가 요청 거부 |
| H3_REQUEST_CANCELLED | 0x010c | 송신자가 요청 취소 |
| H3_REQUEST_INCOMPLETE | 0x010d | 스트림 종료 시 요청 불완전 |
| H3_MESSAGE_ERROR | 0x010e | 잘못된 형식의 HTTP 메시지 |
| H3_CONNECT_ERROR | 0x010f | CONNECT 메서드 TCP 오류 |
| H3_VERSION_FALLBACK | 0x0110 | 재시도 시 HTTP/1.1로 전환 권장 |

### 오류 코드 사용 지침

```
H3_NO_ERROR:
→ 연결 종료가 오류가 아님을 나타냄
→ GOAWAY 프레임에서 정상 드레인에 사용

H3_GENERAL_PROTOCOL_ERROR:
→ 더 구체적인 오류 코드가 없을 때 사용
→ 프로토콜 준수 문제의 일반적 표시

H3_INTERNAL_ERROR:
→ 구현 관련 문제
→ 프로토콜 위반이 아닌 내부 오류

H3_REQUEST_REJECTED vs H3_REQUEST_CANCELLED:
→ REJECTED: 처리되지 않음 (안전하게 재시도 가능)
→ CANCELLED: 처리 중 취소 (재시도 주의 필요)
```

---

## 9. HTTP/3 확장

### 9.1 확장 메커니즘

HTTP/3는 하위 호환성을 유지하면서 새로운 기능을 협상할 수 있는 확장을 허용합니다.

#### 프레임 확장

```
알 수 없는 프레임 타입:
→ 자체 규칙에 따라 허용될 수 있음
→ 요청 또는 푸시 스트림에서 전송 가능 (MAY)
```

#### 스트림 타입 확장

```
예약된 스트림 타입: 0x1f * N + 0x21
→ 새로운 기능 실험 가능
→ 프로토콜 충돌 없이 확장
```

#### 설정 파라미터 확장

```
예약된 설정 식별자: 0x1f * N + 0x21
→ 구현체는 이해하지 못하는 식별자 무시 필수 (MUST)
→ 향후 확장성 보장
```

### 9.2 일반 접근 방식

```
프로토콜 확장 원칙:
1. 알 수 없는 프레임 타입 무시
2. 알 수 없는 스트림 타입 폐기 또는 중단
3. 알 수 없는 설정 식별자 무시
→ 하위 호환성 유지
```

---

## 10. 보안 고려사항

### 10.1 서버 권한

```
권한 요구사항:
- HTTPS URI에 대해 RFC 9110의 인증서 검증 프로세스 준수 필수
- 권한에 http 또는 https 스킴 URI의 폐기된 userinfo 하위 구성요소 포함 금지 (MUST NOT)
- 적절한 검증으로 승인된 서버만 원본 가장 가능
```

### 10.2 교차 프로토콜 공격

```
HTTP/3는 전송 계층에 TLS 1.3 통합
→ TCP를 통한 TLS와 유사한 보호 제공
→ 암호화 핸드셰이크 통합으로 HTTP/3와 다른 서비스 간 프로토콜 혼란 악용 방지
```

### 10.3 중개자 캡슐화 공격

```
중개자 주의사항:
- HTTP/3 변환을 신중하게 처리해야 함
- HTTP/1.x 변환 중 연결 특정 헤더 제거 필요
- 부적절한 헤더 처리는 주입 공격에 시스템 노출 가능
```

### 10.4 푸시된 응답의 캐시 가능성

```
캐시 가능으로 표시된 푸시 응답:
→ 표준 HTTP 캐싱 지시어 준수 필수
→ 수신 시 원본 서버에서 성공적으로 검증된 것으로 간주

캐시 불가 푸시:
→ HTTP 캐시에 저장 금지 (MUST NOT)
```

### 10.5 서비스 거부 고려사항

#### 필드 섹션 크기 제한

```
구현체는 최대 헤더 크기 적용 가능
→ 서버는 과대 헤더를 431 상태 코드로 거부 가능
→ 버퍼 고갈 공격 방지
```

#### CONNECT 메서드 제한

```
CONNECT를 지원하는 프록시:
→ 알려진 포트 집합으로 사용 제한 권장 (SHOULD)
→ 임의 대상으로의 터널 남용 방지
```

### 10.6 압축 및 프라이버시

```
QPACK 설계 고려사항:
- 압축 효율성과 head-of-line 블로킹 지연 시간 균형
- 프레임 패딩 가용성이 트래픽 분석 완화 지원
```

### 10.7 프레임 파싱 견고성

```
프레임 경계의 엄격한 검증:
→ 버퍼 오버플로우 방지
→ 깨끗한 스트림 종료 시 잘린 프레임은 연결 오류 트리거
→ 파싱 안전성 보장
```

### 10.8 초기 데이터 및 마이그레이션

```
0-RTT 재생 보호:
→ 요청 복제 방지를 위한 신중한 구현 필요

연결 마이그레이션 보안:
→ 주소 스푸핑 공격 방지를 위한 적절한 처리 필요
```

---

## 11. IANA 고려사항

### 11.1 HTTP/3 식별 문자열 등록

```
ALPN 토큰: "h3"
목적: TLS 핸드셰이크 중 HTTP/3 프로토콜 협상
```

### 11.2 새 레지스트리

#### 11.2.1 프레임 타입 레지스트리

| 프레임 | 값 |
|--------|-----|
| DATA | 0x00 |
| HEADERS | 0x01 |
| CANCEL_PUSH | 0x03 |
| SETTINGS | 0x04 |
| PUSH_PROMISE | 0x05 |
| GOAWAY | 0x07 |
| MAX_PUSH_ID | 0x07 |
| Reserved | 0x1f * N + 0x21 |

#### 11.2.2 설정 파라미터 레지스트리

| 설정 | 값 |
|------|-----|
| SETTINGS_QPACK_MAX_TABLE_CAPACITY | 0x01 |
| SETTINGS_MAX_FIELD_SECTION_SIZE | 0x06 |
| SETTINGS_QPACK_BLOCKED_STREAMS | 0x07 |
| Reserved | 0x1f * N + 0x21 |

#### 11.2.3 오류 코드 레지스트리

섹션 8.1에 정의된 연결 및 스트림 오류에 대한 오류 코드 할당 설정

#### 11.2.4 스트림 타입 레지스트리

| 스트림 타입 | 값 |
|------------|-----|
| Control | 0x00 |
| Push | 0x01 |
| Reserved | 0x1f * N + 0x21 |
| QPACK Encoder/Decoder | RFC 9204에서 별도 정의 |

---

## 부록 A: HTTP/2에서 HTTP/3로의 전환

### A.1 스트림 차이점

#### 핵심 변화

```
HTTP/2: 애플리케이션 레이어에서 멀티플렉싱 계층 관리
HTTP/3: QUIC 전송 레이어로 멀티플렉싱 이동

결과:
- 한 스트림의 패킷 손실이 다른 스트림 진행 방해 안 함
- 전송 신뢰성 및 흐름 제어가 QUIC에서 처리
```

#### 스트림 관리

| 항목 | HTTP/2 | HTTP/3 |
|------|--------|--------|
| 스트림 관리 위치 | 애플리케이션 레이어 | QUIC 레이어 |
| 신뢰성 | 애플리케이션에서 관리 | QUIC 제공 |
| 흐름 제어 | 애플리케이션 레벨 WINDOW_UPDATE | QUIC 레벨 |

### A.2 프레임 타입 비교

#### 공통 프레임

| 프레임 | HTTP/2 | HTTP/3 |
|--------|--------|--------|
| DATA | O | O |
| HEADERS | O | O |
| SETTINGS | O | O |
| GOAWAY | O | O |
| PUSH_PROMISE | O | O |

#### HTTP/3 신규 프레임

```
CANCEL_PUSH: 푸시 취소 전용
MAX_PUSH_ID: 푸시 동시성 제어
→ QPACK 동적 테이블 관리를 위한 별도 스트림 활용
```

#### HTTP/3에서 제거된 프레임

| 프레임 | 제거 이유 |
|--------|----------|
| PRIORITY | QUIC의 스트림 독립성으로 불필요 |
| RST_STREAM | QUIC의 스트림 리셋 메커니즘 사용 |
| WINDOW_UPDATE | QUIC 레벨 흐름 제어 사용 |
| CONTINUATION | HEADERS가 자체 완전한 단위 |
| PING | QUIC 레벨 연결 유지 사용 |

### A.3 우선순위 메커니즘

```
HTTP/2: 복잡한 우선순위 시스템 (의존성 트리, 가중치)
HTTP/3: 제거됨

이유: QUIC 계층의 스트림 독립성 보장
→ 한 스트림의 지연이 다른 스트림에 영향 없음
```

### A.4 필드 압축 변화

| 항목 | HTTP/2 (HPACK) | HTTP/3 (QPACK) |
|------|----------------|----------------|
| 순서 의존성 | 있음 | 제거됨 |
| 동적 테이블 업데이트 | 헤더 블록 내 | 별도 스트림 |
| HOL 블로킹 | 발생 가능 | 인코더 제어 가능 |

### A.5 흐름 제어 차이

```
HTTP/2:
- 애플리케이션 레이어 흐름 제어 (WINDOW_UPDATE)
- 연결 및 스트림 레벨

HTTP/3:
- QUIC 레이어에서 기본 처리
- WINDOW_UPDATE 프레임 없음
- 스트림 레벨 흐름 제어는 QUIC에서 관리
```

### A.6 오류 코드 매핑

| HTTP/2 | HTTP/3 | 비고 |
|--------|--------|------|
| NO_ERROR | H3_NO_ERROR | |
| PROTOCOL_ERROR | H3_GENERAL_PROTOCOL_ERROR | |
| INTERNAL_ERROR | H3_INTERNAL_ERROR | |
| FLOW_CONTROL_ERROR | (제거) | QUIC에서 처리 |
| SETTINGS_TIMEOUT | (제거) | QUIC 핸드셰이크 |
| STREAM_CLOSED | H3_STREAM_CREATION_ERROR | |
| FRAME_SIZE_ERROR | H3_FRAME_ERROR | |
| REFUSED_STREAM | H3_REQUEST_REJECTED | |
| CANCEL | H3_REQUEST_CANCELLED | |
| COMPRESSION_ERROR | H3_GENERAL_PROTOCOL_ERROR | QPACK 오류 |
| CONNECT_ERROR | H3_CONNECT_ERROR | |
| ENHANCE_YOUR_CALM | H3_EXCESSIVE_LOAD | |
| INADEQUATE_SECURITY | (제거) | QUIC/TLS에서 처리 |

### A.7 핵심 전환 전략

```
1. QUIC 기본 기능 활용
   → 전송 신뢰성 및 흐름 제어 위임

2. 프레임 세트 축소
   → 복잡성 감소, 구현 단순화

3. QPACK 도입
   → 더 나은 압축 성능, HOL 블로킹 제어

4. 단방향 스트림 활용
   → 제어 채널 분리, 독립적 데이터 흐름
```

---

## HTTP/2 vs HTTP/3 비교 요약

| 특성 | HTTP/2 | HTTP/3 |
|------|--------|--------|
| 전송 프로토콜 | TCP | QUIC (UDP 기반) |
| 암호화 | TLS 선택적 | TLS 1.3 필수 (내장) |
| 멀티플렉싱 | 애플리케이션 레이어 | 전송 레이어 |
| HOL 블로킹 | TCP 레벨에서 발생 | 스트림별로 격리 |
| 헤더 압축 | HPACK | QPACK |
| 연결 설정 | TCP + TLS 핸드셰이크 | 0-RTT / 1-RTT |
| 흐름 제어 | 애플리케이션 레벨 | QUIC 레벨 |
| 연결 마이그레이션 | 지원 안 함 | 연결 ID로 지원 |
| 서버 푸시 | PUSH_PROMISE | PUSH_PROMISE + MAX_PUSH_ID |

---

## 요약

RFC 9114 HTTP/3는 다음을 제공합니다:

- QUIC 기반 전송: UDP 위의 신뢰성 있는 멀티플렉싱 전송
- Head-of-Line 블로킹 해결: 스트림별 독립적 전달
- 저지연 연결 설정: 0-RTT 및 1-RTT 핸드셰이크
- QPACK 헤더 압축: HPACK 개선, HOL 블로킹 제어 가능
- 통합 보안: TLS 1.3이 전송 레이어에 내장
- 연결 마이그레이션: 네트워크 변경 시에도 연결 유지
- 개선된 서버 푸시: MAX_PUSH_ID로 푸시 동시성 제어

HTTP/3는 HTTP의 시맨틱을 유지하면서 QUIC의 장점을 활용하여 성능과 보안을 획기적으로 개선합니다.

---

## 참고 자료

- [RFC 9114 원문 (IETF)](https://datatracker.ietf.org/doc/html/rfc9114)
- [RFC 9000 - QUIC: A UDP-Based Multiplexed and Secure Transport](https://datatracker.ietf.org/doc/html/rfc9000)
- [RFC 9204 - QPACK: Field Compression for HTTP/3](https://datatracker.ietf.org/doc/html/rfc9204)
- [RFC 9110 - HTTP Semantics](https://datatracker.ietf.org/doc/html/rfc9110)
- [RFC 7540 - HTTP/2](https://datatracker.ietf.org/doc/html/rfc7540)

---

## 관련 RFC

| RFC | 제목 | 관계 |
|-----|------|------|
| RFC 9000 | QUIC 전송 프로토콜 | HTTP/3의 기반 전송 |
| RFC 9001 | QUIC에서 TLS 1.3 사용 | QUIC 보안 |
| RFC 9002 | QUIC 손실 감지 및 혼잡 제어 | QUIC 성능 |
| RFC 9204 | QPACK | HTTP/3 헤더 압축 |
| RFC 9110 | HTTP 시맨틱 | HTTP 기본 시맨틱 |
| RFC 9111 | HTTP 캐싱 | HTTP 캐싱 동작 |
| RFC 7540 | HTTP/2 | 이전 버전 |

---

*이 문서는 RFC 9114의 한국어 번역 및 정리본입니다.*
