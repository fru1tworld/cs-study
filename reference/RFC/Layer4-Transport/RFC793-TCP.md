# RFC 793: Transmission Control Protocol (TCP)

## 개요

RFC 793은 1981년 9월에 발표된 전송 제어 프로토콜(TCP) 의 기본 명세서입니다. 이 문서는 TCP의 바이블로 불리며, 현대 인터넷 통신의 기반이 되는 핵심 프로토콜을 정의합니다.

> "TCP는 패킷 스위칭 컴퓨터 통신 네트워크에서 호스트 간에 높은 신뢰성을 제공하는 호스트-투-호스트 프로토콜이다."

## 핵심 기능

TCP는 다음과 같은 핵심 기능을 제공합니다:

| 기능 | 설명 |
|-----|------|
| 기본 데이터 전송 | 옥텟(바이트) 스트림을 통한 데이터 전송 |
| 신뢰성 | 순서 번호와 확인 응답을 통한 신뢰성 보장 |
| 흐름 제어 | 윈도잉 메커니즘을 통한 데이터 흐름 조절 |
| 다중화 | 포트 번호를 통한 다중 연결 지원 |
| 연결 관리 | 3-way 핸드셰이크를 통한 연결 설정 |
| 우선순위 및 보안 | 우선순위 및 보안 기능 지원 |

## 연결 관리

### TCP 상태 머신

TCP는 11개의 상태 를 가진 상태 머신을 사용합니다:

```
┌─────────────────────────────────────────────────────────────┐
│                        CLOSED                                │
│                           │                                  │
│    ┌──────────────────────┴──────────────────────┐          │
│    ↓                                              ↓          │
│  LISTEN                                      SYN-SENT       │
│    │                                              │          │
│    ↓                                              ↓          │
│  SYN-RECEIVED ←──────────────────────────────────┘          │
│    │                                                         │
│    ↓                                                         │
│  ESTABLISHED ←───────────────────────────────────────────────┤
│    │                                                         │
│    ├─────────────┬────────────────────┐                     │
│    ↓             ↓                    ↓                     │
│  FIN-WAIT-1   CLOSE-WAIT          CLOSING                   │
│    │             │                    │                     │
│    ↓             ↓                    │                     │
│  FIN-WAIT-2   LAST-ACK               │                     │
│    │             │                    │                     │
│    ↓             ↓                    ↓                     │
│  TIME-WAIT ──────┴────────────────────┘                     │
│    │                                                         │
│    ↓                                                         │
│  CLOSED                                                      │
└─────────────────────────────────────────────────────────────┘
```

### 상태 설명

| 상태 | 설명 |
|-----|------|
| CLOSED | 연결 없음 (초기 상태) |
| LISTEN | 원격 연결 요청 대기 중 |
| SYN-SENT | SYN 전송 후 응답 대기 중 |
| SYN-RECEIVED | SYN 수신 후 SYN-ACK 전송, ACK 대기 중 |
| ESTABLISHED | 연결 수립됨, 데이터 전송 가능 |
| FIN-WAIT-1 | FIN 전송 후 ACK 또는 FIN 대기 중 |
| FIN-WAIT-2 | FIN의 ACK 수신, 원격 FIN 대기 중 |
| CLOSE-WAIT | 원격 FIN 수신, 로컬 종료 대기 중 |
| CLOSING | 양쪽 모두 동시에 FIN 전송 |
| LAST-ACK | FIN 전송 후 마지막 ACK 대기 중 |
| TIME-WAIT | 원격에서 FIN의 ACK 수신 확인 대기 (2MSL) |

## ISN (Initial Sequence Number) 선택

### 개념

TCP 연결 시 사용되는 초기 순서 번호(ISN) 는 보안과 신뢰성을 위해 신중하게 선택되어야 합니다.

### 선택 방법

RFC 793에서는 ISN 생성을 위해 32비트 클럭 기반 방식 을 권장합니다:

```
ISN = (현재 시간 × 상수) mod 2^32
```

- 클럭 주기: 약 4마이크로초마다 1씩 증가
- 순환 주기: 약 4.55시간마다 전체 순서 번호 공간 순환
- 목적: 이전 연결의 세그먼트가 새 연결에서 유효한 것으로 오인되는 것 방지

### ISN 선택의 중요성

| 문제 | 설명 |
|-----|------|
| 오래된 중복 | 네트워크에 남아있는 이전 세그먼트가 새 연결에 영향 |
| 예측 공격 | 예측 가능한 ISN은 TCP 세션 하이재킹에 취약 |
| 연결 혼동 | 동일한 소켓 쌍의 이전/새 연결 간 데이터 혼동 |

### 현대적 ISN 생성

보안 강화를 위해 현대 구현에서는 암호학적 의사 난수 생성기(CSPRNG) 를 사용합니다:

```
ISN = Hash(로컬IP, 로컬포트, 원격IP, 원격포트, 비밀키) + 시간 기반 값
```

## 3-Way Handshake (연결 수립)

TCP 연결은 3-way 핸드셰이크 를 통해 수립됩니다:

```
    클라이언트                                서버
        │                                      │
        │         1. SYN (seq=x)               │
        │─────────────────────────────────────→│
        │                                      │
        │     2. SYN-ACK (seq=y, ack=x+1)     │
        │←─────────────────────────────────────│
        │                                      │
        │         3. ACK (ack=y+1)             │
        │─────────────────────────────────────→│
        │                                      │
        │         연결 수립 완료                │
        │                                      │
```

### 단계별 설명

1. SYN: 시작자(클라이언트)가 초기 순서 번호(ISN)와 함께 SYN 패킷 전송
2. SYN-ACK: 응답자(서버)가 SYN을 확인하고 자신의 순서 번호와 함께 SYN-ACK 전송
3. ACK: 시작자가 양쪽 순서 번호를 확인하는 ACK 전송

## 동시 연결 (Simultaneous Open)

두 호스트가 동시에 서로에게 연결을 시도하는 경우입니다.

### 동작 과정

```
    호스트 A                                  호스트 B
        │                                        │
        │  SYN (seq=x) ────────────────────────→│
        │←──────────────────────────── SYN (seq=y)
        │                                        │
        │  (양쪽 모두 SYN-RECEIVED 상태)          │
        │                                        │
        │  SYN-ACK (seq=x, ack=y+1) ───────────→│
        │←─────────────── SYN-ACK (seq=y, ack=x+1)
        │                                        │
        │  (양쪽 모두 ESTABLISHED 상태)           │
        │                                        │
```

### 상태 전이

1. 양쪽 모두 CLOSED → SYN-SENT 상태로 전이
2. 상대방의 SYN 수신 시 SYN-SENT → SYN-RECEIVED 상태로 전이
3. SYN-ACK 교환 후 양쪽 모두 ESTABLISHED 상태로 전이

### 특징

- 정상적인 3-way 핸드셰이크와 달리 4개의 세그먼트 교환
- 결과적으로 하나의 연결 만 수립됨
- 실제로는 드문 상황이지만 TCP 명세에 정의된 정상 동작

## 4-Way Handshake (연결 종료)

TCP 연결 종료는 4-way 핸드셰이크 를 통해 이루어집니다:

```
    클라이언트                                서버
        │                                      │
        │         1. FIN (seq=x)               │
        │─────────────────────────────────────→│
        │                                      │
        │         2. ACK (ack=x+1)             │
        │←─────────────────────────────────────│
        │                                      │
        │         3. FIN (seq=y)               │
        │←─────────────────────────────────────│
        │                                      │
        │         4. ACK (ack=y+1)             │
        │─────────────────────────────────────→│
        │                                      │
        │         연결 종료 완료                │
        │                                      │
```

## 동시 종료 (Simultaneous Close)

두 호스트가 동시에 연결 종료를 시도하는 경우입니다.

### 동작 과정

```
    호스트 A                                  호스트 B
        │                                        │
        │  FIN (seq=x) ────────────────────────→│
        │←──────────────────────────── FIN (seq=y)
        │                                        │
        │  (양쪽 모두 CLOSING 상태)               │
        │                                        │
        │  ACK (ack=y+1) ─────────────────────→│
        │←───────────────────────── ACK (ack=x+1)
        │                                        │
        │  (양쪽 모두 TIME-WAIT 상태)             │
        │                                        │
```

### 상태 전이

1. 양쪽 모두 ESTABLISHED → FIN-WAIT-1 상태로 전이 (FIN 전송)
2. 상대방의 FIN 수신 시 FIN-WAIT-1 → CLOSING 상태로 전이
3. ACK 수신 후 양쪽 모두 TIME-WAIT 상태로 전이
4. 2MSL 타임아웃 후 CLOSED 상태로 전이

### 특징

- CLOSING 상태는 동시 종료에서만 발생
- 양쪽 모두 TIME-WAIT 상태를 거침
- 일반적인 4-way 핸드셰이크와 다른 상태 전이 경로

## SYN/FIN 시퀀스 번호 소비

### 개념

TCP에서 SYN 과 FIN 플래그는 각각 시퀀스 번호 공간에서 1바이트를 소비 합니다.

### 동작 원리

```
┌────────────────────────────────────────────────────────────┐
│  세그먼트 유형        │  시퀀스 번호 소비                    │
├────────────────────────────────────────────────────────────┤
│  SYN                 │  1 (데이터 없어도)                   │
│  FIN                 │  1 (데이터 없어도)                   │
│  데이터              │  데이터 바이트 수                    │
│  ACK만               │  0 (시퀀스 번호 소비 없음)           │
└────────────────────────────────────────────────────────────┘
```

### 예시: 연결 수립

```
    클라이언트 (ISN=100)                    서버 (ISN=300)
        │                                        │
        │  SYN, seq=100 ──────────────────────→│
        │  (100번 소비, 다음 seq=101)            │
        │                                        │
        │←────────────── SYN-ACK, seq=300, ack=101
        │                (300번 소비, 다음 seq=301)
        │                                        │
        │  ACK, seq=101, ack=301 ─────────────→│
        │                                        │
```

### 예시: 연결 종료

```
    클라이언트 (seq=1000)                   서버 (seq=2000)
        │                                        │
        │  FIN, seq=1000 ─────────────────────→│
        │  (1000번 소비, 다음 seq=1001)          │
        │                                        │
        │←────────────────────── ACK, ack=1001  │
        │                                        │
```

### 중요성

- ACK 번호 계산: SYN/FIN 수신 시 ACK = seq + 1
- 신뢰성 보장: SYN/FIN도 확인 응답 대상
- 재전송 가능: 손실된 SYN/FIN은 타임아웃 시 재전송

## TCP 헤더 구조

TCP 헤더는 최소 20바이트 로 구성됩니다:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |       |U|A|P|R|S|F|                                   |
| Offset| Rsrvd |R|C|S|S|Y|I|            Window                 |
|       |       |G|K|H|T|N|N|                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 헤더 필드 설명

| 필드 | 크기 | 설명 |
|-----|------|------|
| Source Port | 16비트 | 송신 포트 번호 |
| Destination Port | 16비트 | 수신 포트 번호 |
| Sequence Number | 32비트 | 세그먼트 데이터의 첫 번째 바이트 순서 번호 |
| Acknowledgment Number | 32비트 | 다음에 받을 것으로 예상되는 순서 번호 |
| Data Offset | 4비트 | 데이터 시작 위치 (헤더 길이) |
| Reserved | 6비트 | 예약됨 (0으로 설정) |
| Control Flags | 6비트 | URG, ACK, PSH, RST, SYN, FIN |
| Window | 16비트 | 수신 가능한 바이트 수 |
| Checksum | 16비트 | 오류 검출용 체크섬 |
| Urgent Pointer | 16비트 | 긴급 데이터의 끝 위치 |
| Options | 가변 | 추가 옵션 (MSS, Window Scale 등) |

## Pseudo Header와 체크섬 계산

### Pseudo Header 구조

TCP 체크섬 계산 시 실제 TCP 세그먼트 외에 Pseudo Header 를 포함합니다:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Source Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Destination Address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      zero     |   Protocol    |          TCP Length           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### Pseudo Header 필드

| 필드 | 크기 | 설명 |
|-----|------|------|
| Source Address | 32비트 | IP 헤더의 송신자 IP 주소 |
| Destination Address | 32비트 | IP 헤더의 수신자 IP 주소 |
| Zero | 8비트 | 0으로 설정 |
| Protocol | 8비트 | IP 프로토콜 번호 (TCP = 6) |
| TCP Length | 16비트 | TCP 헤더 + 데이터 길이 (바이트) |

### 체크섬 계산 과정

1. 데이터 준비: Pseudo Header + TCP Header + Data
2. 패딩: 총 길이가 홀수이면 0으로 패딩
3. 16비트 분할: 데이터를 16비트 단위로 분할
4. 1의 보수 합: 모든 16비트 값을 1의 보수로 더함
5. 캐리 추가: 오버플로우 발생 시 하위 16비트에 캐리 추가
6. 1의 보수: 최종 합의 1의 보수가 체크섬

```
체크섬 계산 예시:

Pseudo Header (12 bytes) + TCP Segment
    ↓
16비트 단위로 분할
    ↓
[Word1] + [Word2] + [Word3] + ... + [WordN]
    ↓
1의 보수 합 계산 (오버플로우 시 캐리 추가)
    ↓
결과의 1의 보수 = 체크섬
```

### 검증 과정

- 수신 측에서 동일한 방식으로 계산
- 결과가 0xFFFF 이면 체크섬 유효
- 체크섬 실패 시 세그먼트 폐기 (ACK 전송 안 함)

### Pseudo Header의 목적

- 잘못된 라우팅 감지: IP 주소 포함으로 다른 호스트로 잘못 전달된 패킷 감지
- 프로토콜 검증: 올바른 프로토콜로 전달되었는지 확인
- 길이 검증: 세그먼트 길이 무결성 확인

### 제어 플래그 (Control Flags)

| 플래그 | 설명 |
|-------|------|
| URG | 긴급 포인터 필드가 유효함 |
| ACK | 확인 번호 필드가 유효함 |
| PSH | 푸시 기능 - 버퍼링 없이 즉시 전달 |
| RST | 연결 리셋 |
| SYN | 순서 번호 동기화 (연결 시작) |
| FIN | 송신자의 데이터 전송 종료 |

## TCP Options 상세

### 옵션 구조

TCP 옵션은 헤더의 Options 필드에 위치하며, 32비트 경계로 패딩 됩니다.

### 옵션 형식

TCP 옵션은 두 가지 형식이 있습니다:

```
단일 바이트 옵션:
+--------+
|  Kind  |
+--------+

다중 바이트 옵션:
+--------+--------+--------+--------+
|  Kind  | Length |       Data...   |
+--------+--------+--------+--------+
```

### RFC 793 정의 옵션

#### 1. End of Option List (Kind = 0)

```
+--------+
|00000000|
+--------+
 Kind=0
```

- 길이: 1바이트 (Length 필드 없음)
- 목적: 옵션 리스트의 끝을 표시
- 특징: 반드시 옵션의 끝에 위치, 32비트 경계까지 패딩 불필요 시 사용
- 사용: 한 번만 사용 가능

#### 2. No-Operation (NOP, Kind = 1)

```
+--------+
|00000001|
+--------+
 Kind=1
```

- 길이: 1바이트 (Length 필드 없음)
- 목적: 옵션 사이의 패딩/정렬
- 특징: 다음 옵션을 특정 경계에 정렬할 때 사용
- 사용: 여러 번 사용 가능

#### 3. Maximum Segment Size (MSS, Kind = 2)

```
+--------+--------+---------+---------+
|00000010|00000100|   MSS (16 bits)   |
+--------+--------+---------+---------+
 Kind=2   Len=4
```

- 길이: 4바이트
- 목적: 수신 가능한 최대 세그먼트 크기 협상
- 특징: SYN 세그먼트에서만 전송 가능
- 기본값: MSS 옵션 없으면 536바이트 가정
- 계산: MTU - IP헤더(20) - TCP헤더(20) = MSS

### 옵션 사용 예시

```
일반적인 SYN 세그먼트 옵션:

+--------+--------+---------+---------+--------+
|00000010|00000100|    MSS = 1460     |00000000|
+--------+--------+---------+---------+--------+
 MSS Option (4 bytes)                  End of Option

또는 NOP를 사용한 정렬:

+--------+--------+--------+---------+---------+--------+
|00000001|00000001|00000010|00000100 |MSS=1460 |00000000|
+--------+--------+--------+---------+---------+--------+
 NOP      NOP      MSS Option (4 bytes)         End
```

### MSS 협상 과정

```
    클라이언트                                서버
        │                                      │
        │  SYN, MSS=1460 ────────────────────→│
        │                                      │
        │←──────────────── SYN-ACK, MSS=1380  │
        │                                      │
        │  (양측은 상대방의 MSS를 사용)          │
        │  클라이언트→서버: 최대 1380바이트      │
        │  서버→클라이언트: 최대 1460바이트      │
```

## 순서 번호 (Sequence Numbers)

### 개념

- 32비트 공간 을 사용하여 신뢰성 있는 순서 지정 가능
- 중복 감지 및 흐름 제어 지원
- 잠재적으로 신뢰할 수 없는 네트워크에서도 데이터 무결성 보장

### 동작 방식

```
송신자                                    수신자
   │                                        │
   │  Seq=1000, Data="Hello" (5 bytes)     │
   │───────────────────────────────────────→│
   │                                        │
   │          Ack=1005                      │
   │←───────────────────────────────────────│
   │                                        │
   │  Seq=1005, Data="World" (5 bytes)     │
   │───────────────────────────────────────→│
   │                                        │
   │          Ack=1010                      │
   │←───────────────────────────────────────│
```

## 신뢰성 메커니즘

### 1. 체크섬 검증 (Checksum Validation)

- 헤더와 데이터의 무결성 검증
- 손상된 세그먼트는 폐기

### 2. 타임아웃 기반 재전송 (Timeout-Based Retransmission)

```
송신자                                    수신자
   │                                        │
   │  Seq=1000 ─────────────────────────────│
   │───────────────────────────────────────→│
   │                                        │
   │  (타임아웃 - ACK 미수신)               │
   │                                        │
   │  Seq=1000 (재전송) ───────────────────│
   │───────────────────────────────────────→│
   │                                        │
   │          Ack=1005                      │
   │←───────────────────────────────────────│
```

### 3. 누적 확인 응답 (Cumulative Acknowledgments)

- 수신된 연속 데이터의 마지막 바이트+1을 ACK로 전송
- 이전의 모든 데이터가 성공적으로 수신되었음을 의미

## 흐름 제어 (Flow Control)

### 슬라이딩 윈도우 (Sliding Window)

```
┌─────────────────────────────────────────────────────────────┐
│  전송 완료  │  전송 가능  │     윈도우 범위      │  전송 불가  │
│   (ACK 됨)  │  (미ACK)   │    (전송 가능)       │            │
└─────────────────────────────────────────────────────────────┘
      ↑             ↑              ↑                    ↑
   확인됨      전송됨         윈도우 크기           대기 중
```

- 수신자가 Window 필드를 통해 처리 가능한 데이터 양 알림
- 송신자는 확인 응답 없이 윈도우 크기만큼만 전송 가능
- 수신자 버퍼 오버플로우 방지

## Zero Window와 Window Probe 메커니즘

### Zero Window 상황

수신자의 버퍼가 가득 차면 Window = 0 을 광고하여 송신자에게 전송 중단을 요청합니다.

```
    송신자                                    수신자
        │                                        │
        │  Data (seq=1000, 500 bytes) ─────────→│
        │                                        │ ← 버퍼 가득 참
        │←──────────────── ACK, Window=0        │
        │                                        │
        │  (송신 중단, 윈도우 열림 대기)          │
        │                                        │
```

### Window Probe (윈도우 탐색)

Zero Window 상황에서 교착 상태(Deadlock) 를 방지하기 위한 메커니즘입니다.

#### 교착 상태 문제

1. 수신자가 Window=0 전송
2. 수신자 버퍼에 공간 생김, Window 업데이트 ACK 전송
3. ACK가 손실되면 송신자는 영원히 대기
4. 수신자도 데이터를 기다리며 대기 → 교착 상태

#### Window Probe 동작

```
    송신자                                    수신자
        │                                        │
        │←──────────────── ACK, Window=0        │
        │                                        │
        │  (Persist Timer 시작)                  │
        │                                        │
        │  Window Probe (1 byte) ──────────────→│
        │                                        │
        │←──────────────── ACK, Window=0        │
        │  (아직 버퍼 부족)                       │
        │                                        │
        │  (Persist Timer 재시작, 지수 백오프)    │
        │                                        │
        │  Window Probe (1 byte) ──────────────→│
        │                                        │
        │←──────────────── ACK, Window=4096     │
        │  (버퍼 공간 확보됨)                     │
        │                                        │
        │  Data 전송 재개 ─────────────────────→│
```

### Persist Timer (지속 타이머)

| 항목 | 설명 |
|-----|------|
| 초기값 | RTO (재전송 타임아웃) 기반 |
| 증가 방식 | 지수 백오프 (1초, 2초, 4초, ...) |
| 최대값 | 일반적으로 60초 |
| 동작 | 타이머 만료 시 Window Probe 전송 |

### Silly Window Syndrome (SWS) 방지

작은 윈도우 광고로 인한 비효율을 방지합니다:

#### 수신자 측 (Clark's Algorithm)
- 충분한 공간 확보 전까지 Window=0 유지
- 조건: min(MSS, 버퍼크기/2) 이상일 때만 윈도우 열림

#### 송신자 측 (Nagle's Algorithm)
- 작은 세그먼트 전송 억제
- 조건: MSS 이상이거나 이전 데이터의 ACK 수신 시 전송

## 혼잡 제어 (Congestion Control)

RFC 793 이후 추가된 혼잡 제어 메커니즘들:

### 1. 슬로우 스타트 (Slow Start)
- 연결 초기에 작은 윈도우로 시작
- 성공적인 전송마다 윈도우 크기 증가

### 2. 혼잡 회피 (Congestion Avoidance)
- 임계값 도달 후 선형적으로 윈도우 증가

### 3. 빠른 재전송 (Fast Retransmit)
- 3개의 중복 ACK 수신 시 즉시 재전송

### 4. 빠른 복구 (Fast Recovery)
- 빠른 재전송 후 슬로우 스타트 없이 복구

## TIME-WAIT 상태 상세

### 개념

TIME-WAIT 는 TCP 연결 종료 후 일정 시간 동안 유지되는 상태입니다.

### 2MSL (Maximum Segment Lifetime)

| 항목 | 설명 |
|-----|------|
| MSL 정의 | 세그먼트가 네트워크에서 존재할 수 있는 최대 시간 |
| RFC 793 권장값 | 2분 (120초) |
| 실제 구현 | 30초 ~ 2분 (OS에 따라 다름) |
| TIME-WAIT 지속 | 2 × MSL = 일반적으로 1~4분 |

### TIME-WAIT 상태 전이

```
    능동 종료자 (Active Closer)              수동 종료자 (Passive Closer)
        │                                        │
        │  FIN ───────────────────────────────→│
        │  (FIN-WAIT-1)                          │
        │                                        │
        │←─────────────────────────────── ACK  │
        │  (FIN-WAIT-2)                          │
        │                                        │
        │←─────────────────────────────── FIN  │
        │                                        │
        │  ACK ───────────────────────────────→│
        │  (TIME-WAIT 시작)                      │
        │                                        │
        │  ┌─────────────────────┐              │
        │  │  2MSL 타이머 대기    │              │
        │  │  (약 1~4분)         │              │
        │  └─────────────────────┘              │
        │                                        │
        │  (CLOSED)                              │
```

### TIME-WAIT의 목적

#### 1. 마지막 ACK 손실 대비

```
    능동 종료자                              수동 종료자
        │                                        │
        │  ACK (마지막) ─────────X 손실          │
        │  (TIME-WAIT)                           │
        │                                        │
        │←─────────────────────── FIN (재전송)  │
        │                                        │
        │  ACK (재전송) ────────────────────────→│
        │                                        │
```

- 마지막 ACK가 손실되면 수동 종료자는 FIN을 재전송
- TIME-WAIT 상태에서 FIN 수신 시 ACK 재전송 가능

#### 2. 오래된 중복 세그먼트 방지

```
이전 연결의 세그먼트가 새 연결에 영향을 주는 것을 방지:

┌─────────────────────────────────────────────────────────────┐
│  시간                                                        │
│  ────────────────────────────────────────────────────────→  │
│                                                              │
│  [연결 1]        [TIME-WAIT]        [연결 2 가능]            │
│  └──────┘        └─────────┘        └───────────┘           │
│                  ← 2MSL →                                    │
│                                                              │
│  지연된 세그먼트가 2MSL 내에 도착하면                          │
│  새 연결에 영향 없이 폐기됨                                    │
└─────────────────────────────────────────────────────────────┘
```

### TIME-WAIT 관련 문제

| 문제 | 설명 | 해결책 |
|-----|------|-------|
| 포트 고갈 | 많은 연결 시 TIME-WAIT 소켓 누적 | SO_REUSEADDR 옵션 |
| 메모리 사용 | TIME-WAIT 소켓도 자원 소비 | tcp_tw_reuse, tcp_tw_recycle |
| 서버 재시작 | 바인딩 실패 가능 | SO_REUSEADDR 옵션 |

### TIME-WAIT Assassination

RFC 1337에서 설명하는 보안 고려사항:

- TIME-WAIT 상태에서 RST 수신 시 즉시 CLOSED로 전이할 수 있음
- 이로 인해 오래된 세그먼트 문제 발생 가능
- 권장: TIME-WAIT에서 RST 무시 (RFC 1337)

## RST (Reset) 처리 규칙

### RST 세그먼트 생성 조건

TCP는 다음 상황에서 RST 세그먼트 를 생성합니다:

| 상황 | 설명 |
|-----|------|
| 존재하지 않는 연결 | CLOSED 상태에서 SYN 외 세그먼트 수신 |
| 잘못된 상태 | 예상치 못한 세그먼트 수신 |
| 연결 중단 요청 | 애플리케이션이 연결 강제 종료 요청 |
| 리소스 부족 | 연결 수락 불가능 |

### RST 생성 규칙

#### ACK 비트가 없는 세그먼트

```
수신: <SEQ=100><CTL=SYN>
송신: <SEQ=0><ACK=101><CTL=RST,ACK>
```

- RST의 SEQ = 0
- RST의 ACK = 수신 SEQ + 세그먼트 길이

#### ACK 비트가 있는 세그먼트

```
수신: <SEQ=100><ACK=300><CTL=ACK>
송신: <SEQ=300><CTL=RST>
```

- RST의 SEQ = 수신된 ACK 값
- ACK 없이 RST만 전송

### RST 수신 처리

#### 상태별 처리

| 상태 | RST 수신 시 동작 |
|-----|-----------------|
| SYN-SENT | 연결 시도 포기, CLOSED 상태로 전이 |
| SYN-RECEIVED | LISTEN 상태로 복귀 (passive open의 경우) |
| ESTABLISHED | 연결 중단, CLOSED 상태로 전이 |
| FIN-WAIT-1/2 | 연결 중단, CLOSED 상태로 전이 |
| CLOSE-WAIT | 연결 중단, CLOSED 상태로 전이 |
| TIME-WAIT | CLOSED 상태로 전이 (또는 무시) |

### RST 유효성 검증

수신된 RST가 유효하려면:

```
RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND
```

- RST의 시퀀스 번호가 수신 윈도우 내 에 있어야 함
- 윈도우 외 RST는 무시 (보안 강화)

### 반개방 연결 (Half-Open Connection) 탐지

```
    호스트 A (재부팅됨)                    호스트 B (연결 유지 중)
        │                                        │
        │  (재부팅으로 연결 상태 손실)            │
        │                                        │
        │←───────────────────── Data (seq=1000) │
        │                                        │
        │  RST ──────────────────────────────→│
        │  (연결 정보 없으므로 RST 응답)          │
        │                                        │
        │                    (연결 종료)          │
```

### RST와 Linger 옵션

| 옵션 | 동작 |
|-----|------|
| SO_LINGER off | 정상 종료 (FIN-based) |
| SO_LINGER on, timeout=0 | RST로 즉시 종료, 데이터 폐기 |
| SO_LINGER on, timeout>0 | 타임아웃까지 대기 후 종료 |

## Urgent Data 처리 메커니즘

### 개념

Urgent Data (긴급 데이터) 는 수신자에게 즉시 처리해야 함을 알리는 메커니즘입니다.

### 헤더 필드

| 필드 | 역할 |
|-----|------|
| URG 플래그 | 긴급 데이터 존재 표시 (1비트) |
| Urgent Pointer | 긴급 데이터의 위치 표시 (16비트) |

### Urgent Pointer 해석

RFC 793 명세:

```
세그먼트 데이터:
┌────────────────────────────────────────────────────────┐
│ 일반 데이터  │  긴급 데이터  │      일반 데이터          │
└────────────────────────────────────────────────────────┘
                ↑              ↑
              SEQ          SEQ + Urgent Pointer
              (시작)         (긴급 데이터 끝 + 1)

Urgent Pointer = 긴급 데이터 끝의 다음 바이트 오프셋
```

### RFC 793 vs RFC 1122 해석 차이

| RFC | Urgent Pointer 의미 |
|-----|---------------------|
| RFC 793 | 긴급 데이터의 마지막 바이트 다음 위치 |
| RFC 1122 | 긴급 데이터의 마지막 바이트 위치 |

- 대부분의 구현은 RFC 1122 해석 사용
- 1바이트 차이로 인한 상호운용성 문제 가능

### Urgent Mode 동작

```
    송신자                                    수신자
        │                                        │
        │  URG=1, UP=5, Data="Hello" ─────────→│
        │                                        │ ← 긴급 신호 수신
        │                                        │    (SIGURG 또는 예외)
        │                                        │
        │  일반 데이터 전송 ───────────────────→│
        │                                        │
```

### Urgent Data 처리 방식

#### 1. Out-of-Band (OOB) 모드

```c
// 송신
send(sock, "X", 1, MSG_OOB);

// 수신 (SIGURG 시그널 핸들러)
recv(sock, buf, 1, MSG_OOB);
```

- 긴급 데이터를 별도 채널로 처리
- 1바이트만 OOB로 처리 가능 (구현 제한)

#### 2. Inline 모드

```c
// SO_OOBINLINE 옵션 설정
setsockopt(sock, SOL_SOCKET, SO_OOBINLINE, &on, sizeof(on));

// 일반 읽기로 긴급 데이터 수신
recv(sock, buf, size, 0);
```

- 긴급 데이터가 일반 데이터 스트림에 포함
- Urgent Pointer로 위치 확인

### Urgent Mode 사용 사례

| 프로토콜 | 용도 |
|---------|------|
| Telnet | 인터럽트 신호 (Ctrl+C) 전송 |
| FTP | ABOR (전송 중단) 명령 |
| Rlogin | 윈도우 크기 변경 알림 |

### 제한사항

- 신뢰성 없음: Urgent Pointer는 재전송되지 않을 수 있음
- 1바이트 제한: 많은 구현에서 1바이트만 OOB로 처리
- 혼란스러운 의미: RFC 793과 RFC 1122의 해석 차이
- 사용 감소: 현대 애플리케이션에서는 드물게 사용

## 실제 활용

### 일반적인 TCP 포트 번호

| 포트 | 서비스 | 설명 |
|-----|-------|------|
| 20 | FTP-DATA | FTP 데이터 전송 |
| 21 | FTP | FTP 제어 연결 |
| 22 | SSH | 보안 셸 |
| 23 | Telnet | 원격 터미널 |
| 25 | SMTP | 이메일 전송 |
| 80 | HTTP | 웹 서버 |
| 443 | HTTPS | 보안 웹 서버 |

## 최신 업데이트

RFC 793은 역사적 맥락과 기초를 이해하는 데 유명하지만, 최신 통합본은 RFC 9293 입니다. RFC 9293은 이후의 모든 업데이트와 확장을 통합한 문서입니다.

## 요약

TCP는 인터넷 통신의 근간을 이루는 프로토콜로, 다음과 같은 특징을 가집니다:

- 신뢰성 있는 데이터 전송: 순서 보장, 중복 제거, 손실 복구
- 연결 지향: 3-way 핸드셰이크로 연결 수립
- 흐름 제어: 슬라이딩 윈도우로 수신자 과부하 방지
- 혼잡 제어: 네트워크 혼잡 상황에 적응

이러한 특성으로 인해 TCP는 웹 브라우징, 이메일, 파일 전송 등 신뢰성이 중요한 대부분의 인터넷 애플리케이션에서 사용됩니다.
