# SQL:2006 표준 완벽 가이드

## ISO/IEC 9075:2006 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [SQL/XML 대폭 강화](#2-sqlxml-대폭-강화)
3. [XQuery 통합](#3-xquery-통합)
4. [XMLTABLE](#4-xmltable)
5. [XMLQUERY](#5-xmlquery)
6. [XMLEXISTS](#6-xmlexists)
7. [XMLCAST](#7-xmlcast)
8. [XMLVALIDATE](#8-xmlvalidate)
9. [XMLNAMESPACES](#9-xmlnamespaces)
10. [XMLCONCAT](#10-xmlconcat)
11. [XMLCOMMENT](#11-xmlcomment)
12. [XMLPI](#12-xmlpi)
13. [XMLDOCUMENT](#13-xmldocument)
14. [XMLROOT](#14-xmlroot)
15. [XQuery FLWOR 표현식 상세](#15-xquery-flwor-표현식-상세)
16. [XQuery 조건 표현식](#16-xquery-조건-표현식)
17. [XQuery 경로 표현식 상세](#17-xquery-경로-표현식-상세)
18. [SQL/XML 저장 프로시저](#18-sqlxml-저장-프로시저)
19. [XML 데이터 타입](#19-xml-데이터-타입)
20. [SQL/XML 매핑 규칙](#20-sqlxml-매핑-규칙)
21. [영향과 의의](#21-영향과-의의)

---

## 1. 개요

SQL:2006(공식명: ISO/IEC 9075:2006)은 SQL:2003의 개정판으로, SQL/XML(Part 14)의 대폭 강화가 핵심이다. W3C의 XQuery 1.0과 XPath 2.0을 SQL에 통합하여 SQL 내에서 XML 데이터를 본격적으로 질의하고 처리할 수 있게 되었다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2006 |
| 발표 연도 | 2006년 |
| 이전 표준 | SQL:2003 |
| 다음 표준 | SQL:2008 |
| 핵심 변경 | SQL/XML 대폭 강화, XQuery 통합 |
| 주요 신규 기능 | XMLTABLE, XMLQUERY, XMLEXISTS, XMLCAST, XMLVALIDATE |

### SQL:2003 대비 변경 범위

SQL:2006의 변경은 거의 전적으로 Part 14(SQL/XML)에 집중되어 있다. 나머지 파트의 변경은 미미하다.

| 파트 | 변경 수준 |
|------|-----------|
| Part 1 (Framework) | 소폭 수정 |
| Part 2 (Foundation) | 소폭 수정 |
| Part 14 (SQL/XML) | 대폭 확장 |
| 기타 파트 | 거의 변경 없음 |

---

## 2. SQL/XML 대폭 강화

### SQL:2003 vs SQL:2006 XML 기능 비교

| 기능 | SQL:2003 | SQL:2006 |
|------|----------|----------|
| XMLELEMENT | O | O |
| XMLFOREST | O | O |
| XMLAGG | O | O |
| XMLPARSE | O | O |
| XMLSERIALIZE | O | O |
| XMLCONCAT | O | O |
| XMLTABLE | X | O (신규) |
| XMLQUERY | X | O (신규) |
| XMLEXISTS | X | O (신규) |
| XMLCAST | X | O (신규) |
| XMLVALIDATE | X | O (신규) |
| XMLNAMESPACES | X | O (신규) |
| XQuery 지원 | X | O (신규) |

---

## 3. XQuery 통합

SQL:2006의 가장 큰 변화는 W3C XQuery 1.0을 SQL에 통합한 것이다. XQuery는 XML 데이터를 질의하기 위한 표준 언어이다.

### XQuery 기본 개념

```
XQuery는 XPath 2.0을 기반으로 하는 함수형 질의 언어이다:
- XPath: XML 문서 내 노드를 선택하는 경로 표현식
- FLWOR: For-Let-Where-Order-Return 표현식
- 시퀀스(Sequence) 기반 데이터 모델
```

### SQL 내에서 XQuery 사용 예

```sql
-- XML 컬럼이 있는 테이블
CREATE TABLE 주문xml (
    주문번호    INTEGER PRIMARY KEY,
    주문데이터  XML
);

INSERT INTO 주문xml VALUES (1, XMLPARSE(DOCUMENT
    '<주문>
        <고객>홍길동</고객>
        <항목>
            <제품 코드="P001">노트북</제품>
            <수량>2</수량>
            <단가>1500000</단가>
        </항목>
        <항목>
            <제품 코드="P002">마우스</제품>
            <수량>5</수량>
            <단가>30000</단가>
        </항목>
    </주문>'
));
```

---

## 4. XMLTABLE

XMLTABLE은 XML 데이터를 관계형 테이블 형태로 변환하는 강력한 기능이다. SQL:2006의 가장 실용적인 추가 기능 중 하나이다.

```sql
-- 기본 XMLTABLE 구문
SELECT t.*
FROM 주문xml,
     XMLTABLE(
         '/주문/항목'
         PASSING 주문데이터
         COLUMNS
             제품명    VARCHAR(100) PATH '제품',
             제품코드  CHAR(4)      PATH '제품/@코드',
             수량      INTEGER      PATH '수량',
             단가      DECIMAL(10,2) PATH '단가'
     ) AS t;

-- 결과:
-- 제품명  | 제품코드 | 수량 | 단가
-- 노트북  | P001     | 2    | 1500000
-- 마우스  | P002     | 5    | 30000

-- 주문 정보와 함께 조회
SELECT
    주문번호,
    고객명,
    t.제품명,
    t.수량,
    t.단가,
    t.수량 * t.단가 AS 금액
FROM 주문xml,
     XMLTABLE(
         '/주문'
         PASSING 주문데이터
         COLUMNS
             고객명 VARCHAR(50) PATH '고객'
     ) AS h,
     XMLTABLE(
         '/주문/항목'
         PASSING 주문데이터
         COLUMNS
             제품명 VARCHAR(100) PATH '제품',
             수량   INTEGER      PATH '수량',
             단가   DECIMAL(10,2) PATH '단가'
     ) AS t;

-- 기본값 설정
SELECT t.*
FROM 주문xml,
     XMLTABLE(
         '/주문/항목'
         PASSING 주문데이터
         COLUMNS
             제품명    VARCHAR(100)  PATH '제품',
             수량      INTEGER       PATH '수량' DEFAULT 1,
             단가      DECIMAL(10,2) PATH '단가' DEFAULT 0,
             할인율    DECIMAL(5,2)  PATH '할인율' DEFAULT 0
     ) AS t;

-- XMLTABLE에서 네임스페이스 사용
SELECT t.*
FROM 주문xml,
     XMLTABLE(
         XMLNAMESPACES('http://example.com/order' AS "ord"),
         '/ord:주문/ord:항목'
         PASSING 주문데이터
         COLUMNS
             제품명 VARCHAR(100) PATH 'ord:제품'
     ) AS t;

-- 순번 컬럼
SELECT t.*
FROM 주문xml,
     XMLTABLE(
         '/주문/항목'
         PASSING 주문데이터
         COLUMNS
             순번    FOR ORDINALITY,
             제품명  VARCHAR(100) PATH '제품',
             수량    INTEGER      PATH '수량'
     ) AS t;
```

---

## 5. XMLQUERY

XMLQUERY는 XQuery 표현식을 실행하고 XML 결과를 반환한다.

```sql
-- 기본 XMLQUERY
SELECT 주문번호,
       XMLQUERY('/주문/고객/text()' PASSING 주문데이터) AS 고객명
FROM 주문xml;

-- XQuery FLWOR 표현식 사용
SELECT 주문번호,
       XMLQUERY('
           for $item in /주문/항목
           where $item/수량 > 1
           return $item/제품
       ' PASSING 주문데이터) AS 대량주문제품
FROM 주문xml;

-- 연산 포함
SELECT 주문번호,
       XMLQUERY('
           for $item in /주문/항목
           return <항목금액>{
               $item/제품/text() || ": " ||
               string($item/수량 * $item/단가)
           }</항목금액>
       ' PASSING 주문데이터) AS 항목별금액
FROM 주문xml;

-- 합계 계산
SELECT 주문번호,
       XMLQUERY('
           sum(for $item in /주문/항목
               return $item/수량 * $item/단가)
       ' PASSING 주문데이터) AS 주문총액
FROM 주문xml;

-- EMPTY ON EMPTY / NULL ON EMPTY 옵션
SELECT 주문번호,
       XMLQUERY('/주문/비고/text()'
           PASSING 주문데이터
           RETURNING CONTENT
           NULL ON EMPTY
       ) AS 비고
FROM 주문xml;
```

---

## 6. XMLEXISTS

XMLEXISTS는 XQuery 표현식의 결과가 존재하는지 확인하는 술어(predicate)이다. WHERE 절에서 사용한다.

```sql
-- 기본 XMLEXISTS
SELECT 주문번호
FROM 주문xml
WHERE XMLEXISTS('/주문/항목[수량 > 3]' PASSING 주문데이터);

-- 특정 제품 포함 여부 확인
SELECT 주문번호
FROM 주문xml
WHERE XMLEXISTS('/주문/항목[제품/@코드 = "P001"]' PASSING 주문데이터);

-- 바인드 변수 사용
SELECT 주문번호
FROM 주문xml
WHERE XMLEXISTS(
    '/주문/항목[제품/@코드 = $code]'
    PASSING 주문데이터, 'P001' AS "code"
);

-- 특정 고객의 주문
SELECT 주문번호
FROM 주문xml
WHERE XMLEXISTS('/주문[고객 = "홍길동"]' PASSING 주문데이터);

-- 복합 조건
SELECT 주문번호
FROM 주문xml
WHERE XMLEXISTS('
    /주문/항목[수량 * 단가 > 1000000]
' PASSING 주문데이터);

-- NOT과 결합
SELECT 주문번호
FROM 주문xml
WHERE NOT XMLEXISTS('/주문/항목[수량 > 10]' PASSING 주문데이터);
```

---

## 7. XMLCAST

XMLCAST는 XML 값과 SQL 값 사이의 변환을 수행한다.

```sql
-- XML을 SQL 타입으로 변환
SELECT 주문번호,
       XMLCAST(
           XMLQUERY('/주문/고객/text()' PASSING 주문데이터)
           AS VARCHAR(50)
       ) AS 고객명
FROM 주문xml;

-- 숫자 변환
SELECT 주문번호,
       XMLCAST(
           XMLQUERY('sum(/주문/항목/수량)' PASSING 주문데이터)
           AS INTEGER
       ) AS 총수량
FROM 주문xml;

-- SQL 값을 XML로 변환
SELECT XMLCAST('홍길동' AS XML) AS xml값;
SELECT XMLCAST(12345 AS XML) AS xml숫자;

-- 날짜 변환
SELECT XMLCAST(
    XMLQUERY('/주문/@주문일' PASSING 주문데이터)
    AS DATE
) AS 주문일
FROM 주문xml;
```

---

## 8. XMLVALIDATE

XMLVALIDATE는 XML 문서를 XML Schema에 대해 검증한다.

```sql
-- 등록된 XML 스키마를 사용한 검증
SELECT XMLVALIDATE(
    주문데이터
    ACCORDING TO XMLSCHEMA URI 'http://example.com/schemas/order.xsd'
) AS 검증된_xml
FROM 주문xml;

-- 검증 결과로 필터링
SELECT 주문번호
FROM 주문xml
WHERE XMLVALIDATE(
    주문데이터
    ACCORDING TO XMLSCHEMA URI 'http://example.com/schemas/order.xsd'
) IS NOT NULL;

-- ID를 사용한 스키마 지정
SELECT XMLVALIDATE(
    주문데이터
    ACCORDING TO XMLSCHEMA ID 주문스키마
) AS 검증된_xml
FROM 주문xml;

-- ELEMENT 지정 검증
SELECT XMLVALIDATE(
    주문데이터
    ACCORDING TO XMLSCHEMA URI 'http://example.com/schemas/order.xsd'
    ELEMENT "주문"
) AS 검증된_xml
FROM 주문xml;
```

---

## 9. XMLNAMESPACES

XMLNAMESPACES는 XML 네임스페이스를 선언하는 데 사용된다.

```sql
-- XMLNAMESPACES 기본 사용
SELECT XMLELEMENT(
    NAME "ord:주문",
    XMLNAMESPACES('http://example.com/order' AS "ord"),
    XMLELEMENT(NAME "ord:고객", 고객명),
    XMLELEMENT(NAME "ord:금액", 주문금액)
) AS 주문xml
FROM 주문;

-- 기본 네임스페이스 설정
SELECT XMLELEMENT(
    NAME "주문",
    XMLNAMESPACES(DEFAULT 'http://example.com/order'),
    XMLELEMENT(NAME "고객", 고객명)
) AS 주문xml
FROM 주문;

-- XMLTABLE에서 네임스페이스
SELECT t.*
FROM 주문xml,
     XMLTABLE(
         XMLNAMESPACES(
             'http://example.com/order' AS "ord",
             'http://example.com/product' AS "prd"
         ),
         '/ord:주문/ord:항목'
         PASSING 주문데이터
         COLUMNS
             제품명 VARCHAR(100) PATH 'prd:제품',
             수량   INTEGER      PATH 'ord:수량'
     ) AS t;

-- XMLQUERY에서 네임스페이스
SELECT XMLQUERY(
    'declare namespace ord = "http://example.com/order";
     /ord:주문/ord:고객/text()'
    PASSING 주문데이터
) AS 고객명
FROM 주문xml;
```

---

## 10. XMLCONCAT

XMLCONCAT는 여러 XML 값을 하나의 XML 시퀀스로 연결한다. 두 개 이상의 XML 표현식을 인자로 받아 결합된 결과를 반환한다.

```sql
-- 기본 XMLCONCAT: 여러 XMLELEMENT를 연결
SELECT XMLCONCAT(
    XMLELEMENT(NAME "이름", 이름),
    XMLELEMENT(NAME "부서", 부서코드)
) AS 직원xml
FROM 직원;
-- 결과: <이름>김개발</이름><부서>D001</부서>

-- 여러 컬럼을 개별 XML 요소로 연결
SELECT XMLCONCAT(
    XMLELEMENT(NAME "직원번호", 직원번호),
    XMLELEMENT(NAME "이름", 이름),
    XMLELEMENT(NAME "급여", 급여),
    XMLELEMENT(NAME "입사일", 입사일)
) AS 직원정보
FROM 직원
WHERE 부서코드 = 'D001';

-- XMLCONCAT과 XMLELEMENT 중첩
SELECT XMLELEMENT(NAME "직원",
    XMLCONCAT(
        XMLELEMENT(NAME "인적사항",
            XMLELEMENT(NAME "이름", 이름),
            XMLELEMENT(NAME "전화", 전화번호)
        ),
        XMLELEMENT(NAME "근무정보",
            XMLELEMENT(NAME "부서", 부서코드),
            XMLELEMENT(NAME "직급", 직급)
        )
    )
) AS 직원xml
FROM 직원;

-- NULL 처리: XMLCONCAT는 NULL 인자를 무시한다
SELECT XMLCONCAT(
    XMLELEMENT(NAME "이름", 이름),
    CASE WHEN 전화번호 IS NOT NULL
         THEN XMLELEMENT(NAME "전화", 전화번호)
         ELSE NULL
    END
) AS 연락처xml
FROM 직원;
```

---

## 11. XMLCOMMENT

XMLCOMMENT는 XML 주석 노드를 생성한다. 인자로 주석 내용 문자열을 받는다.

```sql
-- 기본 XMLCOMMENT
SELECT XMLCOMMENT('이것은 주석입니다') AS 주석;
-- 결과: <!--이것은 주석입니다-->

-- XMLCONCAT와 함께 사용하여 문서에 주석 삽입
SELECT XMLCONCAT(
    XMLCOMMENT('직원 정보 시작'),
    XMLELEMENT(NAME "직원",
        XMLELEMENT(NAME "이름", 이름),
        XMLELEMENT(NAME "부서", 부서코드)
    ),
    XMLCOMMENT('직원 정보 끝')
) AS 주석포함xml
FROM 직원;
-- 결과:
-- <!--직원 정보 시작-->
-- <직원><이름>김개발</이름><부서>D001</부서></직원>
-- <!--직원 정보 끝-->

-- 동적 주석 생성
SELECT XMLCONCAT(
    XMLCOMMENT('생성일: ' || CAST(CURRENT_DATE AS VARCHAR(10))),
    XMLELEMENT(NAME "보고서",
        XMLELEMENT(NAME "제목", '월간 매출 보고')
    )
) AS 보고서xml;
```

---

## 12. XMLPI

XMLPI는 XML 처리 지시(Processing Instruction) 노드를 생성한다. NAME 뒤에 PI 대상(target)을 지정하고, 선택적으로 PI 내용을 문자열로 전달한다.

```sql
-- 기본 XMLPI: 스타일시트 처리 지시
SELECT XMLPI(NAME "xml-stylesheet", 'type="text/xsl" href="style.xsl"') AS 처리지시;
-- 결과: <?xml-stylesheet type="text/xsl" href="style.xsl"?>

-- 내용 없는 처리 지시
SELECT XMLPI(NAME "page-break") AS 페이지구분;
-- 결과: <?page-break?>

-- XMLCONCAT와 함께 사용하여 문서 앞에 처리 지시 삽입
SELECT XMLCONCAT(
    XMLPI(NAME "xml-stylesheet", 'type="text/xsl" href="order.xsl"'),
    XMLELEMENT(NAME "주문",
        XMLELEMENT(NAME "고객", 고객명),
        XMLELEMENT(NAME "금액", 주문금액)
    )
) AS 주문문서
FROM 주문;

-- 여러 처리 지시를 연결
SELECT XMLCONCAT(
    XMLPI(NAME "xml-stylesheet", 'type="text/xsl" href="report.xsl"'),
    XMLPI(NAME "xml-model", 'href="report.sch" type="application/xml"'),
    XMLELEMENT(NAME "보고서",
        XMLELEMENT(NAME "내용", '보고서 본문')
    )
) AS 보고서xml;
```

---

## 13. XMLDOCUMENT

XMLDOCUMENT는 XML 컨텐츠(조각)를 완전한 XML 문서 노드로 감싼다. XML(CONTENT) 값을 XML(DOCUMENT) 값으로 변환할 때 사용한다.

```sql
-- 기본 XMLDOCUMENT: XML 조각을 문서로 변환
SELECT XMLDOCUMENT(
    XMLELEMENT(NAME "직원목록",
        XMLAGG(
            XMLELEMENT(NAME "직원",
                XMLELEMENT(NAME "이름", 이름),
                XMLELEMENT(NAME "부서", 부서코드)
            )
        )
    )
) AS 직원문서
FROM 직원;

-- XMLPARSE 결과를 문서 노드로 변환
SELECT XMLDOCUMENT(
    XMLPARSE(CONTENT '<항목><이름>노트북</이름><가격>1500000</가격></항목>')
) AS 항목문서;

-- XMLDOCUMENT + XMLCONCAT 조합
SELECT XMLDOCUMENT(
    XMLELEMENT(NAME "주문서",
        XMLCONCAT(
            XMLELEMENT(NAME "주문번호", 주문번호),
            XMLELEMENT(NAME "고객", 고객명),
            XMLELEMENT(NAME "금액", 주문금액)
        )
    )
) AS 주문문서
FROM 주문;

-- IS DOCUMENT로 검증
SELECT 주문번호
FROM (
    SELECT 주문번호,
           XMLDOCUMENT(
               XMLELEMENT(NAME "주문", 주문데이터)
           ) AS 문서
    FROM 주문xml
) AS sub
WHERE 문서 IS DOCUMENT;
```

---

## 14. XMLROOT

XMLROOT는 XML 값에 XML 선언(버전, standalone 속성)을 추가한다.

```sql
-- 기본 XMLROOT: XML 버전 선언 추가
SELECT XMLROOT(
    XMLELEMENT(NAME "직원",
        XMLELEMENT(NAME "이름", '김개발'),
        XMLELEMENT(NAME "부서", 'D001')
    ),
    VERSION '1.0'
) AS 직원xml;
-- 결과: <?xml version="1.0"?><직원><이름>김개발</이름><부서>D001</부서></직원>

-- standalone 속성 지정
SELECT XMLROOT(
    XMLELEMENT(NAME "주문",
        XMLELEMENT(NAME "고객", 고객명),
        XMLELEMENT(NAME "금액", 주문금액)
    ),
    VERSION '1.0',
    STANDALONE YES
) AS 주문xml
FROM 주문;
-- 결과: <?xml version="1.0" standalone="yes"?><주문>...</주문>

-- STANDALONE NO 지정
SELECT XMLROOT(
    XMLPARSE(DOCUMENT '<데이터><값>100</값></데이터>'),
    VERSION '1.0',
    STANDALONE NO
) AS xml문서;

-- STANDALONE NO VALUE (standalone 속성 생략)
SELECT XMLROOT(
    XMLELEMENT(NAME "보고서",
        XMLELEMENT(NAME "제목", '월간 보고'),
        XMLELEMENT(NAME "날짜", CURRENT_DATE)
    ),
    VERSION '1.0',
    STANDALONE NO VALUE
) AS 보고서xml;
```

---

## 15. XQuery FLWOR 표현식 상세

FLWOR는 for, let, where, order by, return의 약자로, XQuery의 핵심 표현식이다. SQL 내에서 XMLQUERY, XMLTABLE 등과 함께 사용된다.

### for 절

시퀀스의 각 항목에 변수를 바인딩하여 반복한다.

```sql
-- for 절: 각 항목을 반복 처리
SELECT XMLQUERY('
    for $item in /주문/항목
    return <제품정보>{$item/제품/text()}</제품정보>
' PASSING 주문데이터) AS 제품목록
FROM 주문xml;

-- 여러 for 절을 사용한 중첩 반복
SELECT XMLQUERY('
    for $dept in /회사/부서
    for $emp in $dept/직원
    return <소속>{$dept/부서명/text()}: {$emp/이름/text()}</소속>
' PASSING xml데이터) AS 소속현황
FROM 회사xml;

-- at 키워드로 위치 변수 사용
SELECT XMLQUERY('
    for $item at $pos in /주문/항목
    return <항목 순번="{$pos}">{$item/제품/text()}</항목>
' PASSING 주문데이터) AS 순번포함목록
FROM 주문xml;
```

### let 절

변수에 시퀀스 전체를 바인딩한다. for와 달리 반복하지 않는다.

```sql
-- let 절: 변수에 값 바인딩
SELECT XMLQUERY('
    let $items := /주문/항목
    let $count := count($items)
    return <요약>총 {$count}건의 항목</요약>
' PASSING 주문데이터) AS 요약
FROM 주문xml;

-- for + let 조합
SELECT XMLQUERY('
    for $item in /주문/항목
    let $금액 := $item/수량 * $item/단가
    return <항목금액>
        <제품>{$item/제품/text()}</제품>
        <금액>{$금액}</금액>
    </항목금액>
' PASSING 주문데이터) AS 항목별금액
FROM 주문xml;
```

### where 절

반복 결과를 조건으로 필터링한다.

```sql
-- where 절: 조건 필터링
SELECT XMLQUERY('
    for $item in /주문/항목
    where $item/수량 > 2
    return $item/제품
' PASSING 주문데이터) AS 대량주문
FROM 주문xml;

-- 복합 where 조건
SELECT XMLQUERY('
    for $item in /주문/항목
    where $item/수량 >= 2 and $item/단가 < 1000000
    return <저가대량>{$item/제품/text()}: {string($item/수량)}개</저가대량>
' PASSING 주문데이터) AS 필터결과
FROM 주문xml;
```

### order by 절

결과의 정렬 순서를 지정한다.

```sql
-- order by 절: 정렬
SELECT XMLQUERY('
    for $item in /주문/항목
    order by $item/단가 descending
    return <제품>{$item/제품/text()} - {string($item/단가)}원</제품>
' PASSING 주문데이터) AS 가격순목록
FROM 주문xml;

-- 여러 정렬 기준
SELECT XMLQUERY('
    for $item in /주문/항목
    order by $item/수량 descending, $item/제품/text() ascending
    return $item/제품
' PASSING 주문데이터) AS 정렬결과
FROM 주문xml;

-- empty greatest / empty least 지정
SELECT XMLQUERY('
    for $item in /주문/항목
    order by $item/할인율 ascending empty least
    return $item/제품
' PASSING 주문데이터) AS 할인율순
FROM 주문xml;
```

### return 절

최종 결과를 구성한다.

```sql
-- return 절: 결과 구성
SELECT XMLQUERY('
    for $item in /주문/항목
    let $금액 := $item/수량 * $item/단가
    where $금액 > 100000
    order by $금액 descending
    return
        <고액항목>
            <제품>{$item/제품/text()}</제품>
            <수량>{$item/수량/text()}</수량>
            <단가>{$item/단가/text()}</단가>
            <금액>{$금액}</금액>
        </고액항목>
' PASSING 주문데이터) AS 고액항목목록
FROM 주문xml;

-- 중첩 FLWOR
SELECT XMLQUERY('
    <주문현황>{
        for $ord in /주문목록/주문
        return
            <주문 번호="{$ord/@번호}">
                <고객>{$ord/고객/text()}</고객>
                <항목수>{count($ord/항목)}</항목수>
                <총액>{
                    sum(for $item in $ord/항목
                        return $item/수량 * $item/단가)
                }</총액>
            </주문>
    }</주문현황>
' PASSING xml데이터) AS 현황
FROM 주문저장소;
```

---

## 16. XQuery 조건 표현식

XQuery 내에서 조건 분기를 수행하는 표현식이다.

### if-then-else

```sql
-- if-then-else 기본 구문
SELECT XMLQUERY('
    for $item in /주문/항목
    return
        <항목 등급="{
            if ($item/수량 * $item/단가 >= 1000000)
            then "고액"
            else if ($item/수량 * $item/단가 >= 100000)
            then "중액"
            else "소액"
        }">
            {$item/제품/text()}
        </항목>
' PASSING 주문데이터) AS 등급별항목
FROM 주문xml;

-- if-then-else로 선택적 요소 생성
SELECT XMLQUERY('
    for $emp in /부서/직원
    return
        <직원>
            <이름>{$emp/이름/text()}</이름>
            {
                if ($emp/급여 > 5000000)
                then <고연봉/>
                else ()
            }
        </직원>
' PASSING xml데이터) AS 직원목록
FROM 부서xml;
```

### typeswitch

타입에 따라 분기 처리한다.

```sql
-- typeswitch: 노드 타입에 따른 분기 처리
SELECT XMLQUERY('
    for $node in /데이터/*
    return
        typeswitch ($node)
            case element(수치) return <결과>{$node/text() * 2}</결과>
            case element(문자) return <결과>{upper-case($node/text())}</결과>
            case element(날짜) return <결과>{$node/text()}</결과>
            default return <결과>알수없음</결과>
' PASSING xml데이터) AS 변환결과
FROM 데이터xml;

-- typeswitch에서 변수 바인딩
SELECT XMLQUERY('
    for $item in /문서/*
    return
        typeswitch ($item)
            case $e as element(주문) return
                <처리결과 유형="주문">{$e/고객/text()}</처리결과>
            case $e as element(반품) return
                <처리결과 유형="반품">{$e/사유/text()}</처리결과>
            default $e return
                <처리결과 유형="기타">{name($e)}</처리결과>
' PASSING xml데이터) AS 처리결과
FROM 문서xml;
```

### quantified 표현식 (some/every)

시퀀스 내 항목에 대한 존재/전칭 조건을 검사한다.

```sql
-- some: 하나라도 만족하면 true
SELECT XMLQUERY('
    if (some $item in /주문/항목 satisfies $item/수량 > 10)
    then <결과>대량 주문 포함</결과>
    else <결과>대량 주문 없음</결과>
' PASSING 주문데이터) AS 대량여부
FROM 주문xml;

-- every: 모두 만족해야 true
SELECT XMLQUERY('
    if (every $item in /주문/항목 satisfies $item/단가 > 0)
    then <결과>유효</결과>
    else <결과>무효 항목 존재</결과>
' PASSING 주문데이터) AS 유효성
FROM 주문xml;
```

---

## 17. XQuery 경로 표현식 상세

XPath 2.0 기반의 경로 표현식으로 XML 문서 내 노드를 탐색한다.

### 축(Axis) 이동

```sql
-- child 축 (기본값): 자식 노드 선택
SELECT XMLQUERY('/주문/child::항목' PASSING 주문데이터) AS 항목들
FROM 주문xml;

-- descendant 축: 모든 하위 노드 선택
SELECT XMLQUERY('/주문/descendant::제품' PASSING 주문데이터) AS 모든제품
FROM 주문xml;

-- descendant-or-self 축 (// 약축)
SELECT XMLQUERY('//제품' PASSING 주문데이터) AS 모든제품
FROM 주문xml;

-- parent 축: 부모 노드 선택
SELECT XMLQUERY('
    for $p in //제품[@코드="P001"]
    return $p/parent::항목/수량
' PASSING 주문데이터) AS 부모항목수량
FROM 주문xml;

-- ancestor 축: 모든 조상 노드 선택
SELECT XMLQUERY('
    //제품[@코드="P001"]/ancestor::주문/고객
' PASSING 주문데이터) AS 주문고객
FROM 주문xml;

-- following-sibling 축: 뒤따르는 형제 노드
SELECT XMLQUERY('
    /주문/항목[1]/following-sibling::항목
' PASSING 주문데이터) AS 나머지항목
FROM 주문xml;

-- preceding-sibling 축: 앞선 형제 노드
SELECT XMLQUERY('
    /주문/항목[last()]/preceding-sibling::항목
' PASSING 주문데이터) AS 이전항목들
FROM 주문xml;

-- self 축: 현재 노드 자신
SELECT XMLQUERY('
    /주문/항목/self::항목
' PASSING 주문데이터) AS 자기자신
FROM 주문xml;

-- attribute 축 (@ 약축): 속성 노드 선택
SELECT XMLQUERY('
    /주문/항목/제품/attribute::코드
' PASSING 주문데이터) AS 제품코드들
FROM 주문xml;

-- 위와 동일 (@ 약축 사용)
SELECT XMLQUERY('
    /주문/항목/제품/@코드
' PASSING 주문데이터) AS 제품코드들
FROM 주문xml;
```

### 노드 테스트

```sql
-- node(): 모든 종류의 노드 선택
SELECT XMLQUERY('/주문/node()' PASSING 주문데이터) AS 모든자식노드
FROM 주문xml;

-- text(): 텍스트 노드만 선택
SELECT XMLQUERY('/주문/고객/text()' PASSING 주문데이터) AS 고객텍스트
FROM 주문xml;

-- element(): 요소 노드만 선택
SELECT XMLQUERY('/주문/element()' PASSING 주문데이터) AS 요소노드
FROM 주문xml;

-- element(이름): 특정 이름의 요소 노드
SELECT XMLQUERY('/주문/element(항목)' PASSING 주문데이터) AS 항목요소
FROM 주문xml;

-- comment(): 주석 노드 선택
SELECT XMLQUERY('//comment()' PASSING 주문데이터) AS 주석노드
FROM 주문xml;

-- processing-instruction(): 처리 지시 노드 선택
SELECT XMLQUERY('//processing-instruction()' PASSING 주문데이터) AS PI노드
FROM 주문xml;

-- processing-instruction('target'): 특정 대상의 PI 선택
SELECT XMLQUERY(
    '//processing-instruction("xml-stylesheet")'
    PASSING 주문데이터
) AS 스타일시트PI
FROM 주문xml;
```

### 술어(Predicate) 필터링

```sql
-- 위치 술어: 특정 위치의 노드
SELECT XMLQUERY('/주문/항목[1]' PASSING 주문데이터) AS 첫번째항목
FROM 주문xml;

SELECT XMLQUERY('/주문/항목[last()]' PASSING 주문데이터) AS 마지막항목
FROM 주문xml;

SELECT XMLQUERY('/주문/항목[position() <= 3]' PASSING 주문데이터) AS 처음3개
FROM 주문xml;

-- 값 비교 술어
SELECT XMLQUERY('
    /주문/항목[수량 > 2]
' PASSING 주문데이터) AS 수량초과항목
FROM 주문xml;

-- 속성값 술어
SELECT XMLQUERY('
    /주문/항목[제품/@코드 = "P001"]
' PASSING 주문데이터) AS P001항목
FROM 주문xml;

-- 존재 술어: 특정 자식 요소가 있는 노드
SELECT XMLQUERY('
    /주문/항목[할인율]
' PASSING 주문데이터) AS 할인항목
FROM 주문xml;

-- 복합 술어 (and/or)
SELECT XMLQUERY('
    /주문/항목[수량 >= 2 and 단가 < 1000000]
' PASSING 주문데이터) AS 조건항목
FROM 주문xml;

-- 중첩 술어
SELECT XMLQUERY('
    /주문[항목[수량 > 3]]/고객
' PASSING 주문데이터) AS 대량주문고객
FROM 주문xml;

-- 함수를 이용한 술어
SELECT XMLQUERY('
    /주문/항목[contains(제품/text(), "노트")]
' PASSING 주문데이터) AS 노트포함항목
FROM 주문xml;

SELECT XMLQUERY('
    /주문/항목[string-length(제품/text()) > 3]
' PASSING 주문데이터) AS 긴이름항목
FROM 주문xml;
```

### 와일드카드

```sql
-- * : 모든 요소 노드
SELECT XMLQUERY('/주문/*' PASSING 주문데이터) AS 모든자식요소
FROM 주문xml;

-- @* : 모든 속성
SELECT XMLQUERY('/주문/항목/제품/@*' PASSING 주문데이터) AS 모든속성
FROM 주문xml;

-- 네임스페이스 와일드카드
SELECT XMLQUERY('
    declare namespace ord = "http://example.com/order";
    /ord:주문/*:항목
' PASSING 주문데이터) AS 항목들
FROM 주문xml;
```

---

## 18. SQL/XML 저장 프로시저

저장 프로시저 내에서 XML 데이터를 처리하는 구문이다.

```sql
-- XML 파라미터를 받는 저장 프로시저
CREATE PROCEDURE 주문등록 (
    IN p_주문번호 INTEGER,
    IN p_주문xml XML
)
BEGIN
    -- XML에서 고객 정보 추출하여 저장
    INSERT INTO 주문 (주문번호, 고객명, 주문일)
    SELECT p_주문번호,
           XMLCAST(XMLQUERY('/주문/고객/text()' PASSING p_주문xml) AS VARCHAR(50)),
           CURRENT_DATE;

    -- XML에서 항목 정보를 추출하여 저장
    INSERT INTO 주문항목 (주문번호, 제품코드, 수량, 단가)
    SELECT p_주문번호, t.제품코드, t.수량, t.단가
    FROM XMLTABLE(
        '/주문/항목'
        PASSING p_주문xml
        COLUMNS
            제품코드 CHAR(4)       PATH '제품/@코드',
            수량     INTEGER       PATH '수량',
            단가     DECIMAL(10,2) PATH '단가'
    ) AS t;
END;

-- 호출
CALL 주문등록(100, XMLPARSE(DOCUMENT
    '<주문>
        <고객>홍길동</고객>
        <항목><제품 코드="P001">노트북</제품><수량>2</수량><단가>1500000</단가></항목>
        <항목><제품 코드="P002">마우스</제품><수량>5</수량><단가>30000</단가></항목>
    </주문>'
));

-- XML 결과를 반환하는 저장 프로시저
CREATE PROCEDURE 주문조회_xml (
    IN p_고객명 VARCHAR(50),
    OUT p_결과xml XML
)
BEGIN
    SET p_결과xml = (
        SELECT XMLELEMENT(NAME "주문목록",
            XMLAGG(
                XMLELEMENT(NAME "주문",
                    XMLATTRIBUTES(o.주문번호 AS "번호"),
                    XMLELEMENT(NAME "주문일", o.주문일),
                    (SELECT XMLAGG(
                        XMLELEMENT(NAME "항목",
                            XMLELEMENT(NAME "제품", i.제품명),
                            XMLELEMENT(NAME "수량", i.수량),
                            XMLELEMENT(NAME "단가", i.단가)
                        )
                    )
                    FROM 주문항목 i
                    WHERE i.주문번호 = o.주문번호)
                ) ORDER BY o.주문번호
            )
        )
        FROM 주문 o
        WHERE o.고객명 = p_고객명
    );
END;

-- XML 유효성 검증 프로시저
CREATE PROCEDURE xml검증_처리 (
    IN p_xml데이터 XML,
    OUT p_유효여부 BOOLEAN,
    OUT p_결과메시지 VARCHAR(200)
)
BEGIN
    DECLARE v_검증결과 XML;

    SET v_검증결과 = XMLVALIDATE(
        p_xml데이터
        ACCORDING TO XMLSCHEMA URI 'http://example.com/schemas/order.xsd'
    );

    IF v_검증결과 IS NOT NULL THEN
        SET p_유효여부 = TRUE;
        SET p_결과메시지 = '유효한 XML 문서입니다.';
    ELSE
        SET p_유효여부 = FALSE;
        SET p_결과메시지 = 'XML 스키마 검증에 실패했습니다.';
    END IF;
END;

-- XML을 사용한 일괄 처리 프로시저
CREATE PROCEDURE 일괄_급여변경 (
    IN p_변경xml XML
)
BEGIN
    -- XML에서 변경 대상을 추출하여 일괄 업데이트
    UPDATE 직원
    SET 급여 = (
        SELECT t.신규급여
        FROM XMLTABLE(
            '/급여변경/대상'
            PASSING p_변경xml
            COLUMNS
                대상번호  INTEGER       PATH '직원번호',
                신규급여  DECIMAL(10,2) PATH '신규급여'
        ) AS t
        WHERE t.대상번호 = 직원.직원번호
    )
    WHERE 직원번호 IN (
        SELECT t.대상번호
        FROM XMLTABLE(
            '/급여변경/대상'
            PASSING p_변경xml
            COLUMNS
                대상번호 INTEGER PATH '직원번호'
        ) AS t
    );
END;

-- 호출
CALL 일괄_급여변경(XMLPARSE(DOCUMENT
    '<급여변경>
        <대상><직원번호>101</직원번호><신규급여>5500000</신규급여></대상>
        <대상><직원번호>102</직원번호><신규급여>4800000</신규급여></대상>
    </급여변경>'
));
```

---

## 19. XML 데이터 타입

### XML 타입 상세

```sql
-- XML 타입 컬럼
CREATE TABLE xml저장소 (
    문서번호    INTEGER PRIMARY KEY,
    xml문서     XML,                          -- 일반 XML
    xml문서_doc XML(DOCUMENT(ANY)),           -- 완전한 XML 문서
    xml내용     XML(CONTENT(ANY)),             -- XML 조각
    xml검증     XML(DOCUMENT(
                    XMLSCHEMA URI 'http://example.com/schema.xsd'))
);

-- XML 타입 변형
-- XML(DOCUMENT(ANY))         : 잘 형성된(well-formed) XML 문서
-- XML(DOCUMENT(UNTYPED))     : 타입 미지정 XML 문서
-- XML(CONTENT(ANY))          : XML 내용 (조각 가능)
-- XML(CONTENT(UNTYPED))      : 타입 미지정 XML 내용
-- XML(SEQUENCE)              : XML 시퀀스

-- IS DOCUMENT 검사
SELECT 문서번호
FROM xml저장소
WHERE xml문서 IS DOCUMENT;

-- IS NOT DOCUMENT (조각 포함)
SELECT 문서번호
FROM xml저장소
WHERE xml내용 IS NOT DOCUMENT;
```

---

## 20. SQL/XML 매핑 규칙

### SQL 타입에서 XML 타입으로의 매핑

| SQL 타입 | XML Schema 타입 |
|----------|-----------------|
| SMALLINT | xs:short |
| INTEGER | xs:integer |
| BIGINT | xs:long |
| DECIMAL(p,s) | xs:decimal |
| FLOAT | xs:float |
| DOUBLE PRECISION | xs:double |
| CHAR(n) | xs:string |
| VARCHAR(n) | xs:string |
| DATE | xs:date |
| TIME | xs:time |
| TIMESTAMP | xs:dateTime |
| BOOLEAN | xs:boolean |
| BLOB | xs:hexBinary |
| CLOB | xs:string |

### 테이블에서 XML로의 매핑

```sql
-- 테이블 → XML 변환 패턴
-- 방법 1: XMLELEMENT + XMLAGG
SELECT XMLELEMENT(NAME "직원목록",
    XMLAGG(
        XMLELEMENT(NAME "직원",
            XMLFOREST(직원번호, 이름, 급여)
        )
        ORDER BY 직원번호
    )
) AS 전체xml
FROM 직원;

-- 결과:
-- <직원목록>
--   <직원><직원번호>101</직원번호><이름>김개발</이름><급여>5000000</급여></직원>
--   <직원><직원번호>102</직원번호><이름>이영업</이름><급여>4500000</급여></직원>
-- </직원목록>

-- 방법 2: 서브쿼리와 XMLAGG
SELECT XMLELEMENT(NAME "부서별현황",
    (SELECT XMLAGG(
        XMLELEMENT(NAME "부서",
            XMLATTRIBUTES(d.부서코드 AS "코드", d.부서명 AS "이름"),
            (SELECT XMLAGG(
                XMLELEMENT(NAME "직원",
                    XMLATTRIBUTES(e.직원번호 AS "번호"),
                    XMLELEMENT(NAME "이름", e.이름),
                    XMLELEMENT(NAME "급여", e.급여)
                ) ORDER BY e.이름
            )
            FROM 직원 e
            WHERE e.부서코드 = d.부서코드)
        ) ORDER BY d.부서코드
    )
    FROM 부서 d)
) AS 부서현황xml;
```

### XML에서 SQL로의 매핑 (XMLTABLE)

```sql
-- XML → 관계형 테이블 변환 패턴
-- 복잡한 XML 문서를 정규화된 테이블로 분해

-- 원본 XML
-- <회사>
--   <부서 코드="D001">
--     <부서명>개발팀</부서명>
--     <직원><이름>김개발</이름><급여>5000000</급여></직원>
--     <직원><이름>박코딩</이름><급여>4500000</급여></직원>
--   </부서>
-- </회사>

-- 부서 정보 추출
SELECT d.*
FROM xml문서,
     XMLTABLE('/회사/부서' PASSING xml컬럼
         COLUMNS
             부서코드 CHAR(4)      PATH '@코드',
             부서명   VARCHAR(50)  PATH '부서명',
             직원수   INTEGER      PATH 'count(직원)'
     ) AS d;

-- 직원 정보 추출 (중첩 XMLTABLE)
SELECT d.부서코드, e.*
FROM xml문서,
     XMLTABLE('/회사/부서' PASSING xml컬럼
         COLUMNS
             부서코드   CHAR(4) PATH '@코드',
             직원xml    XML     PATH '.'
     ) AS d,
     XMLTABLE('/부서/직원' PASSING d.직원xml
         COLUMNS
             이름 VARCHAR(50)   PATH '이름',
             급여 DECIMAL(10,2) PATH '급여'
     ) AS e;
```

---

## 21. 영향과 의의

1. XQuery 통합: W3C XQuery를 SQL에 통합하여 XML 데이터에 대한 강력한 질의 기능을 제공했다.
2. XMLTABLE: XML 데이터를 관계형 형태로 변환하는 표준 방법을 제공하여, XML과 관계형 데이터의 통합을 크게 단순화했다.
3. XMLQUERY/XMLEXISTS: SQL WHERE 절에서 XML 내용 기반 필터링이 가능해졌다.
4. XMLCAST: XML과 SQL 타입 간의 명시적 변환을 표준화했다.
5. XMLVALIDATE: XML Schema를 통한 데이터 검증을 SQL 레벨에서 수행할 수 있게 했다.
6. SOA 시대 대응: 2000년대 중반 웹 서비스와 SOA(Service-Oriented Architecture) 트렌드에 맞춰 SQL의 XML 처리 능력을 강화했다.

### 한계

- XML 중심의 업데이트로, XML을 사용하지 않는 환경에서는 SQL:2003 대비 변화가 거의 없다.
- 이후 JSON이 XML을 대체하면서, SQL/XML의 실질적 활용도는 점차 감소했다.
- SQL:2016에서 JSON 지원이 추가되며 데이터 교환 포맷의 중심이 이동했다.

---

> 참고: SQL:2006 표준은 ISO/IEC 9075:2006 시리즈로 발행되었다. SQL/XML 관련 세부사항은 ISO/IEC 9075-14:2006에서 확인할 수 있다.
