# SQL:2023 표준 완벽 가이드

## ISO/IEC 9075:2023 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [SQL/PGQ (Property Graph Queries)](#2-sqlpgq-property-graph-queries)
3. [JSON 데이터 타입 공식화](#3-json-데이터-타입-공식화)
4. [JSON 함수 확장](#4-json-함수-확장)
5. [ANY_VALUE](#5-any_value)
6. [GREATEST / LEAST](#6-greatest--least)
7. [향상된 숫자 리터럴](#7-향상된-숫자-리터럴)
8. [향상된 숫자 함수](#8-향상된-숫자-함수)
9. [UNIQUE NULLS (NOT) DISTINCT](#9-unique-nulls-not-distinct)
10. [SIMPLE WHEN 확장](#10-simple-when-확장)
11. [개선된 FETCH FIRST](#11-개선된-fetch-first)
12. [Multi-value Constructor 개선](#12-multi-value-constructor-개선)
13. [기타 개선사항](#13-기타-개선사항)
14. [영향과 의의](#14-영향과-의의)

---

## 1. 개요

SQL:2023(공식명: ISO/IEC 9075:2023)은 SQL 표준의 최신 버전으로, 프로퍼티 그래프 쿼리(SQL/PGQ), JSON 데이터 타입 공식화, ANY_VALUE, GREATEST/LEAST 등 현대 데이터 처리에 필요한 기능을 추가했다. 특히 SQL/PGQ는 그래프 데이터베이스 기능을 관계형 SQL에 통합한 획기적인 변화이다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2023 |
| 발표 연도 | 2023년 |
| 이전 표준 | SQL:2016 |
| 핵심 추가 기능 | SQL/PGQ, JSON 타입, ANY_VALUE, GREATEST/LEAST |
| 신규 파트 | Part 16: SQL/PGQ |

### 신규 기능 요약

| 기능 | 분류 | 설명 |
|------|------|------|
| SQL/PGQ | 그래프 쿼리 | 프로퍼티 그래프 정의 및 패턴 매칭 |
| JSON 타입 | 데이터 타입 | JSON을 일급 데이터 타입으로 공식화 |
| JSON_SERIALIZE / JSON_SCALAR | JSON 함수 | JSON 직렬화 및 스칼라 변환 |
| ANY_VALUE | 집계 함수 | 그룹 내 임의 값 반환 |
| GREATEST/LEAST | 스칼라 함수 | 최대/최소 값 반환 |
| 숫자 리터럴 | 구문 | 밑줄 구분자, 이진/8진/16진 리터럴 |
| 숫자 함수 표준화 | 스칼라 함수 | LOG, LOG10, CEIL, FLOOR 등 표준화 |
| UNIQUE NULLS | 제약사항 | NULL 고유성 처리 방식 지정 |
| SIMPLE WHEN 확장 | 구문 | CASE WHEN의 다중 값 비교 |
| FETCH FIRST 개선 | 구문 | PERCENT와 WITH TIES 조합 상세화 |

---

## 2. SQL/PGQ (Property Graph Queries)

SQL:2023의 가장 혁신적인 추가 기능. 관계형 테이블 위에 프로퍼티 그래프를 정의하고 그래프 패턴 매칭 쿼리를 수행할 수 있다.

### 2.1 프로퍼티 그래프 개념

프로퍼티 그래프는 노드(Node)와 엣지(Edge)로 구성되며, 각각 속성(Property)을 가진다.

```
예: 소셜 네트워크 그래프

  [홍길동] ──친구──> [김철수]
     │                  │
   팔로우            팔로우
     │                  │
     ▼                  ▼
  [이영희] ──친구──> [박민수]
```

### 2.2 CREATE PROPERTY GRAPH

관계형 테이블을 기반으로 프로퍼티 그래프를 정의한다.

```sql
-- 기반 테이블
CREATE TABLE 사용자 (
    사용자ID    INTEGER PRIMARY KEY,
    이름        VARCHAR(50) NOT NULL,
    나이        INTEGER,
    도시        VARCHAR(50)
);

CREATE TABLE 친구관계 (
    요청자ID    INTEGER REFERENCES 사용자(사용자ID),
    수락자ID    INTEGER REFERENCES 사용자(사용자ID),
    생성일      DATE,
    PRIMARY KEY (요청자ID, 수락자ID)
);

CREATE TABLE 팔로우 (
    팔로워ID    INTEGER REFERENCES 사용자(사용자ID),
    팔로잉ID    INTEGER REFERENCES 사용자(사용자ID),
    생성일      DATE,
    PRIMARY KEY (팔로워ID, 팔로잉ID)
);

CREATE TABLE 게시글 (
    글번호      INTEGER PRIMARY KEY,
    작성자ID    INTEGER REFERENCES 사용자(사용자ID),
    내용        VARCHAR(1000),
    작성일      DATE
);

CREATE TABLE 좋아요 (
    사용자ID    INTEGER REFERENCES 사용자(사용자ID),
    글번호      INTEGER REFERENCES 게시글(글번호),
    생성일      DATE,
    PRIMARY KEY (사용자ID, 글번호)
);

-- 프로퍼티 그래프 정의
CREATE PROPERTY GRAPH 소셜네트워크
    VERTEX TABLES (
        사용자
            KEY (사용자ID)
            PROPERTIES (이름, 나이, 도시),
        게시글
            KEY (글번호)
            PROPERTIES (내용, 작성일)
    )
    EDGE TABLES (
        친구관계
            SOURCE KEY (요청자ID) REFERENCES 사용자 (사용자ID)
            DESTINATION KEY (수락자ID) REFERENCES 사용자 (사용자ID)
            PROPERTIES (생성일),
        팔로우
            SOURCE KEY (팔로워ID) REFERENCES 사용자 (사용자ID)
            DESTINATION KEY (팔로잉ID) REFERENCES 사용자 (사용자ID)
            PROPERTIES (생성일),
        좋아요
            SOURCE KEY (사용자ID) REFERENCES 사용자 (사용자ID)
            DESTINATION KEY (글번호) REFERENCES 게시글 (글번호)
            PROPERTIES (생성일)
    );
```

### 2.3 DROP PROPERTY GRAPH

프로퍼티 그래프를 삭제한다. 기반 테이블은 삭제되지 않으며, 그래프 정의만 제거된다.

```sql
-- 프로퍼티 그래프 삭제
DROP PROPERTY GRAPH 소셜네트워크;

-- 존재하는 경우에만 삭제
DROP PROPERTY GRAPH IF EXISTS 소셜네트워크;
```

### 2.4 GRAPH_TABLE

GRAPH_TABLE을 사용하여 그래프 패턴 매칭 쿼리를 수행한다.

```sql
-- 기본 노드/엣지 패턴: 홍길동의 친구 찾기
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자 WHERE p1.이름 = '홍길동')
          -[f:친구관계]->
          (p2:사용자)
    COLUMNS (
        p1.이름 AS 사용자,
        p2.이름 AS 친구,
        f.생성일 AS 친구된날짜
    )
);

-- 2촌 친구 (친구의 친구)
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자 WHERE p1.이름 = '홍길동')
          -[f1:친구관계]->
          (p2:사용자)
          -[f2:친구관계]->
          (p3:사용자 WHERE p3.이름 <> '홍길동')
    COLUMNS (
        p1.이름 AS 사용자,
        p2.이름 AS 중간친구,
        p3.이름 AS 친구의친구
    )
);

-- 양방향 관계: 친구이면서 팔로우하는 사용자
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자 WHERE p1.이름 = '홍길동')
          -[f:친구관계]->
          (p2:사용자),
          (p1) -[fl:팔로우]-> (p2)
    COLUMNS (
        p2.이름 AS 친구이자팔로잉,
        f.생성일 AS 친구관계일,
        fl.생성일 AS 팔로우일
    )
);

-- 게시글 좋아요 관계
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (u:사용자)
          -[l:좋아요]->
          (p:게시글)
          <-[:좋아요]-   -- 역방향
          (writer:사용자)
    WHERE u.이름 = '홍길동'
    COLUMNS (
        p.내용 AS 글내용,
        writer.이름 AS 작성자
    )
);
```

### 2.5 GRAPH_TABLE의 WHERE 절과 집계

GRAPH_TABLE 결과에 대해 외부 SQL에서 필터링과 집계를 수행할 수 있다.

```sql
-- 사용자별 친구 수 집계
SELECT 사용자, COUNT(친구) AS 친구수
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p:사용자) -[:친구관계]-> (f:사용자)
    COLUMNS (
        p.이름 AS 사용자,
        f.이름 AS 친구
    )
)
GROUP BY 사용자;

-- COLUMNS 내에서 집계 함수 사용
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p:사용자) -[:친구관계]-> (f:사용자)
    COLUMNS (
        p.이름 AS 사용자,
        COUNT(f.사용자ID) AS 친구수
    )
);

-- WHERE 절과 HAVING을 결합한 그래프 쿼리
SELECT 사용자, 친구수
FROM (
    SELECT 사용자, COUNT(*) AS 친구수
    FROM GRAPH_TABLE (소셜네트워크
        MATCH (p:사용자) -[:친구관계]-> (f:사용자)
        COLUMNS (
            p.이름 AS 사용자,
            f.이름 AS 친구
        )
    )
    GROUP BY 사용자
)
WHERE 친구수 >= 3;
```

### 2.6 레이블 표현식

노드와 엣지의 레이블에 논리 조합(OR, 부정 등)을 적용할 수 있다.

```sql
-- 레이블 OR 조건: 사용자 또는 관리자 노드 매칭
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (n:사용자|관리자)
    COLUMNS (
        n.이름 AS 이름
    )
);

-- 레이블 AND 조건: 두 레이블을 모두 가진 노드
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (n:사용자&프리미엄회원)
    COLUMNS (
        n.이름 AS 이름
    )
);

-- 레이블 부정: 특정 레이블이 아닌 노드
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (n WHERE n IS NOT 관리자)
    COLUMNS (
        n.이름 AS 이름
    )
);

-- 엣지 레이블 OR 조건: 친구관계 또는 팔로우 관계
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자) -[e:친구관계|팔로우]-> (p2:사용자)
    COLUMNS (
        p1.이름 AS 출발,
        p2.이름 AS 도착
    )
);

-- 와일드카드: 모든 레이블
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자) -[e:%]-> (p2)
    COLUMNS (
        p1.이름 AS 출발
    )
);
```

### 2.7 경로 패턴 (Path Patterns)

```sql
-- SHORTEST: 최단 경로
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH SHORTEST (p1:사용자 WHERE p1.이름 = '홍길동')
          -[e:친구관계]->{1,6}
          (p2:사용자 WHERE p2.이름 = '박민수')
    COLUMNS (
        p1.이름 AS 출발,
        p2.이름 AS 도착,
        ELEMENT_NUMBER(e) AS 거리
    )
);

-- ANY: 임의 경로 하나
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH ANY (p1:사용자 WHERE p1.이름 = '홍길동')
          -[e:친구관계]->+
          (p2:사용자 WHERE p2.이름 = '박민수')
    COLUMNS (
        p1.이름 AS 출발,
        p2.이름 AS 도착
    )
);

-- ALL: 모든 경로
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH ALL (p1:사용자 WHERE p1.이름 = '홍길동')
          -[e:친구관계]->+
          (p2:사용자 WHERE p2.이름 = '박민수')
    COLUMNS (
        p1.이름 AS 출발,
        p2.이름 AS 도착
    )
);

-- 경로 길이 제한
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH (p1:사용자 WHERE p1.이름 = '홍길동')
          -[:친구관계]->{1,3}  -- 1~3홉
          (p2:사용자)
    COLUMNS (
        p2.이름 AS 연결된사용자
    )
);
```

### 2.8 경로 변수와 경로 함수

경로 전체를 변수로 캡처하고, 경로에 대한 분석 함수를 사용할 수 있다.

```sql
-- 경로 변수에 경로 바인딩
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH p = (a:사용자 WHERE a.이름 = '홍길동')
              -[:친구관계]->+
              (b:사용자 WHERE b.이름 = '박민수')
    COLUMNS (
        a.이름 AS 출발,
        b.이름 AS 도착,
        PATH_LENGTH(p) AS 경로길이
    )
);

-- VERTICES: 경로상의 모든 노드 반환
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH p = (a:사용자) -[:친구관계]->{1,4} (b:사용자)
    COLUMNS (
        a.이름 AS 출발,
        b.이름 AS 도착,
        VERTICES(p) AS 경유노드
    )
);

-- EDGES: 경로상의 모든 엣지 반환
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH p = (a:사용자) -[:친구관계]->{1,4} (b:사용자)
    COLUMNS (
        a.이름 AS 출발,
        b.이름 AS 도착,
        EDGES(p) AS 경유엣지
    )
);

-- 최단 경로와 경로 함수 결합
SELECT *
FROM GRAPH_TABLE (소셜네트워크
    MATCH SHORTEST p = (a:사용자 WHERE a.이름 = '홍길동')
                       -[:친구관계]->{1,6}
                       (b:사용자 WHERE b.이름 = '박민수')
    COLUMNS (
        PATH_LENGTH(p) AS 최단거리,
        VERTICES(p) AS 경유노드,
        EDGES(p) AS 경유엣지
    )
);
```

### 2.9 그래프 패턴 구문 요약

| 구문 | 설명 | 예시 |
|------|------|------|
| `(n)` | 노드 | `(p:사용자)` |
| `(n:Label)` | 레이블이 있는 노드 | `(p:사용자)` |
| `(n:L1\|L2)` | 레이블 OR 조건 | `(n:사용자\|관리자)` |
| `(n:L1&L2)` | 레이블 AND 조건 | `(n:사용자&프리미엄회원)` |
| `(n IS NOT L)` | 레이블 부정 | `(n WHERE n IS NOT 관리자)` |
| `-[e]->` | 방향 있는 엣지 (정방향) | `-[f:친구관계]->` |
| `<-[e]-` | 방향 있는 엣지 (역방향) | `<-[f:친구관계]-` |
| `-[e]-` | 방향 없는 엣지 | `-[f:친구관계]-` |
| `->+` | 1회 이상 반복 | `->+` |
| `->{n,m}` | n~m회 반복 | `->{1,3}` |
| `SHORTEST` | 최단 경로 | `SHORTEST (a)->(b)` |
| `ANY` | 임의 경로 | `ANY (a)->(b)` |
| `ALL` | 모든 경로 | `ALL (a)->(b)` |
| `p = ...` | 경로 변수 바인딩 | `p = (a)-[]->(b)` |
| `PATH_LENGTH(p)` | 경로 길이 | `PATH_LENGTH(p) AS 거리` |
| `VERTICES(p)` | 경로상의 노드들 | `VERTICES(p) AS 노드목록` |
| `EDGES(p)` | 경로상의 엣지들 | `EDGES(p) AS 엣지목록` |
| `DROP PROPERTY GRAPH` | 그래프 삭제 | `DROP PROPERTY GRAPH g` |

---

## 3. JSON 데이터 타입 공식화

SQL:2016에서는 JSON을 문자열(VARCHAR/CLOB)로 저장했으나, SQL:2023에서는 JSON을 독립적인 일급 데이터 타입으로 공식화했다.

```sql
-- JSON 타입 컬럼
CREATE TABLE 설정 (
    설정키      VARCHAR(50) PRIMARY KEY,
    설정값      JSON NOT NULL
);

-- JSON 리터럴로 삽입
INSERT INTO 설정 VALUES ('테마', JSON '{"모드": "다크", "글꼴": "14px"}');
INSERT INTO 설정 VALUES ('알림', JSON '{"이메일": true, "SMS": false}');

-- JSON 타입 컬럼에 직접 삽입
INSERT INTO 설정 VALUES ('항목', JSON '[1, 2, 3, 4, 5]');

-- JSON 타입을 사용한 쿼리
SELECT 설정키,
       JSON_VALUE(설정값, '$.모드') AS 모드
FROM 설정
WHERE 설정키 = '테마';

-- JSON 타입과 기존 함수 호환
SELECT 설정키,
       JSON_QUERY(설정값, '$') AS 전체값
FROM 설정;

-- JSON 타입으로의 변환
SELECT CAST('{"키": "값"}' AS JSON) AS json값;

-- JSON 타입에서 문자열로 변환
SELECT CAST(설정값 AS VARCHAR(1000)) AS json문자열
FROM 설정;
```

### VARCHAR 저장 vs JSON 타입 비교

| 항목 | VARCHAR 저장 (SQL:2016) | JSON 타입 (SQL:2023) |
|------|------------------------|---------------------|
| 저장 형식 | 문자열 | 내부 JSON 표현 |
| 타입 안전성 | 낮음 (문자열 취급) | 높음 (JSON 전용 타입) |
| 유효성 검증 | CHECK 제약 필요 | 타입 레벨에서 자동 |
| 성능 | 파싱 필요 | 최적화 가능 |
| 인덱싱 | 제한적 | JSON 경로 인덱스 가능 |

---

## 4. JSON 함수 확장

SQL:2023에서 JSON 처리를 위한 새로운 함수들이 추가되었다.

### 4.1 JSON_SERIALIZE

JSON 값을 문자열로 직렬화한다.

```sql
-- 기본 사용: JSON 값을 문자열로 변환
SELECT JSON_SERIALIZE(설정값) FROM 설정;

-- 반환 타입 지정
SELECT JSON_SERIALIZE(설정값 RETURNING VARCHAR(1000)) FROM 설정;

-- FORMAT JSON 지정
SELECT JSON_SERIALIZE(설정값 RETURNING VARCHAR(1000) FORMAT JSON) FROM 설정;

-- CLOB으로 반환
SELECT JSON_SERIALIZE(설정값 RETURNING CLOB) FROM 설정;
```

### 4.2 JSON_SCALAR

JSON 스칼라 값을 SQL 값으로 변환한다. JSON 배열이나 객체가 아닌 단일 스칼라 값(문자열, 숫자, 불리언, null)을 추출한다.

```sql
-- JSON 문자열 스칼라를 SQL 문자열로 변환
SELECT JSON_SCALAR(JSON '"hello"');
-- 결과: 'hello'

-- JSON 숫자 스칼라를 SQL 숫자로 변환
SELECT JSON_SCALAR(JSON '42');
-- 결과: 42

-- JSON 불리언을 SQL 값으로 변환
SELECT JSON_SCALAR(JSON 'true');
-- 결과: TRUE

-- JSON null을 SQL NULL로 변환
SELECT JSON_SCALAR(JSON 'null');
-- 결과: NULL
```

### 4.3 향상된 JSON_TABLE

JSON_TABLE에서 중첩 경로와 오류 처리가 개선되었다.

```sql
-- 중첩 JSON 구조 처리
SELECT j.*
FROM 설정,
     JSON_TABLE(설정값, '$'
         COLUMNS (
             모드     VARCHAR(20) PATH '$.모드',
             글꼴     VARCHAR(20) PATH '$.글꼴',
             -- 존재하지 않는 경로에 대한 기본값
             언어     VARCHAR(20) PATH '$.언어' DEFAULT '한국어' ON EMPTY
         )
     ) AS j;

-- 배열 요소 풀기
SELECT j.*
FROM JSON_TABLE(
    JSON '[{"이름":"홍길동","나이":30},{"이름":"김철수","나이":25}]',
    '$[*]'
    COLUMNS (
        행번호   FOR ORDINALITY,
        이름     VARCHAR(50) PATH '$.이름',
        나이     INTEGER     PATH '$.나이'
    )
) AS j;

-- 중첩 경로 (NESTED PATH)
SELECT j.*
FROM JSON_TABLE(
    JSON '{"부서":"개발팀","직원":[{"이름":"홍길동"},{"이름":"김철수"}]}',
    '$'
    COLUMNS (
        부서     VARCHAR(50) PATH '$.부서',
        NESTED PATH '$.직원[*]'
            COLUMNS (
                직원이름 VARCHAR(50) PATH '$.이름'
            )
    )
) AS j;

-- 오류 처리
SELECT j.*
FROM 설정,
     JSON_TABLE(설정값, '$'
         COLUMNS (
             값 VARCHAR(100) PATH '$.키'
                 DEFAULT 'N/A' ON EMPTY
                 NULL ON ERROR
         )
     ) AS j;
```

---

## 5. ANY_VALUE

ANY_VALUE는 그룹 내에서 임의의 비NULL 값을 반환하는 집계 함수이다. GROUP BY에 포함되지 않은 컬럼을 SELECT에서 사용할 때 유용하다.

```sql
-- ANY_VALUE 기본 사용
SELECT 부서코드,
       ANY_VALUE(부서명) AS 부서명,  -- 부서코드당 부서명은 하나이므로 임의 값 OK
       COUNT(*) AS 인원수,
       AVG(급여) AS 평균급여
FROM 직원 e
  INNER JOIN 부서 d ON e.부서코드 = d.부서코드
GROUP BY 부서코드;

-- ANY_VALUE가 없으면 GROUP BY에 부서명을 포함하거나
-- MAX/MIN 등을 사용해야 했음 (의미상 부자연스러움)

-- 예: 고객별 가장 최근 주문의 정보
SELECT 고객번호,
       ANY_VALUE(고객명) AS 고객명,
       MAX(주문일) AS 최근주문일,
       ANY_VALUE(주문일이_최근인_주문.배송주소) AS 최근배송주소
FROM 주문
GROUP BY 고객번호;

-- 함수형 종속성이 있는 경우 유용
-- (PK → 다른컬럼의 관계에서 PK로 GROUP BY 할 때)
SELECT 제품코드,
       ANY_VALUE(제품명) AS 제품명,   -- 제품코드가 결정
       SUM(판매수량) AS 총판매수량
FROM 판매
GROUP BY 제품코드;
```

---

## 6. GREATEST / LEAST

여러 값 중 최대/최소 값을 반환하는 스칼라 함수이다.

```sql
-- GREATEST: 가장 큰 값
SELECT GREATEST(10, 20, 30) AS 최대;
-- 결과: 30

SELECT GREATEST('apple', 'banana', 'cherry') AS 최대;
-- 결과: 'cherry'

-- LEAST: 가장 작은 값
SELECT LEAST(10, 20, 30) AS 최소;
-- 결과: 10

SELECT LEAST('apple', 'banana', 'cherry') AS 최소;
-- 결과: 'apple'

-- 실용적 예: 날짜 범위 겹침 확인
SELECT *
FROM 이벤트A a, 이벤트B b
WHERE GREATEST(a.시작일, b.시작일) < LEAST(a.종료일, b.종료일);
-- 두 이벤트의 겹치는 기간이 존재하는지 확인

-- 값 범위 제한 (클램프)
SELECT 이름,
       GREATEST(LEAST(급여, 10000000), 3000000) AS 제한급여
       -- 급여를 300만~1000만 범위로 제한
FROM 직원;

-- NULL 처리
SELECT GREATEST(10, NULL, 30);
-- 결과: 구현에 따라 다름 (NULL 전파 또는 무시)

-- 날짜 비교
SELECT 이름,
       GREATEST(입사일, DATE '2020-01-01') AS 기준일이후입사일
FROM 직원;

-- 여러 컬럼 비교
SELECT 이름,
       GREATEST(중간고사, 기말고사, 과제점수) AS 최고점수,
       LEAST(중간고사, 기말고사, 과제점수) AS 최저점수
FROM 학생성적;
```

---

## 7. 향상된 숫자 리터럴

SQL:2023은 숫자 리터럴의 가독성과 표현력을 향상시켰다.

### 7.1 밑줄 구분자

```sql
-- 밑줄을 사용한 숫자 리터럴 (가독성 향상)
SELECT 1_000_000 AS 백만;          -- 1000000
SELECT 1_234_567.89 AS 금액;       -- 1234567.89
SELECT 3.141_592_653 AS 파이;      -- 3.141592653

-- 큰 숫자의 가독성
CREATE TABLE 예산 (
    부서코드    CHAR(4) PRIMARY KEY,
    연간예산    DECIMAL(15,2) DEFAULT 1_000_000_000.00
);

INSERT INTO 예산 VALUES ('D001', 50_000_000.00);
INSERT INTO 예산 VALUES ('D002', 30_000_000.00);

-- WHERE 절에서 사용
SELECT 이름, 급여
FROM 직원
WHERE 급여 >= 5_000_000;
```

### 7.2 이진/8진/16진 리터럴

```sql
-- 이진 리터럴 (0b 접두사)
SELECT 0b1010 AS 이진;              -- 10
SELECT 0b11111111 AS 이진_255;      -- 255

-- 8진 리터럴 (0o 접두사)
SELECT 0o777 AS 팔진;               -- 511
SELECT 0o12 AS 팔진_10;             -- 10

-- 16진 리터럴 (0x 접두사)
SELECT 0xFF AS 십육진;              -- 255
SELECT 0x1A2B AS 십육진수;          -- 6699

-- 밑줄과 결합
SELECT 0b1111_0000 AS 비트마스크;   -- 240
SELECT 0xFF_FF AS 큰16진수;         -- 65535
```

---

## 8. 향상된 숫자 함수

SQL:2023에서 수학 함수들의 표준화가 강화되었다.

```sql
-- LOG: 자연로그 (밑이 e)
SELECT LOG(2.718281828) AS 자연로그;
-- 결과: 약 1.0

-- LOG: 특정 밑의 로그
SELECT LOG(2, 8) AS 로그2_8;
-- 결과: 3.0

-- LOG10: 상용로그 (밑이 10)
SELECT LOG10(1000) AS 상용로그;
-- 결과: 3.0

-- CEIL (CEILING): 올림
SELECT CEIL(4.2) AS 올림;
-- 결과: 5

SELECT CEIL(-4.8) AS 올림;
-- 결과: -4

-- FLOOR: 내림
SELECT FLOOR(4.8) AS 내림;
-- 결과: 4

SELECT FLOOR(-4.2) AS 내림;
-- 결과: -5

-- EXP: 지수 함수 (e^x)
SELECT EXP(1) AS 자연상수;
-- 결과: 약 2.718281828

-- POWER: 거듭제곱
SELECT POWER(2, 10) AS 거듭제곱;
-- 결과: 1024

-- SQRT: 제곱근
SELECT SQRT(144) AS 제곱근;
-- 결과: 12

-- ABS: 절대값
SELECT ABS(-42) AS 절대값;
-- 결과: 42

-- MOD: 나머지
SELECT MOD(17, 5) AS 나머지;
-- 결과: 2

-- 조합 사용 예: 복리 이자 계산
SELECT 이름,
       원금,
       FLOOR(원금 * POWER(1 + 이율, 기간)) AS 만기금액
FROM 예금;

-- 로그 스케일 변환
SELECT 제품명,
       판매수량,
       LOG10(판매수량 + 1) AS 로그스케일
FROM 제품판매;
```

---

## 9. UNIQUE NULLS (NOT) DISTINCT

UNIQUE 제약사항에서 NULL 값의 처리 방식을 명시적으로 지정한다.

### 기존 동작의 모호성

SQL 표준에서 UNIQUE 제약사항의 NULL 처리는 모호했으며, DBMS마다 동작이 달랐다:
- PostgreSQL: NULL 중복 허용 (여러 NULL 가능)
- SQL Server: NULL 중복 불허 (NULL 하나만 가능) - 기본 동작
- Oracle: NULL 행 자체를 제약 검사에서 제외

### SQL:2023의 명시적 지정

```sql
-- NULLS DISTINCT: NULL 값을 각각 고유한 것으로 취급
-- → 여러 NULL 허용 (PostgreSQL 기본 동작)
CREATE TABLE 직원1 (
    직원번호    INTEGER PRIMARY KEY,
    이메일      VARCHAR(100) UNIQUE NULLS DISTINCT
);

INSERT INTO 직원1 VALUES (1, 'a@test.com');
INSERT INTO 직원1 VALUES (2, NULL);     -- 허용
INSERT INTO 직원1 VALUES (3, NULL);     -- 허용 (각 NULL은 별개)
-- INSERT INTO 직원1 VALUES (4, 'a@test.com'); -- 오류 (중복)

-- NULLS NOT DISTINCT: NULL 값을 동일한 것으로 취급
-- → NULL 하나만 허용 (SQL Server 기본 동작)
CREATE TABLE 직원2 (
    직원번호    INTEGER PRIMARY KEY,
    이메일      VARCHAR(100) UNIQUE NULLS NOT DISTINCT
);

INSERT INTO 직원2 VALUES (1, 'a@test.com');
INSERT INTO 직원2 VALUES (2, NULL);     -- 허용
-- INSERT INTO 직원2 VALUES (3, NULL);  -- 오류 (NULL 중복)

-- 복합 UNIQUE 제약에서
CREATE TABLE 배정 (
    직원번호    INTEGER,
    프로젝트코드 CHAR(6),
    역할        VARCHAR(20),
    UNIQUE (직원번호, 프로젝트코드) NULLS NOT DISTINCT
);
```

### NULLS DISTINCT vs NULLS NOT DISTINCT 비교

| 옵션 | NULL 취급 | 복수 NULL 허용 | 사용 사례 |
|------|-----------|:-----------:|------|
| NULLS DISTINCT | 각각 고유 | O | 선택적 필드 (이메일 등) |
| NULLS NOT DISTINCT | 모두 동일 | X | NULL도 유일해야 하는 경우 |

---

## 10. SIMPLE WHEN 확장

CASE 식의 WHEN 절에서 다중 값을 비교할 수 있도록 확장되었다.

```sql
-- 기존: 각 값마다 WHEN 절 필요
SELECT CASE status
    WHEN 'A' THEN '활성'
    WHEN 'B' THEN '활성'
    WHEN 'C' THEN '비활성'
    WHEN 'D' THEN '비활성'
    ELSE '미분류'
END AS 상태분류
FROM 계정;

-- SQL:2023: 하나의 WHEN 절에 다중 값 지정
SELECT CASE status
    WHEN 'A', 'B' THEN '활성'
    WHEN 'C', 'D' THEN '비활성'
    ELSE '미분류'
END AS 상태분류
FROM 계정;

-- 숫자 값에 대한 다중 비교
SELECT CASE 등급코드
    WHEN 1, 2, 3 THEN '상위'
    WHEN 4, 5, 6 THEN '중위'
    WHEN 7, 8, 9 THEN '하위'
    ELSE '미지정'
END AS 등급분류
FROM 회원;

-- UPDATE 문에서 활용
UPDATE 주문
SET 상태 = CASE 상태코드
    WHEN 10, 20 THEN '처리중'
    WHEN 30, 40, 50 THEN '배송중'
    WHEN 60 THEN '완료'
    ELSE '기타'
END;
```

---

## 11. 개선된 FETCH FIRST

FETCH FIRST에서 PERCENT와 WITH TIES를 조합하여 상위 비율 행을 동순위 포함하여 조회한다.

```sql
-- 상위 10% 행 조회
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 10 PERCENT ROWS ONLY;

-- 상위 10% 행 + 동순위 포함
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 10 PERCENT ROWS WITH TIES;

-- 상위 5건 + 동순위 포함
SELECT 이름, 점수
FROM 학생
ORDER BY 점수 DESC
FETCH FIRST 5 ROWS WITH TIES;

-- OFFSET과 결합
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 10 ROWS
FETCH FIRST 5 ROWS WITH TIES;

-- PERCENT와 OFFSET 결합
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 10 ROWS
FETCH FIRST 25 PERCENT ROWS ONLY;
```

---

## 12. Multi-value Constructor 개선

VALUES 절의 표현력이 확장되었다.

```sql
-- 기본 VALUES 생성자
SELECT * FROM (VALUES (1, '홍길동'), (2, '김철수'), (3, '이영희'))
    AS t(번호, 이름);

-- VALUES를 서브쿼리로 활용
SELECT 이름, 급여
FROM 직원
WHERE 부서코드 IN (VALUES ('D001'), ('D002'), ('D003'));

-- INSERT에서 다중 행 삽입
INSERT INTO 직원 (직원번호, 이름, 부서코드)
VALUES (1, '홍길동', 'D001'),
       (2, '김철수', 'D002'),
       (3, '이영희', 'D003');

-- MERGE에서 VALUES 소스 활용
MERGE INTO 직원 AS t
USING (VALUES (1, '홍길동', 5000000),
              (2, '김철수', 6000000),
              (3, '이영희', 7000000))
    AS s(직원번호, 이름, 급여)
ON t.직원번호 = s.직원번호
WHEN MATCHED THEN
    UPDATE SET 급여 = s.급여
WHEN NOT MATCHED THEN
    INSERT (직원번호, 이름, 급여) VALUES (s.직원번호, s.이름, s.급여);

-- JOIN에서 VALUES 활용
SELECT e.이름, v.설명
FROM 직원 e
JOIN (VALUES ('D001', '개발팀'), ('D002', '기획팀'), ('D003', '인사팀'))
    AS v(부서코드, 설명)
ON e.부서코드 = v.부서코드;
```

---

## 13. 기타 개선사항

### 13.1 개선된 문자열 처리

```sql
-- TRIM_ARRAY: 배열 뒤에서 n개 요소 제거
SELECT TRIM_ARRAY(ARRAY[1,2,3,4,5], 2) AS 결과;
-- 결과: [1, 2, 3]
```

### 13.2 ORDER BY 확장

```sql
-- FETCH FIRST에서 PERCENT와 WITH TIES 확장 사용
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 10 PERCENT ROWS WITH TIES;
```

### 13.3 정규화된 기능 추가

```sql
-- 다양한 소규모 개선사항들이 Core SQL에 통합됨
-- 예: 이전에 선택적 기능이었던 것들이 Core로 이동
```

---

## 14. 영향과 의의

1. SQL/PGQ (프로퍼티 그래프 쿼리): 관계형 데이터베이스에 그래프 쿼리 기능을 통합한 혁신적인 변화이다. Neo4j 같은 전용 그래프 DB를 사용하지 않고도 소셜 네트워크, 추천 시스템, 사기 탐지 등의 그래프 분석을 관계형 DB에서 수행할 수 있다.

2. JSON 데이터 타입 공식화: JSON을 일급 데이터 타입으로 승격하여 타입 안전성, 성능, 인덱싱이 향상되었다. SQL:2016에서 문자열 기반으로 도입된 JSON 지원이 완성 단계에 도달했다.

3. ANY_VALUE: GROUP BY의 오랜 불편함(함수적 종속 컬럼도 GROUP BY에 포함해야 하는 문제)을 해결했다.

4. GREATEST/LEAST: 대부분의 DBMS에서 이미 벤더 확장으로 제공하던 함수를 표준화하여 이식성을 확보했다.

5. 숫자 리터럴 향상: 밑줄 구분자와 다양한 진법 리터럴은 코드 가독성을 향상시킨다.

6. UNIQUE NULLS 처리: DBMS간 불일치를 해결하는 명시적 구문을 제공했다.

### SQL 표준 진화 총정리

| 표준 | 핵심 기여 |
|------|-----------|
| SQL-86 | 최초 SQL 표준 |
| SQL-89 | 무결성 제약사항 |
| SQL-92 | JOIN, CASE, 날짜/시간, 서브쿼리, INFORMATION_SCHEMA |
| SQL:1999 | CTE, 트리거, UDT, PSM, OLAP, BOOLEAN, LOB |
| SQL:2003 | 윈도우 함수, MERGE, 시퀀스, IDENTITY, XML, BIGINT |
| SQL:2006 | XQuery 통합, XMLTABLE, XMLQUERY |
| SQL:2008 | TRUNCATE, OFFSET/FETCH, INSTEAD OF, 정규 표현식 |
| SQL:2011 | 시간적 DB (Temporal), LISTAGG |
| SQL:2016 | JSON, MATCH_RECOGNIZE, PTF, DECFLOAT |
| SQL:2023 | 그래프 쿼리 (PGQ), JSON 타입, ANY_VALUE, GREATEST/LEAST |

SQL:2023은 관계형, 문서형(JSON), 그래프라는 세 가지 데이터 모델을 하나의 SQL 표준 안에서 통합적으로 다룰 수 있게 만든 표준이다. 이는 멀티모델 데이터베이스의 표준적 기반을 제공한다.

---

> 참고: SQL:2023 표준은 ISO/IEC 9075:2023 시리즈로 발행되었다. SQL/PGQ는 Part 16으로 신규 추가되었다.
