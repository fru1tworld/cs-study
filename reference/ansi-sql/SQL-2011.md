# SQL:2011 표준 완벽 가이드

## ISO/IEC 9075:2011 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [시간적 데이터베이스 (Temporal Database)](#2-시간적-데이터베이스)
3. [PERIOD 정의](#3-period-정의)
4. [애플리케이션 시간](#4-애플리케이션-시간)
5. [시스템 시간 (SYSTEM_TIME)](#5-시스템-시간)
6. [시스템 버전 관리 테이블](#6-시스템-버전-관리-테이블)
7. [시간적 PRIMARY KEY와 참조 무결성](#7-시간적-primary-key와-참조-무결성)
8. [시간적 쿼리](#8-시간적-쿼리)
9. [시간적 DML 상세](#9-시간적-dml-상세)
10. [시간적 뷰](#10-시간적-뷰)
11. [시간적 테이블의 ALTER 문](#11-시간적-테이블의-alter-문)
12. [PERIOD 술어 (Predicates)](#12-period-술어)
13. [시간적 집합 연산](#13-시간적-집합-연산)
14. [NORMALIZE](#14-normalize)
15. [LISTAGG](#15-listagg)
16. [윈도우 함수 확장](#16-윈도우-함수-확장)
17. [윈도우 함수 EXCLUDE 절](#17-윈도우-함수-exclude-절)
18. [RESPECT NULLS / IGNORE NULLS](#18-respect-nulls--ignore-nulls)

---

## 1. 개요

SQL:2011(공식명: ISO/IEC 9075:2011)은 SQL 표준에 시간적 데이터베이스(Temporal Database) 기능을 대거 도입한 중요한 개정판이다. 이를 통해 데이터의 시간적 변화를 데이터베이스 레벨에서 자동으로 관리하고 질의할 수 있게 되었다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2011 |
| 발표 연도 | 2011년 |
| 이전 표준 | SQL:2008 |
| 다음 표준 | SQL:2016 |
| 핵심 추가 기능 | 시간적 데이터베이스, LISTAGG, 윈도우 함수 확장 |

---

## 2. 시간적 데이터베이스

시간적 데이터베이스는 데이터의 시간적 변화를 체계적으로 추적하는 기능이다.

### 두 가지 시간 차원

| 시간 차원 | 설명 | 관리 주체 |
|-----------|------|-----------|
| 애플리케이션 시간 (Application Time) | 비즈니스 관점의 유효 기간 (예: 계약 기간, 보험 유효 기간) | 사용자/애플리케이션 |
| 시스템 시간 (System Time) | 데이터가 데이터베이스에 존재한 기간 (삽입~삭제/갱신 시점) | DBMS 자동 관리 |

### Bitemporal 테이블

두 시간 차원을 모두 갖는 테이블을 비시간적(bitemporal) 테이블이라 한다.

```
                    시스템 시간 (언제 기록되었는가)
                    ─────────────────────────►
                    │
애플리케이션 시간    │   현재 유효하고
(언제 유효한가)      │   현재 기록된 데이터
                    │
                    │
                    ▼
```

---

## 3. PERIOD 정의

PERIOD는 두 개의 날짜/시간 컬럼으로 구성된 기간을 정의한다. 시작점은 포함되고 종료점은 제외된다 (반개방 구간 [시작, 종료)).

```sql
-- PERIOD 정의
CREATE TABLE 보험계약 (
    계약번호        INTEGER,
    고객번호        INTEGER,
    보험유형        VARCHAR(30),
    보험료          DECIMAL(10,2),
    유효시작일      DATE NOT NULL,
    유효종료일      DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작일, 유효종료일),
    PRIMARY KEY (계약번호)
);

-- PERIOD의 의미: [유효시작일, 유효종료일)
-- 유효시작일은 포함, 유효종료일은 미포함 (반개방 구간)

-- 데이터 삽입
INSERT INTO 보험계약 VALUES
    (1, 100, '생명보험', 50000, DATE '2024-01-01', DATE '2025-01-01');
INSERT INTO 보험계약 VALUES
    (2, 100, '자동차보험', 80000, DATE '2024-03-01', DATE '2025-03-01');
INSERT INTO 보험계약 VALUES
    (3, 200, '생명보험', 60000, DATE '2024-06-01', DATE '2025-06-01');
```

---

## 4. 애플리케이션 시간

애플리케이션 시간은 비즈니스 관점에서 데이터가 유효한 기간을 나타낸다.

### 4.1 애플리케이션 시간 테이블 생성

```sql
CREATE TABLE 직원_이력 (
    직원번호        INTEGER NOT NULL,
    부서코드        CHAR(4) NOT NULL,
    직급            VARCHAR(20) NOT NULL,
    급여            DECIMAL(10,2) NOT NULL,
    유효시작        DATE NOT NULL,
    유효종료        DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작, 유효종료),
    -- 같은 직원에 대해 유효기간이 겹치지 않도록 제약
    PRIMARY KEY (직원번호, 유효기간 WITHOUT OVERLAPS)
);

-- 데이터 삽입: 직원 101의 이력
INSERT INTO 직원_이력 VALUES
    (101, 'D001', '사원', 3000000, DATE '2020-03-01', DATE '2022-01-01');
INSERT INTO 직원_이력 VALUES
    (101, 'D001', '대리', 4000000, DATE '2022-01-01', DATE '2024-01-01');
INSERT INTO 직원_이력 VALUES
    (101, 'D002', '과장', 5000000, DATE '2024-01-01', DATE '9999-12-31');
```

### 4.2 애플리케이션 시간 기반 DML

```sql
-- FOR PORTION OF를 사용한 기간 기반 UPDATE
-- 2023년 동안 급여를 변경
UPDATE 직원_이력
    FOR PORTION OF 유효기간
    FROM DATE '2023-01-01' TO DATE '2024-01-01'
SET 급여 = 4500000
WHERE 직원번호 = 101;

-- 위 UPDATE의 효과:
-- 기존: (101, 'D001', '대리', 4000000, 2022-01-01, 2024-01-01)
-- 분할됨:
--   (101, 'D001', '대리', 4000000, 2022-01-01, 2023-01-01)  ← 유지
--   (101, 'D001', '대리', 4500000, 2023-01-01, 2024-01-01)  ← 급여 변경
-- DBMS가 자동으로 기간을 분할하여 처리

-- FOR PORTION OF를 사용한 기간 기반 DELETE
DELETE FROM 직원_이력
    FOR PORTION OF 유효기간
    FROM DATE '2023-06-01' TO DATE '2023-12-31'
WHERE 직원번호 = 101;

-- 위 DELETE의 효과:
-- 2023-06-01 ~ 2023-12-31 기간의 데이터만 삭제
-- 나머지 기간의 데이터는 자동으로 분할되어 보존
```

---

## 5. 시스템 시간 (SYSTEM_TIME)

시스템 시간은 데이터가 데이터베이스에 실제로 존재한 기간을 DBMS가 자동으로 관리한다.

```sql
CREATE TABLE 직원_시스템관리 (
    직원번호        INTEGER PRIMARY KEY,
    이름            VARCHAR(50) NOT NULL,
    부서코드        CHAR(4),
    급여            DECIMAL(10,2),
    시스템시작      TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    시스템종료      TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (시스템시작, 시스템종료)
) WITH SYSTEM VERSIONING;
```

### 시스템 시간 컬럼의 특징

| 특성 | 설명 |
|------|------|
| GENERATED ALWAYS AS ROW START | DBMS가 자동으로 행 삽입/갱신 시점 기록 |
| GENERATED ALWAYS AS ROW END | DBMS가 자동으로 행 삭제/갱신 시점 기록 |
| 사용자 수정 불가 | 시스템이 자동 관리 (GENERATED ALWAYS) |
| 타입 | TIMESTAMP(6) 이상 권장 |

---

## 6. 시스템 버전 관리 테이블

`WITH SYSTEM VERSIONING`으로 선언된 테이블은 모든 변경 이력을 자동으로 보존한다.

### 6.1 동작 원리

```sql
-- 시스템 버전 관리 테이블 생성
CREATE TABLE 제품 (
    제품코드        CHAR(10) PRIMARY KEY,
    제품명          VARCHAR(100) NOT NULL,
    가격            DECIMAL(10,2) NOT NULL,
    시스템시작      TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    시스템종료      TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (시스템시작, 시스템종료)
) WITH SYSTEM VERSIONING;

-- 1단계: INSERT (2024-01-01 10:00에 실행)
INSERT INTO 제품 VALUES ('P001', '노트북', 1500000, DEFAULT, DEFAULT);
-- 결과: ('P001', '노트북', 1500000, 2024-01-01 10:00, 9999-12-31 23:59)

-- 2단계: UPDATE (2024-03-15 14:00에 실행)
UPDATE 제품 SET 가격 = 1400000 WHERE 제품코드 = 'P001';
-- 현재 행: ('P001', '노트북', 1400000, 2024-03-15 14:00, 9999-12-31 23:59)
-- 이력 행: ('P001', '노트북', 1500000, 2024-01-01 10:00, 2024-03-15 14:00)

-- 3단계: UPDATE (2024-06-01 09:00에 실행)
UPDATE 제품 SET 제품명 = '노트북 Pro', 가격 = 1600000 WHERE 제품코드 = 'P001';
-- 현재 행: ('P001', '노트북 Pro', 1600000, 2024-06-01 09:00, 9999-12-31 23:59)
-- 이력 행1: ('P001', '노트북', 1500000, 2024-01-01 10:00, 2024-03-15 14:00)
-- 이력 행2: ('P001', '노트북', 1400000, 2024-03-15 14:00, 2024-06-01 09:00)

-- 4단계: DELETE (2024-09-01 16:00에 실행)
DELETE FROM 제품 WHERE 제품코드 = 'P001';
-- 현재 행: 없음 (삭제됨)
-- 이력 행1: ('P001', '노트북', 1500000, 2024-01-01 10:00, 2024-03-15 14:00)
-- 이력 행2: ('P001', '노트북', 1400000, 2024-03-15 14:00, 2024-06-01 09:00)
-- 이력 행3: ('P001', '노트북 Pro', 1600000, 2024-06-01 09:00, 2024-09-01 16:00)
```

### 6.2 Bitemporal 테이블

두 시간 차원을 모두 갖는 테이블.

```sql
CREATE TABLE 보험계약_이력 (
    계약번호        INTEGER NOT NULL,
    고객번호        INTEGER NOT NULL,
    보험유형        VARCHAR(30) NOT NULL,
    보험료          DECIMAL(10,2) NOT NULL,
    -- 애플리케이션 시간 (비즈니스 유효 기간)
    유효시작        DATE NOT NULL,
    유효종료        DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작, 유효종료),
    -- 시스템 시간 (데이터베이스 기록 기간)
    시스템시작      TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    시스템종료      TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (시스템시작, 시스템종료),
    -- 키: 계약번호 + 유효기간 (겹침 방지)
    PRIMARY KEY (계약번호, 유효기간 WITHOUT OVERLAPS)
) WITH SYSTEM VERSIONING;
```

---

## 7. 시간적 PRIMARY KEY와 참조 무결성

### 7.1 WITHOUT OVERLAPS

```sql
-- 시간적 PRIMARY KEY: 같은 키 값에 대해 기간이 겹치지 않도록 보장
CREATE TABLE 직원_직급 (
    직원번호        INTEGER NOT NULL,
    직급            VARCHAR(20) NOT NULL,
    유효시작        DATE NOT NULL,
    유효종료        DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작, 유효종료),
    PRIMARY KEY (직원번호, 유효기간 WITHOUT OVERLAPS)
);

-- 가능: 같은 직원이지만 기간이 연속 (겹치지 않음)
INSERT INTO 직원_직급 VALUES (101, '사원', DATE '2020-01-01', DATE '2022-01-01');
INSERT INTO 직원_직급 VALUES (101, '대리', DATE '2022-01-01', DATE '2024-01-01');

-- 오류: 같은 직원의 기간이 겹침
-- INSERT INTO 직원_직급 VALUES (101, '과장', DATE '2023-06-01', DATE '2025-01-01');
-- → 2023-06-01~2024-01-01 구간에서 대리 기간과 겹침
```

### 7.2 시간적 참조 무결성

```sql
CREATE TABLE 부서_이력 (
    부서코드        CHAR(4) NOT NULL,
    부서명          VARCHAR(50) NOT NULL,
    유효시작        DATE NOT NULL,
    유효종료        DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작, 유효종료),
    PRIMARY KEY (부서코드, 유효기간 WITHOUT OVERLAPS)
);

CREATE TABLE 직원_배정 (
    직원번호        INTEGER NOT NULL,
    부서코드        CHAR(4) NOT NULL,
    유효시작        DATE NOT NULL,
    유효종료        DATE NOT NULL,
    PERIOD FOR 유효기간 (유효시작, 유효종료),
    PRIMARY KEY (직원번호, 유효기간 WITHOUT OVERLAPS),
    FOREIGN KEY (부서코드, PERIOD 유효기간)
        REFERENCES 부서_이력 (부서코드, PERIOD 유효기간)
);

-- 시간적 참조 무결성:
-- 직원의 유효기간 동안 참조하는 부서가 반드시 존재해야 함
-- 부서가 2020-01-01 ~ 2025-01-01에 유효하다면,
-- 해당 부서를 참조하는 직원도 이 기간 내여야 함
```

---

## 8. 시간적 쿼리

### 8.1 FOR SYSTEM_TIME AS OF

특정 시점의 데이터 상태를 조회한다.

```sql
-- 2024년 2월 1일 시점의 제품 정보
SELECT * FROM 제품
    FOR SYSTEM_TIME AS OF TIMESTAMP '2024-02-01 00:00:00';

-- 지난 분기 말 시점의 고객 정보
SELECT * FROM 고객
    FOR SYSTEM_TIME AS OF TIMESTAMP '2024-03-31 23:59:59';

-- 특정 시점의 직원-부서 정보 (조인)
SELECT e.이름, d.부서명, e.급여
FROM 직원_시스템관리 FOR SYSTEM_TIME AS OF TIMESTAMP '2024-01-15 12:00:00' e
  INNER JOIN 부서_시스템관리 FOR SYSTEM_TIME AS OF TIMESTAMP '2024-01-15 12:00:00' d
    ON e.부서코드 = d.부서코드;
```

### 8.2 FOR SYSTEM_TIME FROM ... TO

특정 기간 내 존재했던 모든 버전을 조회한다 (시작 포함, 종료 미포함).

```sql
-- 2024년 상반기 동안의 모든 제품 변경 이력
SELECT * FROM 제품
    FOR SYSTEM_TIME FROM TIMESTAMP '2024-01-01 00:00:00'
                    TO   TIMESTAMP '2024-07-01 00:00:00';

-- 특정 제품의 가격 변경 이력
SELECT 제품명, 가격, 시스템시작, 시스템종료
FROM 제품
    FOR SYSTEM_TIME FROM TIMESTAMP '2024-01-01 00:00:00'
                    TO   TIMESTAMP '2024-12-31 23:59:59'
WHERE 제품코드 = 'P001'
ORDER BY 시스템시작;
```

### 8.3 FOR SYSTEM_TIME BETWEEN ... AND

특정 기간 내 존재했던 모든 버전 조회 (양 끝점 모두 포함).

```sql
-- BETWEEN: 양 끝점 포함
SELECT * FROM 제품
    FOR SYSTEM_TIME BETWEEN TIMESTAMP '2024-01-01 00:00:00'
                       AND  TIMESTAMP '2024-06-30 23:59:59';

-- 감사 목적: 특정 기간 동안의 모든 데이터 변경 추적
SELECT 직원번호, 이름, 급여, 시스템시작, 시스템종료
FROM 직원_시스템관리
    FOR SYSTEM_TIME BETWEEN TIMESTAMP '2024-01-01 00:00:00'
                       AND  TIMESTAMP '2024-12-31 23:59:59'
WHERE 직원번호 = 101
ORDER BY 시스템시작;
```

### 시간적 쿼리 비교

| 구문 | 시작점 | 종료점 | 용도 |
|------|--------|--------|------|
| AS OF t | - | - | 특정 시점의 스냅샷 |
| FROM t1 TO t2 | 포함 | 미포함 | 반개방 구간 이력 조회 |
| BETWEEN t1 AND t2 | 포함 | 포함 | 폐쇄 구간 이력 조회 |

### 8.4 실용적인 시간적 쿼리 예제

```sql
-- 데이터 복원: 잘못된 변경을 되돌리기 위해 이전 상태 조회
SELECT * FROM 직원_시스템관리
    FOR SYSTEM_TIME AS OF TIMESTAMP '2024-06-14 23:59:59'
WHERE 직원번호 = 101;

-- 변경 감사: 특정 기간 동안 급여가 변경된 직원 목록
SELECT DISTINCT 현재.직원번호, 현재.이름
FROM 직원_시스템관리 AS 현재
WHERE EXISTS (
    SELECT 1
    FROM 직원_시스템관리
        FOR SYSTEM_TIME FROM TIMESTAMP '2024-01-01 00:00:00'
                        TO   TIMESTAMP '2024-07-01 00:00:00' AS 이력
    WHERE 이력.직원번호 = 현재.직원번호
      AND 이력.급여 <> 현재.급여
);

-- 시점 비교: 연초 대비 현재 급여 변화
SELECT
    현재.직원번호,
    현재.이름,
    과거.급여 AS 연초급여,
    현재.급여 AS 현재급여,
    현재.급여 - 과거.급여 AS 변동액
FROM 직원_시스템관리 AS 현재
  INNER JOIN 직원_시스템관리
      FOR SYSTEM_TIME AS OF TIMESTAMP '2024-01-01 00:00:00' AS 과거
    ON 현재.직원번호 = 과거.직원번호
WHERE 현재.급여 <> 과거.급여;
```

---

## 9. 시간적 DML 상세

시스템 버전 관리 테이블에서 INSERT, UPDATE, DELETE가 이력을 생성하는 방식을 상세히 정리한다.

### 9.1 INSERT

시스템 버전 관리 테이블에 INSERT하면 시스템시작에 현재 트랜잭션 타임스탬프가, 시스템종료에 최대값이 자동 설정된다.

```sql
-- 시스템 버전 관리 테이블에 삽입
INSERT INTO 직원_시스템관리 (직원번호, 이름, 부서코드, 급여)
VALUES (201, '김개발', 'D001', 5000000);

-- DBMS가 자동으로 설정:
--   시스템시작 = CURRENT_TIMESTAMP (예: 2024-04-01 09:00:00.000000)
--   시스템종료 = 9999-12-31 23:59:59.999999
-- 사용자가 시스템시작/시스템종료에 값을 직접 지정하면 오류 발생
```

### 9.2 UPDATE

UPDATE 시 DBMS는 기존 행을 이력 행으로 전환하고, 변경된 값을 가진 새 현재 행을 생성한다.

```sql
-- 급여 변경 (2024-07-01 10:00:00에 실행한다고 가정)
UPDATE 직원_시스템관리
SET 급여 = 5500000
WHERE 직원번호 = 201;

-- DBMS가 자동으로 수행하는 작업:
-- 1) 기존 행의 시스템종료를 현재 트랜잭션 타임스탬프로 변경하여 이력으로 전환
--    (201, '김개발', 'D001', 5000000, 2024-04-01 09:00, 2024-07-01 10:00) ← 이력
-- 2) 변경된 값으로 새 현재 행 생성
--    (201, '김개발', 'D001', 5500000, 2024-07-01 10:00, 9999-12-31 23:59) ← 현재

-- 여러 컬럼을 동시에 변경해도 하나의 이력 행만 생성된다
UPDATE 직원_시스템관리
SET 부서코드 = 'D002', 급여 = 6000000
WHERE 직원번호 = 201;
```

### 9.3 DELETE

DELETE 시 DBMS는 현재 행의 시스템종료를 현재 타임스탬프로 설정하여 이력으로 전환한다. 물리적으로 삭제되지 않는다.

```sql
-- 직원 삭제 (2024-10-01 15:00:00에 실행한다고 가정)
DELETE FROM 직원_시스템관리
WHERE 직원번호 = 201;

-- DBMS가 자동으로 수행하는 작업:
-- 현재 행의 시스템종료를 현재 트랜잭션 타임스탬프로 변경
--   (201, '김개발', 'D002', 6000000, ..., 2024-10-01 15:00) ← 이력으로 전환
-- 현재 행은 더 이상 존재하지 않음
-- 이력 행은 모두 보존됨

-- 삭제된 데이터는 FOR SYSTEM_TIME으로 조회 가능
SELECT * FROM 직원_시스템관리
    FOR SYSTEM_TIME AS OF TIMESTAMP '2024-09-01 00:00:00'
WHERE 직원번호 = 201;
-- 결과: (201, '김개발', 'D002', 6000000, ...)
```

### 9.4 시스템 버전 관리 테이블에서의 DML 요약

| DML | 현재 행 | 이력 행 |
|-----|---------|---------|
| INSERT | 새 행 생성 (시스템시작=현재, 시스템종료=최대값) | 생성 안 함 |
| UPDATE | 새 현재 행 생성 (변경된 값, 시스템시작=현재) | 기존 행을 이력으로 전환 (시스템종료=현재) |
| DELETE | 현재 행 제거 | 기존 행을 이력으로 전환 (시스템종료=현재) |

---

## 10. 시간적 뷰

시간적 테이블에 대해 뷰를 정의할 수 있다. FOR SYSTEM_TIME 절을 뷰 정의에 포함하여 특정 시점이나 기간의 데이터를 고정적으로 제공할 수 있다.

```sql
-- 현재 시점의 데이터만 보여주는 뷰
CREATE VIEW 현재_직원 AS
SELECT * FROM 직원_시스템관리
    FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP;

-- 뷰 조회
SELECT 직원번호, 이름, 급여 FROM 현재_직원
WHERE 부서코드 = 'D001';

-- 특정 시점의 스냅샷 뷰
CREATE VIEW 연초_제품현황 AS
SELECT 제품코드, 제품명, 가격
FROM 제품
    FOR SYSTEM_TIME AS OF TIMESTAMP '2024-01-01 00:00:00';

-- 특정 기간의 이력을 보여주는 뷰
CREATE VIEW 상반기_급여변경이력 AS
SELECT 직원번호, 이름, 급여, 시스템시작, 시스템종료
FROM 직원_시스템관리
    FOR SYSTEM_TIME FROM TIMESTAMP '2024-01-01 00:00:00'
                    TO   TIMESTAMP '2024-07-01 00:00:00';

-- Bitemporal 테이블에 대한 뷰
CREATE VIEW 현재유효_보험계약 AS
SELECT 계약번호, 고객번호, 보험유형, 보험료, 유효시작, 유효종료
FROM 보험계약_이력
    FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP
WHERE 유효시작 <= CURRENT_DATE AND 유효종료 > CURRENT_DATE;
```

---

## 11. 시간적 테이블의 ALTER 문

기존 테이블에 시간적 기능을 추가하거나 제거할 수 있다.

### 11.1 시스템 버전 관리 추가

```sql
-- 기존 테이블에 시스템 시간 컬럼과 PERIOD 추가
ALTER TABLE 직원
    ADD COLUMN 시스템시작 TIMESTAMP(6) GENERATED ALWAYS AS ROW START;
ALTER TABLE 직원
    ADD COLUMN 시스템종료 TIMESTAMP(6) GENERATED ALWAYS AS ROW END;
ALTER TABLE 직원
    ADD PERIOD FOR SYSTEM_TIME (시스템시작, 시스템종료);

-- 시스템 버전 관리 활성화
ALTER TABLE 직원 ADD SYSTEM VERSIONING;
```

### 11.2 시스템 버전 관리 제거

```sql
-- 시스템 버전 관리 비활성화 (이력 데이터는 더 이상 자동 생성되지 않음)
ALTER TABLE 직원 DROP SYSTEM VERSIONING;
```

### 11.3 애플리케이션 시간 PERIOD 추가/제거

```sql
-- 기존 테이블에 애플리케이션 시간 PERIOD 추가
ALTER TABLE 계약
    ADD PERIOD FOR 유효기간 (유효시작, 유효종료);

-- 애플리케이션 시간 PERIOD 제거
ALTER TABLE 계약
    DROP PERIOD FOR 유효기간;
```

---

## 12. PERIOD 술어

PERIOD 술어는 기간 간의 관계를 검사하는 조건식이다. PERIOD와 PERIOD, 또는 PERIOD와 시점 간의 관계를 표현한다.

### 12.1 OVERLAPS

두 기간이 겹치는지 검사한다.

```sql
-- 특정 기간과 겹치는 보험계약 조회
SELECT * FROM 보험계약
WHERE 유효기간 OVERLAPS PERIOD(DATE '2024-06-01', DATE '2024-12-31');

-- 두 테이블의 기간이 겹치는 행 조인
SELECT a.계약번호, b.계약번호
FROM 보험계약 a, 보험계약 b
WHERE a.계약번호 < b.계약번호
  AND a.유효기간 OVERLAPS b.유효기간;
```

### 12.2 CONTAINS

기간이 다른 기간 또는 시점을 포함하는지 검사한다.

```sql
-- 특정 날짜를 포함하는 보험계약 조회
SELECT * FROM 보험계약
WHERE 유효기간 CONTAINS DATE '2024-07-15';

-- 특정 기간을 완전히 포함하는 보험계약 조회
SELECT * FROM 보험계약
WHERE 유효기간 CONTAINS PERIOD(DATE '2024-04-01', DATE '2024-06-30');
```

### 12.3 PRECEDES / SUCCEEDS

기간의 선후 관계를 검사한다.

```sql
-- 유효기간이 2024-06-01 이전에 끝나는 계약
SELECT * FROM 보험계약
WHERE 유효기간 PRECEDES PERIOD(DATE '2024-06-01', DATE '2024-12-31');

-- 유효기간이 2024-06-01 이후에 시작하는 계약
SELECT * FROM 보험계약
WHERE 유효기간 SUCCEEDS PERIOD(DATE '2024-01-01', DATE '2024-06-01');
```

### 12.4 IMMEDIATELY PRECEDES / IMMEDIATELY SUCCEEDS

기간이 빈 틈 없이 바로 연속되는지 검사한다.

```sql
-- 직원의 직급 이력에서 바로 연속되는 기간 쌍 조회
SELECT a.직급 AS 이전직급, b.직급 AS 다음직급, a.유효종료 AS 전환일
FROM 직원_직급 a, 직원_직급 b
WHERE a.직원번호 = b.직원번호
  AND a.유효기간 IMMEDIATELY PRECEDES b.유효기간;
```

### 12.5 EQUALS

두 기간이 동일한지 검사한다.

```sql
-- 유효기간이 정확히 2024년인 계약 조회
SELECT * FROM 보험계약
WHERE 유효기간 EQUALS PERIOD(DATE '2024-01-01', DATE '2025-01-01');
```

### PERIOD 술어 요약

| 술어 | 의미 |
|------|------|
| A OVERLAPS B | A와 B가 겹침 |
| A CONTAINS B | A가 B를 완전히 포함 |
| A PRECEDES B | A가 B 앞에 위치 (A 종료 <= B 시작) |
| A SUCCEEDS B | A가 B 뒤에 위치 (A 시작 >= B 종료) |
| A IMMEDIATELY PRECEDES B | A 종료 = B 시작 (빈틈 없이 연속) |
| A IMMEDIATELY SUCCEEDS B | A 시작 = B 종료 (빈틈 없이 연속) |
| A EQUALS B | A 시작 = B 시작 AND A 종료 = B 종료 |

---

## 13. 시간적 집합 연산

시간적 테이블 간의 집합 연산(UNION, INTERSECT, EXCEPT)에서 기간 컬럼이 포함될 때, 기간의 겹침과 분할을 고려하여 처리한다.

```sql
-- 두 테이블에서 동일 직원의 유효기간에 대한 합집합
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정A
UNION
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정B;

-- 기간이 겹치는 부분만 추출 (교집합)
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정A
INTERSECT
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정B;

-- 차집합: A에만 있고 B에는 없는 기간
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정A
EXCEPT
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM 직원_배정B;
```

---

## 14. NORMALIZE

NORMALIZE는 인접하거나 겹치는 기간을 하나의 기간으로 병합(정규화)하는 연산이다. 동일한 키 값에 대해 연속되거나 겹치는 기간을 합쳐서 최소한의 행으로 표현한다.

```sql
-- 기본 NORMALIZE: 겹치거나 인접한 기간을 병합
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM NORMALIZE(직원_배정, 유효기간);

-- 예시 데이터:
-- (101, 'D001', 2020-01-01, 2022-01-01)
-- (101, 'D001', 2022-01-01, 2024-01-01)  ← 이전 행과 인접
-- (101, 'D001', 2023-06-01, 2025-01-01)  ← 이전 행과 겹침
--
-- NORMALIZE 결과:
-- (101, 'D001', 2020-01-01, 2025-01-01)  ← 하나의 기간으로 병합

-- GROUP BY와 함께 사용
SELECT 직원번호, 부서코드, 유효시작, 유효종료
FROM NORMALIZE(
    SELECT 직원번호, 부서코드, 유효시작, 유효종료
    FROM 직원_배정
    WHERE 부서코드 = 'D001',
    유효기간
);
```

---

## 15. LISTAGG

LISTAGG는 그룹 내 값을 연결하여 하나의 문자열로 만드는 집계 함수이다.

```sql
-- 기본 LISTAGG
SELECT 부서코드,
       LISTAGG(이름, ', ') WITHIN GROUP (ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;

-- 결과:
-- 부서코드 | 직원목록
-- D001     | 김개발, 박코딩, 이설계
-- D002     | 최영업, 한마케팅

-- 전체 직원 목록
SELECT LISTAGG(이름, ' / ') WITHIN GROUP (ORDER BY 직원번호) AS 전체직원
FROM 직원;

-- 결과: '김개발 / 이영업 / 박인사 / ...'

-- 다른 구분자 사용
SELECT 부서코드,
       LISTAGG(이름, ' | ') WITHIN GROUP (ORDER BY 급여 DESC) AS 급여순직원
FROM 직원
GROUP BY 부서코드;

-- 윈도우 함수로 사용
SELECT 직원번호, 이름, 부서코드,
       LISTAGG(이름, ', ') WITHIN GROUP (ORDER BY 이름)
           OVER (PARTITION BY 부서코드) AS 같은부서직원
FROM 직원;

-- 중복 제거와 결합
SELECT 부서코드,
       LISTAGG(DISTINCT 직급, ', ') WITHIN GROUP (ORDER BY 직급) AS 직급목록
FROM 직원
GROUP BY 부서코드;
```

---

## 16. 윈도우 함수 확장

### 16.1 NTH_VALUE

```sql
-- N번째 값 가져오기
SELECT 이름, 부서코드, 급여,
    NTH_VALUE(이름, 1) OVER (
        PARTITION BY 부서코드 ORDER BY 급여 DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 최고급여자,
    NTH_VALUE(이름, 2) OVER (
        PARTITION BY 부서코드 ORDER BY 급여 DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 2위급여자,
    NTH_VALUE(이름, 3) OVER (
        PARTITION BY 부서코드 ORDER BY 급여 DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 3위급여자
FROM 직원;
```

### 16.2 PERCENT_RANK / CUME_DIST

```sql
-- PERCENT_RANK: 백분위 순위 (0~1)
SELECT 이름, 급여,
    PERCENT_RANK() OVER (ORDER BY 급여) AS 백분위순위
FROM 직원;
-- 계산: (RANK - 1) / (전체행수 - 1)

-- CUME_DIST: 누적 분포 (0 초과 ~ 1 이하)
SELECT 이름, 급여,
    CUME_DIST() OVER (ORDER BY 급여) AS 누적분포
FROM 직원;
-- 계산: 현재 행 이하 행 수 / 전체 행 수
```

### 16.3 GROUPS 프레임

```sql
-- GROUPS: 동일 ORDER BY 값을 하나의 그룹으로 취급
SELECT 이름, 급여,
    SUM(급여) OVER (
        ORDER BY 급여
        GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS 전후그룹합계
FROM 직원;

-- GROUPS vs ROWS vs RANGE
-- ROWS:   물리적 행 단위
-- RANGE:  논리적 값 범위
-- GROUPS: ORDER BY 값이 같은 그룹 단위
```

### 프레임 유형 비교

| 프레임 유형 | 단위 | 동점 처리 |
|------------|------|-----------|
| ROWS | 물리적 행 | 각 행 개별 |
| RANGE | 값 범위 | 동일 값 = 하나의 단위 |
| GROUPS | 그룹 | 동일 값 = 하나의 그룹 |

---

## 17. 윈도우 함수 EXCLUDE 절

윈도우 프레임에서 특정 행을 제외하는 EXCLUDE 절을 지원한다. 프레임 정의 뒤에 추가하여 사용한다.

### 17.1 EXCLUDE 옵션

| 옵션 | 제외 대상 |
|------|-----------|
| EXCLUDE CURRENT ROW | 현재 행을 프레임에서 제외 |
| EXCLUDE GROUP | 현재 행과 ORDER BY 값이 동일한 모든 행을 제외 |
| EXCLUDE TIES | 현재 행과 ORDER BY 값이 동일한 다른 행을 제외 (현재 행 자체는 포함) |
| EXCLUDE NO OTHERS | 아무 행도 제외하지 않음 (기본값) |

### 17.2 EXCLUDE CURRENT ROW

```sql
-- 현재 행을 제외한 전후 1행의 평균
SELECT 이름, 급여,
    AVG(급여) OVER (
        ORDER BY 급여
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
        EXCLUDE CURRENT ROW
    ) AS 제외평균
FROM 직원;

-- 자신을 제외한 부서 내 평균 급여
SELECT 이름, 부서코드, 급여,
    AVG(급여) OVER (
        PARTITION BY 부서코드
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        EXCLUDE CURRENT ROW
    ) AS 타인평균급여
FROM 직원;
```

### 17.3 EXCLUDE GROUP

```sql
-- 동일 급여 그룹 전체를 제외한 합계
SELECT 이름, 급여,
    SUM(급여) OVER (
        ORDER BY 급여
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        EXCLUDE GROUP
    ) AS 다른급여합계
FROM 직원;
```

### 17.4 EXCLUDE TIES

```sql
-- 동점자를 제외하되 현재 행은 포함한 카운트
SELECT 이름, 급여,
    COUNT(*) OVER (
        ORDER BY 급여
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        EXCLUDE TIES
    ) AS 비동점카운트
FROM 직원;
```

---

## 18. RESPECT NULLS / IGNORE NULLS

LAG, LEAD, FIRST_VALUE, LAST_VALUE, NTH_VALUE 함수에서 NULL 값을 처리하는 방식을 지정한다. 기본값은 RESPECT NULLS이다.

### 18.1 IGNORE NULLS

NULL 값을 건너뛰고 그 다음 유효한 값을 반환한다.

```sql
-- LAG에서 NULL 건너뛰기
SELECT 이름, 보너스,
    LAG(보너스) IGNORE NULLS OVER (ORDER BY 입사일) AS 이전보너스
FROM 직원;

-- LEAD에서 NULL 건너뛰기
SELECT 이름, 보너스,
    LEAD(보너스) IGNORE NULLS OVER (ORDER BY 입사일) AS 다음보너스
FROM 직원;

-- FIRST_VALUE에서 NULL이 아닌 첫 번째 값
SELECT 이름, 부서코드, 보너스,
    FIRST_VALUE(보너스) IGNORE NULLS OVER (
        PARTITION BY 부서코드 ORDER BY 입사일
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 부서첫보너스
FROM 직원;

-- LAST_VALUE에서 NULL이 아닌 마지막 값
SELECT 이름, 부서코드, 보너스,
    LAST_VALUE(보너스) IGNORE NULLS OVER (
        PARTITION BY 부서코드 ORDER BY 입사일
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 부서마지막보너스
FROM 직원;

-- NTH_VALUE에서 NULL이 아닌 N번째 값
SELECT 이름, 부서코드, 보너스,
    NTH_VALUE(보너스, 2) IGNORE NULLS OVER (
        PARTITION BY 부서코드 ORDER BY 입사일
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 부서두번째보너스
FROM 직원;
```

### 18.2 RESPECT NULLS

NULL 값을 건너뛰지 않고 그대로 반환한다 (기본 동작).

```sql
-- 명시적으로 RESPECT NULLS 지정 (기본 동작과 동일)
SELECT 이름, 보너스,
    LAG(보너스) RESPECT NULLS OVER (ORDER BY 입사일) AS 이전보너스
FROM 직원;

-- IGNORE NULLS와 RESPECT NULLS 비교 예시
-- 데이터: ('김개발', 100), ('이설계', NULL), ('박코딩', 200)
-- LAG RESPECT NULLS: ('김개발', NULL), ('이설계', 100), ('박코딩', NULL)
-- LAG IGNORE NULLS:  ('김개발', NULL), ('이설계', 100), ('박코딩', 100)
```

---

> 참고: SQL:2011 표준은 ISO/IEC 9075:2011 시리즈로 발행되었다.
