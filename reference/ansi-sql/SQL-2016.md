# SQL:2016 표준 완벽 가이드

## ISO/IEC 9075:2016 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [JSON 지원](#2-json-지원)
3. [JSON 경로 표현식](#3-json-경로-표현식)
4. [JSON_TABLE PLAN 절](#4-json_table-plan-절)
5. [JSON_SERIALIZE / JSON_SCALAR](#5-json_serialize--json_scalar)
6. [MATCH_RECOGNIZE](#6-match_recognize)
7. [다형성 테이블 함수 (PTF)](#7-다형성-테이블-함수-ptf)
8. [LISTAGG 개선](#8-listagg-개선)
9. [DECFLOAT](#9-decfloat)

---

## 1. 개요

SQL:2016(공식명: ISO/IEC 9075:2016)은 JSON 지원, 행 패턴 인식(MATCH_RECOGNIZE), 다형성 테이블 함수(PTF) 등 현대 데이터 처리의 핵심 기능을 도입한 중요한 개정판이다. 특히 JSON 지원은 웹 개발과 NoSQL 통합에서 매우 중요한 역할을 한다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2016 |
| 발표 연도 | 2016년 |
| 이전 표준 | SQL:2011 |
| 다음 표준 | SQL:2023 |
| 핵심 추가 기능 | JSON, MATCH_RECOGNIZE, PTF, DECFLOAT |

### 신규 기능 요약

| 기능 | 분류 | 설명 |
|------|------|------|
| JSON 함수 | 데이터 교환 | JSON 생성, 쿼리, 검증 |
| JSON 경로 표현식 | 데이터 교환 | lax/strict 모드, 와일드카드, 필터 |
| JSON_SERIALIZE / JSON_SCALAR | 데이터 교환 | JSON 직렬화, 스칼라 변환 |
| MATCH_RECOGNIZE | 패턴 분석 | 행 시퀀스에서 패턴 인식 |
| PTF | 확장성 | 다형성 테이블 반환 함수 |
| LISTAGG 개선 | 집계 | 오버플로우 처리 |
| DECFLOAT | 데이터 타입 | 10진 부동소수점 |

---

## 2. JSON 지원

SQL:2016의 가장 중요한 추가 기능. JSON 데이터를 SQL에서 생성, 쿼리, 검증할 수 있다.

### 2.1 JSON_VALUE

JSON 문자열에서 스칼라 값을 추출한다.

```sql
-- 기본 JSON_VALUE
SELECT JSON_VALUE('{"이름": "홍길동", "나이": 30}', '$.이름') AS 이름;
-- 결과: '홍길동'

SELECT JSON_VALUE('{"이름": "홍길동", "나이": 30}', '$.나이') AS 나이;
-- 결과: '30'

-- 타입 지정
SELECT JSON_VALUE('{"가격": 15000}', '$.가격' RETURNING INTEGER) AS 가격;
-- 결과: 15000

-- 테이블에서 사용
CREATE TABLE 고객정보 (
    고객번호    INTEGER PRIMARY KEY,
    프로필      VARCHAR(4000)  -- JSON 데이터 저장
);

INSERT INTO 고객정보 VALUES (1, '{"이름": "홍길동", "나이": 30, "도시": "서울"}');
INSERT INTO 고객정보 VALUES (2, '{"이름": "김철수", "나이": 25, "도시": "부산"}');

SELECT 고객번호,
       JSON_VALUE(프로필, '$.이름') AS 이름,
       JSON_VALUE(프로필, '$.나이' RETURNING INTEGER) AS 나이,
       JSON_VALUE(프로필, '$.도시') AS 도시
FROM 고객정보;

-- 중첩 객체 접근
SELECT JSON_VALUE(
    '{"직원": {"이름": "홍길동", "부서": {"코드": "D001", "명칭": "개발팀"}}}',
    '$.직원.부서.명칭'
) AS 부서명;
-- 결과: '개발팀'

-- 배열 요소 접근
SELECT JSON_VALUE(
    '{"취미": ["독서", "등산", "수영"]}',
    '$.취미[0]'
) AS 첫번째취미;
-- 결과: '독서'

-- 오류 처리 옵션
SELECT JSON_VALUE('{"이름": "홍길동"}', '$.주소'
    DEFAULT '미등록' ON EMPTY    -- 경로 없을 때
    NULL ON ERROR                -- 오류 발생 시
) AS 주소;
-- 결과: '미등록'

-- 오류 처리 옵션 종류:
-- NULL ON EMPTY / ERROR ON EMPTY / DEFAULT 값 ON EMPTY
-- NULL ON ERROR / ERROR ON ERROR / DEFAULT 값 ON ERROR
```

### 2.2 JSON_QUERY

JSON 문자열에서 JSON 객체나 배열을 추출한다 (스칼라가 아닌 JSON 구조).

```sql
-- JSON 객체 추출
SELECT JSON_QUERY(
    '{"직원": {"이름": "홍길동", "부서": "개발팀"}}',
    '$.직원'
) AS 직원정보;
-- 결과: '{"이름": "홍길동", "부서": "개발팀"}'

-- JSON 배열 추출
SELECT JSON_QUERY(
    '{"취미": ["독서", "등산", "수영"]}',
    '$.취미'
) AS 취미목록;
-- 결과: '["독서", "등산", "수영"]'

-- WITH WRAPPER 옵션
SELECT JSON_QUERY(
    '{"a": 1, "b": 2, "c": 3}',
    '$.*'
    WITH ARRAY WRAPPER
) AS 모든값;
-- 결과: '[1, 2, 3]'

-- 오류 처리
SELECT JSON_QUERY('{"이름": "홍길동"}', '$.주소'
    EMPTY ARRAY ON EMPTY
    NULL ON ERROR
) AS 주소;
-- 결과: '[]'
```

### 2.3 JSON_TABLE

JSON 데이터를 관계형 테이블 형태로 변환한다.

```sql
-- 기본 JSON_TABLE
SELECT jt.*
FROM JSON_TABLE(
    '[
        {"이름": "홍길동", "나이": 30, "부서": "개발팀"},
        {"이름": "김철수", "나이": 25, "부서": "영업팀"},
        {"이름": "이영희", "나이": 28, "부서": "인사팀"}
    ]',
    '$[*]'
    COLUMNS (
        순번    FOR ORDINALITY,
        이름    VARCHAR(50)  PATH '$.이름',
        나이    INTEGER      PATH '$.나이',
        부서    VARCHAR(50)  PATH '$.부서'
    )
) AS jt;

-- 결과:
-- 순번 | 이름   | 나이 | 부서
-- 1    | 홍길동 | 30   | 개발팀
-- 2    | 김철수 | 25   | 영업팀
-- 3    | 이영희 | 28   | 인사팀

-- 중첩 배열 처리 (NESTED PATH)
SELECT jt.*
FROM JSON_TABLE(
    '{
        "주문번호": "ORD001",
        "고객": "홍길동",
        "항목": [
            {"제품": "노트북", "수량": 1, "단가": 1500000},
            {"제품": "마우스", "수량": 3, "단가": 30000}
        ]
    }',
    '$'
    COLUMNS (
        주문번호    VARCHAR(20)  PATH '$.주문번호',
        고객        VARCHAR(50)  PATH '$.고객',
        NESTED PATH '$.항목[*]' COLUMNS (
            항목순번  FOR ORDINALITY,
            제품      VARCHAR(100) PATH '$.제품',
            수량      INTEGER      PATH '$.수량',
            단가      DECIMAL(10,2) PATH '$.단가'
        )
    )
) AS jt;

-- 결과:
-- 주문번호 | 고객   | 항목순번 | 제품   | 수량 | 단가
-- ORD001   | 홍길동 | 1        | 노트북 | 1    | 1500000
-- ORD001   | 홍길동 | 2        | 마우스 | 3    | 30000

-- EXISTS 컬럼과 기본값
SELECT jt.*
FROM JSON_TABLE(
    '[{"이름": "홍길동"}, {"이름": "김철수", "이메일": "kim@ex.com"}]',
    '$[*]'
    COLUMNS (
        이름     VARCHAR(50)  PATH '$.이름',
        이메일   VARCHAR(100) PATH '$.이메일' DEFAULT '없음' ON EMPTY,
        메일존재 VARCHAR(5)   EXISTS PATH '$.이메일'
    )
) AS jt;
```

### 2.4 JSON_EXISTS

JSON 데이터에 특정 경로가 존재하는지 확인한다.

```sql
-- 기본 JSON_EXISTS
SELECT 고객번호
FROM 고객정보
WHERE JSON_EXISTS(프로필, '$.이메일');

-- 조건부 검사
SELECT 고객번호
FROM 고객정보
WHERE JSON_EXISTS(프로필, '$.나이 ? (@ > 25)');

-- 배열 내 검색
SELECT 고객번호
FROM 고객정보
WHERE JSON_EXISTS(프로필, '$.취미[*] ? (@ == "독서")');

-- NOT과 결합
SELECT 고객번호
FROM 고객정보
WHERE NOT JSON_EXISTS(프로필, '$.이메일');
```

### 2.5 JSON_OBJECT

SQL 값으로부터 JSON 객체를 생성한다.

```sql
-- 기본 JSON_OBJECT
SELECT JSON_OBJECT(
    KEY '이름' VALUE '홍길동',
    KEY '나이' VALUE 30,
    KEY '활성' VALUE TRUE
) AS json결과;
-- 결과: '{"이름":"홍길동","나이":30,"활성":true}'

-- 테이블 데이터로 JSON 생성
SELECT JSON_OBJECT(
    KEY '직원번호' VALUE 직원번호,
    KEY '이름' VALUE 이름,
    KEY '급여' VALUE 급여
) AS 직원json
FROM 직원;

-- NULL 처리 옵션
SELECT JSON_OBJECT(
    KEY '이름' VALUE 이름,
    KEY '이메일' VALUE 이메일
    NULL ON NULL       -- NULL이면 JSON null
) AS json결과
FROM 직원;

SELECT JSON_OBJECT(
    KEY '이름' VALUE 이름,
    KEY '이메일' VALUE 이메일
    ABSENT ON NULL     -- NULL이면 키 자체 생략
) AS json결과
FROM 직원;

-- 중첩 JSON
SELECT JSON_OBJECT(
    KEY '직원' VALUE JSON_OBJECT(
        KEY '이름' VALUE 이름,
        KEY '부서' VALUE JSON_OBJECT(KEY '코드' VALUE 부서코드)
    )
) AS 중첩json
FROM 직원;
```

### 2.6 JSON_ARRAY

SQL 값으로부터 JSON 배열을 생성한다.

```sql
SELECT JSON_ARRAY('독서', '등산', '수영') AS 취미;
-- 결과: '["독서","등산","수영"]'

SELECT JSON_ARRAY(1, 2, 3, 4, 5) AS 숫자배열;
-- 결과: '[1,2,3,4,5]'

-- NULL 처리
SELECT JSON_ARRAY(1, NULL, 3 NULL ON NULL) AS 배열;
-- 결과: '[1,null,3]'

SELECT JSON_ARRAY(1, NULL, 3 ABSENT ON NULL) AS 배열;
-- 결과: '[1,3]'
```

### 2.7 JSON_OBJECTAGG

그룹 내 키-값 쌍을 집계하여 JSON 객체를 생성한다.

```sql
SELECT JSON_OBJECTAGG(KEY 이름 VALUE 급여) AS 급여json
FROM 직원;
-- 결과: '{"홍길동":5000000,"김철수":4500000,"이영희":4000000}'

-- 부서별 JSON 객체
SELECT 부서코드,
       JSON_OBJECTAGG(KEY 이름 VALUE 급여) AS 부서원급여
FROM 직원
GROUP BY 부서코드;
```

### 2.8 JSON_ARRAYAGG

그룹 내 값을 집계하여 JSON 배열을 생성한다.

```sql
SELECT 부서코드,
       JSON_ARRAYAGG(이름 ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;
-- D001 | '["김개발","박코딩","이설계"]'

-- JSON 객체 배열 생성
SELECT JSON_ARRAYAGG(
    JSON_OBJECT(KEY '이름' VALUE 이름, KEY '급여' VALUE 급여)
    ORDER BY 급여 DESC
) AS 직원목록json
FROM 직원;
```

### 2.9 IS JSON

값이 유효한 JSON인지 검증한다.

```sql
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS JSON;
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS NOT JSON;

-- 세부 검증
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS JSON VALUE;
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS JSON OBJECT;
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS JSON ARRAY;
SELECT 고객번호 FROM 고객정보 WHERE 프로필 IS JSON SCALAR;

-- 중복 키 검증
SELECT 고객번호 FROM 고객정보
WHERE 프로필 IS JSON WITH UNIQUE KEYS;

-- CHECK 제약사항에서 사용
CREATE TABLE json_store (
    id      INTEGER PRIMARY KEY,
    data    VARCHAR(4000) CHECK (data IS JSON)
);
```

### JSON 함수 요약

| 함수 | 입력 | 출력 | 용도 |
|------|------|------|------|
| JSON_VALUE | JSON | SQL 스칼라 | 단일 값 추출 |
| JSON_QUERY | JSON | JSON | 객체/배열 추출 |
| JSON_TABLE | JSON | 테이블 | JSON을 테이블로 변환 |
| JSON_EXISTS | JSON | BOOLEAN | 경로 존재 확인 |
| JSON_OBJECT | SQL 값 | JSON 객체 | 객체 생성 |
| JSON_ARRAY | SQL 값 | JSON 배열 | 배열 생성 |
| JSON_OBJECTAGG | 그룹 | JSON 객체 | 키-값 집계 |
| JSON_ARRAYAGG | 그룹 | JSON 배열 | 값 배열 집계 |
| IS JSON | 문자열 | BOOLEAN | 유효성 검증 |
| JSON_SERIALIZE | JSON | 문자열 | JSON 직렬화 |
| JSON_SCALAR | SQL 값 | JSON | 스칼라를 JSON 값으로 변환 |

---

## 3. JSON 경로 표현식

SQL/JSON 경로 표현식은 JSON 데이터 내부를 탐색하기 위한 구문이다. 경로 모드, 와일드카드, 필터 표현식 등을 지원한다.

### 3.1 경로 모드: lax vs strict

경로 모드는 JSON 경로 평가 시 오류 처리 방식을 결정한다.

```sql
-- lax 모드 (기본): 구조적 오류를 NULL로 변환하고, 배열 래핑/언래핑을 자동 수행
SELECT JSON_VALUE(프로필, 'lax $.주소.도시') FROM 고객정보;

-- strict 모드: 구조적 오류 발생 시 예외를 일으킴
SELECT JSON_VALUE(프로필, 'strict $.주소.도시') FROM 고객정보;

-- lax 모드에서 배열 자동 언래핑
-- {"주소": [{"도시": "서울"}]} 에서 lax $.주소.도시 -> "서울" (자동 언래핑)
SELECT JSON_VALUE(
    '{"주소": [{"도시": "서울"}]}',
    'lax $.주소.도시'
) AS 도시;

-- strict 모드에서는 배열 인덱스를 명시해야 함
SELECT JSON_VALUE(
    '{"주소": [{"도시": "서울"}]}',
    'strict $.주소[0].도시'
) AS 도시;

-- lax 모드에서 존재하지 않는 키 접근 -> NULL 반환
SELECT JSON_VALUE('{"이름": "홍길동"}', 'lax $.나이') AS 나이;
-- 결과: NULL

-- strict 모드에서 존재하지 않는 키 접근 -> 오류 발생
SELECT JSON_VALUE('{"이름": "홍길동"}', 'strict $.나이'
    DEFAULT -1 ON ERROR
) AS 나이;
-- 결과: -1 (ON ERROR 절에 의해 기본값 반환)
```

### 3.2 와일드카드

```sql
-- 멤버 와일드카드 (.*): 객체의 모든 멤버 값
SELECT JSON_QUERY(
    '{"이름": "홍길동", "나이": 30, "도시": "서울"}',
    '$.*' WITH ARRAY WRAPPER
) AS 모든값;
-- 결과: '["홍길동", 30, "서울"]'

-- 배열 와일드카드 ([*]): 배열의 모든 요소
SELECT JSON_QUERY(
    '{"항목": [{"이름": "A"}, {"이름": "B"}, {"이름": "C"}]}',
    '$.항목[*].이름' WITH ARRAY WRAPPER
) AS 모든이름;
-- 결과: '["A", "B", "C"]'

-- 재귀 하향 와일드카드 (.): 모든 하위 레벨 탐색
SELECT JSON_QUERY(
    '{"a": {"b": {"c": 1}}, "d": {"c": 2}}',
    'lax $..c' WITH ARRAY WRAPPER
) AS 모든c값;
-- 결과: '[1, 2]'
```

### 3.3 배열 접근

```sql
-- 단일 인덱스
SELECT JSON_VALUE('{"목록": ["A", "B", "C", "D"]}', '$.목록[0]') AS 첫번째;
-- 결과: 'A'

-- 마지막 요소 (last 키워드)
SELECT JSON_VALUE('{"목록": ["A", "B", "C", "D"]}', '$.목록[last]') AS 마지막;
-- 결과: 'D'

-- last를 이용한 산술 연산
SELECT JSON_VALUE('{"목록": ["A", "B", "C", "D"]}', '$.목록[last - 1]') AS 끝에서두번째;
-- 결과: 'C'

-- 범위 지정
SELECT JSON_QUERY('{"목록": ["A", "B", "C", "D"]}', '$.목록[1 to 2]'
    WITH ARRAY WRAPPER
) AS 부분배열;
-- 결과: '["B", "C"]'

-- 다중 인덱스
SELECT JSON_QUERY('{"목록": ["A", "B", "C", "D"]}', '$.목록[0, 2, 3]'
    WITH ARRAY WRAPPER
) AS 선택요소;
-- 결과: '["A", "C", "D"]'
```

### 3.4 필터 표현식

필터 표현식(`?`)은 조건에 따라 JSON 요소를 선택한다. `@`는 현재 항목을 참조한다.

```sql
-- 비교 연산자
SELECT JSON_QUERY(
    '{"항목": [{"이름": "A", "가격": 5000}, {"이름": "B", "가격": 15000}, {"이름": "C", "가격": 8000}]}',
    '$.항목[*] ? (@.가격 > 10000)' WITH ARRAY WRAPPER
) AS 고가항목;
-- 결과: '[{"이름": "B", "가격": 15000}]'

-- 문자열 비교
SELECT JSON_QUERY(
    '{"직원": [{"이름": "홍길동", "부서": "개발"}, {"이름": "김철수", "부서": "영업"}]}',
    '$.직원[*] ? (@.부서 == "개발")' WITH ARRAY WRAPPER
) AS 개발팀;

-- 논리 연산자 (&&, ||, !)
SELECT JSON_QUERY(
    '{"항목": [{"이름": "A", "가격": 5000, "재고": 10}, {"이름": "B", "가격": 15000, "재고": 0}, {"이름": "C", "가격": 8000, "재고": 5}]}',
    '$.항목[*] ? (@.가격 > 3000 && @.재고 > 0)' WITH ARRAY WRAPPER
) AS 구매가능;

-- exists 필터
SELECT JSON_QUERY(
    '{"직원": [{"이름": "홍길동", "이메일": "hong@ex.com"}, {"이름": "김철수"}]}',
    '$.직원[*] ? (exists(@.이메일))' WITH ARRAY WRAPPER
) AS 이메일보유;

-- like_regex 필터
SELECT JSON_QUERY(
    '{"목록": ["abc", "def", "abx", "ghi"]}',
    '$.목록[*] ? (@ like_regex "^ab")' WITH ARRAY WRAPPER
) AS ab시작;
-- 결과: '["abc", "abx"]'

-- starts with 필터
SELECT JSON_QUERY(
    '{"목록": ["서울시", "서울역", "부산시"]}',
    '$.목록[*] ? (@ starts with "서울")' WITH ARRAY WRAPPER
) AS 서울;
-- 결과: '["서울시", "서울역"]'

-- 중첩 필터
SELECT JSON_QUERY(
    '{"주문": [{"고객": "홍길동", "항목": [{"가격": 5000}, {"가격": 20000}]}, {"고객": "김철수", "항목": [{"가격": 3000}]}]}',
    '$.주문[*] ? (@.항목[*].가격 > 10000)' WITH ARRAY WRAPPER
) AS 고가주문;
```

### 3.5 JSON_EXISTS에서의 경로 필터 활용

```sql
-- 경로 필터와 PASSING 절 (변수 바인딩)
SELECT 고객번호
FROM 고객정보
WHERE JSON_EXISTS(프로필, '$.나이 ? (@ > $최소나이)'
    PASSING 25 AS 최소나이
);

-- 여러 조건 결합
SELECT 고객번호
FROM 고객정보
WHERE JSON_EXISTS(프로필, '$.주소 ? (@.도시 == $도시 && @.구 == $구)'
    PASSING '서울' AS 도시, '강남' AS 구
);
```

---

## 4. JSON_TABLE PLAN 절

JSON_TABLE에서 여러 NESTED PATH가 있을 때, PLAN 절로 중첩 경로 간의 조인 방식을 지정한다.

### 4.1 PLAN DEFAULT

```sql
-- PLAN DEFAULT (OUTER): 중첩 경로 간 OUTER JOIN (항목이 없어도 상위 행 유지)
SELECT jt.*
FROM 주문,
    JSON_TABLE(주문데이터, '$'
        COLUMNS (
            주문번호 VARCHAR(20) PATH '$.주문번호',
            NESTED PATH '$.항목[*]' COLUMNS (
                제품명 VARCHAR(100) PATH '$.제품'
            )
        )
        PLAN DEFAULT (OUTER)
    ) AS jt;

-- PLAN DEFAULT (INNER): 중첩 경로 간 INNER JOIN (항목이 없으면 상위 행도 제외)
SELECT jt.*
FROM 주문,
    JSON_TABLE(주문데이터, '$'
        COLUMNS (
            주문번호 VARCHAR(20) PATH '$.주문번호',
            NESTED PATH '$.항목[*]' COLUMNS (
                제품명 VARCHAR(100) PATH '$.제품'
            )
        )
        PLAN DEFAULT (INNER)
    ) AS jt;

-- PLAN DEFAULT (CROSS): 형제 중첩 경로 간 CROSS JOIN
SELECT jt.*
FROM JSON_TABLE(
    '{"주문번호": "ORD001", "항목": [{"제품": "A"}, {"제품": "B"}], "배송지": [{"도시": "서울"}, {"도시": "부산"}]}',
    '$'
    COLUMNS (
        주문번호 VARCHAR(20) PATH '$.주문번호',
        NESTED PATH '$.항목[*]' COLUMNS (
            제품명 VARCHAR(100) PATH '$.제품'
        ),
        NESTED PATH '$.배송지[*]' COLUMNS (
            도시 VARCHAR(50) PATH '$.도시'
        )
    )
    PLAN DEFAULT (CROSS, OUTER)
) AS jt;
```

### 4.2 명시적 PLAN

```sql
-- 개별 중첩 경로에 대해 명시적으로 조인 방식 지정
SELECT jt.*
FROM JSON_TABLE(
    '{"주문번호": "ORD001", "항목": [{"제품": "A"}], "메모": [{"내용": "급배송"}]}',
    '$'
    COLUMNS (
        주문번호 VARCHAR(20) PATH '$.주문번호',
        NESTED PATH '$.항목[*]' AS 항목경로 COLUMNS (
            제품명 VARCHAR(100) PATH '$.제품'
        ),
        NESTED PATH '$.메모[*]' AS 메모경로 COLUMNS (
            메모내용 VARCHAR(200) PATH '$.내용'
        )
    )
    PLAN (항목경로 OUTER (메모경로))
) AS jt;

-- UNION을 사용한 형제 경로 결합
SELECT jt.*
FROM JSON_TABLE(
    '{"데이터": {"A": [1, 2], "B": [3, 4]}}',
    '$'
    COLUMNS (
        NESTED PATH '$.데이터.A[*]' AS pa COLUMNS (
            a값 INTEGER PATH '$'
        ),
        NESTED PATH '$.데이터.B[*]' AS pb COLUMNS (
            b값 INTEGER PATH '$'
        )
    )
    PLAN DEFAULT (UNION, OUTER)
) AS jt;
```

---

## 5. JSON_SERIALIZE / JSON_SCALAR

### 5.1 JSON_SERIALIZE

SQL/JSON 표현식의 결과를 문자열로 직렬화한다.

```sql
-- JSON 값을 문자열로 직렬화
SELECT JSON_SERIALIZE(JSON_OBJECT(
    KEY '이름' VALUE '홍길동',
    KEY '나이' VALUE 30
)) AS json문자열;
-- 결과: '{"이름":"홍길동","나이":30}'

-- RETURNING 절로 반환 타입 지정
SELECT JSON_SERIALIZE(JSON_ARRAY(1, 2, 3) RETURNING VARCHAR(100)) AS 배열문자열;

-- RETURNING CLOB
SELECT JSON_SERIALIZE(
    JSON_OBJECT(KEY '데이터' VALUE 대용량컬럼)
    RETURNING CLOB
) AS 대용량json
FROM 테이블;

-- 포맷 지정
SELECT JSON_SERIALIZE(
    JSON_OBJECT(KEY '이름' VALUE '홍길동')
    FORMAT JSON
    RETURNING VARCHAR(200)
) AS 결과;
```

### 5.2 JSON_SCALAR

SQL 스칼라 값을 JSON 값으로 변환한다.

```sql
-- 문자열을 JSON 문자열로
SELECT JSON_SERIALIZE(JSON_SCALAR('홍길동')) AS 결과;
-- 결과: '"홍길동"'

-- 숫자를 JSON 숫자로
SELECT JSON_SERIALIZE(JSON_SCALAR(42)) AS 결과;
-- 결과: '42'

-- 불리언을 JSON 불리언으로
SELECT JSON_SERIALIZE(JSON_SCALAR(TRUE)) AS 결과;
-- 결과: 'true'

-- NULL을 JSON null로
SELECT JSON_SERIALIZE(JSON_SCALAR(NULL)) AS 결과;
-- 결과: 'null'

-- 날짜를 JSON 문자열로
SELECT JSON_SERIALIZE(JSON_SCALAR(DATE '2024-01-15')) AS 결과;
-- 결과: '"2024-01-15"'
```

---

## 6. MATCH_RECOGNIZE

행 시퀀스에서 정규 표현식 패턴을 인식하는 기능이다. 주가 패턴, 세션 분석, 이벤트 시퀀스 감지 등에 활용된다.

### 6.1 기본 구문

```sql
SELECT *
FROM 테이블
    MATCH_RECOGNIZE (
        PARTITION BY 파티션_컬럼
        ORDER BY 정렬_컬럼
        MEASURES
            측정값_정의
        ONE ROW PER MATCH | ALL ROWS PER MATCH
        AFTER MATCH SKIP 옵션
        PATTERN (패턴_정규식)
        SUBSET 부분집합_정의
        DEFINE
            패턴_변수_조건_정의
    ) AS mr;
```

### 6.2 주가 V자 패턴 감지

```sql
CREATE TABLE 주가 (
    종목코드    CHAR(6),
    거래일      DATE,
    종가        DECIMAL(10,2)
);

-- V자 반등 패턴: 하락 후 상승
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            하락시작.거래일 AS 시작일,
            최저점.거래일   AS 저점일,
            상승끝.거래일   AS 종료일,
            하락시작.종가   AS 시작가,
            최저점.종가     AS 저점가,
            상승끝.종가     AS 종료가
        ONE ROW PER MATCH
        PATTERN (하락시작 하락+ 최저점 상승+ 상승끝)
        DEFINE
            하락 AS 하락.종가 < PREV(하락.종가),
            최저점 AS 최저점.종가 < PREV(최저점.종가),
            상승 AS 상승.종가 > PREV(상승.종가),
            상승끝 AS 상승끝.종가 > PREV(상승끝.종가)
    ) AS mr;
```

### 6.3 세션 분석

```sql
-- 웹 로그에서 세션 식별 (30분 이내 연속 접속)
SELECT *
FROM 웹로그
    MATCH_RECOGNIZE (
        PARTITION BY 사용자ID
        ORDER BY 접속시각
        MEASURES
            FIRST(접속시각) AS 세션시작,
            LAST(접속시각) AS 세션종료,
            COUNT(*) AS 페이지수,
            MATCH_NUMBER() AS 세션번호
        ONE ROW PER MATCH
        PATTERN (시작 연속*)
        DEFINE
            연속 AS 접속시각 - PREV(접속시각) < INTERVAL '30' MINUTE
    ) AS sessions;
```

### 6.4 ONE ROW PER MATCH vs ALL ROWS PER MATCH

```sql
-- ONE ROW PER MATCH: 매치당 요약 1행
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            FIRST(거래일) AS 패턴시작,
            LAST(거래일) AS 패턴종료,
            COUNT(*) AS 패턴길이
        ONE ROW PER MATCH
        PATTERN (상승{3,})
        DEFINE 상승 AS 상승.종가 > PREV(상승.종가)
    ) AS mr;

-- ALL ROWS PER MATCH: 매치된 모든 행 반환
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            MATCH_NUMBER() AS 매치번호,
            CLASSIFIER() AS 분류
        ALL ROWS PER MATCH
        PATTERN (상승{3,})
        DEFINE 상승 AS 상승.종가 > PREV(상승.종가)
    ) AS mr;
```

### 6.5 패턴 구문

| 패턴 요소 | 설명 | 예시 |
|-----------|------|------|
| A | 변수 A 한 번 | A |
| A+ | 1회 이상 반복 | 상승+ |
| A* | 0회 이상 반복 | 횡보* |
| A? | 0 또는 1회 | 특이점? |
| A{n} | 정확히 n회 | 상승{3} |
| A{n,} | n회 이상 | 상승{3,} |
| A{n,m} | n~m회 | 상승{2,5} |
| A \| B | A 또는 B | 상승 \| 횡보 |
| (A B) | 그룹화 | (상승 횡보)+ |
| ^ | 파티션 시작 | ^A |
| $ | 파티션 끝 | A$ |

### 6.6 MEASURES 함수

| 함수 | 설명 |
|------|------|
| MATCH_NUMBER() | 매치 순번 |
| CLASSIFIER() | 현재 행의 패턴 변수명 |
| FIRST(expr) | 매치 내 첫 값 |
| LAST(expr) | 매치 내 마지막 값 |
| PREV(expr) | 이전 행 값 |
| NEXT(expr) | 다음 행 값 |
| COUNT(*) | 매치 행 수 |
| SUM(expr) | 매치 내 합계 |
| AVG(expr) | 매치 내 평균 |

### 6.7 AFTER MATCH SKIP 절

패턴 매치가 완료된 후 다음 매치 시도를 시작할 위치를 결정한다.

```sql
-- AFTER MATCH SKIP PAST LAST ROW (기본값)
-- 매치된 마지막 행 다음부터 새 매치 시도
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            FIRST(거래일) AS 시작일,
            LAST(거래일) AS 종료일
        ONE ROW PER MATCH
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN (상승{2,})
        DEFINE 상승 AS 상승.종가 > PREV(상승.종가)
    ) AS mr;

-- AFTER MATCH SKIP TO NEXT ROW
-- 매치 시작 행의 다음 행부터 새 매치 시도 (겹치는 매치 허용)
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            FIRST(거래일) AS 시작일,
            LAST(거래일) AS 종료일,
            MATCH_NUMBER() AS 매치번호
        ONE ROW PER MATCH
        AFTER MATCH SKIP TO NEXT ROW
        PATTERN (상승{3})
        DEFINE 상승 AS 상승.종가 > PREV(상승.종가)
    ) AS mr;

-- AFTER MATCH SKIP TO FIRST 변수
-- 지정한 패턴 변수에 처음 매핑된 행부터 새 매치 시도
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            하락시작.거래일 AS 시작일,
            상승끝.거래일 AS 종료일
        ONE ROW PER MATCH
        AFTER MATCH SKIP TO FIRST 상승
        PATTERN (하락시작 하락+ 상승+ 상승끝)
        DEFINE
            하락 AS 하락.종가 < PREV(하락.종가),
            상승 AS 상승.종가 > PREV(상승.종가),
            상승끝 AS 상승끝.종가 > PREV(상승끝.종가)
    ) AS mr;

-- AFTER MATCH SKIP TO LAST 변수
-- 지정한 패턴 변수에 마지막 매핑된 행부터 새 매치 시도
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            하락시작.거래일 AS 시작일,
            상승끝.거래일 AS 종료일
        ONE ROW PER MATCH
        AFTER MATCH SKIP TO LAST 하락
        PATTERN (하락시작 하락+ 상승+ 상승끝)
        DEFINE
            하락 AS 하락.종가 < PREV(하락.종가),
            상승 AS 상승.종가 > PREV(상승.종가),
            상승끝 AS 상승끝.종가 > PREV(상승끝.종가)
    ) AS mr;
```

### 6.8 SUBSET 절

패턴 변수들의 부분 집합을 정의하여 MEASURES나 DEFINE에서 그룹 참조로 사용한다.

```sql
-- W자 패턴 감지: 두 번의 하락-상승
SELECT *
FROM 주가
    MATCH_RECOGNIZE (
        PARTITION BY 종목코드
        ORDER BY 거래일
        MEASURES
            FIRST(거래일) AS 시작일,
            LAST(거래일) AS 종료일,
            AVG(전체하락.종가) AS 평균하락가,
            AVG(전체상승.종가) AS 평균상승가
        ONE ROW PER MATCH
        PATTERN (시작점 하락1+ 저점1 상승1+ 고점 하락2+ 저점2 상승2+)
        SUBSET 전체하락 = (하락1, 하락2),
               전체상승 = (상승1, 상승2)
        DEFINE
            하락1 AS 하락1.종가 < PREV(하락1.종가),
            저점1 AS 저점1.종가 < PREV(저점1.종가),
            상승1 AS 상승1.종가 > PREV(상승1.종가),
            고점 AS 고점.종가 > PREV(고점.종가),
            하락2 AS 하락2.종가 < PREV(하락2.종가),
            저점2 AS 저점2.종가 < PREV(저점2.종가),
            상승2 AS 상승2.종가 > PREV(상승2.종가)
    ) AS mr;

-- SUBSET을 DEFINE에서 활용
SELECT *
FROM 센서데이터
    MATCH_RECOGNIZE (
        PARTITION BY 센서ID
        ORDER BY 측정시각
        MEASURES
            FIRST(거래일) AS 시작,
            LAST(거래일) AS 종료,
            AVG(변동구간.측정값) AS 변동평균
        ONE ROW PER MATCH
        PATTERN (안정 변동+ 안정종료)
        SUBSET 변동구간 = (변동)
        DEFINE
            안정 AS ABS(안정.측정값 - PREV(안정.측정값)) < 1.0,
            변동 AS ABS(변동.측정값 - PREV(변동.측정값)) >= 1.0,
            안정종료 AS ABS(안정종료.측정값 - AVG(변동구간.측정값)) < 0.5
    ) AS mr;
```

---

## 7. 다형성 테이블 함수 (PTF)

다형성 테이블 함수(Polymorphic Table Function)는 입력 테이블의 스키마에 따라 출력 스키마가 동적으로 결정되는 테이블 반환 함수이다.

### 7.1 기본 개념

```sql
-- PTF 개념: 입력 테이블 구조를 몰라도 변환 가능
-- 일반 테이블 함수: 출력 스키마 고정
-- PTF: 출력 스키마가 입력에 따라 동적 결정

-- 개념적 예시: 동적 피벗
SELECT *
FROM 동적피벗(
    TABLE 매출,
    DESCRIPTOR(부서코드),
    DESCRIPTOR(분기),
    DESCRIPTOR(매출액)
);

-- CSVReader PTF 개념
SELECT *
FROM CSVReader(
    FILE => '/data/sales.csv',
    DELIMITER => ','
);
```

### 7.2 PTF 유형

| 유형 | 설명 |
|------|------|
| 입력 전달 PTF | 입력 테이블 컬럼 그대로 전달 + 추가/변환 |
| 입력 미전달 PTF | 완전히 새로운 스키마 생성 |

### 7.3 INPUT TABLE과 DESCRIPTOR

PTF 호출 시 TABLE 인자와 DESCRIPTOR 인자를 사용한다.

```sql
-- TABLE 인자: 입력 테이블을 PTF에 전달
SELECT *
FROM 마스킹함수(
    TABLE 고객정보,
    DESCRIPTOR(주민번호, 전화번호)
);

-- DESCRIPTOR: 컬럼 목록을 메타데이터로 전달
SELECT *
FROM 동적집계(
    TABLE 매출,
    DESCRIPTOR(지역, 제품),      -- 그룹화 컬럼
    DESCRIPTOR(매출액, 수량)      -- 집계 대상 컬럼
);

-- 여러 TABLE 인자
SELECT *
FROM 동적조인(
    TABLE 주문 AS 좌측,
    TABLE 고객 AS 우측,
    DESCRIPTOR(고객번호)          -- 조인 키
);
```

### 7.4 PTF 생성 구문 (DESCRIBE 컴포넌트)

PTF를 생성할 때 DESCRIBE 컴포넌트에서 출력 스키마를 동적으로 결정한다.

```sql
-- PTF 생성: 컬럼 마스킹 함수
CREATE FUNCTION 마스킹함수(
    입력테이블 TABLE,
    대상컬럼 DESCRIPTOR
)
RETURNS TABLE
LANGUAGE SQL
SPECIFIC 마스킹함수
-- DESCRIBE 컴포넌트: 출력 테이블의 스키마 결정
-- 입력 테이블 스키마를 그대로 유지하되, 대상 컬럼의 타입을 확인

-- 입력 전달(pass-through) PTF
-- 입력 테이블의 행이 그대로 출력에 포함
PASS THROUGH 입력테이블;

-- PTF에서 컬럼 추가
CREATE FUNCTION 파생컬럼추가(
    입력테이블 TABLE,
    소스컬럼 DESCRIPTOR
)
RETURNS TABLE
ADD COLUMN 파생값 DECIMAL(10,2);
```

### 7.5 PTF 호출

```sql
-- 단일 테이블 PTF 호출
SELECT *
FROM TopN(
    TABLE 직원 PARTITION BY 부서코드 ORDER BY 급여 DESC,
    행수 => 3
);

-- PARTITION BY / ORDER BY를 PTF 호출에서 지정
SELECT *
FROM 누적합계(
    TABLE 매출 PARTITION BY 지역 ORDER BY 날짜
);

-- PTF 결과를 다른 쿼리와 결합
SELECT p.*, d.부서명
FROM TopN(
    TABLE 직원 PARTITION BY 부서코드 ORDER BY 급여 DESC,
    행수 => 5
) AS p
JOIN 부서 AS d ON p.부서코드 = d.부서코드;
```

---

## 8. LISTAGG 개선

SQL:2011에서 도입된 LISTAGG에 오버플로우 처리가 추가되었다.

```sql
-- 기본 LISTAGG (SQL:2011)
SELECT 부서코드,
       LISTAGG(이름, ', ') WITHIN GROUP (ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;

-- 오버플로우 처리 (SQL:2016 신규)
-- ON OVERFLOW TRUNCATE: 초과 시 잘라냄
SELECT 부서코드,
       LISTAGG(이름, ', '
           ON OVERFLOW TRUNCATE '...' WITH COUNT
       ) WITHIN GROUP (ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;
-- 결과: '김개발, 박코딩, 이설계, ...(3)'

-- WITHOUT COUNT
SELECT 부서코드,
       LISTAGG(이름, ', '
           ON OVERFLOW TRUNCATE '...' WITHOUT COUNT
       ) WITHIN GROUP (ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;
-- 결과: '김개발, 박코딩, 이설계, ...'

-- ON OVERFLOW ERROR: 초과 시 오류 (기본)
SELECT 부서코드,
       LISTAGG(이름, ', ' ON OVERFLOW ERROR)
       WITHIN GROUP (ORDER BY 이름) AS 직원목록
FROM 직원
GROUP BY 부서코드;
```

---

## 9. DECFLOAT

10진 부동소수점 타입으로, 금융 계산에서 2진 부동소수점의 정밀도 문제를 해결한다.

```sql
CREATE TABLE 금융거래 (
    거래번호    INTEGER PRIMARY KEY,
    금액        DECFLOAT(16),     -- 16자리 정밀도
    환율        DECFLOAT(34)      -- 34자리 정밀도
);

INSERT INTO 금융거래 VALUES (1, 1234567890.12, 1.2345678901234567);

-- DECFLOAT vs FLOAT 비교
-- FLOAT: 0.1 + 0.2 = 0.30000000000000004 (2진 오차)
-- DECFLOAT: 0.1 + 0.2 = 0.3 (정확한 10진 계산)
```

### DECFLOAT 정밀도 옵션

| 옵션 | 설명 | IEEE 754 대응 |
|------|------|-------------|
| DECFLOAT(16) | 16자리 유효 숫자 | decimal64 |
| DECFLOAT(34) | 34자리 유효 숫자 | decimal128 |

### 숫자 타입 비교

| 타입 | 정밀도 | 금융 적합성 | 범위 |
|------|--------|:-----------:|------|
| INTEGER | 정확 | O | 제한적 |
| DECIMAL(p,s) | 정확 | O | 고정 정밀도 |
| FLOAT/DOUBLE | 근사 | X | 넓음 |
| DECFLOAT | 정확(10진) | O | 넓음 |

---

> 참고: SQL:2016 표준은 ISO/IEC 9075:2016 시리즈로 발행되었다.
