# SQL:1999 (SQL3) 표준 완벽 가이드

## ISO/IEC 9075:1999 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [역사적 배경](#2-역사적-배경)
3. [다중 파트 구조](#3-다중-파트-구조)
4. [적합성 수준 변경](#4-적합성-수준-변경)
5. [CTE (Common Table Expressions)](#5-cte-common-table-expressions)
6. [트리거](#6-트리거)
7. [사용자 정의 타입 (UDT)](#7-사용자-정의-타입-udt)
8. [새로운 데이터 타입](#8-새로운-데이터-타입)
9. [PSM (Persistent Stored Modules)](#9-psm-persistent-stored-modules)
10. [OLAP 확장](#10-olap-확장)
11. [SIMILAR TO](#11-similar-to)
12. [SAVEPOINT](#12-savepoint)
13. [ROLE 기반 권한](#13-role-기반-권한)
14. [재귀 쿼리](#14-재귀-쿼리)
15. [SQL/MED](#15-sqlmed)
16. [SQL/OLB](#16-sqlolb)
17. [제약사항과 한계](#17-제약사항과-한계)
18. [영향과 의의](#18-영향과-의의)

---

## 1. 개요

SQL:1999(공식명: ISO/IEC 9075:1999)는 SQL 표준의 세 번째 주요 개정판으로, SQL3라고도 불린다. SQL-92에서 관계형 모델의 기본 기능을 확립한 이후, SQL:1999는 객체-관계형(Object-Relational) 기능을 대폭 추가하며 SQL의 표현력을 획기적으로 확장했다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:1999 |
| 별칭 | SQL3, SQL:1999 |
| 발표 연도 | 1999년 |
| 이전 표준 | SQL-92 (ISO/IEC 9075:1992) |
| 다음 표준 | SQL:2003 (ISO/IEC 9075:2003) |
| 파트 수 | 5개 파트 (Part 1~5) + 별도 파트 |
| 적합성 모델 | Core SQL + 선택적 기능 패키지 |

---

## 2. 역사적 배경

### 1990년대 데이터베이스 기술 흐름

```
1992  - SQL-92 발표
1993  - 객체지향 데이터베이스(OODB) 연구 활발
1994  - 객체-관계형 접근법 대두
1996  - Informix Universal Server, Oracle8 객체-관계형 기능 도입
1997  - SQL:1999 초안 개발 진행
1999  - SQL:1999 ★ 공식 발표
```

### SQL-92에서 SQL:1999로의 진화 동기

- 객체지향 프로그래밍의 영향: OOP 개념을 관계형 데이터베이스에 통합
- 복잡한 데이터 모델링 요구: 계층 구조, 재귀 관계 표현 필요
- 프로시저적 기능의 표준화: 각 벤더의 독자적 PL/SQL, T-SQL 등을 표준화
- 분석 기능 강화: OLAP 기능에 대한 수요 증가

---

## 3. 다중 파트 구조

SQL:1999부터 표준이 여러 파트로 분리되었다.

| 파트 | 명칭 | 설명 |
|------|------|------|
| Part 1 | SQL/Framework | 전체 프레임워크, 용어, 개념 정의 |
| Part 2 | SQL/Foundation | 핵심 SQL 기능 (DDL, DML, 타입, 표현식 등) |
| Part 3 | SQL/CLI | Call-Level Interface (ODBC 기반) |
| Part 4 | SQL/PSM | Persistent Stored Modules (저장 프로시저/함수) |
| Part 5 | SQL/Bindings | 호스트 언어 바인딩 (C, COBOL, Fortran 등) |
| Part 9 | SQL/MED | Management of External Data (외부 데이터 관리) |
| Part 10 | SQL/OLB | Object Language Bindings (Java 바인딩) |

---

## 4. 적합성 수준 변경

SQL-92의 3단계 적합성(Entry/Intermediate/Full)을 폐지하고, Core SQL + 선택적 기능 패키지 방식으로 변경했다.

### Core SQL

모든 SQL:1999 적합 구현이 반드시 지원해야 하는 최소 기능 집합.

### 선택적 기능 패키지

| 패키지 ID | 명칭 | 설명 |
|-----------|------|------|
| T031 | BOOLEAN 데이터 타입 | TRUE, FALSE, UNKNOWN |
| T041 | 기본 LOB 지원 | BLOB, CLOB |
| T051 | 행 타입 | ROW 타입 |
| T111 | ARRAY 타입 | 배열 |
| T121 | WITH (CTE) | 공통 테이블 표현식 |
| T131 | 재귀 쿼리 | WITH RECURSIVE |
| T141 | SIMILAR TO | 정규 표현식 패턴 매칭 |
| T211 | 트리거 | BEFORE/AFTER 트리거 |
| T321 | UDT 기본 | 사용자 정의 타입 |
| T331 | PSM 기본 | 저장 프로시저/함수 |
| T431 | OLAP 확장 | ROLLUP, CUBE, GROUPING SETS |
| T611 | SAVEPOINT | 부분 롤백 |
| T811 | ROLE | 역할 기반 권한 관리 |

---

## 5. CTE (Common Table Expressions)

### 5.1 기본 WITH 절

```sql
-- 기본 CTE
WITH 부서별급여 AS (
    SELECT 부서코드,
           AVG(급여) AS 평균급여,
           MAX(급여) AS 최대급여,
           MIN(급여) AS 최소급여
    FROM 직원
    GROUP BY 부서코드
)
SELECT 부서.부서명,
       부서별급여.평균급여,
       부서별급여.최대급여,
       부서별급여.최소급여
FROM 부서별급여
  INNER JOIN 부서 ON 부서별급여.부서코드 = 부서.부서코드;

-- 다중 CTE
WITH
고급직원 AS (
    SELECT 직원번호, 이름, 급여, 부서코드
    FROM 직원
    WHERE 급여 >= 5000000
),
고급직원_부서 AS (
    SELECT 부서코드, COUNT(*) AS 인원수
    FROM 고급직원
    GROUP BY 부서코드
)
SELECT 부서.부서명, COALESCE(고급직원_부서.인원수, 0) AS 고급인원수
FROM 부서
  LEFT OUTER JOIN 고급직원_부서
    ON 부서.부서코드 = 고급직원_부서.부서코드;
```

### 5.2 WITH RECURSIVE

```sql
-- 재귀 CTE: 조직도 계층 구조
WITH RECURSIVE 조직도 (직원번호, 이름, 상사번호, 레벨, 경로) AS (
    -- 기저 조건 (anchor member): 최상위 관리자
    SELECT 직원번호, 이름, 상사번호, 0, CAST(이름 AS VARCHAR(1000))
    FROM 직원
    WHERE 상사번호 IS NULL

    UNION ALL

    -- 재귀 조건 (recursive member)
    SELECT e.직원번호, e.이름, e.상사번호, o.레벨 + 1,
           o.경로 || ' > ' || e.이름
    FROM 직원 e
      INNER JOIN 조직도 o ON e.상사번호 = o.직원번호
)
SELECT 직원번호, 이름, 레벨, 경로
FROM 조직도
ORDER BY 경로;

-- 재귀 CTE: 1부터 10까지 숫자 생성
WITH RECURSIVE 숫자 (n) AS (
    SELECT 1

    UNION ALL

    SELECT n + 1
    FROM 숫자
    WHERE n < 10
)
SELECT n FROM 숫자;

-- 재귀 CTE: BOM(Bill of Materials) 전개
WITH RECURSIVE 부품전개 (부품코드, 부품명, 수량, 레벨) AS (
    SELECT 부품코드, 부품명, 1, 0
    FROM 부품
    WHERE 부품코드 = 'PROD001'

    UNION ALL

    SELECT c.하위부품코드, p.부품명, c.수량 * be.수량, be.레벨 + 1
    FROM 부품구성 c
      INNER JOIN 부품전개 be ON c.상위부품코드 = be.부품코드
      INNER JOIN 부품 p ON c.하위부품코드 = p.부품코드
)
SELECT 부품코드, 부품명, 수량, 레벨
FROM 부품전개
ORDER BY 레벨, 부품코드;
```

---

## 6. 트리거

SQL:1999에서 트리거가 처음으로 표준화되었다.

### 6.1 기본 구문

```sql
CREATE TRIGGER 트리거이름
  {BEFORE | AFTER} {INSERT | UPDATE | DELETE}
  ON 테이블이름
  [REFERENCING {OLD AS 이전 | NEW AS 이후 | OLD TABLE AS 이전테이블 | NEW TABLE AS 이후테이블}]
  FOR EACH {ROW | STATEMENT}
  [WHEN (조건)]
  BEGIN ATOMIC
    -- SQL 문
  END;
```

### 6.2 BEFORE 트리거

```sql
-- INSERT 전 데이터 검증/변환
CREATE TRIGGER trg_직원_입력전
  BEFORE INSERT ON 직원
  REFERENCING NEW AS 신규
  FOR EACH ROW
  WHEN (신규.급여 IS NULL)
  BEGIN ATOMIC
    SET 신규.급여 = 3000000;
  END;

-- UPDATE 전 데이터 검증
CREATE TRIGGER trg_급여_변경전
  BEFORE UPDATE OF 급여 ON 직원
  REFERENCING OLD AS 이전 NEW AS 이후
  FOR EACH ROW
  WHEN (이후.급여 < 이전.급여 * 0.5)
  BEGIN ATOMIC
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = '급여를 50% 이상 삭감할 수 없습니다';
  END;
```

### 6.3 AFTER 트리거

```sql
-- INSERT 후 감사 로그 기록
CREATE TRIGGER trg_직원_입력후
  AFTER INSERT ON 직원
  REFERENCING NEW AS 신규
  FOR EACH ROW
  BEGIN ATOMIC
    INSERT INTO 감사로그 (이벤트, 테이블명, 키값, 발생시각)
    VALUES ('INSERT', '직원', CAST(신규.직원번호 AS VARCHAR(20)), CURRENT_TIMESTAMP);
  END;

-- DELETE 후 처리
CREATE TRIGGER trg_직원_삭제후
  AFTER DELETE ON 직원
  REFERENCING OLD AS 이전
  FOR EACH ROW
  BEGIN ATOMIC
    INSERT INTO 퇴사자 (직원번호, 이름, 퇴사일)
    VALUES (이전.직원번호, 이전.이름, CURRENT_DATE);
  END;

-- UPDATE 후 처리
CREATE TRIGGER trg_급여_변경후
  AFTER UPDATE OF 급여 ON 직원
  REFERENCING OLD AS 이전 NEW AS 이후
  FOR EACH ROW
  BEGIN ATOMIC
    INSERT INTO 급여변경이력 (직원번호, 이전급여, 이후급여, 변경일)
    VALUES (이전.직원번호, 이전.급여, 이후.급여, CURRENT_DATE);
  END;
```

### 6.4 FOR EACH STATEMENT 트리거

```sql
-- 문장 단위 트리거: INSERT 문 실행당 한 번 실행
CREATE TRIGGER trg_직원_대량입력후
  AFTER INSERT ON 직원
  REFERENCING NEW TABLE AS 신규테이블
  FOR EACH STATEMENT
  BEGIN ATOMIC
    INSERT INTO 감사로그 (이벤트, 테이블명, 키값, 발생시각)
    VALUES ('BULK_INSERT', '직원',
            CAST((SELECT COUNT(*) FROM 신규테이블) AS VARCHAR(20)),
            CURRENT_TIMESTAMP);
  END;
```

### 트리거 유형 비교

| 유형 | 실행 시점 | 데이터 수정 가능 | 주요 용도 |
|------|-----------|:---:|------|
| BEFORE ROW | DML 전, 행별 | O (NEW 값) | 데이터 검증, 기본값 설정 |
| AFTER ROW | DML 후, 행별 | X | 감사 로그, 파생 데이터 갱신 |
| BEFORE STATEMENT | DML 전, 문장별 | X | 사전 조건 검증 |
| AFTER STATEMENT | DML 후, 문장별 | X | 집계 데이터 갱신 |

---

## 7. 사용자 정의 타입 (UDT)

### 7.1 DISTINCT 타입

기존 타입을 기반으로 새로운 타입을 생성하며, 원본 타입과 호환되지 않는다.

```sql
-- DISTINCT 타입 생성
CREATE TYPE 원화 AS DECIMAL(15, 0) FINAL;
CREATE TYPE 달러 AS DECIMAL(15, 2) FINAL;
CREATE TYPE 유로 AS DECIMAL(15, 2) FINAL;

-- 사용: 원화와 달러를 실수로 혼합할 수 없음
CREATE TABLE 계좌 (
    계좌번호    VARCHAR(20) PRIMARY KEY,
    원화잔액    원화,
    달러잔액    달러
);

-- 타입 간 변환은 명시적 CAST 필요
-- SELECT 원화잔액 + 달러잔액 FROM 계좌;  -- 오류!
SELECT CAST(원화잔액 AS DECIMAL(15,0)) + CAST(달러잔액 AS DECIMAL(15,2))
FROM 계좌;  -- 명시적 변환 필요
```

### 7.2 구조화 타입 (Structured Type)

```sql
-- 구조화 타입 생성
CREATE TYPE 주소_타입 AS (
    우편번호    CHAR(5),
    시도        VARCHAR(20),
    시군구      VARCHAR(30),
    상세주소    VARCHAR(100)
) NOT FINAL;

-- 상속
CREATE TYPE 해외주소_타입 UNDER 주소_타입 AS (
    국가코드    CHAR(2),
    국가명      VARCHAR(50)
) NOT FINAL;

-- 메서드가 있는 타입
CREATE TYPE 직원_타입 AS (
    직원번호    INTEGER,
    이름        VARCHAR(50),
    급여        DECIMAL(10,2),
    입사일      DATE
) NOT FINAL
METHOD 근속년수() RETURNS INTEGER,
METHOD 연봉() RETURNS DECIMAL(12,2);

-- 메서드 구현
CREATE METHOD 근속년수() FOR 직원_타입
BEGIN
    RETURN YEAR(CURRENT_DATE) - YEAR(SELF.입사일);
END;

CREATE METHOD 연봉() FOR 직원_타입
BEGIN
    RETURN SELF.급여 * 12;
END;

-- 구조화 타입을 컬럼으로 사용
CREATE TABLE 회사 (
    회사코드    CHAR(10) PRIMARY KEY,
    회사명      VARCHAR(100),
    본사주소    주소_타입
);

-- 타입이 있는 테이블 (typed table)
CREATE TABLE 직원_객체 OF 직원_타입 (
    직원번호 WITH OPTIONS PRIMARY KEY
);

-- 데이터 삽입 (생성자 사용)
INSERT INTO 직원_객체 VALUES (
    NEW 직원_타입(101, '김개발', 5000000, DATE '2020-03-15')
);

-- 메서드 호출
SELECT 이름, 근속년수(), 연봉()
FROM 직원_객체;
```

---

## 8. 새로운 데이터 타입

### 8.1 BOOLEAN

```sql
CREATE TABLE 설정 (
    설정키      VARCHAR(50) PRIMARY KEY,
    활성화      BOOLEAN NOT NULL DEFAULT TRUE,
    표시여부    BOOLEAN
);

INSERT INTO 설정 VALUES ('알림', TRUE, FALSE);
INSERT INTO 설정 VALUES ('테마', FALSE, UNKNOWN);

-- BOOLEAN 조건식
SELECT 설정키 FROM 설정 WHERE 활성화 = TRUE;
SELECT 설정키 FROM 설정 WHERE 활성화 IS TRUE;
SELECT 설정키 FROM 설정 WHERE NOT 활성화;
SELECT 설정키 FROM 설정 WHERE 표시여부 IS UNKNOWN;
```

### 8.2 BLOB / CLOB

```sql
-- BLOB: Binary Large Object
CREATE TABLE 문서 (
    문서번호    INTEGER PRIMARY KEY,
    제목        VARCHAR(200),
    파일내용    BLOB(10M),      -- 최대 10MB
    썸네일      BLOB(100K)      -- 최대 100KB
);

-- CLOB: Character Large Object
CREATE TABLE 게시글 (
    글번호      INTEGER PRIMARY KEY,
    제목        VARCHAR(200),
    본문        CLOB(1M),       -- 최대 1MB 텍스트
    작성일      DATE
);

-- LOB 연산
SELECT 제목, CHAR_LENGTH(본문) AS 본문길이
FROM 게시글;

SELECT 제목, OCTET_LENGTH(파일내용) AS 파일크기
FROM 문서;

-- SUBSTRING으로 부분 추출
SELECT SUBSTRING(본문 FROM 1 FOR 200) AS 미리보기
FROM 게시글;
```

### 8.3 ARRAY

```sql
-- ARRAY 타입 컬럼
CREATE TABLE 학생 (
    학번        INTEGER PRIMARY KEY,
    이름        VARCHAR(50),
    전화번호    VARCHAR(20) ARRAY[3],    -- 최대 3개 전화번호
    취미        VARCHAR(30) ARRAY[5]     -- 최대 5개 취미
);

-- 배열 값 삽입
INSERT INTO 학생 VALUES (
    1001,
    '김학생',
    ARRAY['010-1234-5678', '02-123-4567'],
    ARRAY['독서', '등산', '수영']
);

-- 배열 요소 접근 (1-based index)
SELECT 이름, 전화번호[1] AS 대표전화
FROM 학생;

-- 배열 카디널리티
SELECT 이름, CARDINALITY(취미) AS 취미수
FROM 학생;

-- 배열 언네스트
SELECT 학생.이름, t.취미항목
FROM 학생, UNNEST(학생.취미) AS t(취미항목);
```

### 8.4 ROW 타입

```sql
-- ROW 타입 컬럼
CREATE TABLE 연락처 (
    연락처번호  INTEGER PRIMARY KEY,
    이름        VARCHAR(50),
    집주소      ROW(우편번호 CHAR(5), 도시 VARCHAR(30), 상세 VARCHAR(100)),
    회사주소    ROW(우편번호 CHAR(5), 도시 VARCHAR(30), 상세 VARCHAR(100))
);

-- ROW 값 삽입
INSERT INTO 연락처 VALUES (
    1,
    '홍길동',
    ROW('06000', '서울', '강남구 역삼동'),
    ROW('13000', '성남', '분당구 판교로')
);

-- ROW 필드 접근
SELECT 이름,
       집주소.도시 AS 거주도시,
       회사주소.도시 AS 근무도시
FROM 연락처;
```

### 데이터 타입 비교 (SQL-92 vs SQL:1999)

| 분류 | SQL-92 | SQL:1999 추가 |
|------|--------|-------------|
| 논리형 | - | BOOLEAN |
| 대용량 | - | BLOB, CLOB |
| 컬렉션 | - | ARRAY |
| 구조체 | - | ROW |
| 사용자 정의 | - | DISTINCT TYPE, STRUCTURED TYPE |

---

## 9. PSM (Persistent Stored Modules)

SQL:1999 Part 4에서 저장 프로시저와 함수를 표준화했다.

### 9.1 CREATE FUNCTION

```sql
-- 스칼라 함수
CREATE FUNCTION 세금계산(금액 DECIMAL(12,2), 세율 DECIMAL(5,4))
  RETURNS DECIMAL(12,2)
  DETERMINISTIC
  CONTAINS SQL
BEGIN
    RETURN 금액 * 세율;
END;

-- 사용
SELECT 이름, 급여, 세금계산(급여, 0.033) AS 세금
FROM 직원;

-- 조건부 로직이 포함된 함수
CREATE FUNCTION 급여등급(급여 DECIMAL(10,2))
  RETURNS VARCHAR(10)
  DETERMINISTIC
  CONTAINS SQL
BEGIN
    IF 급여 >= 7000000 THEN
        RETURN '임원급';
    ELSEIF 급여 >= 5000000 THEN
        RETURN '고급';
    ELSEIF 급여 >= 3000000 THEN
        RETURN '중급';
    ELSE
        RETURN '초급';
    END IF;
END;
```

### 9.2 CREATE PROCEDURE

```sql
-- 기본 프로시저
CREATE PROCEDURE 급여인상(
    IN p_부서코드 CHAR(4),
    IN p_인상율 DECIMAL(5,4),
    OUT p_인원수 INTEGER
)
BEGIN
    UPDATE 직원
    SET 급여 = 급여 * (1 + p_인상율)
    WHERE 부서코드 = p_부서코드;

    GET DIAGNOSTICS p_인원수 = ROW_COUNT;
END;

-- 프로시저 호출
CALL 급여인상('D001', 0.05, :결과_인원수);
```

### 9.3 제어 흐름 구문

```sql
-- IF / ELSEIF / ELSE
CREATE PROCEDURE 분류처리(IN p_코드 INTEGER, OUT p_결과 VARCHAR(20))
BEGIN
    IF p_코드 = 1 THEN
        SET p_결과 = '유형A';
    ELSEIF p_코드 = 2 THEN
        SET p_결과 = '유형B';
    ELSEIF p_코드 = 3 THEN
        SET p_결과 = '유형C';
    ELSE
        SET p_결과 = '기타';
    END IF;
END;

-- CASE 문 (표현식이 아닌 문장)
CREATE PROCEDURE 등급처리(IN p_등급 CHAR(1), OUT p_설명 VARCHAR(50))
BEGIN
    CASE p_등급
        WHEN 'A' THEN SET p_설명 = '우수';
        WHEN 'B' THEN SET p_설명 = '양호';
        WHEN 'C' THEN SET p_설명 = '보통';
        ELSE SET p_설명 = '미달';
    END CASE;
END;

-- LOOP
CREATE PROCEDURE 반복_loop(OUT p_합계 INTEGER)
BEGIN
    DECLARE v_i INTEGER DEFAULT 1;
    DECLARE v_합계 INTEGER DEFAULT 0;

    loop1: LOOP
        SET v_합계 = v_합계 + v_i;
        SET v_i = v_i + 1;
        IF v_i > 100 THEN
            LEAVE loop1;
        END IF;
    END LOOP loop1;

    SET p_합계 = v_합계;
END;

-- WHILE
CREATE PROCEDURE 반복_while(OUT p_합계 INTEGER)
BEGIN
    DECLARE v_i INTEGER DEFAULT 1;
    DECLARE v_합계 INTEGER DEFAULT 0;

    WHILE v_i <= 100 DO
        SET v_합계 = v_합계 + v_i;
        SET v_i = v_i + 1;
    END WHILE;

    SET p_합계 = v_합계;
END;

-- REPEAT
CREATE PROCEDURE 반복_repeat(OUT p_합계 INTEGER)
BEGIN
    DECLARE v_i INTEGER DEFAULT 1;
    DECLARE v_합계 INTEGER DEFAULT 0;

    REPEAT
        SET v_합계 = v_합계 + v_i;
        SET v_i = v_i + 1;
    UNTIL v_i > 100
    END REPEAT;

    SET p_합계 = v_합계;
END;

-- FOR (커서 기반 반복)
CREATE PROCEDURE 직원목록_출력()
BEGIN
    FOR v_row AS
        SELECT 직원번호, 이름, 급여
        FROM 직원
        ORDER BY 직원번호
    DO
        INSERT INTO 처리결과 (메시지)
        VALUES (v_row.이름 || ': ' || CAST(v_row.급여 AS VARCHAR(20)));
    END FOR;
END;
```

### 9.4 예외 처리

```sql
CREATE PROCEDURE 안전한_입력(
    IN p_직원번호 INTEGER,
    IN p_이름 VARCHAR(50),
    IN p_부서코드 CHAR(4),
    OUT p_상태 VARCHAR(100)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLSTATE '23000'
    BEGIN
        SET p_상태 = '무결성 제약 위반: 중복 키 또는 외래 키 오류';
    END;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET p_상태 = '알 수 없는 오류 발생';
    END;

    INSERT INTO 직원 (직원번호, 이름, 부서코드)
    VALUES (p_직원번호, p_이름, p_부서코드);

    SET p_상태 = '성공';
END;
```

---

## 10. OLAP 확장

### 10.1 ROLLUP

```sql
-- ROLLUP: 소계와 총계 생성 (계층적)
SELECT 부서코드,
       직급,
       SUM(급여) AS 급여합계,
       COUNT(*) AS 인원수
FROM 직원
GROUP BY ROLLUP (부서코드, 직급);

-- 결과 예:
-- 부서코드 | 직급   | 급여합계    | 인원수
-- D001     | 과장   | 10000000   | 2
-- D001     | 대리   | 8000000    | 2
-- D001     | NULL   | 18000000   | 4     ← 부서 소계
-- D002     | 과장   | 5000000    | 1
-- D002     | 대리   | 4500000    | 1
-- D002     | NULL   | 9500000    | 2     ← 부서 소계
-- NULL     | NULL   | 27500000   | 6     ← 총계
```

### 10.2 CUBE

```sql
-- CUBE: 모든 조합의 소계 생성
SELECT 부서코드,
       직급,
       SUM(급여) AS 급여합계
FROM 직원
GROUP BY CUBE (부서코드, 직급);

-- 결과: ROLLUP + 직급별 소계도 포함
-- 부서코드 | 직급   | 급여합계
-- D001     | 과장   | 10000000
-- D001     | 대리   | 8000000
-- D001     | NULL   | 18000000    ← 부서별 소계
-- D002     | 과장   | 5000000
-- D002     | 대리   | 4500000
-- D002     | NULL   | 9500000     ← 부서별 소계
-- NULL     | 과장   | 15000000    ← 직급별 소계
-- NULL     | 대리   | 12500000    ← 직급별 소계
-- NULL     | NULL   | 27500000    ← 총계
```

### 10.3 GROUPING SETS

```sql
-- GROUPING SETS: 특정 그룹화 조합만 선택
SELECT 부서코드,
       직급,
       성별,
       SUM(급여) AS 급여합계
FROM 직원
GROUP BY GROUPING SETS (
    (부서코드, 직급),    -- 부서+직급별 집계
    (부서코드),           -- 부서별 집계
    (직급),               -- 직급별 집계
    ()                    -- 전체 합계
);

-- GROUPING 함수: 소계행 식별
SELECT
    CASE WHEN GROUPING(부서코드) = 1 THEN '전체' ELSE 부서코드 END AS 부서,
    CASE WHEN GROUPING(직급) = 1 THEN '전체' ELSE 직급 END AS 직급,
    SUM(급여) AS 급여합계
FROM 직원
GROUP BY ROLLUP (부서코드, 직급);
```

### ROLLUP vs CUBE vs GROUPING SETS 비교

두 컬럼(A, B)에 대해:

| 구문 | 생성되는 그룹화 |
|------|----------------|
| GROUP BY ROLLUP(A, B) | (A, B), (A), () |
| GROUP BY CUBE(A, B) | (A, B), (A), (B), () |
| GROUP BY GROUPING SETS((A, B), (A)) | (A, B), (A) |

---

## 11. SIMILAR TO

SQL:1999에서 정규 표현식 기반 패턴 매칭을 도입했다.

```sql
-- SIMILAR TO: SQL 정규 표현식 패턴 매칭
-- LIKE보다 강력한 패턴 표현 가능

-- 기본 사용
SELECT 이름 FROM 직원
WHERE 이름 SIMILAR TO '김%';

-- 문자 클래스
SELECT 이름 FROM 직원
WHERE 전화번호 SIMILAR TO '[0-9]{3}-[0-9]{3,4}-[0-9]{4}';

-- 선택 (|)
SELECT 이름 FROM 직원
WHERE 부서코드 SIMILAR TO 'D001|D002|D003';

-- 반복
SELECT 제품명 FROM 제품
WHERE 제품코드 SIMILAR TO '[A-Z]{2}[0-9]{4}';
--  [A-Z]{2}: 영문 대문자 2자
--  [0-9]{4}: 숫자 4자

-- 선택적 문자
SELECT 이름 FROM 직원
WHERE 이름 SIMILAR TO '(김|이|박)%';
```

### SIMILAR TO 패턴 요소

| 패턴 | 설명 | 예시 |
|------|------|------|
| `_` | 임의의 한 문자 | `'A_C'` → ABC, AXC |
| `%` | 0개 이상 임의 문자 | `'A%'` → A, AB, ABC |
| `[abc]` | 문자 집합 | `'[ABC]%'` → A로 시작 |
| `[a-z]` | 문자 범위 | `'[0-9]%'` → 숫자로 시작 |
| `[^abc]` | 부정 문자 집합 | `'[^0-9]%'` → 숫자 외로 시작 |
| `\|` | 선택 (OR) | `'A\|B'` → A 또는 B |
| `{n}` | 정확히 n번 반복 | `'[0-9]{3}'` → 숫자 3자리 |
| `{n,m}` | n~m번 반복 | `'[0-9]{2,4}'` → 숫자 2~4자리 |
| `*` | 0번 이상 반복 | `'A*B'` → B, AB, AAB |
| `+` | 1번 이상 반복 | `'A+B'` → AB, AAB |
| `?` | 0 또는 1번 | `'A?B'` → B, AB |

---

## 12. SAVEPOINT

트랜잭션 내에서 부분적인 롤백을 가능하게 한다.

```sql
-- 세이브포인트 생성
SAVEPOINT sp1;

INSERT INTO 직원 VALUES (201, '신입1', 'D001', 3000000);

SAVEPOINT sp2;

INSERT INTO 직원 VALUES (202, '신입2', 'D002', 3500000);

-- sp2까지 롤백 (신입2 입력만 취소)
ROLLBACK TO SAVEPOINT sp2;

-- sp1까지 롤백 (신입1, 신입2 모두 취소)
ROLLBACK TO SAVEPOINT sp1;

-- 세이브포인트 해제
RELEASE SAVEPOINT sp1;

-- 전체 커밋
COMMIT;
```

---

## 13. ROLE 기반 권한

```sql
-- 역할 생성
CREATE ROLE 일반사용자;
CREATE ROLE 관리자;
CREATE ROLE 감사자;

-- 역할에 권한 부여
GRANT SELECT ON 직원 TO 일반사용자;
GRANT SELECT, INSERT, UPDATE ON 직원 TO 관리자;
GRANT DELETE ON 직원 TO 관리자;
GRANT SELECT ON 감사로그 TO 감사자;

-- 역할을 사용자에게 부여
GRANT 일반사용자 TO 사용자1;
GRANT 관리자 TO 사용자2;
GRANT 감사자 TO 사용자3;

-- 역할 계층 (역할에 역할 부여)
GRANT 일반사용자 TO 관리자;  -- 관리자는 일반사용자 권한도 포함

-- 현재 세션에서 역할 설정
SET ROLE 관리자;
SET ROLE NONE;  -- 모든 역할 비활성화

-- 역할 회수
REVOKE 관리자 FROM 사용자2;

-- 역할 삭제
DROP ROLE 감사자;
```

---

## 14. 재귀 쿼리

재귀 쿼리는 CTE의 WITH RECURSIVE를 활용한 고급 기능이다.

```sql
-- 그래프 탐색: 경로 찾기
CREATE TABLE 노선 (
    출발역  VARCHAR(20),
    도착역  VARCHAR(20),
    거리    INTEGER
);

INSERT INTO 노선 VALUES ('서울', '대전', 140);
INSERT INTO 노선 VALUES ('대전', '대구', 120);
INSERT INTO 노선 VALUES ('대구', '부산', 90);
INSERT INTO 노선 VALUES ('서울', '원주', 100);
INSERT INTO 노선 VALUES ('원주', '강릉', 110);

-- 서울에서 도달 가능한 모든 역과 총 거리
WITH RECURSIVE 도달가능 (역, 총거리, 경로) AS (
    SELECT '서울', 0, CAST('서울' AS VARCHAR(500))

    UNION ALL

    SELECT n.도착역,
           r.총거리 + n.거리,
           r.경로 || ' → ' || n.도착역
    FROM 도달가능 r
      INNER JOIN 노선 n ON r.역 = n.출발역
    WHERE POSITION(n.도착역 IN r.경로) = 0  -- 순환 방지
)
SELECT 역, 총거리, 경로
FROM 도달가능
WHERE 역 <> '서울'
ORDER BY 총거리;
```

---

## 15. SQL/MED

SQL/MED(Management of External Data)는 외부 데이터 소스에 대한 접근을 표준화한다.

```sql
-- 외부 서버 정의
CREATE FOREIGN DATA WRAPPER 파일_래퍼
  HANDLER 파일_핸들러;

CREATE SERVER 외부파일서버
  FOREIGN DATA WRAPPER 파일_래퍼
  OPTIONS (디렉토리 '/data/external');

-- 사용자 매핑
CREATE USER MAPPING FOR CURRENT_USER
  SERVER 외부파일서버
  OPTIONS (사용자명 'reader', 비밀번호 'pass');

-- 외부 테이블 정의
CREATE FOREIGN TABLE 외부고객 (
    고객번호    INTEGER,
    이름        VARCHAR(100),
    이메일      VARCHAR(200)
) SERVER 외부파일서버
  OPTIONS (파일명 'customers.csv', 구분자 ',');

-- 일반 테이블처럼 쿼리
SELECT * FROM 외부고객
WHERE 이름 LIKE '김%';
```

---

## 16. SQL/OLB

SQL/OLB(Object Language Bindings)는 SQL을 Java 프로그램에 내장하기 위한 표준이다.

```java
// SQLJ: SQL을 Java에 내장
// (개념적 예시)
#sql {
    SELECT 이름, 급여
    INTO :name, :salary
    FROM 직원
    WHERE 직원번호 = :empId
};

// 커서 사용
#sql cursor = {
    SELECT 직원번호, 이름, 급여
    FROM 직원
    WHERE 부서코드 = :deptCode
    ORDER BY 급여 DESC
};

while (cursor.next()) {
    #sql { FETCH :cursor INTO :id, :name, :salary };
    System.out.println(name + ": " + salary);
}
```

---

## 17. 제약사항과 한계

| 미지원 기능 | 도입 표준 |
|------------|----------|
| 윈도우 함수 (ROW_NUMBER, RANK 등) | SQL:2003 |
| MERGE 문 | SQL:2003 |
| 시퀀스 (CREATE SEQUENCE) | SQL:2003 |
| XML 지원 | SQL:2003 |
| TRUNCATE TABLE | SQL:2008 |
| OFFSET/FETCH | SQL:2008 |
| 시간적 데이터베이스 (Temporal) | SQL:2011 |
| JSON 지원 | SQL:2016 |
| 그래프 쿼리 | SQL:2023 |

---

## 18. 영향과 의의

1. 객체-관계형 패러다임: SQL에 객체지향 개념(UDT, 메서드, 상속)을 도입하여 복잡한 데이터 모델링을 가능하게 했다.
2. CTE와 재귀 쿼리: 계층적 데이터 처리의 표준 방법을 제공했다. 현재 거의 모든 DBMS가 지원한다.
3. 트리거 표준화: 데이터 무결성과 비즈니스 로직의 데이터베이스 레벨 구현이 표준화되었다.
4. PSM 표준화: 저장 프로시저/함수의 표준 문법을 정의하여 이식성을 향상시켰다.
5. OLAP 기능: ROLLUP, CUBE, GROUPING SETS는 비즈니스 인텔리전스 분야에서 핵심 기능이 되었다.
6. 적합성 모델 개선: Core + 패키지 모델은 이후 모든 SQL 표준에서 채택되었다.
7. SIMILAR TO: SQL 내에서 정규 표현식 패턴 매칭의 기초를 확립했다.

SQL:1999는 SQL을 단순한 데이터 조회 언어에서 본격적인 프로그래밍 언어로 발전시킨 전환점이었다.

---

> 참고: SQL:1999 표준의 공식 문서는 ISO/IEC 9075:1999 시리즈로 발행되었다.
