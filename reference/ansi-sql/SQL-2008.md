# SQL:2008 표준 완벽 가이드

## ISO/IEC 9075:2008 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [TRUNCATE TABLE](#2-truncate-table)
3. [ORDER BY 확장 (OFFSET, FETCH FIRST)](#3-order-by-확장)
4. [INSTEAD OF 트리거](#4-instead-of-트리거)
5. [정규 표현식](#5-정규-표현식)
6. [SIMILAR TO 와 LIKE_REGEX 비교](#6-similar-to-와-like_regex-비교)
7. [향상된 MERGE](#7-향상된-merge)
8. [LATERAL 조인](#8-lateral-조인)
9. [BINARY / VARBINARY 타입](#9-binary--varbinary-타입)
10. [향상된 ALTER 문](#10-향상된-alter-문)
11. [향상된 진단 관리 (Enhanced Diagnostics)](#11-향상된-진단-관리)
12. [CALL 문 개선](#12-call-문-개선)
13. [향상된 GRANT / REVOKE](#13-향상된-grant--revoke)
14. [개선된 뷰 관련 구문](#14-개선된-뷰-관련-구문)
15. [기타 변경사항](#15-기타-변경사항)

---

## 1. 개요

SQL:2008(공식명: ISO/IEC 9075:2008)은 SQL:2006의 후속 표준으로, 실용적인 기능 개선에 초점을 맞추었다. TRUNCATE TABLE, 페이징 쿼리(OFFSET/FETCH), INSTEAD OF 트리거, 정규 표현식 함수, 향상된 MERGE 등이 핵심 추가 사항이다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2008 |
| 발표 연도 | 2008년 |
| 이전 표준 | SQL:2006 |
| 다음 표준 | SQL:2011 |
| 핵심 추가 기능 | TRUNCATE, OFFSET/FETCH, INSTEAD OF, 정규 표현식, MERGE 강화 |

### SQL:2008 신규 기능 목록

| 기능 | 설명 |
|------|------|
| TRUNCATE TABLE | 테이블 데이터 전체 고속 삭제 |
| OFFSET / FETCH FIRST | 표준 페이징 쿼리 |
| INSTEAD OF 트리거 | 뷰에 대한 DML 재정의 |
| LIKE_REGEX 등 | XQuery 기반 정규 표현식 |
| MERGE 강화 | DELETE 절, 추가 조건 |
| LATERAL 조인 | 상관 서브쿼리를 FROM 절에서 사용 |
| BINARY / VARBINARY | 이진 문자열 타입 표준화 |
| 향상된 ALTER | ALTER TABLE 확장 구문 |
| 향상된 진단 관리 | GET DIAGNOSTICS 확장 |
| CALL 문 개선 | 프로시저 호출 구문 확장 |
| GRANT / REVOKE 개선 | 권한 관리 구문 강화 |
| 뷰 CHECK OPTION 확장 | 뷰 갱신 제어 개선 |

---

## 2. TRUNCATE TABLE

TRUNCATE TABLE은 테이블의 모든 행을 고속으로 삭제한다. DELETE와 달리 행 단위 로그를 남기지 않아 대량 데이터 삭제에 효율적이다.

```sql
-- 기본 TRUNCATE
TRUNCATE TABLE 임시_로그;

-- IDENTITY 컬럼 재시작 여부 지정
TRUNCATE TABLE 임시_로그 RESTART IDENTITY;   -- IDENTITY 값 리셋
TRUNCATE TABLE 임시_로그 CONTINUE IDENTITY;  -- IDENTITY 값 유지

-- CASCADE/RESTRICT (외래 키 참조 시)
TRUNCATE TABLE 주문 CASCADE;    -- 참조하는 테이블도 TRUNCATE
TRUNCATE TABLE 주문 RESTRICT;   -- 참조되는 경우 실패 (기본값)

-- 복합 옵션
TRUNCATE TABLE 주문 RESTART IDENTITY CASCADE;
```

### TRUNCATE vs DELETE 비교

| 항목 | TRUNCATE | DELETE |
|------|----------|--------|
| 속도 | 매우 빠름 | 상대적으로 느림 |
| 로깅 | 최소 로깅 | 행 단위 로깅 |
| WHERE 절 | 사용 불가 | 사용 가능 |
| 트리거 발생 | 안 함 | 발생 |
| ROLLBACK | 구현에 따라 다름 | 가능 |
| IDENTITY | 리셋 옵션 있음 | 영향 없음 |
| 외래 키 | CASCADE/RESTRICT | 행 단위 검사 |

---

## 3. ORDER BY 확장

### 3.1 OFFSET / FETCH FIRST

SQL:2008에서 표준화된 페이징 쿼리 구문이다. 벤더별 LIMIT/TOP 구문을 대체한다.

```sql
-- 기본 구문
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 0 ROWS
FETCH FIRST 10 ROWS ONLY;

-- 두 번째 페이지 (11~20번째 행)
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 10 ROWS
FETCH FIRST 10 ROWS ONLY;

-- N번째 페이지
-- OFFSET (페이지번호 - 1) * 페이지크기 ROWS
-- FETCH FIRST 페이지크기 ROWS ONLY

-- ROW와 ROWS는 동의어 (1행일 때 가독성)
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 1 ROW ONLY;  -- 최고 급여 1명

-- OFFSET만 사용 (FETCH 없이)
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 5 ROWS;  -- 상위 5명 제외하고 나머지

-- FETCH NEXT (FIRST와 동의어)
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY;

-- PERCENT 지원 (구현에 따라)
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 10 PERCENT ROWS ONLY;  -- 상위 10%

-- WITH TIES: 동점자 포함
SELECT 이름, 급여
FROM 직원
ORDER BY 급여 DESC
FETCH FIRST 3 ROWS WITH TIES;
-- 3위까지 반환하되, 3위와 동점인 행도 모두 포함
```

### 벤더별 페이징 구문 비교

| 벤더 | 구문 | 표준 여부 |
|------|------|:---------:|
| SQL 표준 | OFFSET n ROWS FETCH FIRST m ROWS ONLY | O |
| MySQL/MariaDB | LIMIT m OFFSET n | X |
| PostgreSQL | LIMIT m OFFSET n | X |
| SQL Server | TOP n (구버전), OFFSET/FETCH (2012+) | 부분 |
| Oracle | ROWNUM (구버전), OFFSET/FETCH (12c+) | 부분 |

### 3.2 실용적인 페이징 예제

```sql
-- 게시판 목록 조회 (페이지당 20건)
SELECT 글번호, 제목, 작성자, 작성일
FROM 게시글
WHERE 게시판코드 = 'notice'
ORDER BY 글번호 DESC
OFFSET 40 ROWS         -- 3페이지 시작 (0-indexed: 0, 20, 40, ...)
FETCH FIRST 20 ROWS ONLY;

-- 윈도우 함수와 결합한 페이징
SELECT *
FROM (
    SELECT ROW_NUMBER() OVER (ORDER BY 급여 DESC) AS rn,
           이름, 부서코드, 급여
    FROM 직원
) AS ranked
ORDER BY rn
OFFSET 10 ROWS
FETCH FIRST 10 ROWS ONLY;

-- 서브쿼리에서의 ORDER BY + FETCH
SELECT 부서코드,
       (SELECT 이름 FROM 직원 e
        WHERE e.부서코드 = d.부서코드
        ORDER BY 급여 DESC
        FETCH FIRST 1 ROW ONLY) AS 최고급여자
FROM 부서 d;
```

---

## 4. INSTEAD OF 트리거

INSTEAD OF 트리거는 뷰(View)에 대한 DML 연산을 사용자 정의 로직으로 대체한다. 갱신 불가능한 뷰에 대해 INSERT, UPDATE, DELETE를 가능하게 한다.

```sql
-- 조인 뷰 생성
CREATE VIEW 직원_부서_뷰 AS
    SELECT e.직원번호, e.이름, e.급여,
           d.부서코드, d.부서명
    FROM 직원 e
      INNER JOIN 부서 d ON e.부서코드 = d.부서코드;

-- INSTEAD OF INSERT 트리거
CREATE TRIGGER trg_직원부서뷰_입력
  INSTEAD OF INSERT ON 직원_부서_뷰
  REFERENCING NEW AS 신규
  FOR EACH ROW
  BEGIN ATOMIC
    -- 부서가 존재하지 않으면 생성
    IF NOT EXISTS (SELECT 1 FROM 부서 WHERE 부서코드 = 신규.부서코드) THEN
        INSERT INTO 부서 (부서코드, 부서명)
        VALUES (신규.부서코드, 신규.부서명);
    END IF;

    -- 직원 입력
    INSERT INTO 직원 (직원번호, 이름, 급여, 부서코드)
    VALUES (신규.직원번호, 신규.이름, 신규.급여, 신규.부서코드);
  END;

-- INSTEAD OF UPDATE 트리거
CREATE TRIGGER trg_직원부서뷰_수정
  INSTEAD OF UPDATE ON 직원_부서_뷰
  REFERENCING OLD AS 이전 NEW AS 이후
  FOR EACH ROW
  BEGIN ATOMIC
    -- 직원 정보 업데이트
    UPDATE 직원
    SET 이름 = 이후.이름,
        급여 = 이후.급여,
        부서코드 = 이후.부서코드
    WHERE 직원번호 = 이전.직원번호;

    -- 부서명 변경이 있으면 부서 테이블도 업데이트
    IF 이전.부서명 <> 이후.부서명 THEN
        UPDATE 부서
        SET 부서명 = 이후.부서명
        WHERE 부서코드 = 이후.부서코드;
    END IF;
  END;

-- INSTEAD OF DELETE 트리거
CREATE TRIGGER trg_직원부서뷰_삭제
  INSTEAD OF DELETE ON 직원_부서_뷰
  REFERENCING OLD AS 이전
  FOR EACH ROW
  BEGIN ATOMIC
    DELETE FROM 직원 WHERE 직원번호 = 이전.직원번호;
  END;

-- 이제 뷰를 통해 DML 가능
INSERT INTO 직원_부서_뷰 (직원번호, 이름, 급여, 부서코드, 부서명)
VALUES (201, '신입사원', 3500000, 'D004', '기획팀');

UPDATE 직원_부서_뷰
SET 급여 = 4000000
WHERE 직원번호 = 201;

DELETE FROM 직원_부서_뷰 WHERE 직원번호 = 201;
```

### 트리거 유형 비교 (BEFORE/AFTER/INSTEAD OF)

| 유형 | 대상 | 실행 시점 | 원본 DML |
|------|------|-----------|----------|
| BEFORE | 테이블 | DML 전 | 실행됨 |
| AFTER | 테이블 | DML 후 | 실행됨 |
| INSTEAD OF | 뷰 | DML 대신 | 실행 안 됨 |

---

## 5. 정규 표현식

SQL:2008은 XQuery 정규 표현식 구문을 기반으로 한 정규 표현식 함수를 도입했다.

### 5.1 LIKE_REGEX

```sql
-- LIKE_REGEX: 정규 표현식 패턴 매칭
-- SIMILAR TO보다 강력한 XQuery 정규 표현식 사용

-- 이메일 패턴 검증
SELECT 이름, 이메일
FROM 직원
WHERE 이메일 LIKE_REGEX '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}';

-- 한국 전화번호 패턴
SELECT 이름, 전화번호
FROM 직원
WHERE 전화번호 LIKE_REGEX '0[0-9]{1,2}-[0-9]{3,4}-[0-9]{4}';

-- 플래그 옵션
-- 'i': 대소문자 무시
-- 's': 싱글라인 모드 (. 이 줄바꿈도 매칭)
-- 'm': 멀티라인 모드
-- 'x': 확장 모드 (공백 무시)
SELECT 이름 FROM 직원
WHERE 이름 LIKE_REGEX '[가-힣]+' FLAG 'i';

-- 우편번호 검증
SELECT 주소 FROM 고객
WHERE 우편번호 LIKE_REGEX '[0-9]{5}';
```

### 5.2 OCCURRENCES_REGEX

```sql
-- 정규 표현식 패턴 출현 횟수 반환
SELECT 이름,
       OCCURRENCES_REGEX('[0-9]+' IN 전화번호) AS 숫자그룹수
FROM 직원;

-- 특정 문자 출현 횟수
SELECT 제목,
       OCCURRENCES_REGEX('[,]' IN 태그) AS 쉼표수
FROM 게시글;

-- 단어 수 세기 (근사)
SELECT 제목,
       OCCURRENCES_REGEX('\S+' IN 본문) AS 대략단어수
FROM 게시글;

-- FLAG 옵션
SELECT OCCURRENCES_REGEX('error' FLAG 'i' IN 로그메시지) AS 오류횟수
FROM 시스템로그;
```

### 5.3 POSITION_REGEX

```sql
-- 정규 표현식 패턴의 위치 반환
SELECT 이름,
       POSITION_REGEX('[0-9]+' IN 전화번호) AS 첫숫자위치
FROM 직원;

-- 시작 위치 지정
SELECT POSITION_REGEX('[0-9]+' IN 전화번호 FROM 5) AS 다섯째이후숫자위치
FROM 직원;

-- 출현 순서 지정 (두 번째 매칭 위치)
SELECT POSITION_REGEX('[0-9]+' IN '서울시 강남구 역삼동 123-456'
                      OCCURRENCE 2) AS 두번째숫자위치;

-- AFTER 옵션: 매칭 후 위치 반환
SELECT POSITION_REGEX('[0-9]+' IN '가나다123라마바'
                      AFTER) AS 매칭후위치;
-- 결과: 7 (123 다음 위치)
```

### 5.4 SUBSTRING_REGEX

```sql
-- 정규 표현식에 매칭되는 부분 문자열 추출
SELECT SUBSTRING_REGEX('[0-9]+' IN '주문번호: ORD-12345-2024') AS 주문번호숫자;
-- 결과: '12345'

-- 특정 출현 추출
SELECT SUBSTRING_REGEX('[0-9]+' IN '2024-01-15' OCCURRENCE 1) AS 연도;
-- 결과: '2024'
SELECT SUBSTRING_REGEX('[0-9]+' IN '2024-01-15' OCCURRENCE 2) AS 월;
-- 결과: '01'
SELECT SUBSTRING_REGEX('[0-9]+' IN '2024-01-15' OCCURRENCE 3) AS 일;
-- 결과: '15'

-- 이메일에서 도메인 추출
SELECT SUBSTRING_REGEX('@(.+)$' IN 이메일) AS 도메인
FROM 직원;

-- 그룹 캡처 사용
SELECT SUBSTRING_REGEX('([0-9]{3})-([0-9]{3,4})-([0-9]{4})'
                       IN 전화번호 GROUP 1) AS 지역번호
FROM 직원;
```

### 5.5 TRANSLATE_REGEX

```sql
-- 정규 표현식 기반 문자열 치환
SELECT TRANSLATE_REGEX('[0-9]' IN '전화: 02-123-4567'
                       WITH '*') AS 마스킹;
-- 결과: '전화: -*-'

-- 특정 출현만 치환
SELECT TRANSLATE_REGEX('[0-9]+' IN '2024-01-15'
                       WITH 'XX' OCCURRENCE 2) AS 결과;
-- 결과: '2024-XX-15'

-- 모든 출현 치환
SELECT TRANSLATE_REGEX('[0-9]+' IN '2024-01-15'
                       WITH 'N' FLAG 'g') AS 결과;
-- 결과: 'N-N-N'

-- 이메일 마스킹
SELECT TRANSLATE_REGEX('([a-zA-Z0-9])[a-zA-Z0-9]*(@.+)' IN 이메일
                       WITH '\1*\2') AS 마스킹이메일
FROM 직원;
-- 'kim@example.com' → 'k*@example.com'
```

### 정규 표현식 함수 요약

| 함수 | 반환 타입 | 설명 |
|------|-----------|------|
| LIKE_REGEX | BOOLEAN | 패턴 매칭 여부 |
| OCCURRENCES_REGEX | INTEGER | 패턴 출현 횟수 |
| POSITION_REGEX | INTEGER | 패턴 위치 |
| SUBSTRING_REGEX | VARCHAR | 매칭된 부분 문자열 |
| TRANSLATE_REGEX | VARCHAR | 패턴 치환 결과 |

---

## 6. SIMILAR TO 와 LIKE_REGEX 비교

SIMILAR TO는 SQL:1999에서 도입된 SQL 고유 정규 표현식이고, LIKE_REGEX는 SQL:2008에서 도입된 XQuery 정규 표현식이다. 두 구문은 패턴 문법이 다르다.

### 6.1 기본 문법 차이

```sql
-- SIMILAR TO: SQL 정규 표현식 (LIKE 확장)
-- 패턴이 전체 문자열과 매칭되어야 한다 (암묵적 앵커)
SELECT 이름 FROM 직원
WHERE 이름 SIMILAR TO '[가-힣]{2,5}';
-- 이름 전체가 한글 2~5자인 경우에만 매칭

-- LIKE_REGEX: XQuery 정규 표현식
-- 부분 매칭이 기본이다 (앵커 없으면 부분 문자열 매칭)
SELECT 이름 FROM 직원
WHERE 이름 LIKE_REGEX '[가-힣]{2,5}';
-- 이름에 한글 2~5자 연속이 포함되어 있으면 매칭

-- LIKE_REGEX에서 전체 매칭을 하려면 앵커를 명시해야 한다
SELECT 이름 FROM 직원
WHERE 이름 LIKE_REGEX '^[가-힣]{2,5}$';
```

### 6.2 와일드카드 / 반복 구문 차이

```sql
-- SIMILAR TO: SQL 스타일 와일드카드와 정규 표현식의 혼합
-- '%'는 임의 길이 문자열, '_'는 단일 문자
SELECT 이메일 FROM 직원
WHERE 이메일 SIMILAR TO '%@[a-zA-Z]+.com';

-- LIKE_REGEX: 표준 정규 표현식 메타문자만 사용
-- '.*'는 임의 길이, '.'은 단일 문자
SELECT 이메일 FROM 직원
WHERE 이메일 LIKE_REGEX '.*@[a-zA-Z]+\.com';
```

### 6.3 이스케이프 처리 차이

```sql
-- SIMILAR TO: ESCAPE 절로 이스케이프 문자를 지정
SELECT 설명 FROM 제품
WHERE 설명 SIMILAR TO '%50\%%' ESCAPE '\';
-- '%'를 리터럴로 매칭하려면 ESCAPE 문자 사용

-- LIKE_REGEX: 백슬래시 이스케이프가 기본
SELECT 설명 FROM 제품
WHERE 설명 LIKE_REGEX '50%';
-- '50%'에서 '%'는 리터럴이 아닌 메타문자가 아니므로 그대로 매칭
-- 정규 표현식 메타문자를 리터럴로 매칭하려면 백슬래시 사용
SELECT 설명 FROM 제품
WHERE 설명 LIKE_REGEX '50\.\d+';
```

### 6.4 문자 클래스와 그룹

```sql
-- SIMILAR TO: POSIX 문자 클래스 사용
SELECT 코드 FROM 제품
WHERE 코드 SIMILAR TO '[[:upper:]]{3}-[[:digit:]]{4}';

-- LIKE_REGEX: XQuery/유니코드 문자 클래스 사용
SELECT 코드 FROM 제품
WHERE 코드 LIKE_REGEX '\p{Lu}{3}-\p{Nd}{4}';

-- SIMILAR TO: 교대(alternation) 구문
SELECT 상태 FROM 주문
WHERE 상태 SIMILAR TO '완료|취소|반품';

-- LIKE_REGEX: 동일한 교대 구문
SELECT 상태 FROM 주문
WHERE 상태 LIKE_REGEX '^(완료|취소|반품)$';
```

### 6.5 FLAG 옵션

```sql
-- SIMILAR TO: 플래그 옵션 없음

-- LIKE_REGEX: FLAG 절로 매칭 옵션 지정 가능
SELECT 이름 FROM 직원
WHERE 이름 LIKE_REGEX 'hong' FLAG 'i';
-- 'i' 플래그로 대소문자 무시 매칭
```

### SIMILAR TO vs LIKE_REGEX 비교표

| 항목 | SIMILAR TO | LIKE_REGEX |
|------|-----------|------------|
| 도입 표준 | SQL:1999 | SQL:2008 |
| 정규 표현식 방언 | SQL 고유 (LIKE 확장) | XQuery (W3C) |
| 매칭 범위 | 전체 문자열 (암묵적 앵커) | 부분 문자열 (기본) |
| 와일드카드 | `%`, `_` | `.`, `.*` |
| 문자 클래스 | POSIX `[[:alpha:]]` | 유니코드 `\p{L}` |
| 이스케이프 | ESCAPE 절 | 백슬래시 `\` |
| FLAG 옵션 | 없음 | `'i'`, `'s'`, `'m'`, `'x'` |
| 캡처 그룹 | 없음 | `()` 지원 |

---

## 7. 향상된 MERGE

SQL:2008에서 MERGE 문이 크게 강화되었다.

### 7.1 DELETE 절 추가

```sql
-- MERGE에서 DELETE 지원
MERGE INTO 재고 AS inv
USING 재고조정 AS adj
ON inv.제품코드 = adj.제품코드
WHEN MATCHED AND adj.조정유형 = 'UPDATE' THEN
    UPDATE SET inv.수량 = adj.신규수량
WHEN MATCHED AND adj.조정유형 = 'DELETE' THEN
    DELETE
WHEN NOT MATCHED AND adj.조정유형 <> 'DELETE' THEN
    INSERT (제품코드, 수량)
    VALUES (adj.제품코드, adj.신규수량);
```

### 7.2 추가 조건부 WHEN 절

```sql
-- 여러 WHEN MATCHED 절 사용
MERGE INTO 직원 AS t
USING 인사변동 AS s
ON t.직원번호 = s.직원번호
WHEN MATCHED AND s.변동유형 = '급여인상' THEN
    UPDATE SET t.급여 = s.신규급여
WHEN MATCHED AND s.변동유형 = '부서이동' THEN
    UPDATE SET t.부서코드 = s.신규부서코드
WHEN MATCHED AND s.변동유형 = '퇴사' THEN
    DELETE
WHEN NOT MATCHED AND s.변동유형 = '입사' THEN
    INSERT (직원번호, 이름, 부서코드, 급여)
    VALUES (s.직원번호, s.이름, s.신규부서코드, s.신규급여);

-- 고객 데이터 동기화
MERGE INTO 고객 AS target
USING 외부고객데이터 AS source
ON target.고객번호 = source.고객번호
WHEN MATCHED AND source.상태 = 'ACTIVE' THEN
    UPDATE SET
        target.이름 = source.이름,
        target.이메일 = source.이메일,
        target.최종수정일 = CURRENT_TIMESTAMP
WHEN MATCHED AND source.상태 = 'INACTIVE' THEN
    DELETE
WHEN NOT MATCHED THEN
    INSERT (고객번호, 이름, 이메일, 등록일)
    VALUES (source.고객번호, source.이름, source.이메일, CURRENT_DATE);
```

### SQL:2003 vs SQL:2008 MERGE 비교

| 기능 | SQL:2003 | SQL:2008 |
|------|----------|----------|
| WHEN MATCHED UPDATE | O | O |
| WHEN NOT MATCHED INSERT | O | O |
| WHEN MATCHED DELETE | X | O |
| 다중 WHEN MATCHED | X | O |
| AND 조건절 | X | O |

---

## 8. LATERAL 조인

LATERAL 키워드를 사용하면 FROM 절의 서브쿼리가 앞서 나열된 테이블의 컬럼을 참조할 수 있다. 상관 서브쿼리를 FROM 절에서 사용하는 것과 같다.

### 8.1 CROSS JOIN LATERAL

```sql
-- 각 부서에서 급여 상위 3명 조회
SELECT d.부서코드, d.부서명, e.이름, e.급여
FROM 부서 d
  CROSS JOIN LATERAL (
    SELECT * FROM 직원
    WHERE 직원.부서코드 = d.부서코드
    ORDER BY 급여 DESC
    FETCH FIRST 3 ROWS ONLY
  ) AS e;

-- 각 고객의 최근 주문 5건 조회
SELECT c.고객번호, c.이름, o.주문번호, o.주문일, o.금액
FROM 고객 c
  CROSS JOIN LATERAL (
    SELECT 주문번호, 주문일, 금액
    FROM 주문
    WHERE 주문.고객번호 = c.고객번호
    ORDER BY 주문일 DESC
    FETCH FIRST 5 ROWS ONLY
  ) AS o;
```

### 8.2 LEFT JOIN LATERAL

```sql
-- LEFT JOIN LATERAL: 서브쿼리 결과가 없어도 외부 행을 유지
SELECT d.부서코드, e.이름
FROM 부서 d
  LEFT JOIN LATERAL (
    SELECT 이름 FROM 직원
    WHERE 직원.부서코드 = d.부서코드
    ORDER BY 급여 DESC
    FETCH FIRST 1 ROW ONLY
  ) AS e ON TRUE;
-- 직원이 없는 부서도 결과에 포함 (e.이름은 NULL)

-- 각 제품의 최근 리뷰 1건 (리뷰가 없는 제품도 포함)
SELECT p.제품코드, p.제품명, r.평점, r.내용, r.작성일
FROM 제품 p
  LEFT JOIN LATERAL (
    SELECT 평점, 내용, 작성일
    FROM 리뷰
    WHERE 리뷰.제품코드 = p.제품코드
    ORDER BY 작성일 DESC
    FETCH FIRST 1 ROW ONLY
  ) AS r ON TRUE;
```

### 8.3 LATERAL과 집계 함수

```sql
-- 각 부서별 급여 통계를 LATERAL로 계산
SELECT d.부서코드, d.부서명,
       s.직원수, s.평균급여, s.최대급여
FROM 부서 d
  CROSS JOIN LATERAL (
    SELECT COUNT(*) AS 직원수,
           AVG(급여) AS 평균급여,
           MAX(급여) AS 최대급여
    FROM 직원
    WHERE 직원.부서코드 = d.부서코드
  ) AS s;

-- LATERAL과 UNNEST 결합 (배열 펼치기)
SELECT o.주문번호, item.제품코드, item.수량
FROM 주문 o
  CROSS JOIN LATERAL UNNEST(o.주문항목) AS item(제품코드, 수량);
```

### 8.4 LATERAL과 함수 호출

```sql
-- 테이블 반환 함수를 LATERAL로 호출
SELECT d.부서코드, d.부서명, e.이름, e.직급
FROM 부서 d
  CROSS JOIN LATERAL 부서별직원조회(d.부서코드) AS e(이름, 직급);
```

---

## 9. BINARY / VARBINARY 타입

SQL:2008은 이진 문자열 타입인 BINARY와 VARBINARY를 표준으로 공식 정의했다.

### 9.1 타입 선언

```sql
-- BINARY: 고정 길이 이진 문자열
CREATE TABLE 파일해시 (
    파일번호     INTEGER PRIMARY KEY,
    MD5해시     BINARY(16),        -- 고정 16바이트
    SHA256해시  BINARY(32)         -- 고정 32바이트
);

-- VARBINARY: 가변 길이 이진 문자열
CREATE TABLE 첨부파일 (
    파일번호     INTEGER PRIMARY KEY,
    파일명       VARCHAR(255),
    파일내용     VARBINARY(8000),    -- 최대 8000바이트
    썸네일       VARBINARY(2000)
);

-- BINARY LARGE OBJECT (BLOB)은 SQL:1999부터 있었으나 함께 사용
CREATE TABLE 미디어 (
    미디어번호   INTEGER PRIMARY KEY,
    미리보기     VARBINARY(4000),
    원본파일     BLOB(100M)
);
```

### 9.2 이진 문자열 리터럴과 연산

```sql
-- 16진수 리터럴
INSERT INTO 파일해시 (파일번호, MD5해시)
VALUES (1, X'D41D8CD98F00B204E9800998ECF8427E');

-- 이진 문자열 연결
SELECT X'DEAD' || X'BEEF' AS 결합;
-- 결과: X'DEADBEEF'

-- 길이 함수
SELECT OCTET_LENGTH(파일내용) AS 바이트수
FROM 첨부파일;

-- 부분 추출
SELECT SUBSTRING(MD5해시 FROM 1 FOR 4) AS 처음4바이트
FROM 파일해시;

-- 위치 검색
SELECT POSITION(X'FF' IN 파일내용) AS 위치
FROM 첨부파일;

-- OVERLAY (부분 치환)
SELECT OVERLAY(MD5해시 PLACING X'0000' FROM 1 FOR 2) AS 변경후
FROM 파일해시;
```

### 9.3 이진 타입 비교

| 타입 | 길이 | 용도 |
|------|------|------|
| BINARY(n) | 고정 n바이트 | 해시값, 고정 크기 식별자 |
| VARBINARY(n) | 가변, 최대 n바이트 | 소규모 이진 데이터 |
| BLOB(n) | 대용량 | 파일, 이미지, 멀티미디어 |

---

## 10. 향상된 ALTER 문

SQL:2008은 ALTER TABLE 구문을 확장하여 테이블 구조 변경에 더 세밀한 제어를 제공한다.

### 10.1 컬럼 추가/삭제/변경

```sql
-- 컬럼 추가
ALTER TABLE 직원 ADD COLUMN 입사일 DATE DEFAULT CURRENT_DATE;

-- 여러 컬럼 동시 추가
ALTER TABLE 직원
  ADD COLUMN 퇴사일 DATE,
  ADD COLUMN 퇴사사유 VARCHAR(200);

-- 컬럼 삭제
ALTER TABLE 직원 DROP COLUMN 퇴사사유 CASCADE;
ALTER TABLE 직원 DROP COLUMN 퇴사사유 RESTRICT;
-- RESTRICT: 다른 객체가 참조하면 실패 (기본값)
-- CASCADE: 의존하는 객체(뷰, 제약 등)도 함께 삭제

-- 컬럼 기본값 변경
ALTER TABLE 직원 ALTER COLUMN 급여 SET DEFAULT 0;
ALTER TABLE 직원 ALTER COLUMN 급여 DROP DEFAULT;

-- NOT NULL 제약 추가/삭제
ALTER TABLE 직원 ALTER COLUMN 이메일 SET NOT NULL;
ALTER TABLE 직원 ALTER COLUMN 이메일 DROP NOT NULL;

-- 컬럼 데이터 타입 변경
ALTER TABLE 직원 ALTER COLUMN 전화번호 SET DATA TYPE VARCHAR(20);
```

### 10.2 제약 조건 추가/삭제

```sql
-- 제약 조건 추가
ALTER TABLE 직원
  ADD CONSTRAINT chk_급여양수 CHECK (급여 >= 0);

ALTER TABLE 주문
  ADD CONSTRAINT fk_주문_고객
    FOREIGN KEY (고객번호) REFERENCES 고객(고객번호)
    ON DELETE CASCADE
    ON UPDATE CASCADE;

ALTER TABLE 제품
  ADD CONSTRAINT uq_제품코드 UNIQUE (제품코드);

-- 제약 조건 삭제
ALTER TABLE 직원 DROP CONSTRAINT chk_급여양수 CASCADE;
ALTER TABLE 직원 DROP CONSTRAINT chk_급여양수 RESTRICT;
```

### 10.3 IDENTITY 컬럼 변경

```sql
-- IDENTITY 속성 추가
ALTER TABLE 주문 ALTER COLUMN 주문번호
  ADD GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1);

-- IDENTITY 재시작
ALTER TABLE 주문 ALTER COLUMN 주문번호 RESTART WITH 10000;

-- IDENTITY 속성 삭제
ALTER TABLE 주문 ALTER COLUMN 주문번호 DROP IDENTITY;
```

---

## 11. 향상된 진단 관리

SQL:2008은 GET DIAGNOSTICS 문을 확장하여 더 상세한 오류 및 상태 정보를 조회할 수 있게 했다.

### 11.1 GET DIAGNOSTICS 기본 구문

```sql
-- 문장 수준 진단 정보 조회
GET DIAGNOSTICS
    :행수 = ROW_COUNT,
    :추가상태수 = NUMBER;

-- ROW_COUNT: 직전 SQL 문이 영향을 미친 행 수
-- NUMBER: 조건(condition) 영역의 수
```

### 11.2 조건 영역 조회

```sql
-- 조건 영역에서 상세 정보 조회
GET DIAGNOSTICS CONDITION 1
    :상태코드 = RETURNED_SQLSTATE,
    :메시지 = MESSAGE_TEXT,
    :메시지길이 = MESSAGE_LENGTH,
    :메시지옥텟길이 = MESSAGE_OCTET_LENGTH;
```

### 11.3 SQL:2008 확장 진단 항목

```sql
-- SQL:2008에서 추가된 진단 항목들
GET DIAGNOSTICS CONDITION 1
    :상태코드       = RETURNED_SQLSTATE,
    :메시지         = MESSAGE_TEXT,
    :클래스원본     = CLASS_ORIGIN,
    :서브클래스원본 = SUBCLASS_ORIGIN,
    :제약카탈로그   = CONSTRAINT_CATALOG,
    :제약스키마     = CONSTRAINT_SCHEMA,
    :제약이름       = CONSTRAINT_NAME,
    :카탈로그이름   = CATALOG_NAME,
    :스키마이름     = SCHEMA_NAME,
    :테이블이름     = TABLE_NAME,
    :컬럼이름       = COLUMN_NAME,
    :커서이름       = CURSOR_NAME,
    :연결이름       = CONNECTION_NAME;
```

### 11.4 예외 처리에서 GET DIAGNOSTICS 사용

```sql
-- 프로시저 내에서 진단 정보 활용
CREATE PROCEDURE 안전한_업데이트(IN p_직원번호 INTEGER, IN p_급여 INTEGER)
BEGIN
    DECLARE v_행수 INTEGER;
    DECLARE v_상태코드 CHAR(5);
    DECLARE v_메시지 VARCHAR(256);

    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            v_상태코드 = RETURNED_SQLSTATE,
            v_메시지   = MESSAGE_TEXT;

        INSERT INTO 오류로그 (발생시각, 상태코드, 메시지)
        VALUES (CURRENT_TIMESTAMP, v_상태코드, v_메시지);
    END;

    UPDATE 직원 SET 급여 = p_급여 WHERE 직원번호 = p_직원번호;

    GET DIAGNOSTICS v_행수 = ROW_COUNT;

    IF v_행수 = 0 THEN
        SIGNAL SQLSTATE '02000'
            SET MESSAGE_TEXT = '해당 직원이 존재하지 않습니다';
    END IF;
END;
```

### 11.5 STACKED DIAGNOSTICS

```sql
-- 핸들러 내부에서 원래 예외 정보 조회
CREATE PROCEDURE 일괄처리()
BEGIN
    DECLARE v_상태 CHAR(5);
    DECLARE v_메시지 VARCHAR(256);

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- STACKED: 핸들러 진입 시점의 진단 영역을 조회
        GET STACKED DIAGNOSTICS CONDITION 1
            v_상태  = RETURNED_SQLSTATE,
            v_메시지 = MESSAGE_TEXT;

        INSERT INTO 오류로그 (상태코드, 메시지, 발생시각)
        VALUES (v_상태, v_메시지, CURRENT_TIMESTAMP);

        RESIGNAL;
    END;

    -- 일괄 처리 로직
    UPDATE 직원 SET 급여 = 급여 * 1.1 WHERE 부서코드 = 'D001';
    UPDATE 직원 SET 급여 = 급여 * 1.05 WHERE 부서코드 = 'D002';
END;
```

### 진단 항목 요약

| 항목 | 수준 | 설명 |
|------|------|------|
| ROW_COUNT | 문장 | 영향 받은 행 수 |
| NUMBER | 문장 | 조건 영역 수 |
| RETURNED_SQLSTATE | 조건 | 5자리 SQLSTATE 코드 |
| MESSAGE_TEXT | 조건 | 오류/경고 메시지 |
| CLASS_ORIGIN | 조건 | SQLSTATE 클래스 출처 |
| SUBCLASS_ORIGIN | 조건 | SQLSTATE 서브클래스 출처 |
| CONSTRAINT_NAME | 조건 | 위반된 제약 조건 이름 |
| TABLE_NAME | 조건 | 관련 테이블 이름 |
| COLUMN_NAME | 조건 | 관련 컬럼 이름 |
| CURSOR_NAME | 조건 | 관련 커서 이름 |
| CONNECTION_NAME | 조건 | 관련 연결 이름 |

---

## 12. CALL 문 개선

SQL:2008은 프로시저 호출 구문을 확장했다.

### 12.1 기본 CALL 구문

```sql
-- 프로시저 호출
CALL 급여인상_처리('D001', 10);

-- OUT 매개변수 사용
CALL 부서통계_조회('D001', :직원수, :평균급여, :최대급여);
```

### 12.2 INOUT 매개변수

```sql
-- INOUT 매개변수를 가진 프로시저 정의
CREATE PROCEDURE 세금계산(INOUT p_금액 DECIMAL(15,2), IN p_세율 DECIMAL(5,2))
BEGIN
    SET p_금액 = p_금액 * (1 - p_세율 / 100);
END;

-- INOUT 매개변수로 호출
SET :금액 = 1000000;
CALL 세금계산(:금액, 3.3);
-- :금액에 세후 금액이 반환됨
```

### 12.3 프로시저 내부에서 다른 프로시저 호출

```sql
-- 중첩 프로시저 호출
CREATE PROCEDURE 직원_퇴사처리(IN p_직원번호 INTEGER)
BEGIN
    DECLARE v_부서코드 CHAR(4);

    SELECT 부서코드 INTO v_부서코드
    FROM 직원 WHERE 직원번호 = p_직원번호;

    -- 다른 프로시저 호출
    CALL 퇴직금_계산(p_직원번호);
    CALL 장비_반납처리(p_직원번호);
    CALL 부서인원_갱신(v_부서코드);

    UPDATE 직원
    SET 퇴사일 = CURRENT_DATE, 상태 = '퇴사'
    WHERE 직원번호 = p_직원번호;
END;
```

### 12.4 동적 CALL

```sql
-- 동적 SQL로 프로시저 호출
CREATE PROCEDURE 동적_프로시저호출(IN p_프로시저명 VARCHAR(128), IN p_매개변수 VARCHAR(500))
BEGIN
    DECLARE v_sql VARCHAR(1000);
    SET v_sql = 'CALL ' || p_프로시저명 || '(' || p_매개변수 || ')';
    EXECUTE IMMEDIATE v_sql;
END;
```

---

## 13. 향상된 GRANT / REVOKE

SQL:2008은 권한 부여와 회수 구문을 개선하여 더 세밀한 권한 제어를 가능하게 했다.

### 13.1 기본 GRANT / REVOKE

```sql
-- 테이블에 대한 권한 부여
GRANT SELECT, INSERT, UPDATE ON 직원 TO 인사담당자;
GRANT DELETE ON 직원 TO 인사관리자;

-- 특정 컬럼에 대한 권한
GRANT SELECT (이름, 부서코드) ON 직원 TO 일반사용자;
GRANT UPDATE (급여, 직급) ON 직원 TO 인사담당자;

-- 권한 회수
REVOKE INSERT ON 직원 FROM 인사담당자 CASCADE;
REVOKE INSERT ON 직원 FROM 인사담당자 RESTRICT;
```

### 13.2 GRANT OPTION

```sql
-- WITH GRANT OPTION: 권한을 타인에게 재부여할 수 있는 권한 포함
GRANT SELECT, INSERT ON 주문 TO 영업팀장 WITH GRANT OPTION;

-- 영업팀장이 다시 부여 가능
-- (영업팀장 세션에서)
GRANT SELECT ON 주문 TO 영업사원;

-- GRANT OPTION만 회수 (기본 권한은 유지)
REVOKE GRANT OPTION FOR SELECT ON 주문 FROM 영업팀장 CASCADE;
```

### 13.3 역할(ROLE) 기반 권한 관리

```sql
-- 역할 생성
CREATE ROLE 인사관리역할;
CREATE ROLE 영업역할;
CREATE ROLE 조회전용역할;

-- 역할에 권한 부여
GRANT SELECT, INSERT, UPDATE, DELETE ON 직원 TO 인사관리역할;
GRANT SELECT, INSERT ON 주문 TO 영업역할;
GRANT SELECT ON 직원 TO 조회전용역할;
GRANT SELECT ON 부서 TO 조회전용역할;

-- 사용자에게 역할 부여
GRANT 인사관리역할 TO 김인사;
GRANT 영업역할 TO 이영업;
GRANT 조회전용역할 TO 박조회;

-- 역할에 역할 부여 (중첩)
GRANT 조회전용역할 TO 영업역할;

-- 역할 회수
REVOKE 인사관리역할 FROM 김인사;

-- 역할 삭제
DROP ROLE 조회전용역할;
```

### 13.4 프로시저/함수에 대한 EXECUTE 권한

```sql
-- 프로시저 실행 권한
GRANT EXECUTE ON PROCEDURE 급여인상_처리 TO 인사관리역할;
GRANT EXECUTE ON FUNCTION 세금계산 TO 영업역할;

-- 실행 권한 회수
REVOKE EXECUTE ON PROCEDURE 급여인상_처리 FROM 인사관리역할 CASCADE;
```

### 13.5 스키마 수준 권한

```sql
-- 스키마 내 모든 테이블에 대한 권한
GRANT SELECT ON ALL TABLES IN SCHEMA 인사 TO 조회전용역할;

-- USAGE 권한 (시퀀스, 도메인, 사용자 정의 타입 등)
GRANT USAGE ON SEQUENCE 주문번호_seq TO 영업역할;
GRANT USAGE ON DOMAIN 이메일_도메인 TO PUBLIC;
GRANT USAGE ON TYPE 주소_타입 TO 인사관리역할;
```

---

## 14. 개선된 뷰 관련 구문

SQL:2008은 뷰의 갱신 제어와 관련된 CHECK OPTION 등을 확장했다.

### 14.1 WITH CHECK OPTION

```sql
-- LOCAL CHECK OPTION
CREATE VIEW 활성직원_뷰 AS
    SELECT * FROM 직원
    WHERE 상태 = '재직'
WITH LOCAL CHECK OPTION;
-- 이 뷰를 통해 INSERT/UPDATE할 때 상태 = '재직' 조건을 만족해야 한다
-- LOCAL: 현재 뷰의 조건만 검사

-- CASCADED CHECK OPTION (기본값)
CREATE VIEW 고급여활성직원_뷰 AS
    SELECT * FROM 활성직원_뷰
    WHERE 급여 >= 5000000
WITH CASCADED CHECK OPTION;
-- CASCADED: 현재 뷰 + 기반 뷰의 조건 모두 검사
-- 이 뷰를 통한 INSERT 시: 상태 = '재직' AND 급여 >= 5000000 모두 만족해야 함

-- CHECK OPTION 위반 시 오류 발생
INSERT INTO 고급여활성직원_뷰 (직원번호, 이름, 급여, 상태)
VALUES (301, '테스트', 3000000, '재직');
-- 오류: 급여 < 5000000이므로 CHECK OPTION 위반

INSERT INTO 고급여활성직원_뷰 (직원번호, 이름, 급여, 상태)
VALUES (302, '테스트', 6000000, '퇴사');
-- 오류: CASCADED이므로 기반 뷰의 상태 = '재직' 조건도 위반
```

### 14.2 LOCAL vs CASCADED 차이

```sql
-- 기반 뷰
CREATE VIEW 뷰A AS
    SELECT * FROM 직원 WHERE 부서코드 = 'D001';
-- CHECK OPTION 없음

-- LOCAL CHECK OPTION 뷰
CREATE VIEW 뷰B_LOCAL AS
    SELECT * FROM 뷰A WHERE 급여 >= 3000000
WITH LOCAL CHECK OPTION;

-- CASCADED CHECK OPTION 뷰
CREATE VIEW 뷰C_CASCADED AS
    SELECT * FROM 뷰A WHERE 급여 >= 3000000
WITH CASCADED CHECK OPTION;

-- 뷰B_LOCAL을 통한 INSERT (부서코드 = 'D002')
INSERT INTO 뷰B_LOCAL (직원번호, 이름, 급여, 부서코드)
VALUES (401, '김직원', 4000000, 'D002');
-- LOCAL: 자신의 조건(급여 >= 3000000)만 검사 → 성공
-- 뷰A의 조건(부서코드 = 'D001')은 검사하지 않음

-- 뷰C_CASCADED를 통한 INSERT (부서코드 = 'D002')
INSERT INTO 뷰C_CASCADED (직원번호, 이름, 급여, 부서코드)
VALUES (402, '박직원', 4000000, 'D002');
-- CASCADED: 뷰A의 조건까지 검사 → 오류 (부서코드 <> 'D001')
```

### 14.3 갱신 가능 뷰의 조건

```sql
-- 갱신 가능 뷰: 단일 테이블, 집계/DISTINCT/GROUP BY 없음
CREATE VIEW 부서D001직원 AS
    SELECT 직원번호, 이름, 급여
    FROM 직원
    WHERE 부서코드 = 'D001'
WITH CASCADED CHECK OPTION;

-- 이 뷰를 통한 DML 가능
INSERT INTO 부서D001직원 (직원번호, 이름, 급여)
VALUES (501, '신규직원', 3500000);
-- 기반 테이블에 INSERT됨 (부서코드는 NULL 또는 기본값)
-- CHECK OPTION은 WHERE 절 조건만 검사

UPDATE 부서D001직원 SET 급여 = 급여 * 1.1
WHERE 직원번호 = 501;

DELETE FROM 부서D001직원 WHERE 직원번호 = 501;
```

### LOCAL vs CASCADED 비교표

| 항목 | LOCAL | CASCADED (기본) |
|------|-------|-----------------|
| 자기 뷰 조건 검사 | O | O |
| 기반 뷰 조건 검사 | CHECK OPTION 있는 뷰만 | 모든 기반 뷰 |
| 누락 가능성 | 있음 | 없음 |

---

## 15. 기타 변경사항

### 15.1 ORDER BY 서브쿼리 허용

```sql
-- 서브쿼리에서 ORDER BY 허용
SELECT 부서코드,
       (SELECT 이름 FROM 직원 e
        WHERE e.부서코드 = d.부서코드
        ORDER BY 급여 DESC
        FETCH FIRST 1 ROW ONLY) AS 최고급여직원
FROM 부서 d;
```

### 15.2 CASE 표현식 향상

```sql
-- 약식 CASE (한계 기능)
-- COALESCE와 NULLIF 외에 추가적인 표현식 축약
```

### 15.3 집계 함수 개선

```sql
-- PERCENTILE_CONT: 연속 백분위수
SELECT
    부서코드,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY 급여) AS 급여중앙값
FROM 직원
GROUP BY 부서코드;

-- PERCENTILE_DISC: 이산 백분위수
SELECT
    부서코드,
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY 급여) AS 급여중앙값
FROM 직원
GROUP BY 부서코드;
```

### 15.4 커서 개선

```sql
-- 민감도 옵션 확장
DECLARE 커서1 ASENSITIVE SCROLL CURSOR FOR
    SELECT * FROM 직원;
-- ASENSITIVE: 구현이 민감/비민감 중 선택 가능
```

---

> 참고: SQL:2008 표준은 ISO/IEC 9075:2008 시리즈로 발행되었다.
