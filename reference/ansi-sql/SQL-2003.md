# SQL:2003 표준 완벽 가이드

## ISO/IEC 9075:2003 — Database Language SQL

---

## 목차

1. [개요](#1-개요)
2. [파트 구조](#2-파트-구조)
3. [윈도우 함수](#3-윈도우-함수)
4. [MERGE 문](#4-merge-문)
5. [시퀀스](#5-시퀀스)
6. [자동 생성 컬럼](#6-자동-생성-컬럼)
7. [생성 컬럼 (Generated Column)](#7-생성-컬럼-generated-column)
8. [SQL/XML](#8-sqlxml)
9. [새로운 데이터 타입](#9-새로운-데이터-타입)
10. [MULTISET 연산 상세](#10-multiset-연산-상세)
11. [TABLESAMPLE](#11-tablesample)
12. [배열 개선](#12-배열-개선)
13. [WINDOW 절 (Named Window)](#13-window-절-named-window)
14. [PERCENT_RANK / CUME_DIST](#14-percent_rank--cume_dist)
15. [FILTER 절](#15-filter-절)
16. [ROW 타입 개선](#16-row-타입-개선)
17. [명시적 타입 테이블 (Typed Table)](#17-명시적-타입-테이블-typed-table)

---

## 1. 개요

SQL:2003(공식명: ISO/IEC 9075:2003)은 SQL:1999를 계승한 표준으로, 윈도우 함수(Window Functions), MERGE 문, 시퀀스(Sequence), SQL/XML 등 현대 SQL의 핵심 기능을 대거 도입했다.

### 주요 특징 요약

| 항목 | 내용 |
|------|------|
| 공식 명칭 | ISO/IEC 9075:2003 |
| 발표 연도 | 2003년 |
| 이전 표준 | SQL:1999 |
| 다음 표준 | SQL:2006 |
| 핵심 추가 기능 | 윈도우 함수, MERGE, 시퀀스, SQL/XML, BIGINT |
| 신규 파트 | Part 14: SQL/XML |

---

## 2. 파트 구조

| 파트 | 명칭 | 설명 |
|------|------|------|
| Part 1 | SQL/Framework | 전체 프레임워크 |
| Part 2 | SQL/Foundation | 핵심 SQL 기능 |
| Part 3 | SQL/CLI | Call-Level Interface |
| Part 4 | SQL/PSM | Persistent Stored Modules |
| Part 9 | SQL/MED | Management of External Data |
| Part 10 | SQL/OLB | Object Language Bindings |
| Part 11 | SQL/Schemata | Information and Definition Schemas |
| Part 13 | SQL/JRT | Java Routines and Types |
| Part 14 | SQL/XML | XML 관련 기능 (신규) |

---

## 3. 윈도우 함수

SQL:2003의 가장 중요한 기능 추가. 행 집합에 대한 계산을 각 행에 대해 수행하면서도 GROUP BY처럼 행을 축소하지 않는다.

### 3.1 기본 구문

```sql
함수이름(...) OVER (
    [PARTITION BY 파티션_컬럼, ...]
    [ORDER BY 정렬_컬럼 [ASC|DESC], ...]
    [프레임_절]
)
```

### 3.2 순위 함수

#### ROW_NUMBER

```sql
-- 각 행에 고유 순번 부여
SELECT
    ROW_NUMBER() OVER (ORDER BY 급여 DESC) AS 순번,
    이름, 급여
FROM 직원;

-- 부서별 순번
SELECT
    부서코드,
    ROW_NUMBER() OVER (PARTITION BY 부서코드 ORDER BY 급여 DESC) AS 부서내순번,
    이름, 급여
FROM 직원;
```

#### RANK

```sql
-- 동일 값에 같은 순위, 다음 순위 건너뜀
SELECT
    RANK() OVER (ORDER BY 급여 DESC) AS 순위,
    이름, 급여
FROM 직원;

-- 결과 (동점 있을 때):
-- 순위 | 이름   | 급여
-- 1    | 김개발 | 5000000
-- 2    | 이영업 | 4500000
-- 2    | 최기획 | 4500000
-- 4    | 박인사 | 4000000    ← 3이 아닌 4
```

#### DENSE_RANK

```sql
-- 동일 값에 같은 순위, 다음 순위 연속
SELECT
    DENSE_RANK() OVER (ORDER BY 급여 DESC) AS 밀집순위,
    이름, 급여
FROM 직원;

-- 결과:
-- 밀집순위 | 이름   | 급여
-- 1        | 김개발 | 5000000
-- 2        | 이영업 | 4500000
-- 2        | 최기획 | 4500000
-- 3        | 박인사 | 4000000    ← 3 (연속)
```

#### NTILE

```sql
-- n개 그룹으로 균등 분할
SELECT
    NTILE(4) OVER (ORDER BY 급여 DESC) AS 분위,
    이름, 급여
FROM 직원;
```

### 순위 함수 비교

| 함수 | 동점 처리 | 결과 예 (값: 100, 90, 90, 80) |
|------|-----------|------|
| ROW_NUMBER | 고유 순번 | 1, 2, 3, 4 |
| RANK | 동점=동순위, 건너뜀 | 1, 2, 2, 4 |
| DENSE_RANK | 동점=동순위, 연속 | 1, 2, 2, 3 |
| NTILE(2) | n등분 | 1, 1, 2, 2 |

### 3.3 오프셋 함수

#### LAG / LEAD

```sql
-- LAG: 이전 행의 값 참조
SELECT
    이름, 급여,
    LAG(급여) OVER (ORDER BY 급여 DESC) AS 이전급여,
    LAG(급여, 2) OVER (ORDER BY 급여 DESC) AS 두행전급여,
    LAG(급여, 1, 0) OVER (ORDER BY 급여 DESC) AS 이전급여_기본값0
FROM 직원;

-- LEAD: 다음 행의 값 참조
SELECT
    이름, 급여,
    LEAD(급여) OVER (ORDER BY 급여 DESC) AS 다음급여,
    급여 - LEAD(급여) OVER (ORDER BY 급여 DESC) AS 급여차이
FROM 직원;

-- 전월 대비 매출 비교
SELECT
    연월, 매출,
    LAG(매출) OVER (ORDER BY 연월) AS 전월매출,
    매출 - LAG(매출) OVER (ORDER BY 연월) AS 증감,
    CASE
        WHEN LAG(매출) OVER (ORDER BY 연월) IS NOT NULL
        THEN CAST((매출 - LAG(매출) OVER (ORDER BY 연월)) * 100.0
             / LAG(매출) OVER (ORDER BY 연월) AS DECIMAL(5,2))
    END AS 증감율
FROM 월별매출;
```

#### FIRST_VALUE / LAST_VALUE

```sql
-- FIRST_VALUE: 윈도우 내 첫 번째 값
SELECT
    이름, 부서코드, 급여,
    FIRST_VALUE(이름) OVER (
        PARTITION BY 부서코드 ORDER BY 급여 DESC
    ) AS 부서최고급여자
FROM 직원;

-- LAST_VALUE: 프레임을 명시해야 정확한 결과
SELECT
    이름, 부서코드, 급여,
    LAST_VALUE(이름) OVER (
        PARTITION BY 부서코드 ORDER BY 급여 DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 부서최저급여자
FROM 직원;
```

### 3.4 집계 윈도우 함수

```sql
SELECT
    이름, 부서코드, 급여,
    SUM(급여) OVER (PARTITION BY 부서코드) AS 부서급여합계,
    AVG(급여) OVER (PARTITION BY 부서코드) AS 부서평균급여,
    COUNT(*) OVER (PARTITION BY 부서코드) AS 부서인원,
    MAX(급여) OVER (PARTITION BY 부서코드) AS 부서최고급여,
    MIN(급여) OVER (PARTITION BY 부서코드) AS 부서최저급여
FROM 직원;

-- 누적 합계
SELECT 연월, 매출,
    SUM(매출) OVER (ORDER BY 연월) AS 누적매출
FROM 월별매출;

-- 이동 평균 (3개월)
SELECT 연월, 매출,
    AVG(매출) OVER (
        ORDER BY 연월
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS 이동평균_3개월
FROM 월별매출;
```

### 3.5 프레임 절 (Frame Clause)

```sql
-- 프레임 경계 옵션:
-- UNBOUNDED PRECEDING  : 파티션의 첫 행
-- n PRECEDING          : 현재 행의 n행 이전
-- CURRENT ROW          : 현재 행
-- n FOLLOWING          : 현재 행의 n행 이후
-- UNBOUNDED FOLLOWING  : 파티션의 마지막 행

-- 전후 1행 포함 (3행 이동 평균)
SELECT 연월, 매출,
    AVG(매출) OVER (
        ORDER BY 연월
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS 이동평균
FROM 월별매출;

-- 처음부터 현재 행까지 (누적)
SELECT 연월, 매출,
    SUM(매출) OVER (
        ORDER BY 연월
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS 누적매출
FROM 월별매출;

-- 현재 행부터 끝까지
SELECT 연월, 매출,
    SUM(매출) OVER (
        ORDER BY 연월
        ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
    ) AS 남은기간매출합
FROM 월별매출;

-- 전체 파티션 (비율 계산)
SELECT 이름, 급여,
    급여 * 100.0 / SUM(급여) OVER (
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS 급여비율
FROM 직원;
```

### ROWS vs RANGE 비교

| 구분 | ROWS | RANGE |
|------|------|-------|
| 기준 | 물리적 행 수 | 논리적 값 범위 |
| 동점 처리 | 각 행 개별 처리 | 동일 값 행을 묶어 처리 |
| 예시 | ROWS 2 PRECEDING | RANGE 1000 PRECEDING |

---

## 4. MERGE 문

하나의 문장으로 INSERT, UPDATE, DELETE를 조건에 따라 수행한다 (UPSERT).

```sql
-- 기본 MERGE
MERGE INTO 대상테이블 AS t
USING 원본테이블 AS s
ON t.키컬럼 = s.키컬럼
WHEN MATCHED THEN
    UPDATE SET t.컬럼1 = s.컬럼1, t.컬럼2 = s.컬럼2
WHEN NOT MATCHED THEN
    INSERT (키컬럼, 컬럼1, 컬럼2)
    VALUES (s.키컬럼, s.컬럼1, s.컬럼2);

-- 실제 예: 재고 업데이트
MERGE INTO 재고 AS inv
USING 입고내역 AS rcv
ON inv.제품코드 = rcv.제품코드
WHEN MATCHED THEN
    UPDATE SET
        inv.수량 = inv.수량 + rcv.입고수량,
        inv.최종입고일 = rcv.입고일
WHEN NOT MATCHED THEN
    INSERT (제품코드, 수량, 최종입고일)
    VALUES (rcv.제품코드, rcv.입고수량, rcv.입고일);

-- 서브쿼리를 원본으로 사용
MERGE INTO 월별실적 AS t
USING (
    SELECT 부서코드, SUM(매출) AS 총매출
    FROM 일별매출
    WHERE 연월 = '2024-01'
    GROUP BY 부서코드
) AS s
ON t.부서코드 = s.부서코드 AND t.연월 = '2024-01'
WHEN MATCHED THEN
    UPDATE SET t.매출 = s.총매출
WHEN NOT MATCHED THEN
    INSERT (부서코드, 연월, 매출)
    VALUES (s.부서코드, '2024-01', s.총매출);
```

---

## 5. 시퀀스

### 5.1 CREATE SEQUENCE

```sql
-- 기본 시퀀스
CREATE SEQUENCE 직원번호_seq
    START WITH 1
    INCREMENT BY 1;

-- 상세 옵션
CREATE SEQUENCE 주문번호_seq
    AS INTEGER
    START WITH 10000
    INCREMENT BY 1
    MINVALUE 10000
    MAXVALUE 99999
    NO CYCLE
    CACHE 20;

-- 순환 시퀀스
CREATE SEQUENCE 일련번호_seq
    START WITH 1
    INCREMENT BY 1
    MAXVALUE 999
    CYCLE;

-- 역순 시퀀스
CREATE SEQUENCE 역순_seq
    START WITH 1000
    INCREMENT BY -1
    MINVALUE 1;
```

### 5.2 NEXT VALUE FOR

```sql
-- INSERT에서 시퀀스 사용
INSERT INTO 직원 (직원번호, 이름, 부서코드, 급여)
VALUES (NEXT VALUE FOR 직원번호_seq, '김신입', 'D001', 3500000);

-- SELECT에서 사용
SELECT NEXT VALUE FOR 주문번호_seq AS 새주문번호;

-- 시퀀스 변경 및 삭제
ALTER SEQUENCE 직원번호_seq RESTART WITH 500 INCREMENT BY 2;
DROP SEQUENCE 직원번호_seq;
```

---

## 6. 자동 생성 컬럼

### 6.1 IDENTITY 컬럼

```sql
-- GENERATED ALWAYS: 항상 자동 생성 (수동 입력 불가)
CREATE TABLE 주문 (
    주문번호    INTEGER GENERATED ALWAYS AS IDENTITY
                  (START WITH 1 INCREMENT BY 1),
    고객번호    INTEGER NOT NULL,
    주문일      DATE NOT NULL,
    PRIMARY KEY (주문번호)
);

INSERT INTO 주문 (고객번호, 주문일) VALUES (101, DATE '2024-01-15');

-- GENERATED BY DEFAULT: 기본 자동 생성 (수동 입력 가능)
CREATE TABLE 로그 (
    로그번호    INTEGER GENERATED BY DEFAULT AS IDENTITY
                  (START WITH 1000 INCREMENT BY 1),
    메시지      VARCHAR(500),
    발생시각    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO 로그 (메시지) VALUES ('자동 번호 할당');
INSERT INTO 로그 (로그번호, 메시지) VALUES (9999, '수동 번호 지정');
```

### GENERATED ALWAYS vs GENERATED BY DEFAULT

| 속성 | ALWAYS | BY DEFAULT |
|------|--------|------------|
| 자동 생성 | 항상 | 값 미지정 시 |
| 수동 입력 | 불가 | 가능 |
| 중복 위험 | 없음 | 수동 입력 시 가능 |
| 사용 사례 | 절대 변경 불가 PK | 마이그레이션 대비 PK |

---

## 7. 생성 컬럼 (Generated Column)

GENERATED ALWAYS AS (표현식) 구문으로, 다른 컬럼 값에서 자동 계산되는 컬럼을 정의한다.

### 7.1 기본 구문

```sql
CREATE TABLE 주문항목 (
    주문항목번호 INTEGER PRIMARY KEY,
    수량         INTEGER,
    단가         DECIMAL(10,2),
    금액         DECIMAL(10,2) GENERATED ALWAYS AS (수량 * 단가)
);

INSERT INTO 주문항목 (주문항목번호, 수량, 단가) VALUES (1, 5, 12000.00);
-- 금액은 자동으로 60000.00이 된다
```

### 7.2 다양한 표현식

```sql
CREATE TABLE 직원정보 (
    직원번호    INTEGER PRIMARY KEY,
    성          VARCHAR(20),
    이름        VARCHAR(20),
    전체이름    VARCHAR(41) GENERATED ALWAYS AS (성 || ' ' || 이름),
    기본급      DECIMAL(10,2),
    수당비율    DECIMAL(3,2),
    총급여      DECIMAL(10,2) GENERATED ALWAYS AS (기본급 * (1 + 수당비율))
);

CREATE TABLE 원 (
    원번호  INTEGER PRIMARY KEY,
    반지름  DOUBLE PRECISION,
    넓이    DOUBLE PRECISION GENERATED ALWAYS AS (3.141592653589793 * 반지름 * 반지름),
    둘레    DOUBLE PRECISION GENERATED ALWAYS AS (2 * 3.141592653589793 * 반지름)
);
```

---

## 8. SQL/XML

SQL:2003에서 Part 14로 XML 지원이 처음 도입되었다.

### 8.1 XMLELEMENT

```sql
SELECT XMLELEMENT(NAME "직원",
    XMLATTRIBUTES(직원번호 AS "id"),
    XMLELEMENT(NAME "이름", 이름),
    XMLELEMENT(NAME "급여", 급여)
) AS 직원xml
FROM 직원;
-- 결과: <직원 id="101"><이름>김개발</이름><급여>5000000</급여></직원>
```

### 8.2 XMLFOREST

```sql
SELECT XMLELEMENT(NAME "직원",
    XMLFOREST(이름, 부서코드, 급여)
) AS 직원xml
FROM 직원;
-- 결과: <직원><이름>김개발</이름><부서코드>D001</부서코드><급여>5000000</급여></직원>
```

### 8.3 XMLAGG

```sql
SELECT XMLELEMENT(NAME "부서",
    XMLATTRIBUTES(부서코드 AS "코드"),
    XMLAGG(XMLELEMENT(NAME "직원", 이름) ORDER BY 이름)
) AS 부서xml
FROM 직원
GROUP BY 부서코드;
```

### 8.4 XMLPARSE / XMLSERIALIZE

```sql
SELECT XMLPARSE(DOCUMENT '<직원><이름>홍길동</이름></직원>') AS xml문서;
SELECT XMLPARSE(CONTENT '<이름>홍길동</이름>') AS xml내용;

SELECT XMLSERIALIZE(DOCUMENT xml컬럼 AS VARCHAR(1000)) AS xml문자열
FROM xml테이블;
```

### 8.5 XMLCONCAT

여러 XML 값을 하나로 연결한다.

```sql
-- 두 개의 XMLELEMENT를 연결
SELECT XMLCONCAT(
    XMLELEMENT(NAME "이름", 이름),
    XMLELEMENT(NAME "급여", 급여)
) AS xml결과
FROM 직원;
-- 결과: <이름>김개발</이름><급여>5000000</급여>

-- 여러 XML 조각을 연결
SELECT XMLCONCAT(
    XMLELEMENT(NAME "부서", 부서코드),
    XMLELEMENT(NAME "직급", 직급),
    XMLELEMENT(NAME "이름", 이름)
) AS xml결과
FROM 직원
WHERE 부서코드 = 'D001';

-- XMLELEMENT와 조합하여 루트 요소 감싸기
SELECT XMLELEMENT(NAME "직원정보",
    XMLCONCAT(
        XMLELEMENT(NAME "이름", 이름),
        XMLELEMENT(NAME "부서", 부서코드),
        XMLELEMENT(NAME "급여", 급여)
    )
) AS xml결과
FROM 직원;
```

---

## 9. 새로운 데이터 타입

### 9.1 BIGINT

```sql
CREATE TABLE 대용량데이터 (
    레코드번호  BIGINT PRIMARY KEY,
    조회수      BIGINT DEFAULT 0
);
-- 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
```

### 9.2 MULTISET

```sql
CREATE TABLE 학생 (
    학번        INTEGER PRIMARY KEY,
    이름        VARCHAR(50),
    수강과목    VARCHAR(30) MULTISET
);
```

---

## 10. MULTISET 연산 상세

MULTISET은 중복을 허용하는 비순서 컬렉션 타입이다.

### 10.1 MULTISET UNION

두 멀티셋의 합집합을 구한다. 중복 요소가 모두 유지된다.

```sql
-- MULTISET UNION ALL: 중복 포함 합집합
SELECT 수강과목 MULTISET UNION ALL 추가과목 AS 전체과목
FROM 학생;

-- MULTISET UNION DISTINCT: 중복 제거 합집합
SELECT 수강과목 MULTISET UNION DISTINCT 추가과목 AS 전체과목
FROM 학생;
```

### 10.2 MULTISET INTERSECT

두 멀티셋의 교집합을 구한다.

```sql
-- MULTISET INTERSECT ALL: 중복 포함 교집합
SELECT 수강과목 MULTISET INTERSECT ALL 필수과목 AS 이수필수과목
FROM 학생;

-- MULTISET INTERSECT DISTINCT: 중복 제거 교집합
SELECT 수강과목 MULTISET INTERSECT DISTINCT 필수과목 AS 이수필수과목
FROM 학생;
```

### 10.3 MULTISET EXCEPT

첫 번째 멀티셋에서 두 번째 멀티셋의 요소를 제거한다.

```sql
-- MULTISET EXCEPT ALL: 중복 포함 차집합
SELECT 수강과목 MULTISET EXCEPT ALL 면제과목 AS 남은과목
FROM 학생;

-- MULTISET EXCEPT DISTINCT: 중복 제거 차집합
SELECT 수강과목 MULTISET EXCEPT DISTINCT 면제과목 AS 남은과목
FROM 학생;
```

### 10.4 ELEMENT

멀티셋에 요소가 정확히 하나일 때, 그 단일 요소를 스칼라 값으로 추출한다.

```sql
SELECT ELEMENT(
    MULTISET(SELECT 부서명 FROM 부서 WHERE 부서코드 = 'D001')
) AS 부서명
FROM 직원
WHERE 부서코드 = 'D001';
```

### 10.5 SET

멀티셋에서 중복 요소를 제거하여 고유한 요소만 남긴다.

```sql
SELECT SET(수강과목) AS 고유과목
FROM 학생;
```

### 10.6 CARDINALITY

멀티셋의 요소 수를 반환한다.

```sql
SELECT 이름, CARDINALITY(수강과목) AS 수강과목수
FROM 학생;

-- SET과 조합하여 고유 요소 수 확인
SELECT 이름, CARDINALITY(SET(수강과목)) AS 고유과목수
FROM 학생;
```

### MULTISET 연산 요약

| 연산 | 설명 |
|------|------|
| MULTISET UNION [ALL\|DISTINCT] | 합집합 |
| MULTISET INTERSECT [ALL\|DISTINCT] | 교집합 |
| MULTISET EXCEPT [ALL\|DISTINCT] | 차집합 |
| ELEMENT(멀티셋) | 단일 요소 추출 |
| SET(멀티셋) | 중복 제거 |
| CARDINALITY(멀티셋) | 요소 수 반환 |

---

## 11. TABLESAMPLE

```sql
-- BERNOULLI 샘플링: 행 단위
SELECT * FROM 대용량_로그 TABLESAMPLE BERNOULLI(10);

-- SYSTEM 샘플링: 페이지 단위 (더 빠름)
SELECT * FROM 대용량_로그 TABLESAMPLE SYSTEM(5);

-- 반복 가능한 샘플링
SELECT * FROM 대용량_로그 TABLESAMPLE BERNOULLI(10) REPEATABLE(42);

-- 집계와 함께
SELECT AVG(응답시간) AS 평균응답시간_추정
FROM 웹로그 TABLESAMPLE BERNOULLI(1);
```

| 방식 | 단위 | 정확도 | 속도 |
|------|------|--------|------|
| BERNOULLI | 행 | 높음 | 느림 |
| SYSTEM | 페이지 | 낮음 | 빠름 |

---

## 12. 배열 개선

```sql
CREATE TABLE 설문 (
    설문번호    INTEGER PRIMARY KEY,
    제목        VARCHAR(200),
    선택지      VARCHAR(100) ARRAY[10],
    응답수      INTEGER ARRAY[10]
);

INSERT INTO 설문 VALUES (
    1, '선호 언어',
    ARRAY['Java', 'Python', 'C++', 'JavaScript'],
    ARRAY[150, 200, 80, 180]
);

-- 요소 접근
SELECT 선택지[1] FROM 설문;

-- 크기
SELECT CARDINALITY(선택지) FROM 설문;

-- UNNEST: 배열을 행으로 전개
SELECT s.제목, t.선택지항목, t.응답수항목
FROM 설문 s,
     UNNEST(s.선택지, s.응답수) AS t(선택지항목, 응답수항목);

-- 배열 연결
SELECT 선택지 || ARRAY['기타'] FROM 설문;
```

---

## 13. WINDOW 절 (Named Window)

WINDOW 절을 사용하면 SELECT 문에서 동일한 윈도우 정의를 이름으로 재사용할 수 있다.

### 13.1 기본 구문

```sql
SELECT 이름, 급여,
    SUM(급여) OVER w AS 누적급여,
    AVG(급여) OVER w AS 평균급여
FROM 직원
WINDOW w AS (PARTITION BY 부서코드 ORDER BY 급여);
```

### 13.2 여러 윈도우 정의

```sql
SELECT 이름, 부서코드, 급여,
    ROW_NUMBER() OVER w_부서 AS 부서내순번,
    RANK() OVER w_전체 AS 전체순위,
    SUM(급여) OVER w_부서 AS 부서급여합계
FROM 직원
WINDOW
    w_부서 AS (PARTITION BY 부서코드 ORDER BY 급여 DESC),
    w_전체 AS (ORDER BY 급여 DESC);
```

### 13.3 윈도우 상속

기존 Named Window를 기반으로 프레임 절을 추가할 수 있다.

```sql
SELECT 연월, 매출,
    SUM(매출) OVER w_누적 AS 누적매출,
    AVG(매출) OVER w_이동3 AS 이동평균_3개월
FROM 월별매출
WINDOW
    w_기본 AS (ORDER BY 연월),
    w_누적 AS (w_기본 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),
    w_이동3 AS (w_기본 ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
```

---

## 14. PERCENT_RANK / CUME_DIST

### 14.1 PERCENT_RANK

백분위 순위를 0과 1 사이의 값으로 반환한다. 계산식: (RANK - 1) / (전체 행 수 - 1).

```sql
SELECT 이름, 급여,
    PERCENT_RANK() OVER (ORDER BY 급여) AS 백분위순위
FROM 직원;

-- 결과 예 (4명):
-- 이름   | 급여    | 백분위순위
-- 박인사 | 4000000 | 0.0
-- 이영업 | 4500000 | 0.333...
-- 최기획 | 4500000 | 0.333...
-- 김개발 | 5000000 | 1.0

-- 부서별 백분위 순위
SELECT 이름, 부서코드, 급여,
    PERCENT_RANK() OVER (PARTITION BY 부서코드 ORDER BY 급여) AS 부서내백분위
FROM 직원;
```

### 14.2 CUME_DIST

누적 분포 값을 반환한다. 현재 행의 값 이하인 행의 비율. 계산식: (현재 값 이하 행 수) / (전체 행 수).

```sql
SELECT 이름, 급여,
    CUME_DIST() OVER (ORDER BY 급여) AS 누적분포
FROM 직원;

-- 결과 예 (4명):
-- 이름   | 급여    | 누적분포
-- 박인사 | 4000000 | 0.25
-- 이영업 | 4500000 | 0.75
-- 최기획 | 4500000 | 0.75
-- 김개발 | 5000000 | 1.0

-- 급여가 상위 20% 이내인 직원
SELECT 이름, 급여
FROM (
    SELECT 이름, 급여,
        CUME_DIST() OVER (ORDER BY 급여 DESC) AS 누적분포
    FROM 직원
) AS t
WHERE 누적분포 <= 0.2;
```

### PERCENT_RANK vs CUME_DIST 비교

| 함수 | 범위 | 계산 기준 | 최솟값 |
|------|------|-----------|--------|
| PERCENT_RANK | 0 ~ 1 | (RANK - 1) / (N - 1) | 0 |
| CUME_DIST | 0 초과 ~ 1 | (현재 값 이하 행 수) / N | 1/N |

---

## 15. FILTER 절

집계 함수에 FILTER (WHERE ...) 절을 추가하여, 특정 조건을 만족하는 행만 집계 대상으로 포함한다.

### 15.1 기본 구문

```sql
SELECT 부서코드,
    COUNT(*) AS 전체인원,
    COUNT(*) FILTER (WHERE 급여 > 5000000) AS 고급여인원,
    AVG(급여) FILTER (WHERE 직급 = '과장') AS 과장평균급여
FROM 직원
GROUP BY 부서코드;
```

### 15.2 다양한 집계 함수와 조합

```sql
SELECT 부서코드,
    SUM(급여) AS 전체급여합계,
    SUM(급여) FILTER (WHERE 직급 = '대리') AS 대리급여합계,
    SUM(급여) FILTER (WHERE 직급 = '과장') AS 과장급여합계,
    MAX(급여) FILTER (WHERE 입사년도 >= 2020) AS 최근입사자최고급여,
    MIN(급여) FILTER (WHERE 입사년도 < 2020) AS 기존직원최저급여
FROM 직원
GROUP BY 부서코드;
```

### 15.3 FILTER 절과 윈도우 함수 조합

```sql
SELECT 이름, 부서코드, 급여, 직급,
    COUNT(*) FILTER (WHERE 직급 = '과장')
        OVER (PARTITION BY 부서코드) AS 부서내과장수,
    SUM(급여) FILTER (WHERE 급여 >= 4000000)
        OVER (PARTITION BY 부서코드) AS 부서내고급여합계
FROM 직원;
```

---

## 16. ROW 타입 개선

SQL:2003에서 ROW 타입의 사용이 확장되었다. ROW 타입은 여러 필드를 하나의 복합 값으로 묶는다.

### 16.1 ROW 값 생성자

```sql
-- ROW 값 생성자를 사용한 비교
SELECT * FROM 직원
WHERE ROW(부서코드, 직급) = ROW('D001', '과장');

-- ROW 값을 사용한 다중 컬럼 비교
SELECT * FROM 직원
WHERE ROW(급여, 입사일) > ROW(4000000, DATE '2020-01-01');
```

### 16.2 ROW 타입 컬럼

```sql
CREATE TABLE 고객 (
    고객번호    INTEGER PRIMARY KEY,
    이름        VARCHAR(50),
    주소        ROW(
                    우편번호 VARCHAR(6),
                    도시     VARCHAR(50),
                    상세주소 VARCHAR(200)
                )
);

INSERT INTO 고객 VALUES (
    1, '김고객',
    ROW('06100', '서울', '강남구 역삼동 123')
);

-- ROW 타입 필드 접근
SELECT 이름, 주소.도시, 주소.상세주소
FROM 고객;
```

### 16.3 ROW 타입을 활용한 함수 반환

```sql
-- ROW 타입을 반환하는 함수
CREATE FUNCTION 직원요약(p_직원번호 INTEGER)
    RETURNS ROW(이름 VARCHAR(50), 부서코드 VARCHAR(10), 급여 DECIMAL(10,2))
    RETURN (
        SELECT ROW(이름, 부서코드, 급여)
        FROM 직원
        WHERE 직원번호 = p_직원번호
    );
```

---

## 17. 명시적 타입 테이블 (Typed Table)

사용자 정의 구조화 타입(Structured Type)을 기반으로 테이블을 정의한다. REF 타입을 사용하여 객체 참조를 지원한다.

### 17.1 구조화 타입 정의

```sql
CREATE TYPE 주소_타입 AS (
    우편번호    VARCHAR(6),
    도시        VARCHAR(50),
    상세주소    VARCHAR(200)
) NOT FINAL;

CREATE TYPE 사람_타입 AS (
    이름        VARCHAR(50),
    생년월일    DATE,
    주소        주소_타입
) NOT FINAL;

-- 타입 상속
CREATE TYPE 직원_타입 UNDER 사람_타입 AS (
    직원번호    INTEGER,
    부서코드    VARCHAR(10),
    급여        DECIMAL(10,2)
) NOT FINAL;
```

### 17.2 타입 테이블 생성

```sql
-- 타입 기반 테이블 생성
CREATE TABLE 사람_테이블 OF 사람_타입 (
    REF IS 사람_oid SYSTEM GENERATED,
    PRIMARY KEY (이름, 생년월일)
);

CREATE TABLE 직원_테이블 OF 직원_타입 UNDER 사람_테이블 (
    PRIMARY KEY (직원번호)
);
```

### 17.3 REF 타입

REF는 타입 테이블의 특정 행을 가리키는 참조 타입이다.

```sql
CREATE TYPE 부서_타입 AS (
    부서코드    VARCHAR(10),
    부서명      VARCHAR(50)
) NOT FINAL;

CREATE TABLE 부서_테이블 OF 부서_타입 (
    REF IS 부서_oid SYSTEM GENERATED,
    PRIMARY KEY (부서코드)
);

-- REF 타입을 사용하여 다른 타입 테이블을 참조
CREATE TYPE 소속직원_타입 AS (
    직원번호    INTEGER,
    이름        VARCHAR(50),
    소속부서    REF(부서_타입) SCOPE 부서_테이블
) NOT FINAL;

CREATE TABLE 소속직원_테이블 OF 소속직원_타입 (
    REF IS 직원_oid SYSTEM GENERATED,
    PRIMARY KEY (직원번호)
);
```

### 17.4 DEREF를 사용한 참조 해제

```sql
-- REF를 따라가서 참조된 행의 값을 조회
SELECT 이름, DEREF(소속부서).부서명 AS 부서명
FROM 소속직원_테이블;

-- 화살표 연산자(->) 로 참조 필드 접근
SELECT 이름, 소속부서->부서명 AS 부서명
FROM 소속직원_테이블;
```

---

> 참고: SQL:2003 표준은 ISO/IEC 9075:2003 시리즈로 발행되었다.
