# 프로젝트

# 사용 기술

HoneyFlow Project

### Q1. CRDT를 사용한 이유

동시 편집을 구현하기 위해 분산된 클라이언트가 동시에 요청을 보냈을 때 충돌 문제를 해결해야하는데 이때 충돌 문제의 해결을 서버가 하는 OT 방식과 클라이언트에서 해결하는 CRDT 방식 중에서 서버의 부하가 적은 CRDT 방식을 사용하였다.

### Q2. Yjs를 사용한 이유

CRDT에 관련해서 학습을 하다가 CRDT는 여러가지 버전이 있다는 것을 알게 되었고 여러가지 방식을 비교했을 때 가장 개선되었다고 생각한 YATA Algorithm이 눈에 들어왔다.

이것의 구현체인 Yjs를 선택하게 되었고, 벤치 마크 결과에서도 여러가지 라이브러리랑 비교헀을 때 꽤 우위를 선점하고 Github Star도 가장 많아서 선택하게된 근거가 되었다.

### Q3. YATA Algorithm은 무엇이고 어떻게 동작하는지 ?

- 일단 YATA 알고리즘에 대해서 개략적으로 말씀드리면 분산된 환경에서 타임스탬프는 일관성이 깨진 시계의 문제가 있을 수 있고 따라서 각 연산에 타임스탬프가 아니라 논리적 시계값을 부여하구요.
- 그리고 어떤 클라이언트인지 식별하기 위해 각 클라이언트는 고유한 식별자를 가지고 있다.
- 그래서 데이터를 삽입하는 과정에서 RGA라는 다른 CRDT 알고리즘은 오른쪽의 값만 식별하는 반면 YATA는 현재 상태 기준으로 삽입하려는 값의 좌우값을 가지고 있습니다.
- 정리하면 각 클라이언트의 식별자, 연산의 논리적 시계를 통해서 이벤트의 선후관계, 삽입/삭제할 때 좌우 식별값을 토대로 분산된 환경에서 삽입/삭제에 대한 충돌 문제를 해결합니다.

### Q4. YATA Algorithm의 삭제 메커니즘에 대해서 ?

### WebSocket

- 왜 WebSocket인지 ?
- Nest
  - 왜 Nest인지 ?
- 왜 MongoDB 인지 ?

게시판 프로젝트

- 왜 MySQL인지 ?
