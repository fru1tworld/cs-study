- Lock: 동시성을 제어하기 위함
- Transacion: 데이터의 정합성을 보장하기 위함

### Lock

- 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉨

### MySQL 엔진 레벨 Lock

#### Global Lock

- 사용 이유:
  - FLUSH TABLES WITH READ LOCK 명령어로 획득.
  - 전체 데이터베이스에 대한 읽기 락을 걸기 위해 사용.
  - 주로 백업 작업(특히 논리적 백업) 전에 데이터 변경을 막기 위해 사용돼요.
- 영향:
  - 모든 테이블에 대한 쓰기 및 일부 읽기 작업이 차단됨 전체 인스턴스 수준에서 락이 걸려있음

#### Backup Lock

- 사용 이유: Global Lock 단점을 보완하기 위해 등장
- 영향: 읽기 작업은 대부분 허용되고 특정 메타데이터 변경만 제한됨

#### Table Lock

- 사용 이유: 스키마를 변경하는 쿼리의 경우
- 영향: 테이블 단위로 읽기 및 쓰기에 락이 걸림

#### Named Lock

- 사용 이유: 분산된 환경에서 트랜잭션을 관리할 때 사용함
- 영향:지정한 문자열에 대해 획득/반납 하는 락

#### Metadata Lock

- 사용 이유: 객체의 이름이나 구조를 변경할 때 사용

### InnoDB 스토리지 엔진 Lock

#### Record Lock

- 레코드 자체가 아니라 인덱스의 레코드를 건다.

#### Gap Lock

- 레코드와 레코드 사이의 락을 걸어서 새로운 레코드가 생성되는 것을 방지한다.

#### Next Key Lock

- 레코드 락과 갭 락을 합쳐 놓은 형태의 락
- Record Lock을 걸고 그 Record Gap까지 동시에 잠금

#### Auto Increament Lock

- PK 자동 증가락 테이블 전체에 락 걸림

### 격리 수준

#### READ UNCOMMITTED

- 커밋이 안되어도 읽을 수 있음
- Dirty Read 문제 발생

#### READ COMMITTED

- 커밋되면 읽을 수 있음
- Non Repeatable Read 문제 발생

#### REPEATABLE READ

- Select For Update를 하면 언두 로그 레코드에 락을 걸지 않아서 Phantom Read 문제 발생
- 일반적으로 Next Key Lock으로 문제 해결

#### SERIALIZABLE

- 읽기와 쓰기가 모두 직렬화되어있음
