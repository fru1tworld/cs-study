# MySQL 아키텍처

### 메모리 할당 구조

- 글로벌 메모리 영역, 로컬 메모리 영역이 나뉨

#### 글로벌 메모리 영역

- 테이블 캐시, InnoDB 버퍼풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼등

### 스레드 구조

- 스레드는 포그라운드, 백그라운드로 나뉨
- 포그라운드는 일반적으로 클라이언트의 요청을 처리하기 위함
- 클라이언트 사이드에서 커넥션 풀을 사용하는 것과 별개로 스레드 풀이라는 것을 사용함

### 쿼리 실행 순서

1. Connection Handling

- 클라이언트로부터의 접속을 수락하고, 세션 및 스레드를 연결
- 인증(Authentication) 및 권한 검사 수행

2. Parse Tree

- 클라이언트로부터 수신된 SQL 쿼리를 파싱하여 문법적 구조인 Parse Tree를 생성

3. Preprocessing (Preprocessor)

- 구문 분석된 트리에서 테이블/컬럼 존재 여부 확인
- 사용자 권한 검증 등

4. Optimizer (쿼리 최적화기)

- 최적의 실행 계획(Execution Plan)을 수립
- 인덱스 선택, 조인 순서, 조인 알고리즘 결정 등

5. Query Execution Engine

- 실제로 쿼리를 실행
- Storage Engine과 인터랙션하여 데이터를 읽고 결과 생성

6. Result Return

- 결과를 클라이언트에게 전송

## InnoDB

#### PK 기반 클러스터링 인덱스

- Table은 기본적으로 PK가 존재하고 클러스터드 인덱스가 있음

#### Redo, Undo

- Redo 앞으로 나아가기 위함
  - failover가 발생할 경우 회복할 때 활용되며 장애 회복 단계를 설정할 수 있음
- Undo 뒤로 가기 위함
  - MVCC 등에 활용됨

#### Undo를 활용한 MVCC

- 커밋 전에 버퍼풀에 즉시 반영되고 버퍼풀에 있던 기존 데이터는 transacion id가 부여되고 undo 공간에 보관됨

#### Non Locking Consistency Read

- MVCC에 의해 Read는 Repeatable Read 이하인 경우 Lock 없는 읽기가 가능함

### 버퍼풀 구조

- 데이터는 페이지 크기로 관리됨
- LRU 변형 리스트 (새로운 데이터는 5/8 지점에 삽입되고 사용될 때마다 한칸 씩 올라감 옛날 데이터는 뒤로가서 삭제됨)
- flush (더티 데이터를 디스크와 동기화하기 위함)
  - 옵션에 따라 flush 주기를 설정할 수 있음
- free (사용되지 않고 있는 구조)

### Redo Log의 순환 구조

InnoDB는 1개 이상의 고정 크기 파일을 연결해 순환 구조로 한다.

이때 재활용 가능한 더티 페이지와 클린 페이지가 존재하는데 Redo Log 파일이 충분히 커야 버퍼풀의 쓰기 지연을 충분히 활용할 수 있음

#### Double Write Buffer

- 랜덤 I/O는 비용이 커서 순차 I/O로 한 번 쓰고 랜덤 I/O로 쓰기 위함
- Failover 할 때 활용됨

#### Change Buffer

- 데이터를 변경하면 인덱스도 변경해야하는데 Change Buffer에 보관했다가 한번에 변경함
- 유니크한 PK, 유니크 제약조건이 걸려있는 경우 해당되지 않음

#### 데드락 감지 기법

- 기본적으로 모니터링 백그라운드 스레드가 존재함
- 트랜잭션 자원 점유 그래프를 활용해서 순환 구조가 확인되면 Undo Log가 가장 작은 값을 하나 희생함

#### 어댑티브 해시 인덱스

- KV 해시 인덱스
- 인덱스 키 값과 데이터 주소의 쌍
- 디스크 읽기가 많아서 어댑티브 해시 인덱스를 수시로 갱신해야하는 경우 비효율적일 수 있음
