# .9 가상 메모리 관리

## 9.1 요구 페이징

프로세스가 필요한 데이터를 언제 메모리로 가져올지 결정하는 것이 가져오기 정책이다.
일반적인 방법은 프로세스가 요청할 때 메모리로 가져오는 것이므로 이를 요구 페이징이라고 한다.

### 9.1.1 요구 페이징의 개요

컴퓨터를 오래 사용하다 보면 시스템이 느려지는 것을 경험해 보았을 것이다.

이때 컴퓨터 전원을 껐다가 다시 키면 시스템이 빨라진다.

컴퓨터를 오래 켜두었을 때 시스템이 느려지는 것은 작업을 하지 않고 쉬는 프로세스나 좀비 프로세스가 메모리를 차지하여 메모리 관리가 복잡해지기 때문이다.

따라서 메모리에는 꼭 필요한 프로세스만 유지하는 것이 좋다.

용량이 큰 프로세스를 올린다고 가정해보자.

운영체제는 프로세스를 구성하는 모듈을 전부 메모리에 올라오지 않고 필요한 모듈만 일단 올리고 필요하면 일부를 가져온다.

다음과 같은 이유

1. 메모리를 효율적으로 관리하기 위해
2. 응답 속도 향상 : 용량이 큰 프로세스를 전부 갖고 오면 응답이 느리다.

사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징이라고 한다.

그래서 필요한 것이라고 예상되어 미리 가져오는 방식이 미리 가져오기다.

미리 가져오기의 예시를 캐시이다.

그러나 미리 가져오기가 실패하면 피해가 매우 커서 현대 운영체제는 요구 페이징을 기본으로 사용한다.

> 요구 페이징과 쓰기 시점 복사
> 요구 페이징은 요구할 때까지 물리 메모리로 가져오는 것을 최대한 미루고 쓰기 시점 복사도 필요하다고 판단될 때까지 데이터 복사를 최대한 미룬다.

> 스와핑과 게으른 스와퍼
> 프로세스 입장에서는 프로세스를 구성하는 모든 페이지가 한번에 올라오는 게 좋은데 이러한게 순수한 스와핑 요구 할 때 메모리에 올리는 것을 게으른 스와퍼라고 한다.

### 9.1.2 페이징 테이블 엔트리의 구조

가상 메모리의 크기는 물리 메모리와 스왑 영역을 합친 것이다.

이때 스왑 영역은 하드 디스크에 존재하나 메모리 관리자가 관리하는 것으로, 가상 메모리의 구성 요소 중 하나다.

스왑 영역에서 물리 메모리로 데이털르 가져오는 스왑인과 물리 메모리에서 스왑 영역으로 데이터를 내보내는 스왑아웃을 나타낸다.

가상 메모리 시스템에서 사용자의 프로세스는 물리 메모리와 스왑 영역 중 한 곳에 있다.

이때 페이지가 스왑 영역에 있는 경우는 크게 2 가지다.

하나는 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우,

또 하나는 꽉 차서 스왑 영역으로 옮겨 온 경우다.

어떤 것이든 페이지 테이블에는 페이지가 메모리에 있는지 스왑 영역에 있는지 표시해야하는데 이때 유효비트라는 것을 사용한다.

페이지 테이블은 PTE는 페이지 번호, 플래그 비트, 프레임 번호로 구성된다.

PTE를 구성하는 프레임 번호는 가상 주소의 해당 페이지가 어느 프레임에 있는지 알려주는 자료구조로 페이지 테이블의 핵심이다.
이때 메모리 관리자는 찾은 프레임 번호를 이용하여 가상 주소를 물리 주소로 변환한다.

- **접근 비트**:접근 비트는 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려준다. 해당 메모리에 읽거나 실행 작업을 했다면 접근 비트가 1이 된다. 참조 비트라고도 한다.
- **변경 비트**:변경 비트는 페이지가 메모리에 올라온 후 데이터 변경이 있었는지 알려준다. 쓰기나 추가 작업을 했다면 1이 된다. 새로운 값으로 오염되었다는 의미에서 더티 비트라고도 한다.
- **유효 비트**:유효 비트는 페이지가 실제 메모리에 있는지 나타낸다. 현재 비트라고도 한다.
- **읽기 비트, 쓰기 비트, 실행 비트**:읽기 비트, 쓰기 비트, 실행 비트는 페이지에 대한 읽기 쓰기 실행 권한을 나타낸다. - 접근 권한 비트라고도 한다.

### 9.1.3 페이지 부재

가상 메모리의 페이지 테이블에는 페이지가 물리에 있는지 스왑에 있는지 표시하기 위해 유효 비트를 사용한다.

유효 비트가 0일 때는 페이지가 메모리에 있으므로 주소 필드에 물리 메모리의 프레임 번호가 저장된다.

유효 비트가 1일 때는 스왑영역에 있으므로 주소 필드에 스왑 영역 내 페이지의 주소가 저장된다.

프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 페이지 부재라고 한다.

페이지 부재가 발생하면 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야한다

페이지 부재가 발생하면 위와 같은 과정을 거쳐 스왑 영역에 있는 페이지를 메모리의 빈 영역에 올리고 페이지 테이블을 갱신한다.

빈 프레임이 있으면 작업하기가 수월하고 빈 프레임이 없으면 메모리에 있는 프레임 중 하나를 스왑영역에 보내야한다.

이때 어떤 페이지를 보낼지 결정하는 알고리즘을 페이지 교체 알고리즘이라고 한다.

페이지 교체 알고리즘에 의해 보내지는 것을 대상 페이지라고 한다.

메모리가 꽉차면 어떠한 일이 발생하는지 알아보자

1. 해당 페이지의 유효 비트가 1이다. 즉 페이지 부재가 발생한다.
2. 메모리가 꽉차 있는 상태이기 때문에 스왑 영역에 있는 페이지 E를 가져오기 위해 메모리의 페이지 중 하나를 스왑 영역으로 내보내야 한다. 물리 메모리의 프레임 3에 저장된 페이지를 대상 페이지로 선정하여 스왑 영역으로 옮긴다.
3. 이에 따라 대상 페이지 PTE 0의 유효 비트가 0에서 1로 주소 필드 값이 프레임 3에서 스왑 주소 6으로 바뀐다.
4. 스왑 영역 1번에 있던 페이지 E가 프레임 3으로 올라간다 (스왑인)
5. 이에 따라 PTE4의 유효 비트가 1에서 0으로 주소 필드 값이 스왑 주소 1에서 프레임 3으로 바뀐다.

세그먼테이션 오류와 페이지 부재는 비슷해 보여도 많은 차이가 있다.
접근 권한이 없는 메모리를 참조하는 것과, 해당 페이지가 물리 페이지에 없다는 차이가 있다.

## 9.2 페이지 교체 알고리즘

### 9.2.1 페이지 교체 알고리즘의 개요

프로세스가 요구한 페이지가 현재 메모리에 없으면 페이지 부재가 발생하고 스왑 영역에서 페이지를 메모리로 가져오는데 만약 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야 한다.

페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상한다.

#### **페이지 교체 알고리즘의 종류**

페이지 알고리즘의 종류는 간단한 알고리즘 이론적 알고리즘 최적 알고리즘이 있다.

| 종류               | 알고리즘  | 특징                                                                        |
| ------------------ | --------- | --------------------------------------------------------------------------- |
| 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.                       |
| -                  | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.                         |
| 이론적 알고리즘    | 최적      | 미래의 메모리 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
| 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.                       |
| -                  | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.                             |
| -                  | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.                      |
| -                  | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다.                                     |

#### **페이지 교체 알고리즘의 성능 평가 기준**

페이지 교체 알고리즘을 다루기에 앞서 알고리즘의 성능을 비교하는 기준을 알아보자,

어떤 알고리즘이 다른 알고리즘보다 성능이 좋은지 비교 평가하는 방법은 다양하다.

예를 들어 같은 메모리 접근 패턴을 사용하는 A와 B를 비교해서 페이지 부재 횟수를 세어볼 수 있고 평균 대기 시간을 측정할 수 있고

전체 작업에 걸리는 시간도 확인해볼 수 있는데

이 책에세너는 페이지 부재 횟수와 성공 횟수를 비교해본다.

그러나 아무리 뛰어난 알고리즘이더라도 많은 계산이 발생하면 좋은 알고리즘이 아니다.

### 9.2.2 무작위 페이지 교체 알고리즘

랜덤으로 방출시키는 방식이다.

### 9.2.3 FIFO 페이지 교체 알고리즘

선입선출 방식이다.

시간의 지역성을 고려하면 가장 오래된 페이지가 나가는게 맞긴하다.

그러나 메모리에 올라온지 오래되었더라도 자주 사용되는 페이지가 있다면 FIFO는 메모리에 올라온 시간만 고려하므로 자주 사용된 페이지가 스왑으로 옮겨지기도 한다.

### 9.2.4 최적 페이지 교체 알고리즘

최적 페이지 교체 알고리즘은 앞으로 사용하지 않을 페이지를 스왑으로 옮긴다.

미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 한다.

가장 이상적이지만 가장 미래의 접근 방식을 알 수 없다.

### 9.2.5 LRU 페이지 교체 알고리즘

최근 최소 사용 페이지 교체 알고리즘이다.

#### **페이지 접근 시간에 기반한 구현**

가장 간단한 형태는 시간을 기록하여 구현하는 것이다. 일반적으로 FIFO 보다 우수하고 최적 보단 조금 떨어진다.

#### **카운터에 기반한 구현**

LRU 페이지 교체 알고리즘은 페이지 접근 시간을 기록하여 구현할 수도 있지만 카운터를 사용하여 구현할 수도 있다.

맨 위의 숫자를 시각이 아니라 카운터 숫자라고 생각하면 된다.

시간이든 카운터든 둘다 추가 메모리가 필요하다.

#### **참조 비트 시프트 방식**

참조 비트 시프트 방식인데 일정 크기의 참조 비트를 만들어 사용한다. 초깃값은 0이며 페이지에 접근할 때마다 1로 바뀐다.

그리고 주기적으로 오른쪽으로 한 칸씩 시프트 되는데

그래서 참조비트를 갱신하다가 대상 페이지를 선정할 필요가 있으면 가장 작은 값을 고른다.

### 9.2.6 LFU 페이지 교체 알고리즘

LFU는 몇 번 사용되었는지 기준으로 한다 일반적으로 LRU와 LFU는 비슷한 성능을 보여준다.

### 9.2.7 NUR 페이지 교체 알고리즘

LRU LFU와 성능이 유사하면서도 공간 낭비를 해결했다.

NUR페이지는 최근 미사용 페이지이다.

참조비트와 변경 비트를 가지고 사용한다.

그래서 대상 페이지를 선정할 때는 00 01 10 11 순서로 탐색한다. (접근, 변경)과 같은 방식이다.

고려 대상은 참조 비트다. 참조 비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾는다.

흔한 경우 모두 1,1 이면 적당한 것을 찾을 수 없어서 이땐 모두 0,0으로 초기화한다.

2bit만 추가하면 되어서 많이 사용된다.

### 9.2.8 변형 FIFO 알고리즘

FIFO를 개선한 알고리즘이다.

#### **2차 기회 페이지 교체 알고리즘**

특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지르르 맨 뒤로 이동하여 대상 페이지에서 제외한다.

LRU LFU NUR보다 약간 낮고 FIFO 보다 약간 높은 성능인데 큐를 유지하는 비용이 높고 페이지가 성공하면 큐의 중간에 있는 값이 뒤로 이동하는 작업이 추가 된다.

#### **시계 알고리즘**

즘2차 기회 페이지 교체 알고리즘은 원형 큐를 사용한다.

시계 알고리즘에서는 스왑 영역으로 옮길 대상 페이지를 가리키는 포인터를 사용하는데, 이 포인터가 큐의 맨 아래로 내려가면서 다음번에 큐의 처음으로 가리키게 된다.

참조 비트의 초깃 값은 0이고 성공적으로 참조하면 0에서 1로 변경된다.

참조 비트가 1인 페이지는 건너 뛰는데 1인 페이지를 제외하는것은 기회를 한 번 더 주기 위함이다.

그런데 1인 페이지를 건너뛸 때는 0으로 바꿔놓는다.

추가 공간이 적게 들지만 알고리즘이 복잡하고 계산량이 많다는 것이 단점이다.

## 9.3 스레싱과 프레임 할당

물리 메모리에는 여러 개의 프로세스가 올라와 있다.

운영체제는 물리 메모리의 공간이 충분하면 프로세스의 요청에 따라 프레임을 할당하지만 그렇지 못할 경우 남아 있는 프레임을 어떻게 나누어 주느냐 하는 문제에 맞닥뜨린다.

### 9.3.1 스레싱

#### **스레싱의 개념**

하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태를 스레싱이라고 한다.

#### **물리 메모리의 크기와 스레싱**

스레싱은 메모리의 크기가 일정할 경우 프로그램의 수와 밀접한 관계가 있다.
동시에 실행하는 프로그램의 수를 멀티프로그래밍 정도라고 하는데, 멀티 프로그래밍 정도가 너무 높으면 스레싱이 발생한다.

그래서 멀티 프로그래밍 정도와 CPU 사용률이 증가하다가 CPU가 작업하는 시간보다 스왑영역으로 페이지를 보내고 새로운 페이지를 가져오는 비용이 빈번해져서 CPU가 작업을 할 수 없는 상태에 이르게 된다.
이러한 시점을 스레싱 발생 ㅅ지점이라고 한다.

#### **스레싱과 프레임 할당**

스레싱은 각 프로세스에 프레임을 할당하는 문제와도 연관된다.

실행 중인 여러 프로세스에 프레임을 얼마나 나누어 주느냐에 따라 시스템의 성능이 달라진다.

어떤 프로세스에는 너무 적은 프레임을 할당하여 페이지 부재가 빈번히 일어나고, 어떤 프로세스에는 너무 많은 프레임을 할당하여 페이지 부재는 줄었으나 대신 메모리를 낭비한다면 전반적으로 시스템 성능이 낮아진다.

따라서 남아있는 프레임을 실행 중인 프로세스에 적절히 나누어 주는 정책이 필요하다.

### 9.3.2 정적 할당

#### **균등 할당**

프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당한다.

그러나 큰 프로세스의 경우 필요한 만큼 할당받지 못하기 때문에 페이지 부재가 빈번하게 발생하고 크기가 작으면 메모리가 낭비된다.

#### **비례 할당**

프로세스의 크기에 따라서 프레임을 할당하는 방식이다.
그러나 다음과 같은 두가지 문제가 있다.

1. 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못한다.
   아무리 작은 프로세스라도 실행 중에 많은 메모리를 필요로 하는 경우가 있다.
   대표적으로 동영상 플레이어는 크기가 작지만 재생되는 동영상이 커서 실행되는 동안 몇 십배 큰 메모리가 필요하다.

2. 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비한다. 요구 페이징 방식에는 아무리 큰 프로세스라도 처음부터 메모리에 모두 올리지 않는데, 비레 할당 방식에서는 큰 프로세스를 실행하면서 당장 필요없는 프레임을 미리 할당해 놓기 때문에 메모리가 낭비된다.

### 9.3.3 동적 할당

#### **작업집합 모델**

지역성 이론을 바탕으로 가장 최근에 접근한 프레임이 이후에도 참조될 가능성이 높다는 가정에서 출발한다.
그래서 일정 시간 동안 참조된 페이즈들을 집합으로 만들고 이 집합에 있는 페이즈들을 메모리에 유지하여 프로세스의 실행을 돕는다.

그래서 작업집합에 포함되는 페이지의 범위를 작업집합 윈도우라고 한다(working set window)

작업 집합 크기는 작업 집합에 들어갈 최대 페이지 수를 의미하지만 얼마나 자주 갱신할지 의미하기도 한다.
5번 이라고 하면 페이지에 다섯 번 접근할때마다 갱신한다는 의미다.

그래서 너무 크게 잡으면 필요없는 메모리가 남아서 다른 프로세스에 영향을 미치고 너무 작게 잡으면 필요한 페이지가 스왑 영역으로 옮겨져서 프로세스 성능이 떨어진다.

#### **페이지 부재 빈도**

작업집합 모델은 충분한 페이지를 할당하지 않으면 작업 집합에 있는 페이지를 물리 메모리에 유지하기가 힘들다.

작업집합 모델에서는 어떤 프레임을 물리 메모리에 유지해야 하는지 알 수 있지만 프레임을 얼마나 할당해야 하는지는 알 수 없다.

작업집합 모델은 프로세스의 성능을 높이는 방법이지만 스레싱 문제를 해결하지는 못한다.

그래서 페이지 부재 빈도를 이용하는 방법도 있다.

이는 페이지 부재 횟수를 기록해서 상한선과 하한선을 정해서 상한선을 초과하면 추가로 늘리고 부재비율이 적으면 프레임을 회수한다.

### 9.3.4 전역 교체와 지역 교체

그리고 페이지 교체 알고리즘에 따라 페이지를 교체할 때는 전역 교체 방식 또는 지역 교체 방식을 사용한다.

- 전역 교체: 전체 프레임을 대상으로 교체 알고리즘을 적용한다.

- 지역 교체: 현재 실행 중인 프로세스의 프레임을 대상으로 교체 알고리즘을 적용한다.

전역 교체 방식에는 물리 메모리의 모든 프레임을 대상으로 스왑 영역에 보낼 페이지를 찾는다.

지역 교체 방식의 장점은 자신에게 할당된 프레임의 전체 개수가 변화가 없기 때문에 다른 프로세스에 영향을 미치지 않는다는것이다.

그래서 페이지 교체를 위해 다른 프로세스에 할당된 프레임을 빼앗으면 프레임을 빼앗긴 프로세스는 스레싱 발생 지점에 도달할 수도 있다.

지역 교체 방식에서는 전체 프로세스에 할당된 프레임 수가 변하지 않기 때문에 스레싱을 줄일 수 잇다.

그래서 지역 교체 방식의 단점은 스왑 영역으로 옮겨지면 시스템 효율이 떨어진다는 것이다.

그런데 지역 교체 방식은 스레싱은 줄일 수 있지만 반대로 실행 중인 프로세스의 성능을 떨어뜨릴 수도 있다.

그러므로 전체 시스템의 입장에서는 전역 교체 방식이 지역 교체 방식보다 효율적이다.
