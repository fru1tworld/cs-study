# .9 가상 메모리 관리

## 9.1 요구 페이징

필요세스가 필요한 데이터를 언제 메모리로 가져올지 결정하는 것이 가져오기 정책이다.
일반적인 방법은 프로세스가 요청할 때 메모리로 가져오는 것이므로 이를 요구 페이징이라고 한다.

### 9.1.1 요구 페이징의 개요

컴퓨터를 오래 사용하다 보면 시스템이 느려지는 것을 경험해 보았을 것이다.

이때 컴퓨터 전원을 껐다가 다시 키면 시스템이 빨라진다.

컴퓨터를 오래 켜두었을 때 시스템이 느려지는 것은 작업을 하지 않고 쉬는 프로세스나 좀비 프로세스가 메모리를 차지하여 메모리 관리가 복잡해지기 때문이다.

따라서 메모리에는 꼭 필요한 프로세스만 유지하는 것이 좋다.

용량이 큰 프로세스를 올린다고 가정해보자.

운영체제는 프로세스를 구성하는 모듈을 전부 메모리에 올라오지 않고 필요한 모듈만 일단 올리고 필요하면 일부를 가져온다.

다음과 같은 이유

1. 메모리를 효율적으로 관리하기 위해
2. 응답 속도 향상 : 용량이 큰 프로세스를 전부 갖고 오면 응답이 느리다.

사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징이라고 한다.

그래서 필요한 것이라고 예상되어 미리 가져오는 방식이 미리 가져오기다.

미리 가져오기의 예시를 캐시이다.

그러나 미리 가져오기가 실패하면 피해가 매우 커서 현대 운영체제는 요구 페이징을 기본으로 사용한다.

> 요구 페이징과 쓰기 시점 복사
> 요구 페이징은 요구할 때까지 물리 메모리로 가져오는 것을 최대한 미루고 쓰기 시점 복사도 필요하다고 판단될 때까지 데이터 복사를 최대한 미룬다.

> 스와핑과 게으른 스와퍼
> 프로세스 입장에서는 프로세스를 구성하는 모든 페이지가 한번에 올라오는 게 좋은데 이러한게 순수한 스와핑 요구 할 때 메모리에 올리는 것을 게으른 스와퍼라고 한다.

### 9.1.2 페이징 테이블 엔트리의 구조

가상 메모리의 크기는 물리 메모리와 스왑 영역을 합친 것이다.

이때 스왑 영역은 하드 디스크에 존재하나 메모리 관리자가 관리하는 것으로, 가상 메모리의 구성 요소 중 하나다.

스왑 영역에서 물리 메모리로 데이털르 가져오는 스왑인과 물리 메모리에서 스왑 영역으로 데이터를 내보내는 스왑아웃을 나타낸다.

가상 메모리 시스템에서 사용자의 프로세스는 물리 메모리와 스왑 영역 중 한 곳에 있다.

이때 페이지가 스왑 영역에 있는 경우는 크게 2 가지다.

하나는 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우,

또 하나는 꽉 차서 스왑 영역으로 옮겨 온 경우다.

어떤 것이든 페이지 테이블에는 페이지가 메모리에 있는지 스왑 영역에 있는지 표시해야하는데 이때 유효비트라는 것을 사용한다.

페이지 테이블은 PTE는 페이지 번호, 플래그 비트, 프레임 번호로 구성된다.

PTE를 구성하는 프레임 번호는 가상 주소의 해당 페이지가 어느 프레임에 있는지 알려주는 자료구조로 페이지 테이블의 핵심이다.
이때 메모리 관리자는 찾은 프레임 번호를 이용하여 가상 주소를 물리 주소로 변환한다.

- **접근 비트**:접근 비트는 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려준다. 해당 메모리에 읽거나 실행 작업을 했다면 접근 비트가 1이 된다. 참조 비트라고도 한다.
- **변경 비트**:변경 비트는 페이지가 메모리에 올라온 후 데이터 변경이 있었는지 알려준다. 쓰기나 추가 작업을 했다면 1이 된다. 새로운 값으로 오염되었다는 의미에서 더티 비트라고도 한다.
- **유효 비트**:유효 비트는 페이지가 실제 메모리에 있는지 나타낸다. 현재 비트라고도 한다.
- **읽기 비트, 쓰기 비트, 실행 비트**:읽기 비트, 쓰기 비트, 실행 비트는 페이지에 대한 읽기 쓰기 실행 권한을 나타낸다. - 접근 권한 비트라고도 한다.

### 9.1.3 페이지 부재

가상 메모리의 페이지 테이블에는 페이지가 물리에 있는지 스왑에 있는지 표시하기 위해 유효 비트를 사용한다.

유효 비트가 0일 때는 페이지가 메모리에 있으므로 주소 필드에 물리 메모리의 프레임 번호가 저장된다.

유효 비트가 1일 때는 스왑영역에 있으므로 주소 필드에 스왑 영역 내 페이지의 주소가 저장된다.

프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 페이지 부재라고 한다.

페이지 부재가 발생하면 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야한다

페이지 부재가 발생하면 위와 같은 과정을 거쳐 스왑 영역에 있는 페이지를 메모리의 빈 영역에 올리고 페이지 테이블을 갱신한다.

빈 프레임이 있으면 작업하기가 수월하고 빈 프레임이 없으면 메모리에 있는 프레임 중 하나를 스왑영역에 보내야한다.

이때 어떤 페이지를 보낼지 결정하는 알고리즘을 페이지 교체 알고리즘이라고 한다.

페이지 교체 알고리즘에 의해 보내지는 것을 대상 페이지라고 한다.

메모리가 꽉차면 어떠한 일이 발생하는지 알아보자

1. 해당 페이지의 유효 비트가 1이다. 즉 페이지 부재가 발생한다.
2. 메모리가 꽉차 있는 상태이기 때문에 스왑 영역에 있는 페이지 E를 가져오기 위해 메모리의 페이지 중 하나를 스왑 영역으로 내보내야 한다. 물리 메모리의 프레임 3에 저장된 페이지를 대상 페이지로 선정하여 스왑 영역으로 옮긴다.
3. 이에 따라 대상 페이지 PTE 0의 유효 비트가 0에서 1로 주소 필드 값이 프레임 3에서 스왑 주소 6으로 바뀐다.
4. 스왑 영역 1번에 있던 페이지 E가 프레임 3으로 올라간다 (스왑인)
5. 이에 따라 PTE4의 유효 비트가 1에서 0으로 주소 필드 값이 스왑 주소 1에서 프레임 3으로 바뀐다.

세그먼테이션 오류와 페이지 부재는 비슷해 보여도 많은 차이가 있다.
접근 권한이 없는 메모리를 참조하는 것과, 해당 페이지가 물리 페이지에 없다는 차이가 있다.

## 9.2 페이지 교체 알고리즘

### 9.2.1 페이지 교체 알고리즘의 개요

프로세스가 요구한 페이지가 현재 메모리에 없으면 페이지 부재가 발생하고 스왑 영역에서 페이지를 메모리로 가져오는데 만약 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야 한다.

페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상한다.

#### **페이지 교체 알고리즘의 종류**

페이지 알고리즘의 종류는 간단한 알고리즘 이론적 알고리즘 최적 알고리즘이 있다.

| 종류               | 알고리즘  | 특징                                                                        |
| ------------------ | --------- | --------------------------------------------------------------------------- |
| 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.                       |
| -                  | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.                         |
| 이론적 알고리즘    | 최적      | 미래의 메모리 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
| 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.                       |
| -                  | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.                             |
| -                  | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.                      |
| -                  | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다.                                     |

#### **페이지 교체 알고리즘의 성능 평가 기준**

### 9.2.2 무작위 페이지 교체 알고리즘

### 9.2.3 페이지 교체 알고리즘

### 9.2.4 페이지 교체 알고리즘

### 9.2.5 페이지 교체 알고리즘

#### **페이지 접근 시간에 기반한 구현**

#### **카운터에 기반한 구현**

#### **참조 비트 시프트 방식**

### 9.2.6 페이지 교체 알고리즘

### 9.2.8 변형 FIFO 알고리즘

#### **2차 기회 페이지 교체 알고리즘**

#### **시계 알고리즘**

## 9.3 스레싱과 프레임 할당

### 9.3.1 스레싱

#### **스레싱의 개념**

#### **물리 메모리의 크기와 스레싱**

#### **스레싱과 프레임 할당**

### 9.3.2 정적 할당

#### **균등 할당**

#### **비례 할당**

### 9.3.3 동적 할당

#### **작업집합 모델**

#### **페이지 부재 빈도**

### 9.3.4 전역 교체와 지역 교체
