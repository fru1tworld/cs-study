# 프로세스와 스레드

## 3.1 프로세스의 개요

### 3.1.1 프로세스의 개념

폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 뜻이다.

우리는 프로그램을 짠다 또는 작성한다라고 표현한다.
프로그램이란 어떤 데이터를 사용하여, 어떤 작업을 할지 그 절차를 적어놓은 것이다.

### 3.1.3 프로그램에서 프로세스로의 전환

PCB가 없으면 프로그램이 프로세스로 전환되지 못한다.

PCB에 있는 다양한 정보가 있는데 대표적인 3가지는 다음과 같다.

- 프로세스 구분자 : ID가 존재한다.
- 메모리 관련 정보: 메모리의 어디에 저장되어있는지 알아야 작업이 가능하다. 이때 경계 레지스터와 한계 레지스터가 같이 존재한다.
- 각종 중간 값: PCB에는 프로세스가 사용했던 중간 값이 저장된다. (컨텍스트 스위치에 필요한 정보들)

프로세스 = 프로그램 + PCB
프로그램 = 프로세스 - PCB

### 3.1.4 프로세스의 상태

일괄 작업 시스템에서는 create, run, terminate 중 하나나가 프로세스의 상태가 된다.
시분할 시스템의 프로세스 상태는 일괄 작업 시스템보다 복잡해서
create, ready, running, terminate 로 존재한다

- create: 메모리에 올라와 실행 준비를 완료한 상태로 PCB가 생성됨
- ready: CPU를 얻을 때까지 기다리는 상태
- running: CPU가 실제 작업을 수행하는 상태
- terminate: PCB가 사라진 상태

여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러가 담당한다.
ready -> running : dispatch라 한다.
running -> ready : time out(인터럽트)

프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라 한다.
실행 상태로 들어오면 일정 시간이 흐른 뒤 알려달라고 클록에 요청한다.
타임아웃 밑에 있는 인터럽트의 정확한 표현은 `클록으로부터의 인터럽트`다

효율성을 고려하여 한 가지 상태를 더 만들었는데. 인터럽트 시스템에서 프로세스가 입출력을 요구했다고 가정했을 때 CPU가 직접 데이터를 가져오지 않고 이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없다.

따라서 CPU도 아무 작업을 하지 않고 기다리게 되어 효율성이 떨어지는데, 이는 레스토랑의 예에서 새우가 손질되지 않아 기다리는 상황과 같다.

그래서 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 대기(blocking) 상태라고 한다.
이는 효율성을 높이기 위해 실행 상태에 두지 않고 대기 상태로 옮기는 것을 의미한다.

대기 상태의 프로세스는 요청힌 I/O가 완료되면 I/O 관리자로부터 인터럽트를 받는다.
이때 실행 상태로 돌아가는게 맞지만 두 프로세스의 상태를 변화시켜야하는 복잡한 상황이므로 대기 상태에서 준비 상태로 간다.

이 외에도 생성, 준비, 실행, 대기 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태라고 한다.
프로세스의 상태는 활성 상태 외에 휴식 상태와 보류 상태가 있는데 이 상태들은 조금 특별한 경우에 해당한다.

- **휴식 상태**:
  프로세스가 작업을 일시적으로 쉬고 있는 상태다. (실행을 잠시 멈추고 있음)
  사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있음

-**보류 상태**:
프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다.
일반적인 프로세스 상태를 활성 상태가 되는데 다음과 같은 경우 보류 상태가 된다.

- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
- 프로그램에 오류가 있어서 실행을 미루어야 할 때
- 바이러스와 같이 악의적이라고 판단되는 경우
- 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  ![보류 상태를 포함한 프로세스의 상태 ](<../../../images/쉽게배우는운영체제/보류 상태를 포함한 프로세스의 상태.png>)

이 외에도 여러 가지 이유로 프로세스가 보류 상태에 들어간다.

보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 swap 영역에 보관되는데 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳이다.

보류 상태와 휴식 상태를 구분하면 보류 상태는 스오바 영역에 있는 상태고 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태

보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분된다.

## 3.2 프로세스 제어 블록과 문맥 교환

### 3.2.1 프로세스 제어 블록

PCB는 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조

- **포인터**: 준비 상태나 대기 상태는 큐로 운영되는데, PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 쓴다.
- **프로세스 상태**: 현재 어떠한 상태에 있는지 저장된다.
- **프로세스 구분자**: 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장한다.
- **프로그램카운터**: 다음에 명령어를 실행할 프로그램 카운터의 값을 저장한다.
- **프로세스 우선순위**: 커널 프로세스는 우선순위가 높고, 사용자 프로세스끼리도 다름
- **각종 레지스터 정보**: PCB에는 프로세스가 실행될 때 사용하던 레지스터의 값들이 저장된다.
- **메모리 관리 정보**: 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값이 있음, 그 외 세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관한다.
- **할당된 자원 정보**: 입출력 자원이나 오픈 파일에 대한 정보들이 저장된다.
- **계정 정보**: 계정 번호, CPU 할당 시간, CPU 사용 기간 등에 대한 정보를 말한다.
- **부모 프로세스 구분자와 자식 프로세스 구분자**: 부모 프로세스 구분자 PPID 와 자식 프로세스 구분자 CPID가 저장된다.

### 3.2.2 문맥 교환의 의미

#### 문맥 교환의 의미

P1의 상태를 PCB1에 저장 PCB2에서 P2를 갖고옴 (P1 타임아웃 P2 디스패치)
P2의 상태를 PCB2에 저장 PCB1에서 P1를 갖고옴 (P2 타임아웃 P1 디스패치)

이러한 문맥 교환이 일어나는 상황은 다양하다. 일반적으로 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생하고, 인터럽트가 걸렸을 때도 발생한다.
예를 들어 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 한다면 이는 경계 레지스터의 범위를 벗어나는 것이다.
이때 해당 프로세스를 PCB에 저장하고 인터럽트 관리 프로세스를 실행 상태로 만든다.

이와 같이 인터럽트를 처리할 때도 문맥교환이 발생

#### 문맥 교환과 타임 슬라이스의 크기

너무 길면 끊겨 보이고 너무 짧으면 스위칭 비용이 있어서 적절한 간격을 설정하는 것이 중요
참고로 유닉스 운영체제에서는 10~200ms 사이에서 조정함

## 3.3 프로세스의 연산

### 3.3.1 프로세스의 구조

#### 코드 영역

- 코드 영역은 프로그램의 본문이 기술된 텍스트 영역인데 읽기 전용
- 자기 자신을 수정하는 프로그램은 없기 때문임

#### 데이터 영역

- 데이터 영역은 변수나 파일 등 각종 데이터가 들어감
- 읽기/쓰기

#### 스택 영역

- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
- 프로세스를 작동하기 위해 유지하므로 사용자에게 보이지 않음

### 3.3.2 프로세스의 생성과 복사

### 3.3.3

### 3.3.4

## 3.4

### 3.4.1

### 3.4.2

### 3.4.3

### 3.4.4
