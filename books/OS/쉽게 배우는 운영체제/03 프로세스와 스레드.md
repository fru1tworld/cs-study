# 프로세스와 스레드

## 3.1 프로세스의 개요

### 3.1.1 프로세스의 개념

폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 뜻이다.

우리는 프로그램을 짠다 또는 작성한다라고 표현한다.
프로그램이란 어떤 데이터를 사용하여, 어떤 작업을 할지 그 절차를 적어놓은 것이다.

### 3.1.3 프로그램에서 프로세스로의 전환

PCB가 없으면 프로그램이 프로세스로 전환되지 못한다.

PCB에 있는 다양한 정보가 있는데 대표적인 3가지는 다음과 같다.

- 프로세스 구분자 : ID가 존재한다.
- 메모리 관련 정보: 메모리의 어디에 저장되어있는지 알아야 작업이 가능하다. 이때 경계 레지스터와 한계 레지스터가 같이 존재한다.
- 각종 중간 값: PCB에는 프로세스가 사용했던 중간 값이 저장된다. (컨텍스트 스위치에 필요한 정보들)

프로세스 = 프로그램 + PCB
프로그램 = 프로세스 - PCB

### 3.1.4 프로세스의 상태

일괄 작업 시스템에서는 create, run, terminate 중 하나나가 프로세스의 상태가 된다.
시분할 시스템의 프로세스 상태는 일괄 작업 시스템보다 복잡해서
create, ready, running, terminate 로 존재한다

- create: 메모리에 올라와 실행 준비를 완료한 상태로 PCB가 생성됨
- ready: CPU를 얻을 때까지 기다리는 상태
- running: CPU가 실제 작업을 수행하는 상태
- terminate: PCB가 사라진 상태

여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러가 담당한다.
ready -> running : dispatch라 한다.
running -> ready : time out(인터럽트)

프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라 한다.
실행 상태로 들어오면 일정 시간이 흐른 뒤 알려달라고 클록에 요청한다.
타임아웃 밑에 있는 인터럽트의 정확한 표현은 `클록으로부터의 인터럽트`다

효율성을 고려하여 한 가지 상태를 더 만들었는데. 인터럽트 시스템에서 프로세스가 입출력을 요구했다고 가정했을 때 CPU가 직접 데이터를 가져오지 않고 이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없다.

따라서 CPU도 아무 작업을 하지 않고 기다리게 되어 효율성이 떨어지는데, 이는 레스토랑의 예에서 새우가 손질되지 않아 기다리는 상황과 같다.

그래서 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 대기(blocking) 상태라고 한다.
이는 효율성을 높이기 위해 실행 상태에 두지 않고 대기 상태로 옮기는 것을 의미한다.

대기 상태의 프로세스는 요청힌 I/O가 완료되면 I/O 관리자로부터 인터럽트를 받는다.
이때 실행 상태로 돌아가는게 맞지만 두 프로세스의 상태를 변화시켜야하는 복잡한 상황이므로 대기 상태에서 준비 상태로 간다.

이 외에도 생성, 준비, 실행, 대기 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태라고 한다.
프로세스의 상태는 활성 상태 외에 휴식 상태와 보류 상태가 있는데 이 상태들은 조금 특별한 경우에 해당한다.

- **휴식 상태**:
  프로세스가 작업을 일시적으로 쉬고 있는 상태다. (실행을 잠시 멈추고 있음)
  사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있음

-**보류 상태**:
프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다.
일반적인 프로세스 상태를 활성 상태가 되는데 다음과 같은 경우 보류 상태가 된다.

- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
- 프로그램에 오류가 있어서 실행을 미루어야 할 때
- 바이러스와 같이 악의적이라고 판단되는 경우
- 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  ![보류 상태를 포함한 프로세스의 상태 ](<../../../images/쉽게배우는운영체제/보류 상태를 포함한 프로세스의 상태.png>)

이 외에도 여러 가지 이유로 프로세스가 보류 상태에 들어간다.

보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 swap 영역에 보관되는데 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳이다.

보류 상태와 휴식 상태를 구분하면 보류 상태는 스오바 영역에 있는 상태고 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태

보류 상태는 다시 대기 상태에서 옮겨진 보류 대기 상태와 준비 상태에서 옮겨진 보류 준비 상태로 구분된다.

## 3.2 프로세스 제어 블록과 문맥 교환

### 3.2.1 프로세스 제어 블록

PCB는 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조

- **포인터**: 준비 상태나 대기 상태는 큐로 운영되는데, PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 쓴다.
- **프로세스 상태**: 현재 어떠한 상태에 있는지 저장된다.
- **프로세스 구분자**: 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장한다.
- **프로그램카운터**: 다음에 명령어를 실행할 프로그램 카운터의 값을 저장한다.
- **프로세스 우선순위**: 커널 프로세스는 우선순위가 높고, 사용자 프로세스끼리도 다름
- **각종 레지스터 정보**: PCB에는 프로세스가 실행될 때 사용하던 레지스터의 값들이 저장된다.
- **메모리 관리 정보**: 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값이 있음, 그 외 세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관한다.
- **할당된 자원 정보**: 입출력 자원이나 오픈 파일에 대한 정보들이 저장된다.
- **계정 정보**: 계정 번호, CPU 할당 시간, CPU 사용 기간 등에 대한 정보를 말한다.
- **부모 프로세스 구분자와 자식 프로세스 구분자**: 부모 프로세스 구분자 PPID 와 자식 프로세스 구분자 CPID가 저장된다.

### 3.2.2 문맥 교환의 의미

#### 문맥 교환의 의미

P1의 상태를 PCB1에 저장 PCB2에서 P2를 갖고옴 (P1 타임아웃 P2 디스패치)
P2의 상태를 PCB2에 저장 PCB1에서 P1를 갖고옴 (P2 타임아웃 P1 디스패치)

이러한 문맥 교환이 일어나는 상황은 다양하다. 일반적으로 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생하고, 인터럽트가 걸렸을 때도 발생한다.
예를 들어 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 한다면 이는 경계 레지스터의 범위를 벗어나는 것이다.
이때 해당 프로세스를 PCB에 저장하고 인터럽트 관리 프로세스를 실행 상태로 만든다.

이와 같이 인터럽트를 처리할 때도 문맥교환이 발생

#### 문맥 교환과 타임 슬라이스의 크기

너무 길면 끊겨 보이고 너무 짧으면 스위칭 비용이 있어서 적절한 간격을 설정하는 것이 중요
참고로 유닉스 운영체제에서는 10~200ms 사이에서 조정함

## 3.3 프로세스의 연산

### 3.3.1 프로세스의 구조

#### 코드 영역

- 코드 영역은 프로그램의 본문이 기술된 텍스트 영역인데 읽기 전용
- 자기 자신을 수정하는 프로그램은 없기 때문임

#### 데이터 영역

- 데이터 영역은 변수나 파일 등 각종 데이터가 들어감
- 읽기/쓰기

#### 스택 영역

- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
- 프로세스를 작동하기 위해 유지하므로 사용자에게 보이지 않음

### 3.3.2 프로세스의 생성과 복사

프로세스는 프로그램을 실행할 때 새로 생성된다.

사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 PCB를 생성한다.

하지만 생성 방법에는 실행 중인 프로세스에서 새로운 프로세스를 복사하는 방법도 있다.

#### fork() 시스템 호출의 개념

실행 중인 프로세스에서 새로운 프로세스를 복사하는 함수로 커널에서 제공한다.

결국 복사가 새로 생성하는 것보다 빠르다.

복사를 하면 기존 프로세스는 부모 프로세스가 되고 새로 생긴 프로세스는 자식 프로세스가 된다.

#### fork() 시스템 호출의 동작 과정

- PCB를 포함하여 대부분 복사되어 똑같은 프로세스로 바뀌는데
- PCB 내용 중 일부 변경되는 내용은 다음과 같다.
- PID, PPID, CPID, 메모리의 위치

#### fork() 시스템 호출의 장점

- 프로세스의 생성 속도가 빠르다. : 하드디스크에서 가져오는게 아니라 메모리에서 가져오므로 빠르다.
- 추가 작업 없이 자원을 상속할 수 있다. : 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다. : 부모 프로세스와 자식 프로세스 구분자와 부모 프로세스 구분자로 연결되어있기 때문에, 자식 프로세스를 종료하면 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리 된다.

#### fork() 시스템 호출의 예

pid = fork()을 만나면 똑같은 내용의 자식 프로세스를 하나 생성한다. 이때 fork()문은 부모 프로세스에 0보다 큰 값을 반환하고 자식 프로세스에 0을 반환한다.
따라서 pid == 0이면 자식프로세스 pid > 0 이면 부모 프로세스이다.

```cpp
void main(){{
  int pid = fork();
  if(pid < 0){
    printf("Error");
  }else if(pid > 0){
    printf("Child");
  }else{
    printf("Parent");
  }
}}
```

결론적으로 Parent와 Child 둘다 출력한다.
그러나 두 프로세스는 독립적이므로 어느 것이 먼저 출력될 수 있는지 알 수 없다.

### 3.3.3 프로세스의 전환

fork로 복사하고 새로운 값으로 바꾸는 함수인 exec() 시스ㅡ템 호출을 하면 된다.

#### exec() 시스템 호출의 개념

exec() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수다.

fork()가 똑같은 스파게티를 만드는거라면 exec() 시스템 호출는 스파게티를 우동으로 바꾸는 것.

- fork(): 새로운 프로세스를 복사하는 시스템 호출.
- exec(): 프로세스는 그대로 놔둔채 내용만 바꾼다. 완전 다른 프로세스로 전환된다.

exec()를 사용하는 이유는 프로세스의 구조를 재활용하기 위함이다.

#### exec() 시스템 호출의

exec()을 하면 코드 영역에 있는 기존 내용이 지워지고 새로운 코드로 바뀐다.
그리고 데이터 영역과 스택 영역도 새롭게 된다.
PID, PPID, CPID만 남겨두고 프로세스의 나머지 내용을 새로운 것으로 바꾼다.

#### exec() 시스템 호출의 예

- **부모 프로세스**

```cpp
void main(){{
  int pid = fork();
  if(pid < 0){
    printf("Error");
  }else if(pid > 0){
    execlp("Myplater", "Myplater" Null);
    printf("Child");
  }else{
    wait(NULL);
    printf("mplater Terminated");
    printf("Parent");
  }
}}
```

fork로 자식 프로세스를 생성하고 wait을 사용해서 자식 프로세스가 끝날 때까지 기다린다.
wait()은 자식 프로세스와 동기화하기 위한 코드로 자식 프로세스가 끝날 때까지 부모프로세스가 기다리는 것
새로 생성되면 자식 프로세스와 동일하지만 execlp가 실행되는 순간 코드 영역이 mplayer로 바뀌고 실행이 끝나면 wait()가 있는 곳으로 돌아오고 종료
exec는 결국 PID PPID CPID가 변경되지 않기 때문에, 프로세스가 종료되어도 부모 프로세스로 돌아울 수 있는 것이다.

### 3.3.4 프로세스의 계층 구조

#### **유닉스 프로세스 계층 구조**

유닉스에서 커널이 처음 메모리에 올라와 부팅되면 커널 관련 프로세스를 여러 개 만드는데 그중 init 프로세스는 전체 프로세스의 출발점이 된다.
모든 프로세스는 init 프로세스의 자식이 된다.
init의 자식 프로세스로는 login, shell 프로세스 등이 있다.

#### **프로세스 계층 구조의 장점**

#### **고아 프로세스와 좀비 프로세스**

## 3.4

### 3.4.1

### 3.4.2

### 3.4.3

### 3.4.4
