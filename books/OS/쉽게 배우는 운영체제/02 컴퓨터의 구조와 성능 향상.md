# 2컴퓨터의 구조와 성능 향상

## 2.1. 컴퓨터의 기본 구성

### 2.1.1 하드웨어의 구성

CPU, 메인 메모리, 입출력장치, 저장 장치
이 중에서 CPU와 메인 메모리는 필수 장치 그 외는 보조장치

### 2.1.2 폰노이만 구조

- 폰노이만 구조는 CPU 메모리 입출력장치 저장장치가 버스로 연결된 구조를 의미
- 가장 중요한 특징은 모든 프로그램은 메모리에 올라와야 실행할 수 있다.
- 운영체제도 프로그램이라서 메모리에 올라와야 실행할 수 있음

### 2.1.3 요리사 모형

요리사는 CPU
도마는 메모리
보관 장치는 저장 장치
그 외 보조 요리사도 있음

운영체제의 작업은 크게 프로세스 관리, 메모리 관리 , 저장 장치 관리로 나뉨

### 2.1.4 기초 용어 정리

#### 클록과 헤르츠

- 컴퓨터에서 일정한 박자를 맞추는게 클록이고 틱,펄스, 클록 틱 등으로 불려짐
- CPU가 작업할 때도 펄스에 맞추어 진행됨
- 참고로 CPU의 성능은 헤르츠인데 3GHz의 CPU는 초당 3 \* 10^9임

#### 시스템 버스와 CPU 버스

- 시스템 버스는 메모리와 주변장치를 연결하는 버스
- FSB 3.2GHz는 메인 보드의 버스 클록이 최대 3.2GHz라는 뜻

- CPU 내부에도 여러 장치가 있는데 이들은 CPU 내부 버스로 연결된다.
- 이러한 연결 장치를 BSB 혹은 후면 버스라 한다.

#### 프로그램과 언어

컴파일은 고급언어를 기계어로 번역하는 과정
컴파일을 담당하는 프로그램이 컴파일러
인터프리터는 소스코드를 한 번에 한 문장씩 번역하여 실행

## 2.2 CPU와 메모리

### 2.2.1 CPU의 구성과 동작

#### 산술 논리 연산장치

ALU(Arithmetic and Logic Unit)이라는 산술 논리 연산장치가 데이터를 연산함

#### 제어 장치

CPU에서 작업을 지시하는 부분을 제어장치라 한다.

#### 레지스터

작업에 필요한 데이터를 CPU 내부에 보관하는 곳

#### CPU의 명령어 처리 과정

```
LOAD mem(100), register 2 // 메모리 100을 R2로 이동
LOAD mem(120), register 3 // 메모리 120를 R3으로 이동
ADD register 5, register 2, register 3 R2와 R5를 더하고 R5에 저장
MOVE register 5, mem(160) R5의 결과를 160으로 저장

```

#### 레지스터의 종류

- **데이터 레지스터(DR)** : 메모리에서 가져온 데이터를 임시 보관할 때 사용 대부분 데이터 레지스터라 일반, 범용 레지스터라 함

- **주소 레지스터(AR)** : 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터에 저장

- **프로그램 카운터(PC)** : CPU는 다음에 어떤 명령어를 처리해야 할 지 알아야 한다. 다음에 실행할 명령어의 주소를 가리키기 때문에 프로그램 카운터를 명령어 포인터라 한다.

- **명령어 레지스터(IR)** : 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.

- **메모리 주소 레지스터(MAR)**: 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정하는 데 사용된다. 명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 데이터를 저장한다.

- **메모리 버퍼 레지스터(MBR)**: 메모리에서 가져온 데이터나 메모리로 옮겨갈 데이터를 임시 저장 따라서 항상 메모리 주소 레지스터와 함께 동작

- **프로그램 상태 레지스터(PSR)**: 연산 결과를 저장한다(부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그 등)

#### 버스의 종류

시스템 버스(FSB)는 제어 버스 주소 버스 데이터 버스로 나뉜다.

메모리, 주변 장치는 제어, 주소, 데이터 버스를 모두 참조

---CPU 내부 버스 (BSB)--

제어 장치 -> 제어 버스

메모리 주소 레지스터 -> 주소 버스

메모리 버퍼 레지스터 -> 데이터버스

##### 제어 버스

어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
주변 장치도 마찬가지로 하드디스크에 저장 명령을 내리거나 사운드카드에 소리를 내라는 명령어를 내릴 때 제어 버스를 통해 전달 된다.
제어 버스의 신호는 **CPU, 메모리, 주변장치와 양방향**으로 오고 간다.

##### 주소 버스

메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지 알려주는 정보가 오고 간다.

메모리 주소 레지스터와 연결되어 있으며 **단방향**이다.

CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없다.

##### 데이터 버스

제어 버스가 어떤 작업을 할지 신호를 주고 주소 버스가 위치 정보를 전달하면 데이터가 데이터 버스에 실려 목적지까지 이동한다.
**메모리 버퍼 레지스터와 연결되어 있으며 양방향**이다.

##### CPU 비트의 의미

CPU가 처리할 수 있는 데이터의 최대 크기를 word라고 한다.
32bit CPU는 1word가 32bit
64bit CPU는 1word가 64bit

### 2.2.2 메모리의 종류와 부팅

메모리 주소는 바이트 단위로 저장된다.
메모리 종류는 다양하고 휘발성 비휘발성으로 나뉜다.
휘발성은 보통 캐시로 처리되고 메인메모리는 시간마다 다시 재생해야하는 DRAM 등을 사용
SDRAM은 클록 틱마다 데이터를 저장하는 동기 DRAM

DDR은 클록틱 한번에 2개의 데이터를 전송할 수 있고 현재는 DDR4로 16배 빨라짐

#### 메모리 보호

시분할 시스템에서 메모리 보호를 위해 CPU는 작업의 메모리 범위를 경계 레지스터(시작 주소)와 한계 레지스터(메모리 크기)로 관리
작업 중 메모리 접근이 이 범위를 벗어나면 하드웨어가 이를 감지해 보호
벗어나면 인터럽트를 발생 인터럽트가 바랭하면 모든 작업이 중단되고 운영체제를 깨워서 문제를 처리하고 강제 종료

#### 부팅

운영체제가 메모리에 올려서 실행하는데 운영체제는 누가 메모리에 올려서 실행할까 ?

사용자가 컴퓨터의 전원을 켜면 롬에 저장된 바이오스(BIOS: Basic Input/Output System)이 실행된다.
바이오스는 CPU, 메모리, 하드디스크,키보드, 마우스와 같은 주요 하드웨어가 작동하는지 확인하고 이상이 있으면 삐~ 소리와 함께 오류 메시지를 출력

하드디스크의 마스터 부트 레코드(MBR)에 저장된 작은 프로그램을 메모리로 가져와 실행하는데 운영체제를 실행하기 위한 코드인 **부트스트랩**이 저장되어있음

## 2.3 컴퓨터 성능 향상 기술

### 2.3.1 버퍼

데이터를 하나씩 옮기는거는 효율이 안 좋아서 한꺼번에 전송함으로써 각 장치의 속도를 완화하는게 버퍼

#### 스풀

CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어로 프린터에 사용되는 스풀러가 대표적 인쇄할 내용을 순차적으로 출력하는 소프트웨어로 출력 명령을 내린 프로그램과 독립적으로 작동함
스풀러가 없으면 워드프로세서로 작업하고 출력할 때 출력이 다 될때까지 워드프로세서를 쓸 수 없음

스풀러는 따라서 일종의 버퍼인데 다른점은 프로그램이 버퍼를 공유하기 때문에 어떤 프로그램의 데이터이든 버퍼가 다 차면 이동이 시작된다. 반면 스풀러는 완료될 때까지 끼어들 수 없어 배타적임

#### 하드웨어 안전 제거

버퍼를 사용하면 저장장치 간의 데이터 전송이 지연되는데 따라서 복사해서 바로 제거하면 안되고 종료 버튼 누르지 않고 코드를 뽑는 경우도 마찬가지 fflush를 사용하면 버퍼를 강제로 내보냄

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소
즉 버퍼의 일종
CPU가 앞으로 사용할 것으로 예상되는 것을 미리 가져다 놓는데 이걸 prefetch라 함
캐시 히트 / 캐시 미스 보통 적중률은 90%

컴퓨터 성능을 향상하려면 적중률이 높아야하는데 그 방법은 하나는 그냥 캐시 크기를 늘리면 됨 그런데 비싸서 한계가 있고 지역성 이론이 있음

> NOTE: goto를 사용하면 캐시에 미리 저장된 데이터가 쓸모 없어짐 (다음행이 아니라서)

캐시는 데이터 정합성의 문제도 있는데 캐시의 변경된 데이터를 메모리에 반영하는 방법은 2개이다.

즉시 쓰기와 지연 쓰기

- 즉시 쓰기 : 변경되면 바로 반영 단점 : 느림
- 지연 쓰기 : 모아서 주기적으로 반영 -> 카피백이라 함 근데 캐시와 메모리 간의 불일치가 발생할 수 있음

프로그램의 명령어는 크게 어떤 작업을 할지 나타내는 명령어 부분과 작업 대상인 데이터 부분으로 나눌 수 있다.

캐시는 데이터의 구분 없이 모든 자료를 가져오는 일반 캐시와 명령어와 데이터를 구분하여 가져오는 특수 캐시라는 두 가지 레벨도 구분된다.

명령어 캐시는 명령어 레지스터와 연결되어 있고, 데이터 캐시는 데이터 레지스터와 연결되어 있다.
멸영어 캐시나 데이터 캐시는 CPU 레지스터에 직접 연결되기 때문에 L1 캐시라 부르고 일반 캐시는 메모리와 연결되기 때문에 L2 캐시라 부른다.

### 2.3.2 저장 장치의 계층 구조

1ns 레지스터 <-> 2ns 캐시 <-> 50ns 메모리 <-> 500ns 저장 장치

가격와 컴퓨터의 타협점으로 저장장치의 계층 구조가 존재한다.
컴퓨터는 CPU와 메모리의 협업ㅇ로 작업하지만 메모리 속도가 CPU보다 느리다.
저장 장치의 계층 구조에서는 CPU와 가까운 쪽에 레지스터나 캐시를 배치하여 CPU가 작업을 빨리 진행할 수 있게 한다.
또 한 메모리에서 작업한 내용을 하드디스크와 같이 저렴하고 용량이 큰 저장 장치에 저장할 수 있게 한다.
저장장치의 계층 구조는 사용자가 저렴한 가격으로 용량은 하드디스크처럼 사용하고 작업 속도는 레지스터처럼 빠르게 만들어준다.
저장장치의 계층 구조는 중복되는 데이터의 일관성을 유지하는 것이 문제다.
CPU가 캐시에 저장된 데이터를 변경하면 메모리의 해당 주소에 있는 데이터도 갱신되어야 하는데 내용을 즉시 반영하지 않고 일정 기간 모았다가 한꺼번에 메모리에 반영하는 지연 쓰기의 경우 문제가 된다.
또한 협업 중인 다른 작업에서 해당 데이터를 읽으려 한다면 일관성이 깨질 수 있다.
게다가 갑자기 전원이 꺼지기라도 하면 데이터를 잃을 수도 있다.
버퍼를 사용하는 하드디스크 같은 저장장치에서도 데이터의 일관성이 깨질 수 있다.
버퍼를 비우지 않았는데 하드웨어를 제거하면 일관성이 무너진다.

이러한 문제는 분산된 데이터베이스에 같은 데이터가 저장되는 경우, CPU를 여러 개 사용하는 병렬 컴퓨터의 분산된 메모리 등에서도 발생한다.

### 2.3.3 인터럽트

초기의 컴퓨터 시스템에는 주변장치가 맣지 않아서 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냈는데 이를 폴링 방식이라고 한다.
폴링 방식에서는 CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리한다.

오늘날의 컴퓨터에는 주변장치가 많아서 CPU가 모든 입출력에 관여하면 작업 효율이 떨어져서 인터럽트 방식이 등장했다.
인터럽트는 CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높인다.
즉 데이터의 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있다.
이때 입출력 관리자 또는 장치 관리자가 주방 보조에 해당한다.

인터럽트 방식의 동작 과정

1. CPU가 입출력 관리자에게 입출력 명령을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 CPU에 완료 신호를 보낸다.

입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 한다.
CPU는 입출력 관리자에게 작업 지시를 내리고 다른 일을 하다가 완료 신호를 받으면 하던 일ㅇ르 중단하고 옮겨진 데이터를 처리한다. 이 처럼 하던 작업을 중단하고 처리해야하는 신호라는 의미에서 인터럽트라는 이름이 붙었다.

인터럽트 번호를 사용해서 어떤 장치의 작업이 끝났는지를 CPU에 알려준다
예를 들어 윈도우는 IRQ라고 부른다.

참고로 CPU가 입출력 관리자에게 여러 개의 입출력 작업을 동시에 시킬 수 있는데 그때마다 인터럽트를 여러 번 사용하는게 아니라 여러 개의 인터럽트를 하나의 배열로 만든 인터럽트 벡터를 사용한다.

입출력 작업이 완료되었음을 CPU에 알리는 것 외에도 다양한 종류의 인터럽트가 존재
0으로 나눌 때도 인터럽트 발생

### 2.3.4 직접 메모리 접근

인터럽트 방식을 이해헀다면 직접 메모리 접근도 수비게 이해할 수 있다.
인터럽트 방식이 생기고 나서 입출력 관리자가 데이터 입출력을 맡게 되었다.
메모리는 CPU만 접근 권한을 가진 작업 공간이라 입출력 관리자의 접근이 불가
입출력 관리자에게는 허락없이 메모리에 접근할 수 있는 권한이 필요한데 이를 DMA라 한다.

직접 메모리 접근 제어기

### 2.3.5 메모리 맵 입출력

직접 메모리 접근은 인터럽트 방식의 시스템을 구성하는 필수 요소다.
그러나 직접 메모리 접근을 사용하면 메모리가 복잡해진다.
메모리에는 CPU가 사용하는 데이터와 입출력장치가 사용하는 데이터가 섞여있다.
직접 메모리 접근을 통해 들어온 데이터를 메모리에 아무렇게 둔다면 CPU가 사용하는 데이터와 석여서 관리가 어려울 것으로 나누어 해결하는 방법이 도입되었고 데이터를 위한 공간을 분리하는 것이다.
이렇게 일정 공간을 입출력에 할당하는 기법을 메모리 맵 입출력이라고 한다 (MMO[Memory Mapped I/O])

### 2.3.6 사이클 훔치기

메모리는 CPU가 관할하는 중요한 장치이지만 직접 메모리 접근을 통해 입출력장치도 메모리를 사용할 수 있게 되었다.
그런데 CPU와 직접 메모리 접근이 동시에 메모리에 접근하려 한다면 어떤 일이 발생할까 ?
이 경우에는 누군가는 양보해야 하는데 보통은 CPU가 메모리 사용 권한을 양보한다.
CPU의 작업 속도보다 입출력장치의 속도가 느리기 때문이다.
CPU입장에서는 직접 메모리 접근 사이클을 훔쳐 간 것이 되기 때문에 이러한 상황을 사이클 훔치기(cycle stealing)이라 부른다.

## 2.4 멀티 프로세싱

### 2.4.1 멀티코어 시스템

과거에는 한 대에 CPU가 하나 달린 시스템이었는데 CPU의 성능을 향상하여 만들었다.
이런 시스템에서 성능을 향상하는 방법은 CPU의 클록을 높이거나 캐시의 크기를 늘리는 것 그러나 발열이 생겨서 현재의 기술로는 5GHz를 넘길 수 없다.
그래서 핵심 기능을 가진 코어를 여러 개 만들거나 동시에 실행 가능한 명령의 개수를 늘리는 방법을 사용한다.
컴퓨터의 성능을 높이기 위해 여러 개 설치하여 사용하는 시스템을 멀티 프로세서 시스템이라 부른다.
멀티 프로세서 시스템에서는 프로세서마다 레지스터와 캐시를 가지며, 모든 프로세서가 시스템 버스를 통하여 메인메모리를 공유한다.
멀티 프로세서 시스템의 장점은 많은 작업을 동시에 실행시킬 수 있다는 점
프로세서가 하나만 있는 단일 프로세서 시스템을 멀티 프로세서 시스템으로 바꾸기 위해서는
보드의 설계를 ㅍㄹ요해 많은 변화가 필요한데 기존 시스템을 유지한 채 멀티 프로세싱을 할 수 있게 하는 시스템이 멀티코어 시스템
멀티코어 시스템에서는 하나의 칩에 CPU의 핵심이 되는 코어를 여러 개 만들어 여러 작업을 동시에 처리할 수 있다.

### 2.4.2 CPU 멀티 스레드

하나의 코어에서 2개 이상의 명령어를 처리하는 방법도 있다.
이를 명령어 병렬처리라고 한다.
하나의 작업 공간에서 여러 개의 작업을 동시에 조리하는 것은 하나의 코어에 여러 개의 스레드를 사용하는 방식과 같다.
여기서 스레드란 CPU가 처리할 수 있는 작업의 단위를 나타낸다.
여러 개의 스레드를 동시에 처리하는 방법을 CPU 멀티 스레드라 한다.
명령어 병렬 처리를 사용하면 코어는 하나이지만 2개의 명령어가 거의 동시에 실행되어 마치 코어가 2개 있는 것 처럼 보이는데 이를 인텔 CPU에서는 하이퍼스레드라 부른다.

현대의 CPU는 하나의 칩에 멀티코어와 명령어 병렬 처리 기능을 한꺼번에 구현하였다.
예를 들어 인텔 i7- 3770 CPU는 4코어와 하이퍼 스레드를 지원한다.

CPU 관련 통용 법칙
**1. 무어의 법칙**

-CPU는 24개월마다 2배 빨라진다는 주장

**2. 암달의 법칙**

- 시스템의 일부를 개선할 때 전체 시스템에 미치는 영향과의 관계를 수식으로 나타넀다
- 이 법칙에 따르면 CPU를 늘린다고 2배 빨라지지는 않음
- 싱글코어에서 듀얼코어로 바꾼다해도 다른 부품의 병목 현상으로 CPU 성능이 2배가 되지는 않음
