# 4 CPU 스케줄링

## 4.1 스케줄링의 개요

프로세스는 생성, 준비, 실행, 대기와 같은 여러 상태를 거치며 작업이 이뤄지는데
CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정한다.

### 4.1.1 레스토랑 관리자의 스케줄링

CPU 스케줄러는 프로세서 스케줄러라고도 한다.

### 4.1.2 CPU 스케줄링

CPU 스케줄링은 고수준, 중간 수준, 저 수준 스케줄링으로 구분된다.

작업 대기 <-> 보류 프로세스 (고 수준 스케줄링 | <- - > )
보류 프로세스 <-> 활성 프로세스 (중간 수준 스케줄링 | 보류 <- - > 활성화 )
활성 프로세스 <-> 실행 프로세스 (저 수준 스케줄링 | 대기 또는 타임 아웃<- - > 프로세스 선정)

#### **고수준 스케줄링**

장기 스케줄링 또는 작업 스케줄링이라고 한다.
고수준 스케줄링은 시스템 내의 전체 작업 수를 조절하는 것이다.
작업은 운영체제에서 다루는 일의 가장 큰 단위로 1개 또는 여러 프로세스로 이루어진다.
여기서 어떤 작업을 시스템이 받아들일지 거부할지 결정한다.
작업 요청이 오면 스케줄러가 시스템의 상황을 고려하여 작업을 승인할지, 거부할지 결정하므로 고수준 스케줄링을 **승인 스케줄링**이라고도 한다.
전체 시스템의 부하를 고려하여 작업을 시작할지 말지 결정하는데 이 결정에 따라 전체 프로세스 수가 결정된다.
이를 멀티프로그래밍 정도라 한다.

#### **저수준 스케줄링**

가장 작은 단위의 스케줄링을 저수준 스케줄링이라 한다.
어떤 프로세스에 CPU를 할당할 지 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.
준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고 실행 상태에 있는 프로세서를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보내는 것이다.
짧은 시간에 일어나므로 **단기 스케줄링**이라고도 한다.

특별한 명시가 없으면 저 수준 스케줄러를 의미한다.

#### **중간수준 스케줄링**

시스템의 부하를 조절하려면 고수준 스케줄링 대신 중간 수준 스케줄링을 고려해야한다.
전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 보류 상태로 보낸다.
보류된 프로세스는 처리 능력에 여유가 생기면 다시 활성화된다.

중간 수준 스케줄링은 정지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.
즉 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원한다.
이는 프로세스의 상태 중 보류 상태에 해당하며, 저수준 스케줄링이 원만하게 이루어지도록 완충(buffer)하는 역할을 한다

### 4.1.3 스케줄링의 목적

- **공평성**: 모든 프로세서가 자원을 공평하게 배정받아야 하며, 그 과정에서 특정 프로세스가 배제되어서는 안 된다.
- **효율성**: 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
- **안정성**: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다.
- **확장성**: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
- **반응 시간 보장**: 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- **무한 연기 방지**: 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

## 4.2 스케줄링 시 고려 사항

### 4.2.1 선점형 스케줄링 비선점형 스케줄링

- **선점형 스케줄링**: CPU가 할당받아 실행 중이더라도 운영체제가 강제로 빼앗을 수 있는 스케줄링 방식
- **비선점형 스케줄링**: 어떤 프로세스가 CPU를 점유하면 다른 프로세서가 이를 빼앗을 수 없는 스케줄링 방식

선점형 스케줄링은 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단 시키고 새로운 작업을 시작할 수 있다.
대표적인 예는 인터럽트가 있다.

커널을 깨워서 인터럽트를 처리하게 하며, 인터럽트 처리가 완료되면 원래로 돌아간다.
비선점형 스케줄링에서는 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행된다.
비선점은 선점형에 비해 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적다 그러나 CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어진다.
과거의 일괄 작업 시스템에서 사용하던 방식이다.

선점형 방식에서도 비선점형형 프로세스가 있을 수 있는데 예를 들어 시스템을 백업하는 프로세스는 비선점형으로 작동한다.
이렇게 선점형 프로세스와 비선점형 프로세스가 혼재하는 경우 비선점형 프로세스의 중요도를 매우 낮게 설정하여 선점형 프로세스에 영향을 덜 미치도록 한다.

### 4.2.2 프로세스 우선순위

프로세스의 우선순위가 없다는 것은 모든 프로세스의 중요도가 같다는 의미다.

우선순위가 없는 모든 프로세스는 준비 상태에 한 줄로 서서 순차적으로 실행되는데, 이는 준비 상태의 큐가 하나인 것과 마찬가지다.
보통은 도착한 순서대로 자리를 배정받는다.

하지만 대부분의 스케줄러는 우선순위를 사용한다.
우선순위가 있다는 것은 프로세스의 중요도가 다르다는 의미다.
프로세스는 크게 커널 프로세스와 일반 프로세서로 나뉘는데 커널 프로세스가 일반 프로세스보다 우선순위가 높다.

우선순위가 높다는 것은 더 빨리 실행된다는 뜻이다.

일반 프로세스도 다를 수 있는데 워드프로세서보다 비디오 플레이어가 더 높다 왜냐면 타이핑하는 속도가 CPU의 연산 속도보다 느리기 때문에 그렇다.

참고로 유닉스에서는 nice 명령어로 우선순위를 조절할 수 있고 관리자만 높일 수 있고 다른 사용자는 낮출 수 만 있음

### 4.2.3 CPU 집중 프로세스 입출력 집중 프로세스

CPU burst, 입출력 작업을 I/O burst 라고 한다.
CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있다.
둘이 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있다.
만약 CPU 집중 프로세스가 먼저 실행 상태로 들어가면 해당 타임 슬라이스를 다 쓸 때까지 다른 프로세스는 CPU를 사용할 수 없다.

### 4.2.4 전면 프로세스와 후면 프로세스

### 4.2.5 정리

## 4.3 다중 큐

### 4.3.1 준비 상태의 다중 큐

### 4.3.2 대기 상태의 다중 큐

## 4.4 스케줄링 알고리즘

### 4.4.1 스케줄링 알고리즘

### 4.4.2 FCFS 스케줄링

### 4.4.3 SJF 스케줄링

### 4.4.4 HRN 스케줄링

### 4.4.5 라운드 로빈 스케줄링

### 4.4.6 SRT 스케줄링

### 4.4.7 우선순위 큐 스케줄링

### 4.4.8 다단계 큐 스케줄링

### 4.4.9 다단계 피드백 큐 스케줄링

## 4.5 인터럽트 처리

### 4.5.1 인터럽트의 개념

### 4.5.2 동기적 인터럽트와 비동기적 인터럽트

### 4.5.3 인터럽트 처리 과정

### 4.5.4 인터럽트와 이중 모드
