# 4 CPU 스케줄링

## 4.1 스케줄링의 개요

프로세스는 생성, 준비, 실행, 대기와 같은 여러 상태를 거치며 작업이 이뤄지는데
CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정한다.

### 4.1.1 레스토랑 관리자의 스케줄링

CPU 스케줄러는 프로세서 스케줄러라고도 한다.

### 4.1.2 CPU 스케줄링

CPU 스케줄링은 고수준, 중간 수준, 저 수준 스케줄링으로 구분된다.

작업 대기 <-> 보류 프로세스 (고 수준 스케줄링 | <- - > )
보류 프로세스 <-> 활성 프로세스 (중간 수준 스케줄링 | 보류 <- - > 활성화 )
활성 프로세스 <-> 실행 프로세스 (저 수준 스케줄링 | 대기 또는 타임 아웃<- - > 프로세스 선정)

#### **고수준 스케줄링**

장기 스케줄링 또는 작업 스케줄링이라고 한다.
고수준 스케줄링은 시스템 내의 전체 작업 수를 조절하는 것이다.
작업은 운영체제에서 다루는 일의 가장 큰 단위로 1개 또는 여러 프로세스로 이루어진다.
여기서 어떤 작업을 시스템이 받아들일지 거부할지 결정한다.
작업 요청이 오면 스케줄러가 시스템의 상황을 고려하여 작업을 승인할지, 거부할지 결정하므로 고수준 스케줄링을 **승인 스케줄링**이라고도 한다.
전체 시스템의 부하를 고려하여 작업을 시작할지 말지 결정하는데 이 결정에 따라 전체 프로세스 수가 결정된다.
이를 멀티프로그래밍 정도라 한다.

#### **저수준 스케줄링**

가장 작은 단위의 스케줄링을 저수준 스케줄링이라 한다.
어떤 프로세스에 CPU를 할당할 지 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.
준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고 실행 상태에 있는 프로세서를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보내는 것이다.
짧은 시간에 일어나므로 **단기 스케줄링**이라고도 한다.

특별한 명시가 없으면 저 수준 스케줄러를 의미한다.

#### **중간수준 스케줄링**

시스템의 부하를 조절하려면 고수준 스케줄링 대신 중간 수준 스케줄링을 고려해야한다.
전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 보류 상태로 보낸다.
보류된 프로세스는 처리 능력에 여유가 생기면 다시 활성화된다.

중간 수준 스케줄링은 정지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.
즉 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원한다.
이는 프로세스의 상태 중 보류 상태에 해당하며, 저수준 스케줄링이 원만하게 이루어지도록 완충(buffer)하는 역할을 한다

### 4.1.3 스케줄링의 목적

- **공평성**: 모든 프로세서가 자원을 공평하게 배정받아야 하며, 그 과정에서 특정 프로세스가 배제되어서는 안 된다.
- **효율성**: 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
- **안정성**: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다.
- **확장성**: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
- **반응 시간 보장**: 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- **무한 연기 방지**: 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

## 4.2 스케줄링 시 고려 사항

### 4.2.1 선점형 스케줄링 비선점형 스케줄링

- **선점형 스케줄링**: CPU가 할당받아 실행 중이더라도 운영체제가 강제로 빼앗을 수 있는 스케줄링 방식
- **비선점형 스케줄링**: 어떤 프로세스가 CPU를 점유하면 다른 프로세서가 이를 빼앗을 수 없는 스케줄링 방식

선점형 스케줄링은 운영체제가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단 시키고 새로운 작업을 시작할 수 있다.
대표적인 예는 인터럽트가 있다.

커널을 깨워서 인터럽트를 처리하게 하며, 인터럽트 처리가 완료되면 원래로 돌아간다.
비선점형 스케줄링에서는 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지는 계속 실행된다.
비선점은 선점형에 비해 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적다 그러나 CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되어 전체 시스템의 처리율이 떨어진다.
과거의 일괄 작업 시스템에서 사용하던 방식이다.

선점형 방식에서도 비선점형형 프로세스가 있을 수 있는데 예를 들어 시스템을 백업하는 프로세스는 비선점형으로 작동한다.
이렇게 선점형 프로세스와 비선점형 프로세스가 혼재하는 경우 비선점형 프로세스의 중요도를 매우 낮게 설정하여 선점형 프로세스에 영향을 덜 미치도록 한다.

### 4.2.2 프로세스 우선순위

프로세스의 우선순위가 없다는 것은 모든 프로세스의 중요도가 같다는 의미다.

우선순위가 없는 모든 프로세스는 준비 상태에 한 줄로 서서 순차적으로 실행되는데, 이는 준비 상태의 큐가 하나인 것과 마찬가지다.
보통은 도착한 순서대로 자리를 배정받는다.

하지만 대부분의 스케줄러는 우선순위를 사용한다.
우선순위가 있다는 것은 프로세스의 중요도가 다르다는 의미다.
프로세스는 크게 커널 프로세스와 일반 프로세서로 나뉘는데 커널 프로세스가 일반 프로세스보다 우선순위가 높다.

우선순위가 높다는 것은 더 빨리 실행된다는 뜻이다.

일반 프로세스도 다를 수 있는데 워드프로세서보다 비디오 플레이어가 더 높다 왜냐면 타이핑하는 속도가 CPU의 연산 속도보다 느리기 때문에 그렇다.

참고로 유닉스에서는 nice 명령어로 우선순위를 조절할 수 있고 관리자만 높일 수 있고 다른 사용자는 낮출 수 만 있음

### 4.2.3 CPU 집중 프로세스 입출력 집중 프로세스

CPU burst, 입출력 작업을 I/O burst 라고 한다.
CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있다.
둘이 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있다.
만약 CPU 집중 프로세스가 먼저 실행 상태로 들어가면 해당 타임 슬라이스를 다 쓸 때까지 다른 프로세스는 CPU를 사용할 수 없다.

### 4.2.4 전면 프로세스와 후면 프로세스

워드 프로세서를 사용하면서 큰 파일을 압축하는 경우를 생각해 보자, 워드 프로세서는 사용자에게서 키보드로 입력을 받기 때문에 전면 프로세스로 실행되고,
압축 프로그램은 압축이 끝날 때까지 사용자 입력이 필요 없기 때문에 후면 프로세스로 실행된다.

전면 프로세스는 GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스를 말한다.
현재 입력과 출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 한다.
후면 프로세스는 사용자와 상호작용이 없는 프로세스다.
압축 프로그램처럼 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 한다.

전면 프로세스는 즉각 받아야하지만 후면 프로세스는 상호작용이 없어서 전면 프로세스가 우선 순위가 더 높다

### 4.2.5 정리

우선순위 높음 --- 우선순위 낮음
커널 프로세스 <-> 일반 프로세스
전면 프로세스 <-> 후면 프로세스
대화형 프로세스 <-> 일괄 처리 프로세스
입출력 집중 프로세스 <-> CPU 집중 프로세스

커널 일반 전면 후면은 명확해서 구분할 수 있으나 나머지 기준은 그러나 명확하게 구분이 어려워서 우선순위를 고려하기 어려울 수도 있다.

## 4.3 다중 큐

### 4.3.1 준비 상태의 다중 큐

중요도는 PCB에 표시된다.
스케줄러는 PCB를 뒤져서 가장 높은 우선순위 프로세스에 CPU를 할당한다.
준비 상태의 다즁 큐를 나타내는데 우선순위 별로 다중 큐를 준비한다.
준비 큐를 몇 개로 나눌지, 여러 개의 준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당 할지 결정하는 일은 스케줄링 알고리즘에 달라진다.

프로세스 우선순위 배정 방식에는

- **고정 우선순위 방식**: 운영체제가 부여하면 바뀌지 않음
- **변동 우선순위 방식**: 프로세스 생성시 부여받은 우선순위가 작업 중간에 변하는 방식

### 4.3.2 대기 상태의 다중 큐

대기 상태에서도 다중 큐를 사용한다.
대기 상태는 입출력이 완료되기를 기다리는 프로세스가 모여있는 곳이다.
시스템 내에는 다양한 종류의 입출력장치가 있기 때문에 한 곳에 모아 놓으면 관리가 어렵다.

이러한 대기 상태의 다중 큐는 입출력 종류에 따라 나뉜다.

준비 상태와 대기 상태의 차이가 있는데 준비 상태는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당하는 반면
대기 큐는 여러 개의 PCB를 동시에 꺼내어 준비 상태로 옮긴다.

이렇게 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터라는 자료 구조를 사용한다.
인터럽트 벡터에는 동시에 완료된 입출력 정보와 처리 방법이 담겨 있는데, 이 정보에 따라 완료된 프로세스 제어 블록은 모두 준비 상태로 이동한다.

입출력 장치는 CPU나 메모리보다 느리기 때문에 작업 속도를 높이기 위해 작업 순서를 뒤바꾸는 경우가 있는데 이때는 나중에 요청된 작업이 먼저 처리되기도 한다.

## 4.4 스케줄링 알고리즘

비선점형 아록리즘은 효율이 떨어져서 지금은 거의 사용되지 않음

비선점형 알고리즘

- FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링
  선점형 알고리즘

- 라운드 로빙 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링

### 4.4.1 스케줄링 알고리즘의 선택 기준

스케줄링 알고리즘의 평가 기준은 다음과 같다.

- **CPU 사용률**: 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법이다. 가장 이상적인 수치는 100%이고 실제로는 여러 가지 이유로 90%에도 못 미친다.
- **처리량**: 시스템이 정상적으로 작동한다면 일정 시간 후 작업이 끝난다 처리량은 단위 시간당 작업을 마친 프로세스의 수로 이 수치가 클수록 좋은 알고리즘이다.
- **대기 시간**: 작업을 요청하더라도 실제 작업이 이루어지기 전까지 대기시간이 필요한데 대기 시간이 짧을 수록 좋다.
- **응답 시간**: 대화형 시스템에서는 얼마 만에 반응하는지가 중요하다. 프로세스 시작 후 첫 번째 출력 또는 반응이 나올때 까지 걸리는 시간으로 이 역시 짧을수록 좋다.
- **반환 시간**: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는데 걸리는 시간이다. 반환 시간은 대기 시간과 실행 시간을 더한 값이다.

CPU 알고리즘의 효율성을 평가할 때 사용률과 처리량은 계산하기 어렵다.
주로 대기 시간, 응답 시간, 반환 시간, 실행 시간을 계산한다.

- **대기 시간**: 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
- **응답 시간**: 첫 작업을 시작한 후 출력이 나오기까지 걸리는 시간
- **실행 시간**: 프로세스 작업이 시작된 후 종료되기까지 걸리는 시간
- **반환 시간**: 대기 시간을 포함하여 실행이 종료될 때까지 걸리는 시간

주로 평균 대기 시간을 본다.
평균 대기 시간은 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값이다.

### 4.4.2 FCFS 스케줄링

FIFO는 보통 큐에서 사용하는 말이라서
First Come First Serve라고 한다.

### 4.4.3 SJF 스케줄링

Shortest Job First 스케줄링은 가장 짧은 작업 시간부터 한다.

##### 1. 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.

과거에는 전체 연산 개수만 정하면 알 수 있었는데 현대의 프로세스는 상호자와 빈번하게 상호작용 하므로 예측하기 어렵다.

##### 2. SJF 알고리즘은 공평성에 위배된다.

계속 짧은 작업 시간이 들어오면 계속 연기된다. 이를 아사(starvation)현상 혹은 무한 봉쇄(infinite blocking) 현상이라 한다.

### 4.4.4 HRN 스케줄링

Highest Response Ratio Next(최고 응답률 우선 스케줄링)
기다린 시간과 CPU 사용 시간을 고려하여 스케줄링하는 방식이다.

HRN 스케줄링에서 프로세스의 우선순위를 결정하는 기준은 다음과 같다.
우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간

실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 시간을 완화한다.
다만 공평성이 위배되어 많이 사용하지 않음

### 4.4.5 라운드 로빈 스케줄링

한 프로세스가 할당받은 시간 동안 작업을 못하면 준비 큐의 맨 뒤로 간다.
앞의 긴 작업을 무작정 기다리는 콘 보이 효과가 줄어든다.

RR은 문맥 교환 비용에 의해 비효율적이다.

### 4.4.6 SRT 스케줄링

SRT( Shortest Remaining Time)은 SJF 스케줄링과 RR 혼합

SRT는 기본적으로 RR을 사용하지만 남은 시간이 가장 적은 프로세스를 선택한다.

현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고 SJF에 없는 작업이 추가된다.
SRT는 SJF와 마찬가지로 운영체제가 프로세스 종료시간을 예측하기 어려워서 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

### 4.4.7 우선순위 스케줄링

우선순위를 반영한 스케줄링 알고리즘
우선순위는 비선점형과 선점형 모두 적용할 수 있다.

- **(비선점형 방식) SJF 스케줄링**: 작업 시간이 짧은 프로세스에 높은 우선순위 부여
- **(비선점형 방식) HRN 스케줄링**: 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위 부여
- **(선점형 방식) SRT 스케줄링**: 남은 시간이 짧은 프로세스에 높은 우선순위 부여

이러한 우선순위 스케줄링은 고정 우선순위와 변동 우선순위로 나뉜다.

### 4.4.8 다단계 큐 스케줄링

MLQ(Multi Level Queue) 스케줄링은 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
우선순위는 고정형 우선순위를 사용하며, 상단 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다.
다단계 스케줄링은 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식

다단계 큐 스케줄링에서는 우선순위가 높은 상위 큐 프로세스의 작업이 끝나기 전에 하위 큐 프로세스의 작업을 할 수 없다.

### 4.4.9 다단계 피드백 큐 스케줄링

우선순위가 낮은 프로세스에 불리한 MLQ 방식의 문제점을 보완한 방법

각 단계 피드백 큐는 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다.
물론 우선순위가 낮아지더라도 커널 프로세스가 일반 프로세스 큐에 삽입되지는 않음

또 다른 특징은 우선순위에 따라 타임슬라이스가 다르다.
우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커진다.

유닉스가 10~200 초를 사용하는 이유는 이러한 MLFQ를 사용하기 때문이다.

## 4.5 인터럽트 처리

### 4.5.1 인터럽트의 개념

### 4.5.2 동기적 인터럽트와 비동기적 인터럽트

### 4.5.3 인터럽트 처리 과정

### 4.5.4 인터럽트와 이중 모드
