# 7. 물리 메모리 관리

## 7.1 메모리 관리의 개요

폰 노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리 공간에 올라와야 실행할 수 있다.
모든 프로그램은 하드디스크나 SSD와 같은 보조 저장 장치에 보관되어 있다. 프로그램이 실행되어 프로세스가 된다는 것은 저장 장치에 있던 프로그램이 메모리로 올라온다는 뜻이다.

이 책에서는 메인 메모리를 메모리라 한다. 의미를 분명하게 나타내야 하는 경우에만 메인 메모리나 물리 메모리라 표기한다.

### 7.1.1 메모리 이해하기

메모리의 구조는 1바이트 크기로 나뉜다. 1B로 나뉜 각 영역은 주소로 구분되는데 보통 0번지부터 시작한다.
CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다.

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.
전원 버튼을 누르면 사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정 즉 부팅이 이뤄지는데 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

CPU 입장에서 메모리는 매우 느리다. CPU 안에 있는 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 몇 배 이상 느리다.
예를 들어 CPU 안에 있는 레지스터에 접근하려면 1~2클록이면 되지만 메모리에 있는 데이터를 CPU로 가져오려면 그 10배 이상의 클록이 필요하다.
이러한 속도 차이를 극복 하기 위해 CPU 안에 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와(prefetch) 작업한다.

또는 하드디스크나 SSD 같은 저장 장치를 메인 메모리의 보조 저장장치로 활용한다.

> **메모리에 있는 데이터를 CPU로 가져오는 과정**
> CPU가 메모리에 있는 데이터를 가져오기까지 필요한 과정을 생각해보면 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다. 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다. 메모리 버퍼 레지스터에 있는 데이터가 레지스터로 옮겨지면 메모리 접근 작업이 끝난다. FSB의 속도를 고려하면 CPU가 메모리에 접근하는 작업은 10클록 이상 걸린다

### 7.1.2 메모리 관리의 이중성

메모리 관리 시스템(MMS)이 메모리 관리를 한다.
현대 운영체제는 시분할 시스템으로 운영되어 모든 응용 프로그램이 메모리에 올라와 실행되므로 메모리 관리가 복잡하다.

프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데
이를 메모리 관리의 이중성이라 한다.

### 7.1.3 소스코드의 번역과 실행

프로그램은 메모리 관리와 밀접한 관련이 있다.

#### **소스코드의 번역 방식**

컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며, 작성한 프로그램은 보통 컴파일러를 사용하여 실행 가능한 코드로 변경한다.

#### **컴파일러**

#### **컴파일러**

### 7.1.4 메모리 관리 작업

## 7.2 메모리 주소

### 7.2.1 32bit CPU와 64bit CPU의 차이

### 7.2.2 논리 주소와 물리 주소

## 7.3 단일 프로그래밍 환경의 메모리 할당

### 7.3.1 메모리 오버레이

### 7.3.2 스왑

## 7.4 다중 프로그래밍 환경의 메모리 할당

### 7.4.1 메모리 분할 방식

### 7.4.2 가변 분할 방식의 메모리 관리

### 7.4.3 고정 분할 방식의 메모리 관리

### 7.4.4 버디 시스템

## 7.5 분할 컴파일과 메모리 관리

### 7.5.1 분할 컴파일

### 7.5.2 변수와 메모리 할당
