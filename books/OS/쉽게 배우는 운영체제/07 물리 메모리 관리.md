# 7. 물리 메모리 관리

## 7.1 메모리 관리의 개요

폰 노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리 공간에 올라와야 실행할 수 있다.
모든 프로그램은 하드디스크나 SSD와 같은 보조 저장 장치에 보관되어 있다. 프로그램이 실행되어 프로세스가 된다는 것은 저장 장치에 있던 프로그램이 메모리로 올라온다는 뜻이다.

이 책에서는 메인 메모리를 메모리라 한다. 의미를 분명하게 나타내야 하는 경우에만 메인 메모리나 물리 메모리라 표기한다.

### 7.1.1 메모리 이해하기

메모리의 구조는 1바이트 크기로 나뉜다. 1B로 나뉜 각 영역은 주소로 구분되는데 보통 0번지부터 시작한다.
CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다.

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.
전원 버튼을 누르면 사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정 즉 부팅이 이뤄지는데 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

CPU 입장에서 메모리는 매우 느리다. CPU 안에 있는 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 몇 배 이상 느리다.
예를 들어 CPU 안에 있는 레지스터에 접근하려면 1~2클록이면 되지만 메모리에 있는 데이터를 CPU로 가져오려면 그 10배 이상의 클록이 필요하다.
이러한 속도 차이를 극복 하기 위해 CPU 안에 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와(prefetch) 작업한다.

또는 하드디스크나 SSD 같은 저장 장치를 메인 메모리의 보조 저장장치로 활용한다.

> **메모리에 있는 데이터를 CPU로 가져오는 과정**
> CPU가 메모리에 있는 데이터를 가져오기까지 필요한 과정을 생각해보면 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다. 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다. 메모리 버퍼 레지스터에 있는 데이터가 레지스터로 옮겨지면 메모리 접근 작업이 끝난다. FSB의 속도를 고려하면 CPU가 메모리에 접근하는 작업은 10클록 이상 걸린다

### 7.1.2 메모리 관리의 이중성

메모리 관리 시스템(MMS)이 메모리 관리를 한다.
현대 운영체제는 시분할 시스템으로 운영되어 모든 응용 프로그램이 메모리에 올라와 실행되므로 메모리 관리가 복잡하다.

프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데
이를 메모리 관리의 이중성이라 한다.

### 7.1.3 소스코드의 번역과 실행

프로그램은 메모리 관리와 밀접한 관련이 있다.

#### **소스코드의 번역 방식**

컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며, 작성한 프로그램은 보통 컴파일러를 사용하여 실행 가능한 코드로 변경한다.

언어 번역 프로그램은 고급언어로 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역한다.

대표적으로 컴파일러와 인터프리터다.

#### **컴파일러**

##### **오류 발견**

컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로 선언하지 않은 변수를 사용하지 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.

##### **소스 코드 최적화**

컴파일러 방식을 사용하는 두 번째 목적은 최적화다. 소스코드에서도 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져 실행 속도가 빨라진다.

컴파일러는 실행 전 소스 코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.

그러나 인터프리터는 한 행씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하거나 필요 없는 변수를 확인할 수 없다.

#### **컴파일러의 컴파일 과정**

컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다. 이렇게 해서 만들어진 기계어 코드가 목적 코드로 확장자는 obj다

기계어라고 하지 않고 목적 코드라고 하는 이유는 아직 처리할 단계가 남아있기 때문이다.

목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.

라이브러리는 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로 프로그래머가 직접 만들기 어렵거나 만드는데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것이다.

C 언어 코드에는 printf()문이 있는데 컴파일러는 라이브러리 연결 단계에서 printf() 문에 해당하는 기계어 코드를 <stdio.h> 라이브러리에서 가져와 목적 코드에 삽입한다.

printf 문에 더 좋은 기능이 추가되었다고 가정하자.

과거에는 새로운 printf()문의 실행 코드가 담긴 stdio.h 라이브러리를 가져와 다시 컴파일 해야 했다. 하지만 매번 새로운 라이브러리를 가져와 다시 컴파일 하는 것은 번거로운 일이다.

오늘날의 프로그래밍에서는 printf() 문의 자리를 비워놓고 컴파일 한 후 printf() 문의 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용한다

이렇게 실행할 때 삽입되는 라이브러리를 동적 라이브러리라고 한다.

동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없이 새로운 라이브러리만 사용하여 실행하면 된다.

윈도우에서 동적 라이브러리 파일을 DLL이라고 한다. 윈도우에서 함수의 변경이 일어나면 DLL 파일을 특정 폴더에 삽입하여 새로운 기능을 사용할 수 있다.

### 7.1.4 메모리 관리 작업

## 7.2 메모리 주소

### 7.2.1 32bit CPU와 64bit CPU의 차이

### 7.2.2 논리 주소와 물리 주소

## 7.3 단일 프로그래밍 환경의 메모리 할당

### 7.3.1 메모리 오버레이

### 7.3.2 스왑

## 7.4 다중 프로그래밍 환경의 메모리 할당

### 7.4.1 메모리 분할 방식

### 7.4.2 가변 분할 방식의 메모리 관리

### 7.4.3 고정 분할 방식의 메모리 관리

### 7.4.4 버디 시스템

## 7.5 분할 컴파일과 메모리 관리

### 7.5.1 분할 컴파일

### 7.5.2 변수와 메모리 할당
