# 7. 물리 메모리 관리

## 7.1 메모리 관리의 개요

폰 노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리 공간에 올라와야 실행할 수 있다.
모든 프로그램은 하드디스크나 SSD와 같은 보조 저장 장치에 보관되어 있다. 프로그램이 실행되어 프로세스가 된다는 것은 저장 장치에 있던 프로그램이 메모리로 올라온다는 뜻이다.

이 책에서는 메인 메모리를 메모리라 한다. 의미를 분명하게 나타내야 하는 경우에만 메인 메모리나 물리 메모리라 표기한다.

### 7.1.1 메모리 이해하기

메모리의 구조는 1바이트 크기로 나뉜다. 1B로 나뉜 각 영역은 주소로 구분되는데 보통 0번지부터 시작한다.
CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다.

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.
전원 버튼을 누르면 사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정 즉 부팅이 이뤄지는데 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

CPU 입장에서 메모리는 매우 느리다. CPU 안에 있는 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 몇 배 이상 느리다.
예를 들어 CPU 안에 있는 레지스터에 접근하려면 1~2클록이면 되지만 메모리에 있는 데이터를 CPU로 가져오려면 그 10배 이상의 클록이 필요하다.
이러한 속도 차이를 극복 하기 위해 CPU 안에 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와(prefetch) 작업한다.

또는 하드디스크나 SSD 같은 저장 장치를 메인 메모리의 보조 저장장치로 활용한다.

> **메모리에 있는 데이터를 CPU로 가져오는 과정**
> CPU가 메모리에 있는 데이터를 가져오기까지 필요한 과정을 생각해보면 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다. 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다. 메모리 버퍼 레지스터에 있는 데이터가 레지스터로 옮겨지면 메모리 접근 작업이 끝난다. FSB의 속도를 고려하면 CPU가 메모리에 접근하는 작업은 10클록 이상 걸린다

### 7.1.2 메모리 관리의 이중성

메모리 관리 시스템(MMS)이 메모리 관리를 한다.
현대 운영체제는 시분할 시스템으로 운영되어 모든 응용 프로그램이 메모리에 올라와 실행되므로 메모리 관리가 복잡하다.

프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데
이를 메모리 관리의 이중성이라 한다.

### 7.1.3 소스코드의 번역과 실행

프로그램은 메모리 관리와 밀접한 관련이 있다.

#### **소스코드의 번역 방식**

컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며, 작성한 프로그램은 보통 컴파일러를 사용하여 실행 가능한 코드로 변경한다.

언어 번역 프로그램은 고급언어로 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역한다.

대표적으로 컴파일러와 인터프리터다.

#### **컴파일러**

##### **오류 발견**

컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로 선언하지 않은 변수를 사용하지 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.

##### **소스 코드 최적화**

컴파일러 방식을 사용하는 두 번째 목적은 최적화다. 소스코드에서도 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져 실행 속도가 빨라진다.

컴파일러는 실행 전 소스 코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.

그러나 인터프리터는 한 행씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하거나 필요 없는 변수를 확인할 수 없다.

#### **컴파일러의 컴파일 과정**

컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다. 이렇게 해서 만들어진 기계어 코드가 목적 코드로 확장자는 obj다

기계어라고 하지 않고 목적 코드라고 하는 이유는 아직 처리할 단계가 남아있기 때문이다.

목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.

라이브러리는 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로 프로그래머가 직접 만들기 어렵거나 만드는데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것이다.

C 언어 코드에는 printf()문이 있는데 컴파일러는 라이브러리 연결 단계에서 printf() 문에 해당하는 기계어 코드를 <stdio.h> 라이브러리에서 가져와 목적 코드에 삽입한다.

printf 문에 더 좋은 기능이 추가되었다고 가정하자.

과거에는 새로운 printf()문의 실행 코드가 담긴 stdio.h 라이브러리를 가져와 다시 컴파일 해야 했다. 하지만 매번 새로운 라이브러리를 가져와 다시 컴파일 하는 것은 번거로운 일이다.

오늘날의 프로그래밍에서는 printf() 문의 자리를 비워놓고 컴파일 한 후 printf() 문의 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용한다

이렇게 실행할 때 삽입되는 라이브러리를 동적 라이브러리라고 한다.

동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없이 새로운 라이브러리만 사용하여 실행하면 된다.

윈도우에서 동적 라이브러리 파일을 DLL이라고 한다. 윈도우에서 함수의 변경이 일어나면 DLL 파일을 특정 폴더에 삽입하여 새로운 기능을 사용할 수 있다.

### 7.1.4 메모리 관리 작업

메모리 관리 작업은 크게 가져오기, 배치, 재배치로 구분된다.

#### **메모리 가져오기**

실행할 프로세스와 데이터를 메모리로 가져오는 작업이다.

그런데 어떤 상황에서는 데이터의 일부만 가져와 실행하기도 한다.

예를 들어 용량이 큰 동영상을 실행해야 하는데 메모리가 충분하지 않다면 동영상 플레이어를 먼저 가져와 실행하고 동영상 데이터는 필요할때마다 수시로 가져와 실행한다.

#### **메모리 배치**

가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다.

배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다. 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 복잡성이 달라지기 때문이다.

같은 크기를 자르는 것을 페이징이라고 하고 프로세스의 크기에 맞게 자르는 것을 세그먼테이션이라고 한다.

효율적인 정책을 고려하는 것이 중요하다.

#### **메모리 재배치**

새로운 프로세스를 가져와야 하는데 꽉 찼다면 기존 메모리에 있는 프로세스를 하드 디스크로 옮겨놓아야 새로운 프로세스를 메모리에 가져올 수 있다.

이처럼 꽉찬 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 보내는 작업을 재배치 작업이라고 한다.

그런데 자주 사용할 프로세스를 내보내면 성능이 떨어진다.

그래서 교체 알고리즘이 따로 있따.

## 7.2 메모리 주소

메모리에 접근 할 때는 주소를 이용한다.

메모리 주소는 물리 주소와 논리 주소로 나뉜다.

이 절에서는 두 주소의 차이와 주소를 지정하는 방법을 살펴보자.

### 7.2.1 32bit CPU와 64bit CPU의 차이

CPU를 나타낼 때의 비트는 CPU가 한 번에 달루 수 있는 데이터의 최대 크기를 의미한다.

CPU의 비트는 메모리 주소 공간의 크기와도 연관이 있다.

CPU의 경우 메모리 주소 레지스터의 크기가 2^32개인데 약 4GB이다.
그래서 32bit CPU는 최대 4GB 까지 쓸 수 있다.

64bit의 CPU는 레지스터의 크기 버스의 대역폭 한 번에 처리되는 데이터의 최대 크기 등이 2배인데 16,777,216TB이기 때문에 크게 사용할 수 있따.

컴퓨터에는 메모리가 설치되고 각 메모리에는 주소 공간이 있다.

메모리의 주소 공간을 물리 주소 공간이라고 하는데 이는 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.

반대로 사용자 입장에서 바라본 주소 공간을 논리 주소 공간이라고 한다.

### 7.2.2 논리 주소와 물리 주소

#### **메모리 영역의 구분**

메모리 관리를 설명하기 위해 단순 메모리 구조를 살펴보자, 메모리 관리자는 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다.

운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에 사용자가 운영체제가 침범하지 못하도록 분리해서 관리한다.

그림에서 운영체제가 0~359번지를 사용하고 사용자가 360~999번지를 사용한다.

사용자 운영체제는 운영체제 영역을 피하여 메모리에 적재된다.

360번지부터 적재되는데 만약 운영체제 영역을 399번지까지 사용한다면 사용자 프로세스가 400번지부터 적재돼야 한다.

그런데 이처럼 운영체제의 크기에 따라 매번 적재되는 주소가 달라지면 번거롭다.

이를 개선한 방법이 사용자 프로세스의 최상위부터 사용하는 것이다.

즉 메모리를 최상위에서 운영체제 방향으로 내려오면서 사용한.

이 방법을 쓰면 운영체제의 크기에 상관없이 사용자 영역의 시작점을 결정할 수 있으나 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡해진다.

사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요한데 이는 CPU 내에 있는 경계레지스터가 담당한다.

경계 레지스터는 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진다.

메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 경계 레지스터가 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료한다.

#### **논리 주소와 물리 주소의 변환**

`char alp = 'A'` 이러한 프로그램 코드를 실행시켜보면 메모리의 어딘가에 A가 저장된다

그 주소를 40번지라고 해보자

코드가 컴파일되어 실행 파일이 만들어졌다.

해당 실행 파일에는 40번지에 A를 넣는 기계어 코드가 있다.

해당 코드가 실행되면 프로세스가 메모리에 올라온다.

여기서 메모리는 물리적으로 설치된 메인 메모리를 말한다.

물리 메모리도 0번지부터 시작하는 주소를 가지고 있다.

중요한 것은 실행 파일에 40번지의 A가 들어간다고 해서 실제 물리 메모리의 40번지에 A가 들어가는 것은 아니라는 점이다.

실행을 위해 프로세스가 메모리에 올라오면 이 메모리는 빈 공간에 배치된다.

빈 공간의 시작 주소는 물리 메모리 주소의 100번지 일 수 있고 300번지 일 수도 있다.

물리 메모리의 360번지부터 프로세스가 사용한다고 가정해 보자.

이 경우 40번지는 물리 메모리의 주소 400번지가 된다.

여기서 400번지는 물리 주소다.

물리 주소는 메모리의 입장에서 바라본 주소다.

즉 메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소를 말한다.

40번지는 논리 주소이며, 이는 시작점을 0으로 놓았을 때 40번지의 위치에 있는 주소를 말한다.

프로세스 입장에서는 0번지부터 시작하는 논리주소가 편하다.

기억할 것은 프로그램이 실행될 때마다 시작하는 물리 주소는 매번 바뀐다는 점이다.

이렇듯 논리 주소와 물리 메모리에서 사용하는 물리 주소 사이에 차이가 발생한다.

프로세스가 사용하는 논리 주소는 논리 주소 공간에 있다.

논리 주소 공간은 항상 0번지부터 시작하며 컴퓨터가 허용하는 최대의 주소 크기를 가진다.

컴파일러는 논리 주소 공간의 0번지부터 변수들을 배치한다.

물리 주소 공간도 0 번지부터 시작하지만 최대 주소 크기는 컴퓨터에 설치된 메모리 크기에 따라 달라진다.

다시 말해, 컴퓨터에 실제로 설치된 메모리의 크기가 마지막 주소가 된다.

논리 주소로 이루어진 프로세스를 실행하면 이를 물리 주소로 변환하는 작업이 필요하다.

이 작업은 메모리 관리 유닛이 담당한다.

메모리 관리 유닛은 CPU 안에 존재하며 프로세스가 논리 주소에 접근할 때마다 이를 물리 주소로 변환하는 작업을 한다.

메모리 관리 유닛이 논리 주소를 물리 주소로 변환하는 과정은 다음과 같다.

1. 사용자 프로세스가 논리 주소 40번지에 있는 데이터를 요청한다.
2. CPU는 메모리 관리 유닛에 40번지에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리 유닛은 재배치 레지스터를 사용하여 메모리 400번지에 저장된 데이터를 가져온다.

재배치 레지스터는 주소 변환의 기본이 되는 주소 값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소 값이 저장된다.

사용자 영역의 시작 주소 값이 360이므로 360번지가 재배치 레지스터에 저장된다.

사용자 프로세스 입장에서는 메모리 관리자가 재배치 레지스터를 사용하여 논리 주소를 물리 주소로 변환하기 때문에 메모리가 항상 0번지부터 시작하는 연속된 작업 공간으로 보인다.

## 7.3 단일 프로그래밍 환경의 메모리 할당

### 7.3.1 메모리 오버레이

과거에 메모리가 값비싼 장비였기 때문에 MS-DOS가 기본 메모리가 640KB로 한정되어있는데 이는 640KB를 넘을 수 없을 것이라 생각해서 그렇다.
과거에는 작은 메모리로 큰 메모리의 프로그램을 어떻게 작동할것인가의 문제였다.

실제로 메모리보다 큰 메모리도 적당한 크기로 잘라서 가져오는 기법을 메모리 오버레이라고 한다.

오버레이는 하나의 메모리를 여러 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말한다.

모듈을 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.

전체 프로그램을 올려놓고 실행하기에는 메모리의 크기가 작기 때문에 실행하는 데 필요한 모듈만 올려놓고 나머지는 필요할 때마다 메모리에 가져와 사용하는 것이다.

이 방식은 프로그램 전체를 메모리에 올리는 것보다 느리지만 메모리가 프로그램보다 작을 때도 실행할 수 있어서 유용하다.

이때 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 프로그램 카운터가 결정한다.

해당 모듈이 메모리에 없으면 메모리 관리자에게 요청하여 가져오게 한다.

한정된 메모리에서 메모리보다 큰 프로그램을 실행할 수 있다.

프로그램 전체가 아니라 일부만 메모리에 올라와도 실행할 수 있다.

프로그램은 개념적으로 한 덩어리지만 일부부만으로도 실행할 수 있다.

이는 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미이기도 하다.

### 7.3.2 스왑

메모리 오버레이가 처리해야할 문제는 남아있는데

도마의 크기가 작아 고깃덩어리를 잘라서 손질했다 이런 상황에서 다른 고깃덩어리를 가져와 손질하려면 현재 도마에 있는 고깃덩어리를 치워야한다.

어디로 치우는 것이 좋을까 ?

보관 창고에 가져다 놓되 다른 고기와 섞이지 않도록 별도의 공간에 임시로 저장하면 된다.

모듈 B를 가져올 때 먼저 메모리에 올라온 모듈 A를 어딘가에 보관해야 한다.

쉽게 생각하면 모듈 A를 원래의 하드디스크 위치에 옮겨 놓으면 되겠지만,

다시 사용할지도 모르고 아직 작업이 끝나지 않았기 때문에 저장장치의 별도 공간에 보관해야 한다.

이처럼 메모리가 모자라서 쫓겨난 프로세스의 저장장치의 특별한 공간에 모아두는데 이러한 영역을 **스왑 영역이**라 한다.

스왑 영역에서 메모리로 데이터를 가져오는 작업을 스왑인 메모리에서 스왑 영역으로 데이터를 내보내는 작업을 스왑 아웃이라고 한다.

스왑 영역은 메모리 관리자가 관리한다.

원래는 하드디스크 같은 저장장치는 저장장치 관리자가 관리하지만

스왑 영역은 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리한다.

메모리 오버레이에서는 메모리보다 큰 프로그램을 실행할 때

프로그램을 메모리보다 작은 크기의 모듈로 나누어서 사용한다.

여기에 스왑을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식된다.

사용자는 실제 메모리와 스왑 영역의 크기를 합쳐서 전체 메모리의 크기로 인식하고 사용할 수 있다.

예를 들어 실제 메모리의 크기가 1GB, 스왑의 크기아 3GB라면 사용자가 인식하는 메모리 크기는 4GB다. 실제 메모리가 4GB인 컴퓨터보다 속도가 느리겠지만 스왑을 사용하여 실제 메모리의 모자란 부분을 보충할 수 있다.

사용자 입장에서는 실제 메모리의 크기에 상관없이 큰 프로그램을 실행할 수 있다.

유닉스 운영체제는 하드디스크의 분리된 파티션에 스왑 영역을 배정하기 때문에 스왑 영역을 확인하기가 어렵다.

스왑 영역을 확인하려면 free 명령을 사용해야 한다.

free는 메모리의 상태를 보여주는 명령어이며 -m은 메가바이트 단위로 출력하라는 의미다.

보통 유닉스 계열의 운영체제에서는 스왑 영역의 크기를 메모리의 2배 정도로 잡는다.

## 7.4 다중 프로그래밍 환경의 메모리 할당

### 7.4.1 메모리 분할 방식

### 7.4.2 가변 분할 방식의 메모리 관리

### 7.4.3 고정 분할 방식의 메모리 관리

### 7.4.4 버디 시스템

## 7.5 분할 컴파일과 메모리 관리

### 7.5.1 분할 컴파일

### 7.5.2 변수와 메모리 할당
