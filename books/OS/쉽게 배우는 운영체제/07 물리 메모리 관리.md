# 7. 물리 메모리 관리

## 7.1 메모리 관리의 개요

폰 노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리 공간에 올라와야 실행할 수 있다.
모든 프로그램은 하드디스크나 SSD와 같은 보조 저장 장치에 보관되어 있다. 프로그램이 실행되어 프로세스가 된다는 것은 저장 장치에 있던 프로그램이 메모리로 올라온다는 뜻이다.

이 책에서는 메인 메모리를 메모리라 한다. 의미를 분명하게 나타내야 하는 경우에만 메인 메모리나 물리 메모리라 표기한다.

### 7.1.1 메모리 이해하기

메모리의 구조는 1바이트 크기로 나뉜다. 1B로 나뉜 각 영역은 주소로 구분되는데 보통 0번지부터 시작한다.
CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다.

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.
전원 버튼을 누르면 사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정 즉 부팅이 이뤄지는데 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

CPU 입장에서 메모리는 매우 느리다. CPU 안에 있는 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 몇 배 이상 느리다.
예를 들어 CPU 안에 있는 레지스터에 접근하려면 1~2클록이면 되지만 메모리에 있는 데이터를 CPU로 가져오려면 그 10배 이상의 클록이 필요하다.
이러한 속도 차이를 극복 하기 위해 CPU 안에 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와(prefetch) 작업한다.

또는 하드디스크나 SSD 같은 저장 장치를 메인 메모리의 보조 저장장치로 활용한다.

> **메모리에 있는 데이터를 CPU로 가져오는 과정**
> CPU가 메모리에 있는 데이터를 가져오기까지 필요한 과정을 생각해보면 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다. 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다. 메모리 버퍼 레지스터에 있는 데이터가 레지스터로 옮겨지면 메모리 접근 작업이 끝난다. FSB의 속도를 고려하면 CPU가 메모리에 접근하는 작업은 10클록 이상 걸린다

### 7.1.2 메모리 관리의 이중성

메모리 관리 시스템(MMS)이 메모리 관리를 한다.
현대 운영체제는 시분할 시스템으로 운영되어 모든 응용 프로그램이 메모리에 올라와 실행되므로 메모리 관리가 복잡하다.

프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데
이를 메모리 관리의 이중성이라 한다.

### 7.1.3 소스코드의 번역과 실행

프로그램은 메모리 관리와 밀접한 관련이 있다.

#### **소스코드의 번역 방식**

컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며, 작성한 프로그램은 보통 컴파일러를 사용하여 실행 가능한 코드로 변경한다.

언어 번역 프로그램은 고급언어로 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역한다.

대표적으로 컴파일러와 인터프리터다.

#### **컴파일러**

##### **오류 발견**

컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로 선언하지 않은 변수를 사용하지 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.

##### **소스 코드 최적화**

컴파일러 방식을 사용하는 두 번째 목적은 최적화다. 소스코드에서도 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져 실행 속도가 빨라진다.

컴파일러는 실행 전 소스 코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.

그러나 인터프리터는 한 행씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하거나 필요 없는 변수를 확인할 수 없다.

#### **컴파일러의 컴파일 과정**

컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다. 이렇게 해서 만들어진 기계어 코드가 목적 코드로 확장자는 obj다

기계어라고 하지 않고 목적 코드라고 하는 이유는 아직 처리할 단계가 남아있기 때문이다.

목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.

라이브러리는 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로 프로그래머가 직접 만들기 어렵거나 만드는데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것이다.

C 언어 코드에는 printf()문이 있는데 컴파일러는 라이브러리 연결 단계에서 printf() 문에 해당하는 기계어 코드를 <stdio.h> 라이브러리에서 가져와 목적 코드에 삽입한다.

printf 문에 더 좋은 기능이 추가되었다고 가정하자.

과거에는 새로운 printf()문의 실행 코드가 담긴 stdio.h 라이브러리를 가져와 다시 컴파일 해야 했다. 하지만 매번 새로운 라이브러리를 가져와 다시 컴파일 하는 것은 번거로운 일이다.

오늘날의 프로그래밍에서는 printf() 문의 자리를 비워놓고 컴파일 한 후 printf() 문의 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용한다

이렇게 실행할 때 삽입되는 라이브러리를 동적 라이브러리라고 한다.

동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없이 새로운 라이브러리만 사용하여 실행하면 된다.

윈도우에서 동적 라이브러리 파일을 DLL이라고 한다. 윈도우에서 함수의 변경이 일어나면 DLL 파일을 특정 폴더에 삽입하여 새로운 기능을 사용할 수 있다.

### 7.1.4 메모리 관리 작업

메모리 관리 작업은 크게 가져오기, 배치, 재배치로 구분된다.

#### **메모리 가져오기**

실행할 프로세스와 데이터를 메모리로 가져오는 작업이다.

그런데 어떤 상황에서는 데이터의 일부만 가져와 실행하기도 한다.

예를 들어 용량이 큰 동영상을 실행해야 하는데 메모리가 충분하지 않다면 동영상 플레이어를 먼저 가져와 실행하고 동영상 데이터는 필요할때마다 수시로 가져와 실행한다.

#### **메모리 배치**

가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다.

배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다. 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 복잡성이 달라지기 때문이다.

같은 크기를 자르는 것을 페이징이라고 하고 프로세스의 크기에 맞게 자르는 것을 세그먼테이션이라고 한다.

효율적인 정책을 고려하는 것이 중요하다.

#### **메모리 재배치**

새로운 프로세스를 가져와야 하는데 꽉 찼다면 기존 메모리에 있는 프로세스를 하드 디스크로 옮겨놓아야 새로운 프로세스를 메모리에 가져올 수 있다.

이처럼 꽉찬 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 보내는 작업을 재배치 작업이라고 한다.

그런데 자주 사용할 프로세스를 내보내면 성능이 떨어진다.

그래서 교체 알고리즘이 따로 있따.

## 7.2 메모리 주소

메모리에 접근 할 때는 주소를 이용한다.

메모리 주소는 물리 주소와 논리 주소로 나뉜다.

이 절에서는 두 주소의 차이와 주소를 지정하는 방법을 살펴보자.

### 7.2.1 32bit CPU와 64bit CPU의 차이

CPU를 나타낼 때의 비트는 CPU가 한 번에 달루 수 있는 데이터의 최대 크기를 의미한다.

CPU의 비트는 메모리 주소 공간의 크기와도 연관이 있다.

CPU의 경우 메모리 주소 레지스터의 크기가 2^32개인데 약 4GB이다.
그래서 32bit CPU는 최대 4GB 까지 쓸 수 있다.

64bit의 CPU는 레지스터의 크기 버스의 대역폭 한 번에 처리되는 데이터의 최대 크기 등이 2배인데 16,777,216TB이기 때문에 크게 사용할 수 있따.

컴퓨터에는 메모리가 설치되고 각 메모리에는 주소 공간이 있다.

메모리의 주소 공간을 물리 주소 공간이라고 하는데 이는 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.

반대로 사용자 입장에서 바라본 주소 공간을 논리 주소 공간이라고 한다.

### 7.2.2 논리 주소와 물리 주소

#### **메모리 영역의 구분**

메모리 관리를 설명하기 위해 단순 메모리 구조를 살펴보자, 메모리 관리자는 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다.

운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에 사용자가 운영체제가 침범하지 못하도록 분리해서 관리한다.

그림에서 운영체제가 0~359번지를 사용하고 사용자가 360~999번지를 사용한다.

사용자 운영체제는 운영체제 영역을 피하여 메모리에 적재된다.

360번지부터 적재되는데 만약 운영체제 영역을 399번지까지 사용한다면 사용자 프로세스가 400번지부터 적재돼야 한다.

그런데 이처럼 운영체제의 크기에 따라 매번 적재되는 주소가 달라지면 번거롭다.

이를 개선한 방법이 사용자 프로세스의 최상위부터 사용하는 것이다.

즉 메모리를 최상위에서 운영체제 방향으로 내려오면서 사용한.

이 방법을 쓰면 운영체제의 크기에 상관없이 사용자 영역의 시작점을 결정할 수 있으나 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡해진다.

#### **논리 주소와 물리 주소의 변환**

## 7.3 단일 프로그래밍 환경의 메모리 할당

### 7.3.1 메모리 오버레이

### 7.3.2 스왑

## 7.4 다중 프로그래밍 환경의 메모리 할당

### 7.4.1 메모리 분할 방식

### 7.4.2 가변 분할 방식의 메모리 관리

### 7.4.3 고정 분할 방식의 메모리 관리

### 7.4.4 버디 시스템

## 7.5 분할 컴파일과 메모리 관리

### 7.5.1 분할 컴파일

### 7.5.2 변수와 메모리 할당
