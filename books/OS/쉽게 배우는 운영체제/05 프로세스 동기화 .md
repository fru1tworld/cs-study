# 5 프로세스 동기화

## 5.1 프로세스 간 통신

### 5.1.1 프로세스 간 통신의 개념

프로세스 혹은 스레드는 독립적으로 실행된다.

프로세스나 스레드가 협업하기 위해서는 데이터를 주고 받아야 한다.

스레드는 하나의 프로세스에서 자원을 공유하는 실행 단위다.

프로세스 간 소통은 IPC라고 한다.

- **공유 메모리나 공유 파일을 이용한 통신**: IPC 중 가장 원시적인 방법으로 이 ㄹ정한 메모리 영역이나 파일을 공유하고 데이터를 주고 받는다 알아서 결정해야 하므로 원시적이라 한다.

- **파이프를 이용한 통신**: 하나의 컴퓨터 내에서 IPC는 파이프가 많이 쓰인다. 파이프는 운영체제가 제공하는 통신기법이다. 보통의 경우에는 fork로 만들어진 부모-자식 간 통신에 사용된다.

- **소켓을 이용한 통신**:컴퓨터와 컴퓨터가 네트워크로 연결된 경우의 통신에 주로 사용된다. 소켓은 네트워크로 연결된 컴퓨터에서 데이터를 주고 받기 위한 통신 방법이다. 그런데 같은 컴퓨터내에서도 소켓 통신은 가능한데 초기화할 내용도 많고 시스템 자원도 많이 사용된다. 그래서 비효율적이다.

통신은 결국 send/receive 그래서 이 send(message) receive(message)를 사용한다.

### 5.1.2 프로세스 간 통신의 분류

#### 통신 방향에 따른 분류

통신 방향에 따른 분류는 양방향, 반양방향, 단방향으로 나뉜다.

대부분 통신은 양방향이지만 공유 메모리나 공유 파일은 단방향이다.

왜냐면 누군가 공유 메모리에 쓰면 이전에 있던 데이터는 사라지기 때문이다.

그래서 양방향을 구현하려면 공유 메모리 2개를 사용해야 한다.

#### 통신 구현 방식에 따른 분류

공유 메모리를 사용하는 가장 큰 문제는 언제 데이터를 보낼지 받는 쪽에서 모른다는 것인데 그래서 수시로 대기해야한다는 점이다.

그리고 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기라고 한다.

시스템 차원에서 바쁜 대기는 자원 낭비가 커서 안 좋은 프로그램의 전형적인 예가 된다.

바쁜 대기 문제를 해결하기 위해 데이터가 도착했음을 알려주는 동기화를 사용한다.

IPC는 동기화 기능에 따라 대기가 있는 통신과 대기가 없는 통신으로 구분되고 대기가 있는 통신을 동기화 통신 대기가 없는 통신을 비동기화 통신이라고 한다.

## 5.1.3 프로세스 간 통신의 종류

#### **파일을 이용한 통신**

##### **파일 열기**

파일 입출력 코드는 크게 세 부분으로 구성된다 open write read close이다.

open은 일종의 준비 단계로 존재하는지, 권한 여부를 체크한다.

사용할 수 있으면 fd를 반환한다.

fd는 파일에 쓰거나 읽기 연산을 하려면 fd를 얻고 끝나면 반환해야 한다.

이처럼 어떤 파일에 접근할 수 있는 권한인 fd를 file descriptor라 한다.

##### **파일 쓰기 또는 읽기**

fd는 해당 파일에 대한 접근권한을 가지므로 연산의 맨 앞에는 언제나 fd를 사용한다.

##### **파일 닫기**

close로 파일을 닫는다.
-close(fd)로 가리키는 파일 즉 파일을 닫는다.

파일을 이용한 통신은 부모-자식 관계의 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다.

그래서 프로세스가 알아서 동기화를 해야하는데 주로 부모 프로세스가 wait 홤수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다린다.

#### **파이프를 이용한 통신**

프로세스 동기화 문제를 해결하는 방법으로 파이프가 있다.

파이프를 이용한 통신은 운영체제가 제공하는 동기화 통신 방식으로, 파일 입출력과 같이 open 함수로 기술자를 얻어 작업이 만료도고 close로 마무리한다.

파이프에 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받는다.

파이프는 이름 없는 파이프와 이름 있는 파이프로 나뉜다.

- **이름 없는 파이프**: 일반적으로 파이프라고 하면 이름 없는 파이프를 가리킨다. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 IPC간 사용된다.
- **이름 있는 파이프**: FIFO라 불리는 특수 파일을 이용하며 서로 관련없는 프로세스 간 통신에 사용된다.

#### **소켓을 이용한 통신**

여러 컴퓨터 프로세스도 소통할 수 있고 이를 네트워킹이라 한다.

이때 소켓을 이용한다.

TCP/IP가 있어야 인터넷을 사용할 수 있는데, IP는 목적지까지 데이터를 전송하는 프로토콜이다. 이때 사용되는게 IP주소이다.

해당 컴퓨터에는 네트워크를 사용하는 많은 프로세스가 존재하는데 이를 구분하는게 포트이다.

포트 번호는 0부터 65535 사이의 포트번호를 부여받는다.

서버에서 돌아가는 프로세스를 데몬이라고 하는데, 서버용 데몬도 포트번호가 필요하다.

서버용 데몬에 임의의 포트 번호를 부여하면 클라이언트가 해당 포트 번호를 찾아야 한다.

그래서 중요한 서버용 프로세스(데몬)에는 미리 정해진 포트 번호를 할당한다.

예를 들어 웹 데몬의 포트 번호는 80 파일 데몬의 포트 번호는 21이다.

서버 쪽 데몬 80번을 생각해보면 여러명의 사용자가 요청할 수 있다. 이때 소켓을 통해 하나의 포트에 여러 클라이언트를 연결하기 위한 소켓이 필요한데.

클라이언트들은 포트에 연결된 멀티 소켓에 하나씩 연결된다.

서버 프로세는 소켓을 사용하여 동시에 여러 클라이언트에 서비스를 제공한다.

결국 네트워크에서 데이터를 보낸다는 것은 클라이언트 소켓이 서버 소켓에 데이터를 보내는 것이다.

그래서 네트워크 프로그래밍을 소켓 프로그래밍이라고 부른다.

통신할 때는 원격 프로시저 호출이나 소켓을 사용한다.

프로시저 호출이 한 컴퓨터에 있는 함수를 호출하는 것이라면, 원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것이다.

자바와 같은 객체 지향 언어에서 다른 컴퓨터에 있는 개체의 메서드를 불러와 사용하는 것은 모두 원격 프로시저 호출의 예이다.

일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현한다.

소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.

앞에서 언급했듯이 파이프를 이용한 통신에서는 양방향 통신에 파이프가 2개 필요하지만 소켓을 이용한 통신에서는 소켓을 1개만 사용해도 양방향 통신이 가능하다.

## 5.2 공유 자원과 임계 구혁

### 5.2.1 공유 자원에 대한 접근

공유 자원은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다.

이처럼 2개 이상의 프로세스가 공유 자원을 병행해서 읽거나 쓰는 상황을 경쟁 조건이 발생했다고 한다.

### 5.2.2 임계구역

경쟁 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 **임계구역** 이라고 한다.

각 프로세스가 전역 변수를 사용하는 부분, 즉 예금을 확인하고 입금한 후에 에금을 저장하는 부분이 임계구역이다.

### 5.2.3 생산자 - 소비자 문제

임계구역과 관련된 전통적인 문제로 생산자- 소비자 문제가 있다.
예를 들어 생산자는 물건을 계속 버퍼에 넣고
소비자는 계속 물건을 가져오는 원형 버퍼를 사용한다.
이때 가득찼는지 확인하기 위해 전역 변수 sum을 사용하는데
현재 버퍼에 있는 상품의 총수가 저장된다.

```cpp
producer()
{
 input(buf);
 sum+=1;
}
```

```cpp
consumer()
{
 output(buf);
 sum-=1;
}
```

이제 이러한 변수를 3에서 동시에 실행하면 값이 2이나 4가 된다.

### 5.2.4 임계구역 문제 해결 조건

- **상호 배제**: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다. 이것이 지켜지지 않으면 임계구역을 설정한 의미가 없다.
- **한정 대기**: 어떤 프로세스도 임계구역에 진입하지 못하여 무한대기 하지 않는다.
- **진행의 융통성**: 작업 속도와 관계없이 비어있으면 언제든 사용할 수 있어야한다이며, 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 것을 의미한다.

## 5.3 임계구역 문제 해결 방법

가장 단순한 방법은 잠금을 이용하는 것이다.

### 5.3.1 기본 코드 소개

```cpp
main(){
    while(lock==true);
    lock=true;
    balance=balance+10;
    lock=false;
}
```

### 5.3.2 임계구역 문제 해결 조건을 고려한 코드 설계

##### 상호 배제 문제

###### p1

```cpp
while(lock==true){
lock=true;
    [임계구역]
lock=false;
}
```

###### p2

```cpp
while(lock==true){
lock=true;
    [임계구역]
lock=false;
}
```

제대로 작동할 것 같지만 제대로 작동하지 않는다.

동시 진입 상황 - 상호 배제 조건을 충족하지 않은 경우

1. P1이 while(lock==true) 문을 실행한다. 임계구역에 프로세스가 없어서 무한 루프를 빠져나온다. 다음 문장을 실행하려는 순간 CPU 사용시간을 다써서 빠져 나온다.
2. P2이 while(lock==true) 문을 실행한다. 아직 프로세스 P1이 잠금을 걸지 않았기 때문에 lock은 여전히 false이며 P2는 임계영역에 진입할 수 있다.
3. 프로세스 P1이 lock=true 문을 실행하여 임계구역에 잠금을 걸고 진입한다.
4. 프로세스 P2이 lock=true 문을 실행하여 임계구역에 잠금을 걸고 진입한다. 결국 둘다 임계 구역에 진입하게 된다.

##### 한정대기 문제

###### p1

```cpp
lock1=true;
while(lock2==true){
    [임계구역]
    lock1=false
}

```

###### p2

```cpp
lock2=true;
while(lock1==true){
    [임계구역]
    lock2=false
}
```

보완한 방법이다.

1. 프로세스 P1 lock1=true 문을 실행한 후 자신의 CPU시간을 다 써버렸다(타움아웃). 문맥 교환이 발생하고 P2가 실행 상태로 바뀐다.
2. 프로세스 P2 lock2=true 문을 실행한 후 자신의 CPU시간을 다 써버렸다(타움아웃). 문맥 교환이 발생하고 P1가 실행 상태로 바뀐다.
3. 프로세스 P1 lock1=true 문을 실행했기 때문에 프로세스 P1은 while(lock2=true)문에서 무한 루프에 빠진다.
4. 프로세스 P2 lock2=true 문을 실행했기 때문에 프로세스 P1은 while(lock1=true)문에서 무한 루프에 빠진다.

둘 다 무한정 대기한다.

그리고 이러한 방법은 프로세스가 n개라면 n개의 lock이 늘어나 비효율적이다.

##### 진행의 융통성 문제

공유 변수 int lock=1;

###### P1

```cpp
while(lock=2);
    [임계구역]
lock2;
```

###### P2

```cpp
while(lock=1);
    [임계구역]
lock=1;
```

잠금을 확인하는 문장이 하나이므로 상호 배제와 한정 대기를 보완한다.

그런데 이러한 구조는 결국 다른 프로세스로 인해 방해받는 현상을 경직된 동기화라고 한다.

이 코드에서는 진행의 융통성 조건을 보장하지 못한다.

**하드웨어로 해결 방법**

임계구역 문제는 알고리즘을 이용한 소프트웨어 방법뿐 아니라 하드웨어 방법으로도 간단히 해결할 수 있다.

앞서 살펴보았듯이. 이 코드에서 잠금이 걸렸는지 검사하는 while(lock==true) ㅁ문과 검사한 후 잠금 설정을 하는 lock=true문이 분리되어 실행되면(즉 두 명령어 중간에 타임 아웃이 걸리면) 문제가 발생한다.

이 경우 하드웨어로 두 명령어를 동시에 실행하면 임계구역 문제를 쉽게 해결할 수 있다.

왼쪽 코드의 1~2행은 오른쪽 코드의 1행과 같다.

이는 검사와 지정 이라는 하드웨어의 지원을 받아 한번에 실행한 것이다.

임계구역을 하드웨어로 해결하는 방법은 편리하지만 바쁜 대기를 사용하여 검사하기 때문에 자원 낭비가 발생한다.

이어서 소개하는 피터슨 알고리즘과 데커 알고리즘은 이러한 문제를 해결한 알고리즘이다.

그러나 구조가 복잡하여 현재 잘사용되지는 않는다.

### 5.3.3 피터슨 알고리즘

```cpp
lock1=true;
turn=2;
while(lock2== true &&  turn==2);
    [임계구역]
lock1=false;
```

```cpp
lock2=true;
turn=1;
while(lock1== true &&  turn==1);
    [임계구역]
lock1=false;
```

두 프로세스가 동시에 했더라도 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나온다.

피터슨 알고리즘은 임계구역 문제 해결의 세 가지 조건을 모두 만족하지만 2개의 프로세스만 사용 가능하다는 한계까 있다.

### 5.3.4 데커 알고리즘

```cpp
lock1=true;
while(lock2==true){
    if(turn=2){
        lock=false;
        while(turn==2);
        lock=true;
    }/* end if */
} /*end while */
    [임계구역]
turn=2;
lock1=false;
```

```cpp
lock2=true;
while(lock1==true){
    if(turn=1){
        lock=false;
        while(turn==1);
        lock=true;
    }/* end if */
} /*end while */
    [임계구역]
turn=1;
lock2=false;
```

1. 프로세스 P1은 우선 잠금을 건다(lock1=true)
2. 프로세스 P2이 잠금이 걸렸는지 확인한다.[while(lock2==true)].
3. 만약 프로세스 P2도 잠금을 걸었다면 누가 먼저인지 확인한다 [if(turn==2)] 만약 프로세스 P1의 차례라면(turn==1) 임계구역으로 진입하고 P2의 차례라면 (turn==2)로 이동한다.
4. 프로세스 P1은 잠금을 풀고(lock1=false) 프로세스 P2가 작업을 마칠 때까지 기다린다 [while(turn==2)] 프로세스 P2가 작업을 마치면 잠금을 걸고 임계구역으로 진입한다.

피터슨 알고리즘이나 데커 알고리즘은 임계 구역의 세가지를 모두 만족하지만 매우 복잡하다 프로세스가 늘어나면 변수도 늘어나고 전체 알고리즘도 복잡하다.
복잡한 알고리즘은 바람직한 방법이 아니다.

### 5.3.5 세마포어

다익스트라는 세마포어라는 알고리즘을 제안했다.

세마포어 알고리즘은 프로세스가 임계구역에 진입하기 전에 스위치를 사용중으로 놓고 임계구역으로 들어간다.

이후 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다.

프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다.

세마포어는 사용 전에 초기 설정 세마포어를 사용하는데 n은 공유 가능한 자원의 수를 의미한다.

예를 들어 공유자원인 프린터가 N 대면 Semaphore(N)이다.

세마포어는 초기화가 끝난 후 프로세스가 임계구역에 들어가기 전에 사용중이라고 표시하고 [P()] 임계구역이 나올 때 비었다고 표시하는 [V()] 간단한 방법으로 임계구역을 보호한다.

```cpp
Semaphore(n);
P();
    [임계구역]
V();
```

```cpp
Semaphore(n); -> RS=n;
P(); -> if RS>5 then RS=RS-1 else block(); /*until RS > 0*/
    [임계구역]
V(); -> RS = RS+1; wake_up();
```

세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 wake_up() 신호를 받으면 큐에서 나와 임계구역에 진입한다.

따라서 바쁜 대기를 하는 프로세스가 없다.

그러나 세마포어의 P()나 V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다.

그러므로 검사와 지정을 사용하여 완전히 실행되도록 구현된다.

### 5.3.6 모니터

세마포어 알고리즘의 가장 큰 문제는 잘못된 사용으로 인해 임계구역이 보호받지 못한다는 것이다.

사용하지 않거나 사용 중에 실수를 해서 문제가 생긴 경우를 나타낸다.

공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요 없이 자동으로 처리하면 된다.

이를 실제로 구현한 것이 모니터다.

모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킨다.

모니터는 시스템 호출과 같은 개념이다.

## 5.4 파일, 파이프, 소켓 프로그래밍

### 5.4.1 파일

#### **순차 파일**

파일 내의 데이터는 한 줄로 길게 저장되는데 이러한 파일을 순차 파일이라 한다.

순차 파일에 접근하는 방식을 순차적 접근이라 한다.

open() 함수로 열고자 하는 파일, 그 파일에 대한 접근 권한 여부, 파일을 여는 방식을 결정한다.

이때 파일을 여는 방식에는 읽기 전용, 읽기/쓰기 전용, 쓰기 전용, 생성 등이 있다.

이 모든 조건을 만족하면 fd를 얻는다.

파일 안에는 fd가 있는데 fd는 현재 파일에서 어느 위치를 읽고 있는지를 가리킨다.

#### **파일 이용한 통신**

부모 프로세스와 자식 프로세스가 파일을 이용하면 통신을 하는 코드다.
fork()문을 실행하기 전에 파일을 open()하고 자식 프로세스는 파일 com.txt에 Test라고 쓴다.
여기서 Test는 4B이지만 문자열의 끝을 알리는 널 문자가 필요하기 때문에 5B를 할당한다. (EOF)

```cpp

#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>

void main(){
    int pid, fd;
    char buf[5];
    fd=open("com.txt", 0_RDWR); /* init */
    pid= fork();
    if(pid<0 || fd<0) exit(-1);
    else if(pid==0){ /* child */
        write(fd, "Test" ,5);
        clos(fd);
        exit(0);
    }else{             /* parent */
        lseek(fd, 0, SEEK_SET);
        read(fd, buf, 5);
        printf("%s", buf);
        close(fd);
        exit(0);
    }
}
```

부모 프로세스가 자식 프로세스보다 먼저 실행되면 자식 프로세스가 하지 않았기 때문에 빈 내용을 읽는다.

따라서 부모/자식 동기화를 해주어야 한다.

부모 프로세스는 자식 프로세스의 작업이 끝난후 read를 수행해야 하므로 wait()를 사용하여 자식 프로세스를 기다린다.

자식 프로세스가 작업을 마치면 lseek()가 실행되어 파일 기술자가 맨 앞으로 옮겨진다.

그 후 읽은 데이터를 화면에 출력하고 파일 기술자를 닫고 프로그램을 끝낸다.

가장 먼저 이해할 내용은 fork() 이전에 파일을 open()하면 생성된 파일 기술자가 자식 프로세스에도 상속된다는 점이다.

fork()는 부모 프로세스의 자원 대부분을 자식 프로세스에도 그대로 복사해주는데 fd도 포함된다.

open()은 한번이지만 close()는 자식/부모 두 번 실행된다.

파일 기술자 fd가 자식 프로세스에 복사되었다는 것은 파일을 읽고 쓸 권한만 복사되었다는 의미다. 위치 정보는 부모/자식 간 공유된다.

읽기 연산을 해도 fd가 전진하고 자식 프로세스가 읽기 연산을 해도 fd가 전진한다.

따라서 자식이 종료된 이후에도 부모 프로세스가 fd를 0으로 이동시켜야 하는데 이때 사용하는 명령어가 lseek()이다.

lseek()는 파일 기술자의 위치를 임의로 움직이는 행위다.

lseek()는 움직이는 기준점을 정할 수 있는데 SEEK_SET은 파일의 처음 SEEK_CUR는 파일 기술자의 현재 위치, SEEK_END는 파일의 맨 마지막 위치가 기준이다.

예를 들어 lseek(fd,0 , SEEK_SET)는 파일의 맨 처음 위치를 기준으로 0번째 위치에 파일 기술자를 옮기라는 의미다.

자식 프로세스에 의해 파일 기술자가 다 섯 칸 이동했으므로 lseek(fd, -5 , SEEK_END)는 는 파일의 맨 앞으로 fd를 옮긴다.

파일을 이용한 통신은 운영체제가 두 프로세스 간 동기화를 하지 않으므로 프로세스가 알아서 동기화를 해야한다

wait을 사용하여 자식 프로세스의 작업이 끝날 때 까지 기다린다.

### 5.4.2 파이프

동기화를 지원하는 단방향 통신 시스템인 파이프는 이름 없는 파이프 이름 있는 파이프로 나뉜다.

일반적으로 이름 없는 파이프를 가리키며 여기서는 이름 없는 파이프를 살펴볼 것이다.

파이프는 부모/자식 혹은 같은 부모의 자식 프로세스처럼 서로 관련 있는 프로세스 간 통신에 사용된다.

아래의 코드는 파이프를 이용하여 자식 프로세스가 Test라는 문자를 부모 프로세스에게 전달하는 코드다.
마찬가지로 close()로 기술자를 닫는 구조다.

```cpp
#include <stdio.h>
#include <unistd.h>

void main(){
    int pid, fd[2];
    char buf[5];
    if(pipe (fd)== -1) exit(-1); /* init */
    pid=fork();
    if(pid<5) exit(-1);

    else if(pid==0){ /* child */
        close(fd[0]); /* unused */
        write(fd[1,] "Test", 5);
        close(fd[1];
        exit(0);

    }
    else{               /* child */
        close(fd[1]); /* unused */
        write(fd[0,] buf, 5);
        close(fd[0]);
        printf("%s", buf);
        exit(0);
    }
}
```

파일을 이용한 통신과 파이프를 이용한 통신의 차이를 살펴보자, 파일에서는 read()와 write()가 파일 기술자를 공유하지만 파이프에서는 read()와 write()의 기술자가 따로 존재한다.

파일에서는 파일 기술자를 공유하기 때문에 read()를 하건 write()를 하건 상관없이 파일 기술자가 전진하므로 동기화를 할 수 없다.

그러나 파이프에서는 기술자가 따로 존재하기 때문에 동기화가 가능하다. 기술자를 fd[2]와 같이 2개의 원소를 가진 배열로 정의하는데 원소 하나는 읽기용으로 다른 하나는 쓰기 용이다.

파이프에서 fd[2] 로 선언한 후 fork()를 하면 부모 프로세스에 fd[2], 자식 프로세스에 fd[2] 총 4개의 기술자가 존재한다 (그래서 close가 4번 나타난다).

파이프는 단방향 통신이므로 프로세스당 하나의 기술자만 사용한다. 따라서 필요 없는 기술자는 닫아버린다. 위 코드에서 자식 프로세스가 fd[1]에 쓰고 부모 프로세스가

fd[0]으로 받는 구조이므로, 자식 프로세스는 사용하지 않을 fd[0]를 닫고 부모 프로세스는 fd[1]를 닫는다.
파이프 기술자가 4개 이니 파이프 기술자를 닫을게 아니라 양방향 통신에 이용하면 된다고 착각할 수 있다.

```cpp
    write(fd[1] "Test", 5);
    read(fd[0] buf, 5);
    close(fd[1]);
    close(fd[0]);
```

위 코드는 자식 프로세스가 부모 프로세스에게 test를 전송한게 아니라 지신이 write한 것을 자신이 read한 것이다.

따라서 부모 프로세스에게 test가 전달되지 않는다.

파이프로 양방향 통신을 구현하려면 2개 사용해야 한다.

### 5.4.3 네트워킹
