# 5 프로세스 동기화

## 5.1 프로세스 간 통신

### 5.1.1 프로세스 간 통신의 개념

프로세스 혹은 스레드는 독립적으로 실행된다.

프로세스나 스레드가 협업하기 위해서는 데이터를 주고 받아야 한다.

스레드는 하나의 프로세스에서 자원을 공유하는 실행 단위다.

프로세스 간 소통은 IPC라고 한다.

- **공유 메모리나 공유 파일을 이용한 통신**: IPC 중 가장 원시적인 방법으로 이 ㄹ정한 메모리 영역이나 파일을 공유하고 데이터를 주고 받는다 알아서 결정해야 하므로 원시적이라 한다.

- **파이프를 이용한 통신**: 하나의 컴퓨터 내에서 IPC는 파이프가 많이 쓰인다. 파이프는 운영체제가 제공하는 통신기법이다. 보통의 경우에는 fork로 만들어진 부모-자식 간 통신에 사용된다.

- **소켓을 이용한 통신**:컴퓨터와 컴퓨터가 네트워크로 연결된 경우의 통신에 주로 사용된다. 소켓은 네트워크로 연결된 컴퓨터에서 데이터를 주고 받기 위한 통신 방법이다. 그런데 같은 컴퓨터내에서도 소켓 통신은 가능한데 초기화할 내용도 많고 시스템 자원도 많이 사용된다. 그래서 비효율적이다.

통신은 결국 send/receive 그래서 이 send(message) receive(message)를 사용한다.

### 5.1.2 프로세스 간 통신의 분류

#### 통신 방향에 따른 분류

통신 방향에 따른 분류는 양방향, 반양방향, 단방향으로 나뉜다.

대부분 통신은 양방향이지만 공유 메모리나 공유 파일은 단방향이다.

왜냐면 누군가 공유 메모리에 쓰면 이전에 있던 데이터는 사라지기 때문이다.

그래서 양방향을 구현하려면 공유 메모리 2개를 사용해야 한다.

#### 통신 구현 방식에 따른 분류

공유 메모리를 사용하는 가장 큰 문제는 언제 데이터를 보낼지 받는 쪽에서 모른다는 것인데 그래서 수시로 대기해야한다는 점이다.

그리고 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기라고 한다.

시스템 차원에서 바쁜 대기는 자원 낭비가 커서 안 좋은 프로그램의 전형적인 예가 된다.

바쁜 대기 문제를 해결하기 위해 데이터가 도착했음을 알려주는 동기화를 사용한다.

IPC는 동기화 기능에 따라 대기가 있는 통신과 대기가 없는 통신으로 구분되고 대기가 있는 통신을 동기화 통신 대기가 없는 통신을 비동기화 통신이라고 한다.

## 5.1.3 프로세스 간 통신의 종류

#### **파일을 이용한 통신**

##### **파일 열기**

파일 입출력 코드는 크게 세 부분으로 구성된다 open write read close이다.

open은 일종의 준비 단계로 존재하는지, 권한 여부를 체크한다.

사용할 수 있으면 fd를 반환한다.

fd는 파일에 쓰거나 읽기 연산을 하려면 fd를 얻고 끝나면 반환해야 한다.

이처럼 어떤 파일에 접근할 수 있는 권한인 fd를 file descriptor라 한다.

##### **파일 쓰기 또는 읽기**

fd는 해당 파일에 대한 접근권한을 가지므로 연산의 맨 앞에는 언제나 fd를 사용한다.

##### **파일 닫기**

close로 파일을 닫는다.
-close(fd)로 가리키는 파일 즉 파일을 닫는다.

파일을 이용한 통신은 부모-자식 관계의 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다.

그래서 프로세스가 알아서 동기화를 해야하는데 주로 부모 프로세스가 wait 홤수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다린다.

#### **파이프를 이용한 통신**

프로세스 동기화 문제를 해결하는 방법으로 파이프가 있다.

파이프를 이용한 통신은 운영체제가 제공하는 동기화 통신 방식으로, 파일 입출력과 같이 open 함수로 기술자를 얻어 작업이 만료도고 close로 마무리한다.

파이프에 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받는다.

파이프는 이름 없는 파이프와 이름 있는 파이프로 나뉜다.

- **이름 없는 파이프**: 일반적으로 파이프라고 하면 이름 없는 파이프를 가리킨다. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 IPC간 사용된다.
- **이름 있는 파이프**: FIFO라 불리는 특수 파일을 이용하며 서로 관련없는 프로세스 간 통신에 사용된다.

#### **소켓을 이용한 통신**

여러 컴퓨터 프로세스도 소통할 수 있고 이를 네트워킹이라 한다.

이때 소켓을 이용한다.

TCP/IP가 있어야 인터넷을 사용할 수 있는데, IP는 목적지까지 데이터를 전송하는 프로토콜이다. 이때 사용되는게 IP주소이다.

해당 컴퓨터에는 네트워크를 사용하는 많은 프로세스가 존재하는데 이를 구분하는게 포트이다.

포트 번호는 0부터 65535 사이의 포트번호를 부여받는다.

서버에서 돌아가는 프로세스를 데몬이라고 하는데, 서버용 데몬도 포트번호가 필요하다.

서버용 데몬에 임의의 포트 번호를 부여하면 클라이언트가 해당 포트 번호를 찾아야 한다.

그래서 중요한 서버용 프로세스(데몬)에는 미리 정해진 포트 번호를 할당한다.

예를 들어 웹 데몬의 포트 번호는 80 파일 데몬의 포트 번호는 21이다.

서버 쪽 데몬 80번을 생각해보면 여러명의 사용자가 요청할 수 있다. 이때 소켓을 통해 하나의 포트에 여러 클라이언트를 연결하기 위한 소켓이 필요한데.

클라이언트들은 포트에 연결된 멀티 소켓에 하나씩 연결된다.

서버 프로세는 소켓을 사용하여 동시에 여러 클라이언트에 서비스를 제공한다.

결국 네트워크에서 데이터를 보낸다는 것은 클라이언트 소켓이 서버 소켓에 데이터를 보내는 것이다.

그래서 네트워크 프로그래밍을 소켓 프로그래밍이라고 부른다.

통신할 때는 원격 프로시저 호출이나 소켓을 사용한다.

프로시저 호출이 한 컴퓨터에 있는 함수를 호출하는 것이라면, 원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것이다.

자바와 같은 객체 지향 언어에서 다른 컴퓨터에 있는 개체의 메서드를 불러와 사용하는 것은 모두 원격 프로시저 호출의 예이다.

일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현한다.

소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.

앞에서 언급했듯이 파이프를 이용한 통신에서는 양방향 통신에 파이프가 2개 필요하지만 소켓을 이용한 통신에서는 소켓을 1개만 사용해도 양방향 통신이 가능하다.

## 5.2 공유 자원과 임계 구혁

### 5.2.1 공유 자원에 대한 접근

### 5.2.2 임계구역

### 5.2.3 생산자 - 소비자 문제

### 5.2.4 임계구역 문제 해결 조건

## 5.3 임계구역 문제 해결 방법

### 5.3.1 기본 코드 소개

### 5.3.2 임계구역 문제 해결 조건을 고려한 코드 설계

### 5.3.3 피터슨 알고리즘

### 5.3.4 데커 알고리즘

### 5.3.5 세마포어

### 5.3.6 모니터

## 5.4 파일, 파이프, 소켓 프로그래밍

### 5.4.1 파일

### 5.4.2 파이프

### 5.4.3 네트워킹
