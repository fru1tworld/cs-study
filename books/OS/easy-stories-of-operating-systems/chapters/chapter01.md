# .4 프로세스의 개념

일반적으로 프로세스는 **실행 중인 프로그램**으로 정의

**핵심 질문 : CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가**

시분할(time sharing)이라 분리는 기법은 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게한다. CPU를 공유하기 때문에 각 프로세스의 성능은 낮아진다.

CPU 가상화의 효율적 구현을 위해서는 도구와 지능이 필요하다.

도구를 **매커니즘(mechanism)**이라 한다. 매커니즘은 필요한 기능을 구현하는 방법이다. 예를 들어 **문맥 교환(context switch)이** 있다.

운영체제의 지능은 **정책(policy)의** 형태로 표현된다. 정책이란 운영체제에서 어떤 결정을 내리는데 사용되는 알고리즘이다.

운영체제의 **스케줄링 정책(scheduling policy)**이 이러한 결정을 내린다.

이러한 결정을 위해 과거 정보 및 성능 측정 결과를 이용한다.

### .4.1 프로세스의 개념

운영체제는 실행 중인 프로그램의 개념을 제공하는데 이를 프로세스라 한다.

프로세스의 구성 요소를 이해하기 위해 하드웨어 상태를 이해해야한다. 프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있는데 가장 중요한 구성 요소는 메모리이다.

명령어는 메모리에 저장되고 읽고 쓰는 데이터 역시 메모리에 저장된다.

프로세스가 접근할 수 있는 메모리**(주소 공간(address space)이라 불림)**는 프로세스를 구성하는 요소이다.

마찬가지로 레지스터도 프로세스의 하드웨어 상태를 구성하는 요소이다.

프로세스의 하드웨어 상태를 구성하는 레지스터 중에 특별한 레지스터들이 존재한다.

**프로그램 카운터(program counter, PC)**는 프로그램의 어느 명령어가 실행 중인지를 알려준다.

프로그램 카운터는 **명령어 포인터(instruction pointer, IP)라고도 불린다.**

**스택 포인터(stack pointer)** 와 **프레임 포인터는(frame pointer)** 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터이다.

팁 : 정책과 구현의 분리

다수의 운영체제들이 공통적으로 채택하고 있는 설계 패러다임은 정책과 메커니즘의 분리이다.

### .4.2 프로세스 API

실제 API는 다음의 장으로 미루겠지만 운영체제가 반드시 제공해야 하는 몇몇 기본 기능에 대해 간단히 살펴본다.

- 생성(Create) :운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야한다.
- 제거(Destroy) : 운영체제는 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야한다.
- 대기(Wait) : 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공된다.
- 각종 제어(Miscellaneous Control) : 프로세스의 제거, 대기 이외에, 여러 가지 제어 기능들이 제공된다. 예를 들어, 대부분의 운영체제는 프로세스를 일시정지하거나 재개하는 기능을 제공한다.
- 상태(Status) : 프로세스 상태 정보를 얻어내는 인터페이스도 제공된다.

### 4.3 프로세스 생성 : 좀 더 자세하게

프로그램 실행을 위해 운영체제가 하는 첫 번째 작업은 프로그램 코드와 정적 데이터(static data, 예를 들어 초기값을 가지는 변수)를 메모리, 프로세스 주소 공간에 **탑재(load)**하는 것이다.

프로그램은 디스크 또는 요즘은 SSD에 특정 실행 파일 형식으로 존재한다.

초기에는 실행전 코드와 데이터를 모두 메모리에 탑재하였는데 현대의 운영체제는 필요할 때 필요한 부분만 메모리에 탑재한다.

코드와 데이터의 늦은 탑재의 동작은 **페이징과 스와핑** 동작의 이해가 필요하다.

이후 소개되며 요점은 디스크에서 메모리에 탑재해야한다는 것이다.

코드와 정적데이터가 메모리로 탑재된 후 프로세스를 실행시키기 전에 운영체제가 해야 할 일 몇 가지가 있다. 특정 크기의 메모리 공간이 프로그램에 **스택(run-time stack, 혹은 그냥 스택)** 용도로 할당되어야 한다.

운영체제는 스택을 주어진 인자로 초기화한다.

운영체제는 프로그램의 **힙(heap)**을 위한 메모리 영역을 할당한다.

힙은 동적으로 할당된 데이터를 저장하기 위해 사용된다.

힙은 연결 리스트, 해시 테이블, 트리 등 크기가 가변적인 자료 구조를 위해 사용된다.

운영체제는 또 입출력과 관계된 초기화 작업을 수행한다.

각 프로세스는 기본적으로 표준 입력, 표준 출력, 표준 에러 장치에 해당하는 세 개의 파일 디스크립터를 갖는다. 이 디스크립터들을 사용하여 프로그램은 터미널로부터 입력을 읽고 화면에 출력을 프린트하는 작업을 쉽게 할 수 있다.

코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관계된 다른 작업을 마치게 되면 운영체제는 프로그램 실행을 위한 준비를 마치게 된다.

프로그램의 시작 지점(entry point) 즉 main()에서 부터 프로그램 실행한다.

### 4.4 프로세스 상태

프로세스의 상태의 개념은 초기 컴퓨터에서 등장하였다.

프로세스 상태를 단순화하면 다음 세 상태 중 하나에 존재할 수 있다.

**실행(Running) :** 실행 상태에서 프로세스는 프로세서에서 실행 중인다. 즉 프로세스는 명령어를 실행하고 있다.

**준비(Ready) :** 준비 상태에서 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다.

**대기(Blocked)** : 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산이다. 흔한 예 : 프로세스가 디스크에 대한 입출력 요청을 하였을 떄 프로세스는 입출력이 완료될 떄까지 대기 상태가 되고, 다른 프로세스가 실행 상태로 될 수 있다.

프로세스는 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 전이한다.

이벤트가 발생하면 프로세스는 다시 준비 상태로 전이되고 운영체제의 결정에 따라 바로 다시 실행될 수 있다.

### 4.5 자료구조

프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 프로세스 리스트(process list)와 같은 자료 구조를 유지한다. 또 대기 상태인 프로세스들에 대한 정보도 관리한다.

**레지스터 문맥(register context)** 자료 구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터값들을 저장한다. 이 레지스터값들을 복원하여 운영체제는 프로세스 실행을 재개한다.

**초기(initial)** 상태를 가지는 시스템도 있다.

프로세스가 완전히 생성되기 전까지의 상태를 나타낸다.

xv6 커널에서 각 프로세스를 추적하기 위해 운영체제가 필요로 하는 정보를 보이고 있다.

```c
//프로세스를 중단하고 이후에 재개하기 위해
//xv6가 저장하고 복원하는 레지스터
struct context{
	int eip;
	int esp;
	int evx;
	int ecx;
	int edx;
	int esi;
	int edi;
	int ebp;
};

enum proc_state { UNUSED, EMBRYO, SLEEPING,
									RUNNABLE, RUNNING, ZOMBIE};

// 레지스터 문맥과 상태를 포함하여
// 각 프로세스에 대하여 xv6가 추적하는 정보

struct proc{
	char *mem; //프로세스 메모리 시작 주소
	uint sz; // 프로세스 메모리의 크기
	char *kstack; //이 프로세스의 커널 스택의 바닥 주소
	enum proc_state state; // 프로세스 상태
  int pid;
  struct proc *parent; //부모 프로세스
  struct *chan // 0이 아니면, chan에서 수면
  int killed; // 0이 아니면 종료됨
  struct file *ofile[NOFILE]; // 열린 파일
  struct inode *cwd; // 현재 디렉토리
  struct context context; // 프로세스를 실행시키려면 여기로 교환
  struct trapframe *tf // 현재 인터럽트에 해당하는 트랩 프레임
};
```

프로세스는 종료되었지만 완전히 반납되지 않은 상태인 **최종(final)** 상태도 있다.

(UNIX 기반 시스템에서 이 상태는 **좀비(zombie)** 상태로 불린다.

이 상태는 하나의 프로세스가 (보통 부모 프로세스) 다른 프로세스가 성공적으로 실행을 마쳤는지를 파악하는 데 유용하게 사용된다.

자료구조 : 프로세스 리스트

다수의 프로그램을 동시에 실행할 수 있는 모든 운영체제는 이와 유사한 자료 구조를 가지고 있고, 이 자료 구조를 이용하여 시스템에서 실행 중인 프로그램을 관리한다. 이 프로세스의 관리를 위한 정보를 저장하는 자료구조를 **프로세스 제어 블럭(Process Control Block, PCB**)라고 부른다. 프로세스 관련 정보를 저장한 C 자료 구조를 일컫는 멋진 이름이다.

프로세스 관련 주요 용어

**프로세스 API** 는 프로세스와 **관련된 함수**들을 일컫는다. 프로세스의 생성, 삭제 등에 관련된 함수들이다.

**프로세스 리스트는** 시스템에 존재하는 모든 프로세스에 대한 정보를 갖는다. 이 리스트의 **각 노드는 프로세스 제어 블럭**이다.

# .5 프로세스 API

### 5.1 fork() 시스템

```c
int main(int argc, char*argc[]){
	printf("hello world (pid:%d)\n", (int) getpid());
	int rc = fork();
	if ( rc < 0 ){  // fork 실패; 종료
		fprintf(stderr, "fork failed\n");
	}else if(rc == 0){ // 자식(새 프로세스)
		printf("hello, I am child (pid:%d)\n", (int) getpid());
	}else{ // 부모 프로세스는 이 경로를 따라 실행한다.
		(main)
		 printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid());
  }
	return 0;
}

prompt> ./p1
hello world (pid:29146)
hello, I am parent of 29147 (pid:29146)
hello, I am child (pid:29147)
promte>

prompt> ./p1
hello world (pid:29146)
hello, I am child (pid:29147)
hello, I am parent of 29147 (pid:29146)
prompt>
```

이 프로그램의 출력 결과는 항상 동일하지 않다 단일 CPU 시스템에서 이 프로그램을 실행하면 프로세스가 생성되는 시점에는 2개의 프로세스 중 하나가 실행된다.

CPU 스케줄러는 실행할 프로세스를 선택한다. 스케줄러의 동작은 일반적으로 상당히 복잡하고 상황에 따라 다른 선택이 이루어지기 때문에 어느 프로세스가 먼저 실행된다고 단정할 수 없다.

이러한 **비결정성(nondeterminism)**으로 인해 멀티 쓰레드 ㅂ프로그램 실행시 다양한 문제가 발생한다.

### 5.2 wait() 시스템 콜

```c
int main(int argc, char*argv[]){
	printf("hello world (pid: %d)\n", (int) getpid());
	int rc = fork();

	if ( rc < 0 ){  // fork 실패; 종료
		fprintf(stderr, "fork failed\n");
	}else if(rc == 0){ // 자식(새 프로세스)
		printf("hello, I am child (pid:%d)\n", (int) getpid());
	}else{ // 부모 프로세스는 이 경로를 따라 실행한다.
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait: %d) (pid: %d) \n",
               rc, rc_wait, (int) getpid());
    }
	return 0;
}
```

wait 시스템 콜을 호출하여서 자식 프로세스 종료 시점까지 자신의 실행을 잠시 중지 시킨다.

자식 프로세스가 종료되면 wait()는 리턴한다.

wait() 호출을 위와 같이 코드에 추가하면 항상 동일한 결과를 출력한다.

자식 프로세스가 부모 프로세스보다 먼저 실행되면 당연히 자식 프로세스가 먼저 실행되고

부모 프로세스가 먼저 실행되면 wait 를 호출한다. 이 시스템 콜은 자식 프로세스가 종료될 때까지 리턴하지 않는다.

### 5.3 exec() 시스템 콜

프로세스 생성 관련 API 중에서 마지막으로 중요한 시스템 콜은 exec() 시스템 콜이다.

이 시스템 콜은 자기 자신이 아닌 다른 프로그램을 실행해야할 때 사용된다.

fork()는 자신의 복사본을 생성하여 실행한다.

자신의 복사본이 아닌 다른 프로그램을 실행해야 할 경우에는 exec() 시스템 콜이 그 일을 한다.

fork()는 매우 특이하다. exec()도 마찬가지이다.

실행 파일 이름과 약간의 인자가 주어지면 해당 파일의 코드와 정적 데이터를 읽어 들여 현재 실행 중인 프로세스의 코드 세그먼트와 정적 데이터 부분을 덮어쓴다.

힙과 스택 및 프로그램 다른 주소 공간들로 새로운 프로그램의 실행을 위하여 다시 초기화된다.

그런 다음 프로세스의 argv와 같은 인자를 전달하여 프로그램을 실행시킨다.

새로운 프로그램를 생성하는 것이 아닌 다른 프로그램으로 대체하는 것이다.

### 5.4 왜 이런 API를 ?

새로운 프로세스를 생성하는 것은 간단한 작업같은데 왜 이런 이상한 인터페이스를 사용할까 ?

UNIX의 쉘을 구현하기 위해서는 fork()와 exec()을 분리해야 한다.

그래야만 쉘이 fork()를 호출하고 exec()를 호출하기 전에 코드를 실행할 수 있다.

### 5.5 프로세스 제어와 사용자

UNIX 시스템에는 다양한 프로세스 관련 인터페이스가 있다.

여담 : RTFM (R**ead The Fucking Manual)**

메뉴얼 페이지 또는 man 페이지를 읽어라

man 페이지는 UNIX 시스템에 존재하는 문서의 원형으로 web 이전에 만들어졌다.

시스템콜에 (시스템 콜에 값이 무엇이고 어떤 에러 조건이 존재하는지 보기 위하여) 관한 페이지이다.

예를 들면 Kill() 은 프로세스에게 멈추거나 끝내기와 같은 시그널(Signal)을 보내는데 사용된다.

편의를 위해서 대부분의 UNIX 쉘은 현재 실행 중인 프로세스에 특정 시그널을 보내는 단축키가 설정되어있다.

동시에 여러 사용자가 접속할 수 있어서 누군가 SIGINT(프로세스에 인터럽트를 걸고 종료) 시그널을 보낼 수 있다 그럴 경우 보안이 취약할 수 있어서 사용자(user)라는 강력한 개념을 도입하여 권한을 얻을 수 있게 하였다.

### 5.6 유용한 도구들

유용한 명령어들이 많이 있다.

### 5.7 요약

다양한 API를 소개하였다.

UNIX 프로세스에 대한 예찬이 대단하지만 항상 긍정적이지 않다. fork()에 문제가 있다는 것을 밝혔고 spawn()과 같은 간단한 프로세스 생성 API를 사용해야 한다고 주장하였다.

즉 모든 의견이 항상 보편적이지 않을 수 있다는 것을 기억하자

# .6 제한적 직접 실행 원리 (Limited Direct Execution)

CPU를 가상화하기 위해서 운영체제는 여러 작업이 동시에 실행되는 것처럼 보이도록 물리적 CPU를 공유한다.

CPU 시간을 나누어 씀으로써 가상화를 구현할 수 있다.

이러한 가상화 기법을 구현하기 위해 몇 가지 문제를 해결해야 한다.

1. 성능 저하, 시스템에 과중한 오버헤드를 주지 않으면서 가상화를 구현할 수 있을까?
2. 제어 문제이다. CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시킬 수 있는 방법은 무엇인가.

## 6.1 기본 원리

운영체제 개발자들은 프로그램을 빠르게 실행하기 위하여 제한적 직접 실행(Limited Direct Execution)이라는 기법을 개발하였다.

운영체제가 프로그램을 실행하기 시작할 때 프로세스 목록에 해당 프로세스 항목을 만들고 메모리를 할당하며 프로그램 코드를 디스크에 탑재하고 진입점을 찾아 그 지점으로 분기하여 사용자 코드를 실행하기 시작한다.

이 접근법은 CPU를 가상화함에 있어서 몇 가지 문제가 있다.

- 직접 실행시킨다면 프로그램이 운영체제가 원치않는 일을 하지 않는 다는 것을 보장할 수 없다.
- 프로세스 실행 시 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환할 수 있는 시분할 기법을 구현할 수 있느냐는 것이다.

### 6.2 문제점 1 : 제한된 연산

직접 실행의 장점은 빠르게 실행된다는 것이다.

그러나 직접 실행의 단점은 프로세스가 특수한 종류의 연산을 수행하길 원한다면 어떻게 될 것인가 ?

- 디스크 입출력 요청, CPU 또는 메모리와 같은 시스템 자원에 대한 추가할당 요청

프로세스가 원하는 대로 할 수 있게 방치하는 방안이 있다. 그러나 이 방안은 바람직한 시스템을 구축하는 데에는 방해요인이다.

파일에 대한 접근을 허용하기 전 접근 권한을 검사하는 파일 시스템을 구현하는 것을 예를 들어보자.

프로세스가 디스크에 대해 입출력하는 것을 제한하지 않으면 프로세스는 전체 디스크를 읽고 쓸 수 있기 때문에

사용자 모드가 도입되었다. 사용자 모드에서는 실행되는 코드는 할 수 있는 일이 제한되고, 입출력 요청을 하면 프로세스가 예외를 발생시키고 운영체제는 해당 프로세스를 제거한다.

커널 모드는 사용자 모드와 대비되는 모드로 중요한 코드들이 실행된다. 이 모드에서 실행되는 코드는 특수한 명령어를 포함하여 원하는 모든 작업을 수행할 수 있다.

그러나 사용자 프로세스가 디스크를 읽기와 같은 특권 명령어를 실행해야 할 때 trap 이라는 특수 명령어를 실행하여 커널 모드로 상향 조정된다.

커널 모드로 진입 시 운영체제는 모든 명령어를 실행할 수 있고 이를 통하여 요청한 작업을 처리할 수 있다.

완료되면 return-from-trap 특수 명령어를 호출한다.

이 명령어는 커널 모드에서 사용자 모드로 하향 조정하는 것이다.

하드 웨어는 trap 모드를 사용할 때 주의가 필요하다.

호출한 프로세스의 필요한 레지스트들을 저장해야한다. return-from-trap 명령어 실행 시 제대로 리턴할 수 있기 위함이다.

예를 들면 x86 에서는 프로그램 카운터, 플래그와 다른 몇 개의 레지스터를 각 프로세스의 커널 스택에 저장한다.

return-from-trap 명령어가 이 값들을 스택에서 pop하여 사용자 모드 프로그램의 실행을 다시 시작한다.

또 다른 중요한 지점은 trap이 운영체제 코드의 어디를 실행할지 어떻게 아느냐는 것이다.

호출한 프로세서는 분기할 주소를 명시할 수 없다. 커널이 임의의 코드를 실행하기 위해서는 접근 권한 검사가 끝난 후 분기해야 한다.

이러한 문제 때문에 커널은 trap 발생 시 어떤 코드를 실행할 지 신중하게 통제해야 한다.

커널은 부팅 시 트랩 테이블을 만들고 이를 이용하여 시스템을 통제한다.

컴퓨터가 부트될 때는 커널 모드에서 동작하기 때문에 하드웨어를 원하는 대로 제어할 수 있다.

운영체제가 하는 초기 작업 중 하나는 하드웨어에게 예외 사건이 일어났을 때 어떤 코드를 실행해야 하는지 알려주는 것이다.

운영체제는 특정 명령어를 사용하여 하드웨어에게 트랩 핸들러의 위치를 알려준다.

모든 시스템 콜은 자신의 고유 번호를 갖는다.

trap 핸들러는 운영체제의 일부이다.

하드웨어에게 트랩 테이블의 위치를 알려주는 것은 매우 강력한 기능이다.

당연히 이 역시 특권 명령어이다.

### 6.3 문제점 2 : 프로세스 간 전환

직접 실행의 두 번째 문제점은 프로세스 전환이 가능해야한다는 점이다.

프로세스의 전환은 실행 중인 프로세스를 멈추고 다른 프로세스를 실행하는 것이다.

말로 들으면 간단하지만 프로세스가 실행 중이라는 것은 운영체제는 실행 중이지 않다는 것을 의미한다.

### 협조 방식 : 시스템 콜 호출시 까지 대기

협조 방식으로 알려진 방법은 과거의 몇몇 시스템에서 채택된 방법으로 이 방식은 각 사용자 프로세스가 비정상적인 행동은 하지 않을 것으로 가정한다.

대부분의 프로세스는 시스템 콜을 자주 호출하는 것으로 알려져 있다. 협조 방식을 사용하는 운영체제는 yield 시스템 콜을 제공한다 이 시스템 콜은 운영체제에게 제어를 넘겨 응용 프로그램이 비정상적인 행위를 하면 운영체제에게 제어가 넘어간다.

예를 들어 운영체제가 0으로 나누는 연산을 실행하거나 허가되지 않은 메모리에 접근을 시도하면 운영체제로의 트랩이 일어난다.

협조 방식의 스케줄링 시스템은 근본적으로 수동적이다.

즉 CPU 제어권 획득을 위해 시스템 콜이 호출디거나 불법적인 연산이 일어나기를 대기하는 것이다.

실수이든 의도적이든 프로세스가 무한 루프에 빠져 시스템 콜을 호출할 수 없다면 문제가 발생할 수 있다.

### 비협조 방식 : 운영체제가 제어권 확보

시스템 콜의 호출이 없더라도, 운영체제에게 제어권을 넘길 수 있는 방법은 타이머 인터럽트를 이용하는 것이다.

인터럽트가 발생했을 때 이를 처리하는 것은 운영체제의 가장 중요한 역할 중 하나이다.

인터럽트가 발생하면 실행 중인 프로세스를 종료하고 인터럽트에 대한 인터럽트 핸들러를 실행한다.

운영체제는 타이머 인터럽트가 발생 시 실행해야 할 코드의 주소를 기록해두어야 한다.

타이머는 인터럽트를 주기적으로 발생시킨다.

특정주기로 제어권이 운영체제에 넘어감으로 운영체제는 사용자 프로그램이 비정상적으로 작동하는 경우가 발생하더라도 언제든지 해당 프로그램을 적절히 처리할 수 있는 기회를 갖을 수 있다.

### 문맥의 저장과 복원

시스템 콜을 통하여 협조적으로 하던 또는 타이머 인터럽트를 통하여 약간은 강제적으로 하던, 운영체제가 제어권을 다시 획득하면 중요한 결정을 내려야한다.

즉 현재 실행중인 프로세스를 계속 실행할 것인지, 아니면 다른 프로세스로 전환할 것인지를 결정해야한다.

이 결정은 운영체제의 스케줄러(scheduler)라는 부분에 의해 내려진다.

현재 프로세스를 종료하고 다른 프로세스를 실행하기로 결정하면 운영체제는 문맥 교환(context switch)이라 불리는 코드를 실행한다.

문맥 교환의 개념은 : 현재 실행 중인 프로세스의 레지스터 값들을 커널 스택 같은 곳에 저장하고 새로이 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이 전부다.

그렇게 함으로써 운영체제는 return-from-trap 명령어가 마지막으로 실행될 때 현재 실행중이던 프로세스로 리턴하는 것이 아니라 다른 프로세스로 리턴하여 실행을 다시 시작할 수 있다.

현재 프로세스의 문맥을 메모리에 저장하고 새로이 실행될 프로세스로 문맥을 CPU로 읽어들이는 작업은 주로 어셈블리 코드를 사용하여 작성된다.

### 6.4 병행실행으로 인한 문제

만약 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하면 어떻게 해야할까

하나의 인터럽트를 처리하고 있을 때 다른 인터럽트가 발생하면 ?

이러한 문제는 병행성에 관한 것이다.

인터럽트를 처리하는 동안에는 인터럽트를 불능화 시키는 것이다.

하나의 인터럽트가 처리되고 잇는 동안 다른 어떤 인터럽트들도 CPU에 전달되지 않는다.

이러한 기법은 신중하게 사용해야 한다.

인터럽트를 장기간 불능화하면 손실되기 때문이다.

운영체제는 내부 자료 구조가 동시에 접근되는 것을 방지하기 위해 다양한 락(lock) 기법을 개발해 왔다.

커널 내부의 각종 자료 구조들이 락으로 보호되기 때문에 내부에서 다수의 작업들이 동시에 진행되는 것이 가능하다.

### 6.5 요약

운영체네는 프로그램이 특별연산을 수행할 때 혹은 어떤 프로세스가 CPU를 독점하고 있어, CPU를 강제로 다른 프로세스에게 전환할 때에만 개입한다.

그리고 어떤 프로세스를 다음에 실행할까에 대한 문제가 남아있다.

# .7 스케줄링 : 개요

다양한 스케줄링 정책을 소개한다.

## 7.1 워크로드에 대한 가정

프로세스가 동작하는 일련의 행위를 워크로드라 한다.

워크로드의 선정은 스케줄링 정책 개발에 매우 중요한 부분이다.

워크로드에 대한 이해도 높을수록, 그에 최적화된 스케줄링 정책을 정교하게 개발할 수 있다.

최종적으로는 제대로 동작하는 스케줄링 정책을 만들게 될 것이다.

## 7.2 스케줄링 평가 항목

스케줄링 평가 항목을 결정해야한다.

먼저, 반환 시간(turnaround time)이라는 스케쥴러는 평가하는 기준에 대해 확인해보면

작업 반환 시간은 작업이 완료된 시각에서 작업이 도착한 시간을 뺀 시간이다.

반환 시간은 성능 측면에서의 평가 기준이라는 것을 주목해야한다.

다른 평가 기준으로는 공정성이 있다. 성능과 공정성은 스케줄링에서 서로 상충된다.

스케줄러는 전체 시스템의 성능을 극대화하기 위해 몇몇 작업에 대해 실행기회를 주지 않을 수 있다.

결과적으로 공정성이 약화된다.

## 7.3 선입선출 FIFO

가장 기본적인 알고리즘은 FIFO 또는 선도착선처리 FCFS 이다

FIFO 스케줄링은 A,B,C 가 100,10,10초 동안 실행된다고 가정했을 때

평균 반환시간이 110초가 된다. (100 + 110 + 120 ) / 3 = 110

이 현상을 convoy effect 라 부른다 CPU를 많이 필요로 하지 않는 프로세스들이 CPU를 오래동안 기다리는 현상을 의미한다.

## 7.4 최단 작업 우선 SJF

가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.

아까의 예시에서는

B,C,A 로 실행시킴으로써 (10 + 20 + 120) / 3 = 50) 으로 2배 향상시켰다.

모든 작업이 동시에 도착한다면 SJF가 최적임을 증명할 수 있다.

하지만 임의의 시간에 도착한다고 가정한다면

B,C 가 A 바로 뒤에 도착한다 하더라도 A가 끝날 때까지 기다릴 수 밖에 없어 다시 같은 문제가 발생한다.

## 7.5 최소 잔여시간 우선

이 문제를 해결하기 위해서는 작업은 실행도중 중단될 수 있어야한다.

SJF에 선점 기능을 추가한 스케쥴러를 최단 잔여시간 우선(STCF) 또는 PSJF 라 한다.

아까에 예시에서는

A가 먼저 도착했더라도 중간에 난입한 B,C가 서로 선점하여 평균 반환 시간이 단축된다.

## 7.6 새로운 평가 기준 : 응답 시간

작업의 길이를 미리 알고 있고, 작업이 오직 CPU만 사용하며, 평가 기준이 반환 시간 하나라면 STCF는 매우 훌륭한 정책이다. 하지만 시분할 컴퓨터의 등장으로 응답 시간이라는 새로운 평가기준을 탄생하게 되었다.

응답 시간은 작업이 도착하는 시점부터 처음으로 스케줄 될 때까지의 시간으로 정의된다.

T(response) = T(firstrun) - T(arrival)

STCF를 비롯하여 비슷한 류의 정책들은 응답 시간이 짧다고 할 수 없다.

예를 들어 3개의 작업이 동시에 도착한 경우 두 작업이 완전히 끝날 때까지 기다린다.

## 7.7 라운드 로빈(RR)

응답 시간 문제를 해결하기 위하여 라운드 로빈 스케줄링이라 불리는 스케줄링 알고리즘을 도입한다.

일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다. 이때 작업이 실행되는 일정 시간을 타임 슬라이스 또는 스케줄링 퀀텀이라 부른다.

이러한 이유로 RR은 타임 슬라이싱이라고 불린다.

RR에서 타임 슬라이스의 길이는 매우 중요하다. 타임 슬라이스가 짧을 수록 응답 시간 기준으로는 성능이 더 좋아진다 하지만 너무 짧게 지정하면 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 된다.

따라서 문맥 교환 비용을 상쇄할 수 있을 만큼 길어야 하지만 그렇다고 응답시간이 너무 길면 곤란하다.

문맥 교환 비용에는 레지스터를 저장/복원하는 작업만 있는 것이 아닌 CPU 캐시, TLB, 분기 예측 등을 비롯하여 다른 하드웨어에도 프로그램과 관련된 다양한 작업 정보들이 저장되어 있따. 작업이 전환되면 모두 갱신되어야 한다.

갱신 작업이 매우 큰 성능 비용을 유발한다.

적당한 길이의 응답 시간이 유일한 평가 기준인 경우 타임 슬라이스를 가진 RR은 매우 훌륭한 스케줄러이다.

반환 시간 기준으로는 최악의 정책이 될 수 있다.

## 7.8 입출력 연산의 고려

이제 모든 프로그램은 입출력 작업을 수행한다.

현재 실행 중인 프로세스가 입출력 작업을 요청한 경우 스케줄러는 다음에 어떤 작업을 실행해야할지 결정한다.

입출력이 완료될때까지 CPU를 사용하지 않을 것이기 때문이다. 그런 경우 입출력 완료를 기다리며 대기 상태가 된다.

마찬가지로 스케줄러는 입출력 완료시에도 의사 결정을 해야한다.

## 7.9 만병통치약은 없다

각 스케줄러는 각 작업의 실행 시간을 알 수 없으므로 사전 지식 없이 SJF 처럼 알고리즘을 구축하고 추가적으로 RR 스케줄러의 아이디어를 도입하는 방법은 없을까 ?

## 7.10

과거의 프로세스 동작 이력을 반영하는 식으로 문제를 해결한다.

이 스케줄러를 멀티 레벨 피드백 큐라 한다.

# .8 스케줄링 : 멀티 레벨 피드백 큐

멀티 레벨 피드백 큐(Multi-level Feddback Queue, MLFQ)로 알려진 가장 유명한 스케줄링 기법에 대해 논의한다.

## 8.1 MLFQ: 기본 규칙

MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위가 배정된다.

실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다.

실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 높은 우선순위를 가진 작업이, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다.

큐에 둘 이상의 작업이 존재할 수 있다. 이들은 모두 같은 우선순위를 가진다.

이 작업들 사이에서는 라운드 로빈 스케줄링 알고리즘이 사용된다.

MLFQ의 핵심은 우선순위를 정하는 방식이다.

각 작업에 고정된 우선순위를 정하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다.

규칙 1. Priority(A) > Priority(B) 이면 A가 실행된다.

규칙 2. Priority(A) = Priority(B) 이면 A와 B는 RR 방식으로 실행된다.

## 8.2 시도 1 : 우선순위의 변경

# .9 스케줄링 : 비례 배분

# .10 멀티프로세서 스케줄링 (고급)
