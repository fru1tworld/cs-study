# 개요

안녕하세요.

추석 기간 동안 책 하나를 붙잡고 완독을 목표로 달리고 있습니다.

여러가지 책 중에서 마음에 든 책이 **사이트 신뢰성 엔지니어링**인데요.

이 책을 읽고 내용을 정리하고 그 내용을 설명하듯이 블로그에 포스팅해보도록 하겠습니다.

## 1장 소개

### 서비스의 안정성과 변화 수용

개발팀과 운영팀의 입장은 서로 상반되어 이 둘의 입장을 포용하는 역할이 되는 직종을 **DevOps**라고 하는데요.

개발팀은 새로운 기능을 향상 개발하고 싶어하고, 운영팀은 보수적으로 서비스가 안정적으로 운영되길 바랍니다.

그래서 **SRE**는 중간점을 찾아서 신뢰성 목표를 100%로 설정하지 않고 일정 에러를 허용하는 방식으로 에러 예산이라는 개념을 도입했습니다.

예를 들어서 신뢰성 목표를 100%로 설정하는 것과 **99.9999%의 차이**는 사실상 없다고 볼 수 있습니다.

일단 소프트웨어를 잘 만들었다하더라도 외부에 의존적인 경우 **각 의부 컴포넌트의 신뢰성**이 100%이지 않습니다.

사용하는 디바이스의 신뢰성, 네트워크의 신뢰성 등 다양한 요소로 인해 100%의 목표를 달성하는 것은 거의 불가능합니다.

그렇다면 99.99%와 같은 지표를 목표로 잡았다면 **0.01%**가 여기서 이야기하는 **에러 예산**에 해당합니다.

그러면 개발팀은 이 에러 예산 내에서 자유롭게 새로운 기능 출시를 위한 리스크를 감당할 수 있게 됩니다.

## 모니터링

모니터링은 시스템의 상태와 가용성을 점검하는 것을 의미하는데요.

중요한 개념은 다음과 같습니다.

**알람:** 어떤 문제가 발생했거나 발생하고 할 때 상황을 개선하기 위해 사람이 즉각적으로 어떤 대응을 취해야 하는 것을 알림

**티켓:** 사람의 대응은 필요하지만 즉각적으로 필요하지않고 시스템이 자동으로 처리할 수 없지만 사람이 며칠 내로 대응하면 문제 없는 경우

**로징:** 이후 분석 혹은 조사를 위해 기록되는 내용을 의미합니다.

## 프로비저닝

프로비저닝은 변화 관리와 수용 계획을 함한 개념이라고 합니다.

변화 관리는 앞서 언급한 모니터링 등에 해당하고 수용 계획은 에러 예산과 관련된 내용입니다.

그래서 결국 프로비저닝은 무엇을 의미하는 것일까요 ?

위키피디아에서는 사용자의 요구에 맞춰 필요한 IT 자원을 준비하고 할당하여 사용 가능한 상태로 만드는 과정이라고 하는데요.

## 2장 SRE 관점에서 바라본 구글의 프로덕션 환경

### 하드웨어

구글의 데이터센터는 일반적인 데이터센터나 소규모 서버 팜과는 근본적으로 다른 접근 방식을 취합니다.

**머신(Machine)**

- 물리적 하드웨어 또는 가상 머신(VM)을 의미합니다
- 특정 서비스에 종속되지 않고 유연하게 활용됩니다

**서버(Server)**

- 머신 위에서 실행되는 소프트웨어 조각을 의미합니다
- 하나의 머신에 여러 서버가 동작할 수 있습니다

### 시스템 소프트웨어로 하드웨어 관리하기

**보그(Borg) - 클러스터 운영 시스템**

- 수천 대의 머신을 하나의 클러스터로 관리합니다
- 자원 할당과 작업 스케줄링을 자동으로 처리합니다
- 개발자는 "어느 머신에서 실행할지"를 고민하지 않고 "어떤 자원이 필요한지"만 선언하면 됩니다

**스토리지 계층**

- D (디스크): 로컬 디스크 스토리지
- Colossus: 구글의 차세대 분산 파일 시스템 (GFS의 후속)
- 데이터의 중요도와 접근 패턴에 따라 적절한 스토리지 계층을 선택합니다

**네트워킹**

- 글로벌 스케일의 네트워크 인프라
- 지연 시간 최소화를 위한 전략적 배치
- 대역폭 관리와 우선순위 설정

### 기타 시스템 소프트웨어

**네이밍과 서비스 디스커버리**

- BNS(Borg Naming Service): 서비스 인스턴스를 찾을 수 있게 해주는 이름 서비스
- 동적으로 변하는 서비스 위치를 추상화합니다

**모니터링과 알림**

- Borgmon: 모니터링 시스템으로 메트릭 수집 및 알림 생성
- 시계열 데이터 저장 및 쿼리 기능 제공

### 소프트웨어 인프라스트럭처

**RPC 인프라**

- Stubby: 구글 내부의 RPC(원격 프로시저 호출) 프레임워크
- 서비스 간 통신을 표준화하고 단순화합니다
- 프로토콜 버퍼를 사용한 데이터 직렬화

**데이터 처리 파이프라인**

- MapReduce, Flume, MillWheel 등을 활용한 대규모 데이터 처리
- 배치 처리와 스트리밍 처리 모두 지원

### 개발 환경

**코드 저장소**

- 단일 소스 코드 저장소 사용
- 모든 엔지니어가 동일한 코드베이스에 접근 가능

**빌드와 배포**

- 자동화된 빌드 시스템
- 카나리 배포, 점진적 롤아웃 등 안전한 배포 전략 활용

---

## 3장 위험 요소 수용하기

### 서비스 위험 측정하기

신뢰성을 100%로 만드는 것은 불가능하고, 바람직하지도 않습니다. 대신 적절한 수준의 위험을 측정하고 관리해야 합니다.

**가용성 측정 지표**

- **시간 기반 가용성**: 가용 시간 / 전체 시간
  - 예: 99.9% = 연간 약 8.76시간의 다운타임 허용
- **요청 기반 가용성**: 성공한 요청 / 전체 요청
  - 사용자 경험을 더 정확하게 반영합니다

**계산 예시**

- 99.9% 가용성: 연간 약 8.76시간 다운타임
- 99.99% 가용성: 연간 약 52.6분 다운타임
- 99.999% 가용성: 연간 약 5.26분 다운타임

### 서비스의 위험 수용도

모든 서비스가 같은 수준의 신뢰성을 필요로 하지 않습니다.

**위험 수용도를 결정하는 요소들**

1.  **서비스 수준 기대치**
    - 소비자 서비스 vs 인프라 서비스
    - 무료 서비스 vs 유료 서비스
    - 예: YouTube vs Google Ads (광고 플랫폼이 더 높은 신뢰성 요구)
2.  **비즈니스 비용**
    - 다운타임의 직접적인 수익 손실
    - 브랜드 평판 영향
    - 법적 요구사항
3.  **기술적 비용**
    - 높은 신뢰성 달성을 위한 추가 인프라 비용
    - 개발 속도 저하
    - 운영 복잡도 증가

### 에러 예산 활용하기

**에러 예산의 개념**

- 목표 신뢰성: 99.99%
- 에러 예산: 100% - 99.99% = 0.01%
- 이는 분기당 약 13분의 다운타임에 해당

**에러 예산의 실제 활용**

1.  **제품 개발 속도 조절**
    - 에러 예산이 남아있을 때: 공격적인 기능 출시 가능
    - 에러 예산을 소진했을 때: 신뢰성 개선에 집중
2.  **출시 결정의 기준**

```
   if (에러 예산 > 0) {
       새로운 기능 출시 가능
   } else {
       안정성 개선 작업 우선
       새 기능 출시 동결
   }
```

1.  **팀 간 목표 정렬**
    - 개발팀: 에러 예산 내에서 혁신 추구
    - SRE팀: 에러 예산 관리 및 모니터링
    - 둘의 이해관계가 일치하여 협력 촉진

**실제 적용 사례**

- 에러 예산을 초과한 경우: 자동으로 배포 중단, 안정성 개선 작업에 투입
- 에러 예산이 충분한 경우: 더 빠른 릴리스 주기, 실험적 기능 도입

이러한 접근 방식을 통해 SRE는 **신뢰성과 혁신 사이의 균형**을 데이터 기반으로 관리할 수 있습니다.

4장 서비스 수준 목표   
서비스를 운영하는 데 잇있어 가장 중요한 지표들과 이 지표들을 측정하고 평가하는 방법에 대해서 설명합니다.  
서비스 수준 척도(SLI), 서비스 수준 목표(SLO), 서비스 수준 협약(SLA) 등을 어떻게 정의하고, 활용할까요 ?

## 서비스 수준 관련 용어  
SLA의 개념은 일반적으로 알고 있을 테지만, 상대적으로 SLI와 SLO 역시 주의 깊게 정의해야한다.  
그 이유는 문맥에 따라서 SLA의 의미가 변하거나 여러 가지 의미를 갖는다.

### 척도(Service Level Indicator)  
SLI는 서비스 수준 척도를 의미하며, 서비스 수준을 판단할 수 있는 몇 가지를 정량적으로 측정한 값이다.

대부분의 서비스는 핵심 SLI로서 요청에 대한 응답 속도를 이야기하거나, 시스템이 수신한 전체 요청 수 대비 에러율, 그리고 초당 처리할 수 있는 요청 수를 의미하는 시스템 처리량 등이 있다.

알고자 하는 서비스 수준의 SLI를 직접 측정하는 것이 이상적이기는 하지만 경우에 따라서는 필요한 값을 얻어내거나 해석하기가 어려워 그에 준하는 대체 값을 사용하는 경우도 있다.

예를 들어 클라이언트 측의 응답 속도를 측정하는 것이 사용자와 관련해서 조금 더 의미가 있겠지만 우리 입장에서는 서버의 응답 속도만을 측정할 수 있다.

SRE가 중요하게 생각하는 SLI 중 하나는 가용성  
즉 서비스가 사용 가능한 상태로 존재하는시간의 비율이다.

이 값은 주로 올바른 형태의 요청이 성공적으로 처리된 비율을 의미하며 수율(yield), 비록 100%은 불가능하지만 100%에 가까운 가용성은 얼마든지 달성할 수 있으며, 업계에서는 통상 고가용성을 여러 개의 9를 사용해서 백분율로 표현한다.

참고로 현재 구글 컴퓨트 엔진은 99.95의 가용성을 목표로 하고 있다.

## 목표  
SLO(Service Level Objectives)는 서비스 수준의 목표를 의미하며 SLI에 의해 측정된 서비스 수준의 목표 값 혹은 일정 범위의 값을 의미한다.  
SLO는 SLI <= 목표치 또는 최솟값 <= SLI <= 최대값 으로 표현할 수 있다.

예를 들어 검색 결과를 빠르게 리턴하기로 결정했다면 응답 시간은 100ms 이하로 설정할 수 있다.

적절한 SLO를 설정하는 것은 생각보다 복잡하다.

무엇보다 필요한 값을 항상 얻어낼 수가 없다.

예를 들어 외부에서 서비스로 유입되는 HTTP 요청의 경우, 기본적으로 QPS라는 지표는 사용자가 서비스를 얼마나 사용하느냐에 따라 결정되므로 이 지표에 대한 SLO를 설정하는 것은 말이 되지 않는다.

반면 요청팡 평균 응답 시간을 100ms 이하로 달성하겠다는 목표는 설정할 수 있다.

SLO를 설정하고 고객에게 이를 공개하는 것은 서비스의 동작에 대한 예측을 가능케한다.  
이런 전략을 통해 서비스 소유자들의 서비스가 느려지고 있다는 등의 근거없는 불평을 줄일 수 있다.  
 명확한 SLO를 설정하지 않았으면 서비스를 디자인하고 운영하는 사람들의 생각과는 전혀 다른 자신들이 희망하는 성능을 기대하곤 한다.   
 그리고 이렇게 생겨난 다양한 기대치 때문에 사용자가 실제 서비스가 제공할 수 있는 것 이상의 가용성을 기대해서 지나치게 서비스에 의존하는 현상을 유발하게 된다.

## 협약  
 마지막으로 SLA(Service Level Agreements)는 서비스 수준 협약의 약자로 SLO를 만족했을 경우의 댓가에 대한 사용자와의 명시적 혹은 암묵적인 계약을 의미한다.   
그 댓가란 대부분 경제적인 것으로 대변되지만 다른 형태로 나타나기도 한다.

SLO와 SLA의 차이점을 쉽게 파악하려면 SLO를 지키지 못하면 어떻게 될까를 생각해보면 되는데 SLO는 명확한 결론이 없는 경우가 많다.

SRE는 참고로 SLA의 체결에는 관여하지 않는다 왜냐하면 SLA는 사업부 및 제품에 대한 의사 결정과 관련되기 때문이다.

그러나 SLO를 달성하지 못하는 경우를 피하기 위해서는 SRE의 도움이 필요로 하다.

구글 검색은 중요한 서비스이지만 SLA가 존재하지 않는 서비스이다.  
반면 구글 앱스등 다른 구글의 서비스들은 SLA를 체결하고 있고 SLA와 별개로 SLI와 SLO를 설정하고 이를 토대로 서비스를 관리해야 한다.

## 지표설정  
## 정말 중요한 것은 무엇인가 ?  
사실 시스템 모니터링 시스템을 통해 추적할 수 있는 모든 지표를 SLI로 취급할 필요는 없다.

예를 들어 셰익스피어 검색 프런트엔드처럼 사용자와 직접 대면하는 서비스는 주로 가용성, 응답 시간이 중요하고

저장소 시스템은 주로 응답 시간, 가용성, 그리고 내구성을 중요시한다.

데이터 처리 파이프라인같은 빅데이터 시스템은 처리량과 종단 간 응답 시간이 중요하다.   
모든 시스템은 정확성 역시 중요하게 생각해야 한다.

올바른 응답이 리턴되었는지, 올바른 데이터를 조회했는지 분석은 정확히 이루어졌는지 등을 고려해야한다.   
하지만 정확성은 인프라스트럭쳐보다는 시스템의 데이터에 대한 것이므로 이를 달성하기 위해 SRE가 관여하지 않는 경우가 대부분이다.

## 척도 수집하기  
많은 척도들은 기본적으로 보그몬이나 프로메테우스 또는 전체 요청 대비 HTTP 500 오류가 발생한 비율 등을 파악하기 위해 일정 기간에 대해 실행하는 로그 분석 등의 방법을 통해 주로 서버 측에서 수집된다.

그러나 일부 시스템들은 클라이언트 측의 수집이 이루어져야 하기도 한다.

왜냐하면 클라이언트 측에서 행위를 측정하지 않으면 서버 상의 지표에는 나타나지 않지만 사용자에게는 보여지는 문제들을 놓칠 수 있기 때문이다.

예를 들어 셰익스피어 검색 백엔드의 응답 속도만으로는 페이지의 자바스크립트 때문에 발생하는 지연응답을 판단할 수 없다.

이런 경우 페이지가 로드되기까지 걸리는 시간을 브라우저에서 측정하면 사용자의 실제 경험을 판단할 수 있다.

## 합산하기   
단순함과 유용함을 위해 측정된 원본 데이터를 합산하는 경우도 있는데 다만 이 경우 상당한 주의를 기울여야 한다.

초당 요청 수 같은 일부 지표들은 보기에는 직관적이지만, 측정 방식에 따라 직관적으로 보이는 지표들도 일정 시간 놓고 보면 은연중에 합산되어 있다.

측정 자체가 일초에 한 번 수행되는가 아니면 일분에 걸쳐 발생한 요청들의 평균 값인가? 후자의 경우라면 단 몇 초 동안에 폭발적으로 증가한 요청 비율을 제대로 분석해낼 수 없다.

어떤 시스템은 짝수초마다 200개의 요청을 처리하는 반면 나머지는 0개의 요청을 처리했다고 보면 해당 시스템의 초당 처리량은 100하지만 순간 부하는 2배이다.

그래서 대부분의 지표는 평균보다는 분포가 중요하다.  
예를 들어 SLI의 경우 일부 요청은 빠르지만 나머지는 균일하게 더 느리게 어쩌면 그보다 더 느리게 처리되었을 수 있다.

척도에 따른 백분위 수를 사용하면 분포와 더불어 독특한 특징을 알아볼 수 있다. 즉 99번째같은 수가 최악의 상황을 보여줄 수 있는데 이를 P99 값이라고 한다.

SRE는 높은 백분위 수 값들에 더 주목하기도 한다.

### 척도의 표준화  
우리는 각각 척도들의 최우선 원칙이 무엇인지를 매번 고민할 필요가 없도록 SLI들에 대한 일반적인 정의를 표준화하기를 권장한다.

- 집계 간격: 평균 1분  
- 집계 범위: 하나의 클러스터에서 수행되는 모든 태스크들  
- 측정 빈도: 매 10초  
- 집계에 퐇마한 요청들: 블랙박스 모니터링 잡이 수집한 HTTP GET 요청들  
- 데이터 수집 방식: 모니터링 시스템에 의해 서버에서 수집  
- 데이터 액세스 응답 시간: 데이터의 마지막 바이트가 전송된 시간

목표치 설정하기  
- 현재의 성능을 기준으로 목표치를 설정하지 말 것   
시스템의 장점과 한계를 이해하는 것이 기본이므로 이것을 고려하지 않고 목표치를 설정하지 않으면 방대한 재설계 없이는 시스템의 향상이 불가하게 된다.

최대한 단순하게 생각할 것   
- SLI를 복잡하게 생각하면 시스템의 성능 변화를 명확하게 반영하지 못하고 그 원인을 파악하기 어렵게 된다.

자기 만족에 얽매이지 말 것

처음부터 완벽하게 하려고 하지 말것

# 5장 삽질은 이제 그만

SRE 조직은 단순한 운영 업무보다는 장기간의 엔지니어링 프로젝트를 수행하는 것을 더 선호한다. 여기서 운영 업무란 사람에 따라 다르게 해석하므로 여기서는 toil로 언급하겠다.

우리가 말하는 삽질은 다음과 같다.
수작업을 필요로 하면서, 반복적이고, 자동화가 가능하면서, 사후 대처가 필요하고 가치가 지속되지 않으면서 서비스 성장의 따라서 O(n)으로 증가한다.

## 삽질이 줄어들면 좋은 이유

우리의 SRE 조직은 각 SRE의 전체 작업 시간 중 삽집을 50% 이내로 유지한다는 목표를 공공연하게 가지고 있다.

따라서 최소 50%의 시간을 엔지니어링 프로젝트 업무에 투입해서 향후에 발생 가능한 삽질을 줄이거나 서비스에 새로운 기능을 추가해야 한다.

기능의 개발은 주로 안정성이나 성능 혹은 활용도를 개선하고 결과적으로 삽질의 발생 가능성을 줄이는 것에 중점을 둔다.

## 엔지니어링에해당하는 업무는 ?

엔지니어링 업무는 새로우면서도 본질적으로 사람의 판단을 필요로 하는 업무다.
전략에 따라 서비스의 지속적인 개선을 이루어낼 뿐 아니라, 창의적이고 혁신적이며, 디자인 주도 접근법으로 문제를 해결한다.

보통 SRE의 활동은 다음과 같이 분류할 수 있다.

소프트웨어 엔지니어링

코드를 작성하거나 수정하고, 관련된 디자인이나 문서화 작업을 수행한다.
예를 들어 자동화 스크립트를 작성하는 일, 도구나 프레임워크를 개발하는 일, 확장성과 신뢰성을 위해 서비스 기능을 추가하거나 서비스를 더 안정적으로 운영하기 위해 인프라스트럭처 코드를 수정하는 일 등이 해당된다.

시스템 엔지니어링
한 번의 노력으로 지속적인 개선을 이루어내기 위해 프로덕션 시스템의 설정을 조정하거나 문서화를 수행한다.
예를 들어 설정을 모니터링하고 수정하는 일, 로드밸런서나 서버의 설정 변경, OS 매개변수 튜닝 및 로드밸런서 설치 등의 업무가 이에 해당된다.

삽질
서비스 운영과 직접적으로 관련된, 반복적으로 발생하는 수작업들을 말한다.

부하
서비수 운영과 직접 관련되지 않은 관리 업무를 말한다.
예를 들어 채용, HR 서류 작업, 팀/회사 회의, 버그 큐 치우기, 업무 보고, 동료 및 자기 자신에 대한 평가 및 훈련 등의 업무가 이에 해당된다.

모든 SRE는 평균적으로 1년 혹은 두세 분기에 걸쳐 최소 50%의 시간을 엔지니어링 업무에 할당해야 한다.

## 삽질은 무조건 나쁜 것일까 ?

삽질에 해당하는 일이 문제가 되는 경우는 다음과 같다.

## 경력 개발이 침체된다.

프로젝트에 너무 적은 시간을 투입하다 보면 개인의 경력 개발이 늦어지거나 서서히 멈추게 된다.

구글은 필연적으로 발생하는 궃은 일에 대해서는 상당히 큰 긍정적 효과를 발휘하는 보상을 해주지만, 그렇다고 경력을 내팽개칠 수는 없다.

## 의욕이 저하된다.

삽질을 참고 용인하는 수준은 사람마다 다르지만 누구든 한계를 느끼게 마련이다. 삽질에 할애하는 시간이 너무 많다면 지치고 지루하고 불만을 갖게 될 것이다.

결론
모두가 매주 조금씩 삽질을 걷어낼 수 있다면 서비스를 지속적으로 깔끔하게 유지할 수 있고, 서비스를 더욱 확장하기 위한 엔지니어링이나 차세대 서비스의 아키텍팅, SRE 업무에 필요한 도구 개발 등에 시간을 투입할 수 있다.
삽질을 줄이고 창의적인 일에 더 집중하자.

# 6장 분산 시스템 모니터링

## 정의

모니터링과 관련된 모든 논의들에 공통적으로 사용될 수 있을 만큼 통일된 용어들은 아직도 존재하지 않는다.

### 화이트박스 모니터링

로그나 자바 가상 머신의 프로파일링 인터페이스같은 인터페이스 혹은 내부 통계 지표를 제공하는 HTTP 핸들러 등을 이용해서 얻은 시스템의 내부 지표들을 토대로 하는 모니터링을 의미한다.

### 블랙박스 모니터링

사용자가 보게 되는 확인 가능한 동작들을 외부에서 테스트하는 과정을 말한다.

### 대시보드

서비스의 핵심 지표에 대한 요약된 뷰를 보여주는 애플리케이션을 말한다.

### 알림

사람이 읽을 수 있도록 작성된 통지를 말하며, 주로 버그나 티켓 큐, 메일 혹은 호출기 등으로 보내진다. 이런 알림들은 각각 티켓, 메일 알림, 호출 등으로 분류된다.

### 근본 원인

소프트웨어 시스템의 결함이나 사람의 실수는 일단 고쳐지면 그 일이 다시는 발생하지 않을 것이라는 확신을 심어준다. 이런 사고는 여러 원인에 의해 발생할 수 있다. 예를 들어 프로세스의 자동화가 충분하지 못해서 발생할 수 있고, 조작된 정보에 의해 소프트웨어가 충돌해서 발생할 수도 있고, 이런 원인들은 각자가 근본 원인일수도 있으며, 따라서 모두 수정되어야 한다.

### 노드와 머신

물리적 서버, 가상 머신 혹은 컨테이너가 동작하는 커널의 단일 인스턴스를 의미 두 가지 종류로 나뉠 수 있음
서로 관려노

## 왜 모니터링을 해야하는가 ?

시스템을 모니터링 해야하는 이유는 다음과 같이 다양하다
장기적인 트렌드 분석
시간순 혹은 실험 그룹에 대한 비교
알림
대시보드
임시적인 회고 분석의 수행

### 모니터링에 대한 적절한 기대치 설정하기

잘못된 알림 비율을 낮게 유지하고 올바른 알림의 비율을 높게 유지하기 위해서는 호출을 담당하는 모니터링 시스템은 반드시 간결하면서도 안정적이어야 한다. 사람이 확인할 알림을 발송하기 위한 규칙들은 이해하기 쉽고 문제를 명확하게 표현할 수 있어야 한다.

## 증상과 원인

모니터링 시스템은 어떤 장애가 왜 발생했는지에 대한 질문에 답을 제시할 수 있어야 한다.

## 블랙박스와 화이트박스

우리는 중요도가 낮은 서비스들에 대해 화이트박스 모니터링을 수행하지만 중요한 서비스들에 대해서는 블랙박스 모니터링을 수행한다.

다중계층 시스템에서는 한 사람에게서 발생한 증상이 다른 누군가에게 장애의 원인이 되기도 한다.
예를 들어 데이터베이스의 속도가 느려졌다고 가정해보자.

데이터베이스 읽기 작업이 느려진 현상은 이를 탐지한 데이터베이스 SRE 에게는 하나의 증상이다.

그러나 FE SRE 입장에서는 웹사이트가 느려진 원인은 다름이 아니라 DB 읽기가 느려졌기 때문이다.

그래서 화이트박스 모니터링을 통해 어떤 정보를 얻느냐에 따라 증상에 초점을 맞출 수 있고 원인에 초점을 맞출 수도 있다.

원격으로 디버깅을 수행할 때는 화이트박스 모니터링이 필수적이다.

## 네가지 결정적 지표

### 지연응답

### 트래픽

### 에러

에러는 실패한 요청의 비율을 의미한다. 이때 명시적 실패와 묵시적 실패 혹은 정책과 관련된 실패 등을 모두 고려해야한다.
사실 프로토콜의 응답 코드는 모든 종류의 실패를 표현하기에 충분하지 않으므로 부분적인 실패를 올바르게 추적해야 한다면 부차적인 프로토콜의 사용을 고려해야 한다.
이런 상황의 모니터링은 엄청나게 어렵다.

### 서비스 포화 상태

서비스가 얼마나 포화 상태로 동작하는지를 의미한다.
시스템의 일부를 측정하며 가장 병목이 발생하는 리소스를 집중해서 측정해야 한다.
많은 시스템들이 100% 사용량에 도달하기 전에 체감 성능의 하락이 발생하므로 기본적인 목표 사용량을 설정해야 한다.

# 7장 구글의 발전된 자동화

## 자동화의 가치

### 일관성

시스템의 스케일 조정은 자동화를 채택하는 주요한 이유이지만 아닐 수도 있다.

정확하게 정의된 업무 범위와 정해진 절차를 수행하는데 있어 일관성의 가치는 다양한 측면에서 자동화가 최우선으로 추구하는 가치이다.

### 플랫폼

플랫폼은 일관성을 위해서 제공하는 방법은 아니다.
올바르게 디자인해서 구현된 자동화 시스템은 확장이 가능하고, 다른 시스템에도 적용이 가능하거나, 심지어 이윤을 창출할 수도 있는 플랫폼을 제공한다.
이렇게 구축된 플랫폼은 실수를 중앙집중화하는 데도 도움이 된다.
다만 앞서 설명한 것 처럼 엄청난 인력이 수동으로 동일한 절차를 수행하면 반복적으로 발생할 수 있는 것에 비해 자동화된 코드 상에서 수정된 버그는 수정되면 다시는 발생하지 않는다.

## 자동화 클래스의 계층 구조

자동화의 혁신은 다음과 같은 단계를 밟는다.

1. 자동화를 하지 않는 단계
2. 별도로 관리되며 시스템에 특화된 자동화를 수행하는 단계
3. 별도로 관리되는 범용 자동화를 수행하는 단계
4. 내재화되었지만 시스템에 특화된 자동화를 수행하는 단계
5. 자동화가 불필요한 시스템을 도입하는 단계

# 8장 릴리즈 엔지니어링

릴리즈 엔지니어링은 소프트웨어 엔지니어링보다 상대적으로 새롭고 빠르게 성장하고 있는 원리로, 소프트웨어를 빌드하고 전달하는 과정을 간략하게하게기술하는 분야다.

릴리즈 엔지니어링은 소스 코드 관리, 컴파일러, 빌드 설정 언어, 빌드 자동화 도구들, 패키지 관리자 및 설치 도구에 대해 잘 이해하고 있다.

릴리즈 엔지니어의 역할
일관되고 반복 가능한 방법을 통해 프로젝트를 릴리즈하기 위한 최선의 방법들을 정의한다.
우리가 정의한 방법들은 릴리즈 프로세스의 전 과정을 아우른다.

구글에서는 많은 SRE 들이 구글 서비스들을 안전하게 배포하고 지속적으로 운영하기 위해 불철주야 노력하고 있다.

## 릴리즈 엔지니어링의 철학

### 자기 주도 서비스 모델

### 밀폐된 빌드

빌드 도구는 일관성과 반복성을 제공해야 한다.

만일 두 사람이 동일한 제품의 동일한 버전을 소스 코드 저장소에서 각각 다른 머신으로 내려받아 빌드를 수행하면 그 결과는 완전히 동일해야 한다.

우리의 빌드는 완전히 밀폐된 구조다.

다시 말해 빌드 머신에서 설치된 라이브러리나 다른 소프트웨어에 영향을 받지 않는다는 뜻이다.

그 대신 빌드는 지정된 버전의 빌드 관련 도구들 즉 컴파일러, 의존 라이브러리 등을 사용한다.

빌드 프로세스는 필요한 도구를 스스로 조달할 수 있어야 하며, 빌드 환경 외부의 서비스에 의존해서는 안된다.

## 원리와 절차의 강제

프로젝트를 릴리즈할 때는 누가 어떤 작업을 수행할 수 있는지 결정하기 위해 여러 단계의 보안 및 접근 제어 계층이 존재한다. 여기에는 다음과 같은 작업들이 해당된다.

- 소스 코드 변경 수락
- 릴리즈 과정에서 수행해야 할 행위들을 정의
- 새 릴리즈의 생성

## 단지 구글러에게만 해당되는 이야기는 아니다.

패키지의 버전을 어떻게 관리할 것인가 ?
지속적인 빌드와 배포 모델을 사용할 것인가 ?
릴리즈는 얼마나 자주할 것인가 ?
설정 관리 정책은 어떻게 가져갈 것인가 ?
어떤 릴리즈 지표를 살펴볼 것인가 ?

## 릴리즈 엔지니어링을 처음부터 도입하라

릴리즈 엔지니어링은 대체로 나중에 고려되는 경우가 많은데 플랫폼과 서비스의 규모와 복잡도가 증가하면 이런 생각을 반드시 고쳐야 한다.

팀은 제품 개발 주기의 처음부터 반드시 릴리즈 엔지니어링 자원에 대한 여유를 확보해야 한다.

적절한 사례와 프로세스를 처음부터 도입하는 비용은 나중 도입하는 비용에 비하면 훨씬 저렴하다.

# 9장: 간결함 (Simplicity)

## 📌 핵심 개념

**"소프트웨어 시스템의 가장 큰 적은 복잡성이다"**

- 복잡한 시스템은 이해하기 어렵고, 수정하기 어렵고, 장애가 발생하기 쉽다
- SRE의 핵심 목표 중 하나는 **시스템을 가능한 한 단순하게 유지**하는 것

---

## 1. 시스템의 안정성 vs 신속함 (Stability vs Agility)

### 딜레마

- **안정성**: 변경을 최소화, 검증된 방식 고수 → 느린 발전
- **신속함**: 빠른 기능 추가, 실험 → 불안정성 증가

### SRE의 접근법

간결함이 해답이다. 단순한 시스템은 안전하게 빠르게 변경 가능하다.

- 이해하기 쉬움 → 버그 적음
- 테스트 용이 → 자신감 있는 배포
- 모듈화 → 독립적 변경 가능

### 실무 적용

- **Error Budget**: 신뢰성과 혁신의 균형을 정량화
- **간결한 아키텍처**: 빠른 반복과 안정성 동시 달성
- **자동화**: 복잡한 수동 작업을 단순한 자동화로 전환

---

## 2. 지루함의 미덕 (The Virtue of Boring)

### "지루한 기술을 선택하라"

**지루한 = 검증된, 안정적인, 예측 가능한**

### Google의 철학

최신 유행 기술을 남발하면 각 기술마다 배우고, 디버깅하고, 장애 대응해야 한다.
지루하지만 검증된 기술은 10년간 검증되었고, 문서가 풍부하며, 전문가가 많다.

### 실제 예시

- **Google의 Borg** (Kubernetes 전신): 단순하고 지루한 설계
- **Bigtable**: 복잡한 기능보다 안정성 우선
- **Chubby** (분산 락): 최소 기능으로 최대 안정성

### 언제 새로운 기술을 도입하나?

1. **명확한 이점**이 있을 때만
2. **기존 도구로 불가능**할 때만
3. **팀이 감당할 수 있는** 복잡도일 때만

---

## 3. 내 코드는 절대 포기하지 않을 거야 (I Won't Give Up on My Code)

### 문제: "내 코드 애착 증후군"

개발자는 3개월 걸린 코드를 버리고 싶지 않지만, SRE는 아무도 사용하지 않는 코드를 문제로 본다.

### 왜 문제인가?

- **유지보수 비용**: 안 쓰는 코드도 업데이트, 보안 패치 필요
- **복잡도 증가**: 다른 개발자가 이해해야 할 코드 증가
- **기회비용**: 레거시 유지보수에 시간 낭비

### Google의 해결책: "Code Deletion"

"삭제된 코드 = 최고의 코드"

- 버그가 없음
- 유지보수 불필요
- 복잡도 감소

### 실천 방법

1. **Deprecation Policy**: 사용 중단 → 경고 → 삭제 (명확한 타임라인)
2. **Sunset Date**: 모든 기능에 종료일 설정
3. **메트릭 기반 결정**: 사용량이 임계값 미만이면 삭제 검토

**예시**: Google Wave, Google+, 수많은 내부 도구들 과감히 삭제

---

## 4. 부정적 영향을 미치는 코드의 지표

### 🚩 복잡한 코드의 신호

#### 1. 필수적 복잡도 vs 우발적 복잡도

- **필수적 복잡도 (Essential Complexity)**: 문제 자체가 복잡함, 피할 수 없음 (예: 세금 계산)
- **우발적 복잡도 (Accidental Complexity)**: 잘못된 설계로 인한 불필요한 복잡도 (예: DB 3번 조회, 불필요한 변환, 중복 로직)

#### 2. 부정적 코드 지표

| 지표                 | 설명                               | 해결                         |
| -------------------- | ---------------------------------- | ---------------------------- |
| **높은 결합도**      | 한 모듈 변경이 10개 모듈 수정 필요 | 인터페이스 분리, 의존성 주입 |
| **긴 함수**          | 100줄 넘는 함수                    | 작은 함수로 분할             |
| **깊은 중첩**        | if 안에 if 안에 if...              | Early return, 전략 패턴      |
| **매직 넘버/문자열** | 의미 없는 숫자나 문자열 하드코딩   | 상수/Enum 사용               |
| **글로벌 상태**      | 전역 변수 남발                     | 의존성 명시화                |

#### 3. Google의 복잡도 측정

- **순환 복잡도(Cyclomatic Complexity)**: 경로의 수
- **인지 복잡도(Cognitive Complexity)**: 사람이 이해하기 어려운 정도
- **코드 커버리지**: 테스트되지 않는 코드 = 복잡도 증가

---

## 5. 최소한의 API (Minimal APIs)

### 원칙: "API는 작을수록 좋다"

#### 왜 작은 API가 좋은가?

**작은 API:**

- ✅ 배우기 쉬움
- ✅ 잘못 사용하기 어려움
- ✅ 유지보수 부담 적음
- ✅ 하위 호환성 유지 쉬움

**큰 API:**

- ❌ 학습 곡선 높음
- ❌ 오용 가능성 높음
- ❌ 변경 영향도 큼
- ❌ Deprecation 어려움

### Google의 API 설계 원칙

#### 1. 필수 기능만 노출

나쁜 예는 모든 내부 메서드를 public으로 노출하는 것이다. 이메일 검증, 비밀번호 해싱, 알림 전송 같은 내부 로직까지 외부에 공개하면 안 된다.

좋은 예는 get_user, create_user 같은 필수 기능만 노출하고 나머지는 private으로 숨기는 것이다.

#### 2. 확장은 쉽게, 변경은 어렵게

좋은 설계는 Config 객체나 옵션 패턴을 사용해서 미래에 필드를 추가해도 기존 코드가 깨지지 않도록 한다.

나쁜 설계는 파라미터를 계속 나열하는 것이다. Connect(host, port, timeout, retry, ...) 같은 함수는 파라미터 추가 시 모든 호출부를 수정해야 한다.

#### 3. API 버전 관리

- v1: 최소 기능
- v2: 필수 기능 추가 (v1 deprecated)
- v3: v1 제거, v2 유지

---

## 6. 모듈화 (Modularity)

### "작은 조각으로 나누어 정복하라"

#### 좋은 모듈의 조건

1. **높은 응집도(High Cohesion)**: 관련 기능끼리 모음
2. **낮은 결합도(Low Coupling)**: 다른 모듈과 독립적
3. **명확한 인터페이스**: 외부에 노출할 것만 노출
4. **단일 책임(Single Responsibility)**: 한 가지 일만 잘함

#### 실제 예시: Microservices

**Monolith (모놀리스)의 문제점:**

- 한 기능 변경 → 전체 재배포
- 장애 전파 위험 높음
- 팀 간 충돌 많음

**Microservices (마이크로서비스)의 장점:**

- 독립 배포
- 장애 격리
- 팀별 자율성

#### Google의 모듈화 전략

**1. Service-Oriented Architecture (SOA)**
Frontend가 API Gateway를 통해 Auth Service, User Service, Data Service와 통신한다.
각 서비스는 독립 배포, 독립 확장, 독립 장애 처리가 가능하다.

**2. Library 모듈화**
나쁜 예: 500개 함수가 들어있는 google_utils 하나를 import
좋은 예: google.auth에서 login, google.storage에서 upload, google.analytics에서 track처럼 기능별로 분리

**3. 데이터베이스 분리**
User Service는 User DB를, Order Service는 Order DB를, Payment Service는 Payment DB를 사용한다.
서로 직접 DB에 접근하지 않고 API로만 통신한다.

---

## 7. 릴리즈의 간소화 (Release Simplicity)

### "배포는 지루할수록 좋다"

#### Google의 배포 철학

복잡한 배포 = 위험한 배포
단순한 배포 = 안전한 배포

### 간소화 전략

#### 1. 자동화된 CI/CD

모든 배포는 동일한 파이프라인을 거친다:

1. 코드 푸시
2. 자동 테스트
3. 자동 빌드
4. 자동 배포 (단계적)
5. 자동 모니터링

#### 2. 점진적 롤아웃 (Progressive Rollout)

1% 사용자에게 먼저 배포 → 모니터링 → 문제 없으면
10% 사용자 → 모니터링 → 문제 없으면
50% 사용자 → 모니터링 → 문제 없으면
100% 사용자

문제 발생 시 즉시 롤백

#### 3. Feature Flags

코드는 배포하되, 기능은 켜고 끌 수 있게 한다.
feature_flag로 new_checkout이 활성화되면 새 결제 플로우를, 아니면 기존 플로우를 사용한다.

**장점:**

- 배포와 출시 분리
- A/B 테스트 가능
- 즉시 롤백 가능 (코드 재배포 불필요)

#### 4. 단순한 롤백 전략

복잡한 롤백: "DB 마이그레이션 롤백하고, 캐시 지우고, 설정 파일 수정하고, 서비스 재시작하고..."

단순한 롤백: kubectl rollout undo 명령어 하나로 이전 버전으로 자동 복구

#### 5. 릴리즈 체크리스트

**배포 전:**

- ☑ 자동 테스트 통과
- ☑ 코드 리뷰 완료
- ☑ 롤백 계획 수립
- ☑ 모니터링 대시보드 준비

**배포 중:**

- ☑ 카나리 배포 (1%)
- ☑ 메트릭 확인 (에러율, 레이턴시)
- ☑ 점진적 확대

**배포 후:**

- ☑ 24시간 모니터링
- ☑ 사후 검토 (Postmortem)

---

## 간결함의 효과 측정

### Google이 추적하는 지표

| 지표                   | 목표   | 간결함의 영향               |
| ---------------------- | ------ | --------------------------- |
| **MTTR** (복구 시간)   | ↓ 감소 | 단순한 시스템 = 빠른 디버깅 |
| **배포 빈도**          | ↑ 증가 | 자동화 = 안전한 잦은 배포   |
| **변경 실패율**        | ↓ 감소 | 단순한 코드 = 버그 적음     |
| **신규 개발자 온보딩** | ↓ 단축 | 이해하기 쉬운 시스템        |
| **코드 리뷰 시간**     | ↓ 감소 | 짧고 명확한 코드            |

---

## 핵심 요약

### 간결함을 위한 SRE 원칙

1. **지루한 기술을 선택하라**

   - 유행보다 안정성
   - 검증된 도구 우선

2. **코드를 과감히 삭제하라**

   - 안 쓰는 기능 = 부채
   - Deprecation 정책 필수

3. **API는 최소화하라**

   - 필수 기능만 노출
   - 확장은 쉽게, 변경은 신중히

4. **모듈화하라**

   - 높은 응집도, 낮은 결합도
   - 독립적 배포 가능하게

5. **배포를 단순하게**
   - 자동화된 파이프라인
   - 점진적 롤아웃
   - 쉬운 롤백

### Google의 격언

> "Complexity is the enemy of reliability."  
> (복잡성은 신뢰성의 적이다)

> "The best code is no code at all."  
> (최고의 코드는 코드가 없는 것이다)

> "Boring is good."  
> (지루한 것이 좋다)

---

## 🔗 참고 자료

- Site Reliability Engineering (O'Reilly)
- Google SRE Book: https://sre.google/books/
- "Choose Boring Technology" - Dan McKinley
