# 4. 컨피그맵과 비밀값으로 애플리케이션 설정하기

컨테이너에서 애플리케이션을 실행하는 장점은 다양한 환경 간 차이를 원천적으로 없앨 수 있다는 것이다.

쿠버네티스에서 컨테이너에 설정값을 주입하는 데 쓰는 리소스는 컨피그맵과 비밀값이다 .

이 데이터는 클러스터 속에서 다른 리소스와 독립적인 장소에 보관된다.

파드 정의에서 컨피그맵과 비밀값의 데이터를 읽어 오도록 할 수 있다.

이때 파드에 데이터가 전달되는 과정도 다양한 설정이 가능하다.

# 4.1 쿠버네티스에서 애플리케이션에 설정이 전달되는 과정

kubectl의 create 명령을 사용하거나 YAML 포맷으로 기재된 정의를 읽어 들여 생성할 수 있다.

# output

다른 리소스와 달리 컨피그맵과 비밀값은 스스로 어떤 기능을 하지는 않는다.

단지 적은 양의 데이터를 저장하는 목적

> 환경 변수는 리눅스와 윈도우 등 운영체제가 제공하는 핵심 기능이다. 환경 변수는 컴퓨터 단위로 설정되며 모든 애플리케이션이 이 값을 읽을 수 있다.

```bash

kubectl apply -f sleep/sleep.yaml
# output
deployment.apps/sleep created

kubectl wait --for=condition=Ready pod -l app=sleep
# output
pod/sleep-547547544f-pcf2k condition met

kubectl exec deploy/sleep -- printenv HOSTNAME KIAMOL_CHAPTER
# output
sleep-547547544f-pcf2k
## KIAMOL 없음
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sleep
spec:
  selector:
    matchLabels:
      app: sleep
  template:
    metadata:
      labels:
        app: sleep
    spec:
      containers:
        - name: sleep
          image: kiamol/ch03-sleep
          env:
            - name: KIAMOL_CHAPTER
              value: "04"
```

환경 변수는 파드의 생애 주기 내내 변하지 않는다.

파드가 실행되는 도중 환경 변수의 값을 수정할 수 없고 변경하려면 파드의 정의를 수정하고 파드를 수정된 버전으로 대체해야 한다.

따라서 애플리케이션도 잦은 파드 교체를 염두해두고 설계되어야 한다.

```bash
kubectl apply -f sleep/sleep-with-env.yaml
# output
deployment.apps/sleep configured

kubectl exec deploy/sleep -- printenv HOSTNAME KIAMOL_CHAPTER
# output
sleep-7d8845bc7d-bdk5n
04
```

중요한 점은 새로운 애플리케이션 역시 동일한 이미지를 사용한다는 점이다.

간단한 경우 파드 정의에 포함시켜도 상관없지만, 실제 애플리케이션의 설정값은 더 복잡하므로 이런 경우 컨피그맵을 사용한다.

컨피그맵은 파드에서 어떻게 쓰이는지 나타낸 다이어그램이다.

컨피그맵은 특정 애플리케이션 전용으로 사용하거나 여러 파드에서 공유하는 내용으로 사용할 수 있고 Read-Only이다.

```yaml
env:
  - name: KIAMOL_CHAPTER
    value: "04"
  - name: KIAMOL_SECTION
    valueFrom:
      configMapKeyRef: # 이 값은 컨피그맵에서 읽어 들이라는 의미
        name: sleep-config-literal # 컨피그맵 이름
        key: kiamol.section # 컨피그맵에서 읽어 들일 항목 이름
```

정의에서 컨피그맵을 참조하는 파드는 해당 컨피그맵이 있어야 클러스터에 배치할 수 있다.
키-값을 데이터로 가진 sleep-config-leteral 이라는 이름의 컨피그맵이 필요하다.

```bash
kubectl create configmap sleep-config-literal --from-literal=kiamol.sction='4.1'
# output
configmap/sleep-config-literal created

kubectl get cm sleep-config-literal
# output

NAME                   DATA   AGE
sleep-config-literal   1      7s
kubectl describe cm sleep-config-literal

# output
Name:         sleep-config-literal
Namespace:    default
Labels:       <none>
Annotations:  <none>
Data

kiamol.sction:
----
4.1
BinaryData
Events:  <none>

kubectl apply -f sleep/sleep-with-configMap-env.yaml
# output
deployment.apps/sleep configured

command terminated with exit code 127
kubectl exec deploy/sleep -- sh -c 'printenv | grep "^KIAMOL"'
# output
KIAMOL_CHAPTER=04
```

# 4.2 컨피그맵에 저장한 설정 파일 사용하기

```
KIAMOL_CHAPTER=ch04
KIAMOL_SECTION=ch04-4.1
KIAMOL_EXERCISE=try it now
```

쿠버네티스는 이 파일의 내용으로 컨피그맵을 만들어 파드 속 컨테이너에 에전달할 수 있다.

```bash
kubectl create configmap sleep-config-env-file --from-env-file=sleep/ch04.env
# output
configmap/sleep-config-env-file created

kubectl get cm sleep-config-env-file
# output
NAME                    DATA   AGE
sleep-config-env-file   3      8s

kubectl apply -f sleep/sleep-with-configMap-env-file.yaml
# output
deployment.apps/sleep configured

kubectl exec deploy/sleep -- sh -c 'printenv | grep "^KIAMOL"'
# output
KIAMOL_CHAPTER=04
```

```bash
kubectl apply -f todo-list/todo-web.yaml
# output
service/todo-web created
deployment.apps/todo-web created

kubectl wait --for=condition=Ready pod -l app=todo-web
# output
pod/todo-web-5b55bf94cf-mmv46 condition met

kubectl get svc todo-webv -o jsonpath='http//{.status.loadBalancer.ingress[0].*}:8080'
# output
Error from server (NotFound): services "todo-webv" not found

kubectl logs -l app=todo-web
# output

```

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: todo-web-config-dev
data:
  config.json: |-
    {
      "ConfigController": {
        "Enabled" : true
      }
    }
```

```bash
kubectl apply -f todo-list/configMaps/todo-web-config-dev.yaml
# output
configmap/todo-web-config-dev created

kubectl apply -f todo -list/todo-web-dev.yaml
# output
error: the path "todo" does not exist

kubectl apply -f todo-list/todo-web-dev.yaml
# output
deployment.apps/todo-web configured
```

설정값 페이지를 차단하던 기본 설정이 컨피그맵으로 수정되었기 때문에 이제 설정값 페이지를 열어 볼수 있다.

# 4.3 컨피그맵에 담긴 설정값 데이터 주입하기

환경 변수 외에 설정값을 전달하는 또 다른 방법은 컨테이너 파일 시스템 속 파일로 설정값을 주입하는 것이다.

컨테이너 파일 시스템은 컨테이너 이미지와 그 외 출처에서 온 파일로 구성된 가상 구조이다.

쿠버네티스는 컨테이너 파일 시스템 구성에 컨피그맵도 추가할 수 있다.

```yaml
spec:
  containers:
    - name: web
      image: kiamol/ch04-todo-list
      volumeMounts: # 컨테이너에 볼륨을 마운트
        - name: config # 마운트할 볼륨 이름
          mountPath: "/app/config" # 볼륨이 마운트될 경로
          readOnly: true # 볼륨을 읽기 전용으로
  volumes:
    - name: config # 이 이름이 볼륨 마운트의 이름과 일치해야 한다.
      configMap: # 볼륨의 원본은 컨피그맵이다.
        name: todo-web-config-dev # 내용을 읽어 올 컨피그맵 이름
```

여기에서 기억해야 할 점은 컨피그맵이 디렉터리로 취급된다는 것이다.
그리고 컨피그맵 속 각각의 항목이 컨테이너 파일 시스템 속 파일이 된다.

이 예저는 /app/appsettings.json 에서 기본으로 읽고
그 다음 /app/config/config.json 파일을 찾아 담긴 설정값을 우선 적용한다.

컨테이너 이미지에는 /app/config가 없고 쿠버네티스가 이 디렉터리 만들어 넣는다.

```bash
kubectl apply -f todo-list/todo-web-dev.yaml
# output
deployment.apps/todo-web configured

kubectl exec deploy/todo-web -- sh -c 'ls -l /app/app*.json'
# output
-rw-r--r--    1 root     root           469 Feb 19 21:42 /app/appsettings.json

kubectl exec deploy/todo-web -- sh -c 'ls -l /app/config/*.json'
# output
lrwxrwxrwx    1 root     root            18 Aug 14 08:07 /app/config/config.json -> ..data/config.json

kubectl exec deploy/todo-web -- sh -c 'echo ch04 >> /app/config/config.json'
# output
sh: can't create /app/config/config.json: Read-only file system
command terminated with exit code 1
```

쿠버네티스가 주입한 컨피그맵의 파일은 읽기 전용으로 취급되는 것도 확인했다.

컨피그맵을 디렉터리 형태로 읽어 들이면 다양한 애플리케이션 설정 방법을 적용할 수 있다.

설정이 여러파일에 나뉘어 있더라도 모든 설정을 하나의 컨피그맵으로 관리할 수 있다.

파드가 동작 중인 상황에서 컨피그맵을 업데이트하면 어떻게 될까? 그건 애플리케이션 나름이다.

/config 디렉터리를 주시하다가 변경이 생기면 다시 읽어 들인다.

볼륨은 설정 파일을 다루는 강력한 수단이 된다. 특히 to-do 애플리케이션처럼 설정 파일의 변경에 곧바로 반응하는 앱이라면 더욱 효과가 크다.

하지만 의도대로 동작하지 않을 수 있다.

볼륨의 마운트 경로가 이미 컨테이너 이미지에 있는 경로라면 컨피그맵 디렉터리가 원래 디렉터리를 덮어쓰고 디렉터리의 모든 내용이 교체되어 애플리케이션 역시 이상을 일으킬 수 있다.

어떤 사람이 작성한 경로를 병합하려고 기대하고 작성했다가는 기존 애플리케이션 파일이 통째로 날아갈 수 있다.

쿠버네티스는 몇 번 더 파드를 실행해보지만 역시 오류를 발생시키고 세 번의 시도 후 잠시 재시도를 멈춘다.

설정값을 컨피그맵에 저장해 두고 환경 변수부터 볼륨 마운트까지 애플리케이션 요구에 맞추면 된다.

이를 분리하면 각 팀이 각자의 담당 부분을 따로 처리할 수 있어 출시 워크플로에도 유연성이 생긴다.
맇

# 4.4 비밀값을 이용하여 민감한 정보가 담긴 설정값 다루기

비밀값은 컨피그맵과 비슷한 API를 가진 별개의 리소스다.

사용법은 똑같지만 컨피그맵과 다른 점이 있다면 클러스터 내부에서 별도로 관리된다는 것이다.

비밀값은 해당 값을 사용해야 하는 노드에만 전달되며노드에서도 디스크에 저장하지 않고 메모리에만 담긴다.
그리고 전달과정과 저장할 때 모두 암호화가 적용된다.

하지만 항상 암호화가 유지되는 것은 아니고 접근할 권한이 있다면 비밀값의 평문을 읽을 수 있다.

하지만 난독화 계층이 하나 추가된다. 평문은 Base64로 인코딩된 상태로 취급된다.

```bash
kubectl create secret generic sleep-secret-literal --from-literal=secret=shh
# output
secret/sleep-secret-literal created

kubectl describe secret sleep-secret-literal
# output
Name:         sleep-secret-literal
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
secret:  3 bytes

kubectl get secret sleep-secret-literal -o jsonpath='{.data.secret}'
# output
c2ho%

kubectl get secret sleep-secret-literal -o jsonpath='{.data.secret}' | base64 -d
# output
shh%
```

데이터 값이 출력되지 안혹 데이터 값을 확인하려고 해도 Base64로 인코딩된 값만 출력된다.
완벽한 평문을 보려면 Base64 디코더로 파이핑해야한다.

하지만 컨테이너에 전달되고 나면 평문이 담긴 텍스트 파일이 된다.

비밀값을 사용하는 것은 컨피그맵과 거의 동일하다.

비밀값의 특정 항목을 원하는 이름의 환경 변수로 들여올 수 있다.

한편 환경 변수는 주의를 해야하는데 모든 애플리케이션에서 접근할 수 있기 때문이다

애플리케이션 플랫폼 중에는 치명적 오류가 발생했을 때 모든 환경 변수를 로그로 남기는 경우도 있다.

대안은 비밀값을 파일 형태로 전달하는 것이다.

애플리케이션이 설정 파일을 지원한다면 파일 권한 설정으로 민감한 정보를 지킬 수 있다.

# 4.5 쿠버네티스의 애플리케이션 설정 관리

kubectl delete -f sleep/
kubectl delete -f todo-list/
