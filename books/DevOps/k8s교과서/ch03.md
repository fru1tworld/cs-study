파드는 쿠버네티스에서 애플리케이션을 구성하는 기본 요소다.

대부분의 애플리케션션이셔은 여러 개의 구성 요소로 나뉘는데, 쿠버네티스에서는 이들 구성 요소를 각각 파드의 형태로 모델링한다.

예를 들어 웹 사이트가 있다면, 이 웹사이트 구조는 웹 사이트 파드와 API 파드 단 두 개로 구성되거나 마이크로서비스 아키텍처를 채택해서 파드 수십 개로 나뉘어 구성되는 식이다.

모든 파드는 서로 통신할 수 잇어야 한다 파드 끼리 통신은 TCP/UDP를 지원한다.

이 두 프로토콜은 IP로 트래픽을 제어하는데 IP 주소는 파드를 대체할 때 주소가 변경된다는 문제가 있다.

쿠버네티스는 서비스에 어드레스 디스커버리 기능을 제공하여 이 문제를 해결했다.

서비스는 파드에서 들고나는 통신 트래픽 라우팅을 맡는 유연한 리소소다.

이 통신 트래픽은 클러스터 외부에서 파드로 전달되는 것과 파드에서 클러스터 외부로 전달되는 것 모두를 포함한다.

# 3.1 쿠버네티스 내부의 네트워크 트래픽 라우팅

지난 장에서 파드에 대해 두 가지 중요한 사실을 배웠다.

첫 번째는 파드가 쿠버네티스에서 부여한 IP 주소를 가진 가상 환경이라는 점이다. 두 번째는 파드가 다른 컨트롤러 객체에 의해 생에 주기가 관장되는 쓰고 버리는 리소스라는 점이다.

어떤 파드가 다른 파드와 통신하는 데는 IP 주소가 필요하다.

이 때 두가지 문제가 발생한다. 하나는 파드가 새로운 파드로 교체될 때 IP 주소가 바뀌고, 다른 하나는 교체된 파드의 새로운 IP 주소를 찾기가 어렵다는 점이다.

새로운 IP 주소는 쿠버네티스 API를 통해서만 파악할 수 있다.

쿠버네티스가 만든 가상 네트워크는 클러스터 전체를 커버한다.

따라서 IP 주소만 있으면 서로 다른 노드에서 실행 중인 파드끼리도 통신이 가능하다.

`언제든지 다른 것으로 바뀔 수 있는 리소스에 접근하기 위한 고정된 주소` 라는 문제는 새로운 문제가 아니다.

인터넷에서는 IP 주소에 기억하기 쉬운 도메인 네임을 도입하여 이 문제를 해결했고 쿠버네티스도 마찬가지이다.

쿠버네티스 클러스터에는 전용 DNS 서버가 있다.

이 서버가 서비스 이름과 IP 주소를 대응시켜 준다.

그림 3-3은 파드와 파드 간 통신에서 도메인 네임 조회가 어떻게 쓰이는지 나타낸 다이어그램이다.

이런 유형의 서비스는 파드와 파드가 가진 네트워크 주소를 추상화한것이다.

디플로이먼트가 파드와 파드가 포함하는 컨테이너를 추상화한 것과 같다.

이 주소 역시 서비스가 삭제될 때까지 바뀌지 않는다.

컨슈머 컴포넌트가 이 주소로 요청을 보내면 쿠버네티스가 서비스와 연결된 파드와 실제 IP 주소로 요청을 연결해준다.

서비스와 파드의 연결 관계는 디플로이먼트와 파드의 연결 관계와 마찬가지로 레이블 셀렉터를 사용한다.

```yaml
apiVersion: v1 # 서비스는 코어 v1 API를 사용한다.
kind: Service
metadata:
  name: sleep-2
spec:
  selector:
    app: sleep-2
  ports:
    - port: 80
```

이 서비스 정의는 지난 실습 예제에서 생성한 디플이먼트와 연동할 수 있다.

서비스를 클러스터에 배포하면 sleep-2 라는 도메인 네임이 생성되고, 이 도메인 네임은 sleep-2 디플로이먼트에 포함된 파드로 트래픽을 연결해 준다.

다른 파드에서도 이 파드를 통해 통신을 보낼 수 있다.

필자의 환경에서 실행한 결과인 그림 3-4를 보면, 도메인 네임은 잘 해소되지만 ping 명령은 기대했던 대로 동작하지 않았다.

그 이유는 ping 명령이 쿠버네티스 서비스에 지원하지 않는 프로토콜을 사용하기 때문이다.

# 3.2 파드와 파드 간 통신

서비스의 유형 중 가장 기본이 되는 것을 클러스터 IP라고 한다.

클러스터 IP는 클러스터 전체에서 통용되는 IP 주소를 생성하는데, 이 IP 주소는 파드가 어느 노드에 있더라도 접근이 가능하다.

하지만 이 IP 주소는 클러스터 내에서만 유효하다.

따라서 클러스터 IP는 파드와 파드간 통신에서만 쓰인다.

내부에서는 접근이 가능하되 외부의 접근은 차단해야 하는 분산 시스템의 컴포넌트에 딱 적합하다.

```yaml
apiVersion: v1
kind: Service

metadata:
  name: numbers-api
spec:
  ports:
    - port: 80
  selector:
    app: numbers-api
  type: ClusterIP
```

서비스의 기본 유형은 클러스터 IP 이므로 유형을 생략할 수 있지만, 의미가 더 분명해지기 때문에 유형을 명시하는 것이 낫다.

서비스가 클러스터에 배포되면 웹 애플리케이션 파드와 API 파드의 통신이 가능해지며 애플리케이션이 정상 동작한다.

이 과정에서 디플로이먼트와 파드 모두 어떤 변경도 하지 않았다.

```bash
# 예제 3-2에 정의된 서비스를 배포한다.
kubectl apply -f numbers/api-service.yaml

# 서비스의 상세 정보를 출력한다.
kubectl get svc numbers-api

# 웹 애플리케이션에 접근할 수 있도록 포트포워딩을 적용한다.
kubectl port-forward deploy/numbers-web 8080:80
```

여기서 중요한 것은 서비스나 디플로이먼트, 파드가 아니다.

YAML 스크립트에 애플리케이션 전체를 정의할 수 있다는 것이다.

애플리케이션의 모든 컴포넌트, 심지어 이들 간 통신까지 말이다.

쿠버네티스에서는 애플리케이션 아키텍처의 세세한 부분까지 직접 YAML에 정의해 주어야한다.

이런 간단한 애플리케이션도 현재 상태처럼 동작하기 위해 두 개의 디플로이먼트, 한 개의 서비스까지 합해서 세 개나 되는 쿠버네티스 리소스를 정의해야 했다.

하지만 이렇게 각 구성 요소를 분할한 덕분에 애플리케이션에 상당한 자기회복성을 부여할 수 있었다.

실제 운영 환경에서 파드 교체는 늘상 일어나는 일이다.

노드가 고장을 일으켜도 해당 노드에서 동작하던 파드는 다른 노드에서 대체된다.

서비스가 제공하는 추상화가 있으면 이렇게 지속적인 파드 교체에도 애플리케이션이 계속 서로 통신할 수 있다.

# 3.3 외부 트래픽을 파드로 전달하기

쿠버네티스에는 클러스터 외부에서 들어오는 트래픽을 파드에 전달하는 여러 가지 방법이 있다.

먼저 간단하고 유연한 방법부터 시작하겠다.

이 방법은 로컬 개발 환경과 운영 환경 어디라도 적용할 수 있는 방법으로, 로드밸런서라는 유형의 서비스를 사용한다.

로드밸런서는 트래픽을 받은 노드가 아닌 노드에서 실행되는 파드에도 트래픽을 전달할 수 있다.

서비스의 입장이 되어 생각해보면 서비스의 레이블 셀렉터와 일치하는 파드가 많으면 파드보다 먼저 노드를 선택해야하니 까다로운 문제처럼 보인다.

그러나 이런 문제는 ㅂ쿠버네티스가 다 말아 해결해준다.

```yml
apiVersion: v1
kind: Service
metadata:
  name: numbers-web
spec:
  ports:
    - port: 8080
      targetPort: 80
  selector:
    app: numbers-web
  type: LoadBalancer
```

이 서비스는 8080번 포트를 주시하다가 해당 포트로 들어오는 트래픽을 웹 애플리케이션 파드 80번 포트로 전달한다.

이 서비스가 클러스터에 배포되면 kubectl로 따로 포트포워딩을 설정하지 않아도 웹 애플리케이션에 접근할 수 있다.

다만 그 구체적인 과정은 쿠버네티스 클러스터의 상황에 따라 달라질 수 있다.

로드밸런서 서비스는 실제 IP주소를 부여받는다. 이 주소는 공인 IP가 아니지만 같은 실습을 AKS 또는 EKS 클러스터에서 한다면 클라우드에서 제공되는 공인 IP 주소를 부여받는다.

쿠버네티스에는 확장 가능한 지점이 여럿 있다.

그리고 분산 환경에 따라 이들이 구현되는 방식에는 차이가 있다.

로드밸런서 서비스도 이렇게 분산 환경에 따라 구현 방식의 차이가 발생하는 지점 중 하나다.

다른 기능에서도 분산 환경 여부와 가용한 자원의 상황에 따라 이런 패턴을 종종 볼 수 있다.

외부에서 클러스터로 들어오는 트래픽을 파드로 전달하는 역할을 하는 서비스 리소스의 유형이 한 가지 더 있다.

바로 **노드 포트**다. 노드 포트 서비스는 외부 로드밸런서가 필요 없다. 클러스터를 구성하는 모든 노드가 이 서비스에 지정된 포트를 주시하며 들어온 트래픽을 대상 파드의 대상 포트로 전달한다.

노드 포트와 로드밸런서와 차이가 있다면 로드 밸런서는 트래픽을 분산하지만 노드 포트는 여러 트래픽을 하나로 묶는다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: numbers-web-node
spec:
  ports:
    - port: 8080
      targetPort: 80
      nodePort: 30080
  selector:
    app: numbers-web
  type: NodePort
```

# 3.4 쿠버네티스 클러스터 외부로 트래픽 전달하기

쿠버네티스는 거의 모든 서버용 소프트웨어를 실행할 수 있다.

그렇다고 모든 서버용 소프트웨어를 꼭 쿠버네티스에서 실행하는 것은 아니다.

데이터베이스 같은 스토리지 컴포넌트 등이 대표적으로 쿠버네티스 외부에서 동작하는 소프트웨어이다.

애플리케이션과 무관하게 도메인 네임 해소에도 쿠버네티스 서비스 리소스를 활용할 수 있다.

첫 번째 선택지는 익스터널네임 서비스이다.

익스터널네임 서비스는 어떤 도메인 네임에 대한 별명이라고 생각하면 쉽다.

익스터널네임 서비스는 애플리케이션 파드에서 로컬 네임을 사용하고, 쿠버네티스 DNS 서버에 이 로컬 네임을 조회하면 외부 도메인으로 해소해 주는 방식이다.

익스터널 네임 서비스는 애플리케이션 설정에 포함하기 어려운 환경 간 차이를 반영할 때 유용하다.

데이터베이스 서버 대신 하드코딩된 문자열을 사용한다거나, 개발 환경에서는 로컬 도메인 네임을 파드에서 동작하는 테스트용 데이터베이스 서버에 연결하고 운영 환경에서는 실제 도메인에 연결된 운영 데이터베이스 서버에 연결하도록 할 수도 있다.

쿠버네티스는 DNS의 표준 기능 중 하나인 캐노니컬 네임을 사용하여 익스터널 네임 서비스를 구현했다.

웹 애플리케이션 파드가 도메인 네임을 조회하면 쿠버네티스 DNS 서버가 이 CNAME을 반환한다.

이에 따라 클러스터 내 DNS 서버가 이 로컬 도메인 네임의 해소를 담당한다.

익스터널 네임 서비스는 애플리케이션이 사용하는 주소가 가리키는 대상을 치환해줄 뿐 요청의 내용 자체를 바꾸어 주지 못한다.

TCP 프로토콜은 상없지만 HTTP라면 얘기가 달라진다. 호스트명이 익스터널 네임 서비스와 응답이 다르다면 HTTP 요청이 실패한다.

HTTP 프로토콜을 사용하는 서비스라면 헤더의 호스트명을 직접 수정해야한다.

클러스터 안에서만 유효한 로컬 도메인 네임을 외부 시스템으로 연결할 수 있는 방법이 한 가지 더 있다.

HTTP 헤더 문제를 해결하지는 못하지만 익스터널 네임 서비스와 비슷하게 도메인 네임 대신 IP 주소를 대체해 주는 방법이다.

이런 서비스를 헤드리스 서비스라고 한다.

헤드리스 서비스는 클러스터 IP의 형태로 정의되지만 레이블 셀렉터가 없기 때문에 대상 파드가 없다.

그 대신 헤드리스 서비스는 자신이 제공해야 할 IP 주소의 목록이 담긴 엔드포인트 리소스와 함께 배포된다.

IP 주소 하나가 담긴 엔드포인트를 포함하는 헤드리스 서비스의 정의 예다.

YAML 에서는 우리가 처음 보는 문법이 사용되었는데, 한 파일에 여러 개의 리소스를 정의할 때 각 리소스의 정의를 구분하기 위해 하이폰 세 개를 사용한다.

```yaml
apiVersion: v1
metadata:
  name: numbers-api
spec:
  type: ClusterIP # SELECTOR 필드가 없으므로 헤드리스 서비스가 됨
  ports:
    - port: 80
---
kind: Endpoints # 한 파일에 두 번째 리소스의 정의
apiVersion: v1
metadata:
  name: numbers-api
subsets:
  - addresses: # 정적 IP 주소 목록
      - ip: 192.168.123.234
    ports:
      - port: 80 # 각 IP 에서 주시할 포트
```

엔드포인트의 정의에 포함된 IP 주소는 실제 주소가 아니지만 쿠버네티스는 정의에 포함된 주소가 실재하는지 확인하지 않는다.

# 3.5 쿠버네티스 서비스의 해소 과정

파드 속 컨테이너가 요청한 도메인 네임 조회는 쿠버네티스 DNS 서버가 응답한다.

조회 대상이 서비스 리소스라면 DNS 서버는 클러스터내 IP 주소 또는 외부 도메인 네임을 반환한다.

파드에서 나온 모든 통신은 쿠버네티스의 또 다른 구성 요소인 네트워크 프록시가 라우팅을 담당한다.

이 프록시는 각각의 노드에서 동작하며 모든 서비스의 엔드포인트에 대한 최신 정보를 유지하고, 운영체제가 제공하는 네트워크 패킷 필터를 사용하며 트래픽을 라우팅한다.

여기서 기억해야하는 점은 클러스터 IP는 네트워크상에 실재하지 않는 가상 IP 주소라는 것이다.

파드는 각 노드마다 동작하는 네트워크 프록시를 경유하여 네트워크에 접근한다.

그리고 이 프록시는 패킷 필터링을 적용하여 가상 IP 주소를 실제 엔드포인트로 연결한다.

서비스 리소스는 삭제 될 때까지 IP 주소가 바뀌지 않으며 애플리케이션의 다른 부분과 무관하게 오래 지속될 수 있다.

서비스에도 컨트롤러가 있어 파드가 변경될 때마다 엔트포인트의 목록을 최신으로 업데이트한다

쿠버네티스 DNS 서버는 엔드포인트 IP 주소가 아닌 클러스터 IP 주소를 반환한다.

엔드포인트가 가리키는 IP 주소는 계속 변화하기 때문이다.

정적 가상 IP 주소는 파드가 아무리 여러 번 교체되더라도 그대로 유지되기 때문에 클라이언트가 DNS 조회 결과를 영구적으로 캐시할 수 있다.

쿠버네티스 네임스페이스를 살펴보자

쿠버네티스 리소스는 네임스페이스 안에 존재한다.

네임스페이스는 다른 리소스를 하나로 묶기 위한 리소스이다.

따라서 쿠버네티스 클러스터를 논리적 파티션으로 나누는 역할을 한다. 제품별로 네임스페이스를 두거나 팀별 네임스페이스, 아니면 하나의 네임스페이스를 모두 공유할 수도 있다.

아직 사용할 필요가 없지만 여기에서 네임스페이스를 소개하는 이유는 DNS 해소 과정에 네임스페이스가 관련되어 있기 때문이다.

우리가 사용하는 클러스터에는 이미 여러 개의 네임스페이스가 있다.

지금까지 우리가 생성한 모든 리소스는 default 네임스페이스이기 때문에 따로 지정할 필요가 없었다.

그러나 DNS서버나 쿠버네티스 API 같은 쿠버네티스 내장 컴포넌트는 kube-system 네임스페이스에 속한 파드에서 동작한다.

파드는 IP 주소를 가지며, 이 IP 주소를 통해 TCP/UDP로 통신한다는 것을 배웠다.
