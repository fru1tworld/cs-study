# 10 네임스페이스와 멀티 테넌시

## 네임스페이스란?

### 개념

- 클러스터 리소스를 논리적으로 분리하는 가상 클러스터
- 리소스 이름의 스코프 제공
- 팀, 프로젝트, 환경별 격리

### 기본 네임스페이스

```bash
# 네임스페이스 목록 확인
kubectl get namespaces

# 기본 네임스페이스
# - default: 기본 네임스페이스
# - kube-system: 쿠버네티스 시스템 컴포넌트
# - kube-public: 모든 사용자가 읽을 수 있는 리소스
# - kube-node-lease: 노드 하트비트 정보
```

## 네임스페이스 생성 및 관리

### 네임스페이스 생성

```bash
# 명령어로 생성
kubectl create namespace dev
kubectl create namespace prod

# YAML로 생성
kubectl apply -f namespace.yaml
```

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
  labels:
    environment: development
```

### 네임스페이스별 리소스 조회

```bash
# 특정 네임스페이스의 파드 조회
kubectl get pods -n dev

# 모든 네임스페이스의 파드 조회
kubectl get pods --all-namespaces
# 또는
kubectl get pods -A
```

### 기본 네임스페이스 설정

```bash
# 현재 컨텍스트의 기본 네임스페이스 변경
kubectl config set-context --current --namespace=dev

# 확인
kubectl config view --minify | grep namespace
```

## 네임스페이스 범위 리소스

### 네임스페이스 안에 속하는 리소스

```bash
# 네임스페이스 범위 리소스 확인
kubectl api-resources --namespaced=true

# 예: Pod, Service, Deployment, ConfigMap, Secret 등
```

### 클러스터 범위 리소스

```bash
# 클러스터 범위 리소스 확인
kubectl api-resources --namespaced=false

# 예: Node, PersistentVolume, Namespace, StorageClass 등
```

## 네임스페이스별 리소스 격리

### Deployment와 Service

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: dev
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: app
          image: myapp:1.0
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: dev
spec:
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: 8080
```

### 네임스페이스 간 통신

```bash
# 같은 네임스페이스 내
http://myapp:80

# 다른 네임스페이스
http://myapp.dev.svc.cluster.local:80

# 전체 형식
http://<service-name>.<namespace>.svc.cluster.local:<port>
```

## 리소스 쿼터 (Resource Quota)

### CPU와 메모리 제한

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
```

### 오브젝트 수 제한

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: object-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    services: "5"
    persistentvolumeclaims: "4"
    secrets: "10"
    configmaps: "10"
```

### 쿼터 확인

```bash
# 리소스 쿼터 확인
kubectl get resourcequota -n dev

# 상세 정보
kubectl describe resourcequota compute-quota -n dev
```

## 리밋 레인지 (LimitRange)

### 개념

네임스페이스 내 리소스의 기본값과 제한 설정

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: dev
spec:
  limits:
    - default:
        memory: 512Mi
        cpu: 500m
      defaultRequest:
        memory: 256Mi
        cpu: 250m
      max:
        memory: 1Gi
        cpu: 1
      min:
        memory: 128Mi
        cpu: 100m
      type: Container
```

### Pod에 대한 제한

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: pod-limit-range
  namespace: dev
spec:
  limits:
    - max:
        memory: 2Gi
        cpu: 2
      type: Pod
```

## RBAC과 네임스페이스

### Role: 네임스페이스 범위 권한

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev-reader
  namespace: dev
rules:
  - apiGroups: [""]
    resources: ["pods", "services"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list"]
```

### RoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: dev
subjects:
  - kind: User
    name: jane
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev-reader
  apiGroup: rbac.authorization.k8s.io
```

## 네트워크 정책

### 네임스페이스 간 통신 제어

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-prod
  namespace: dev
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              environment: production
      ports:
        - protocol: TCP
          port: 8080
```

### 네임스페이스 격리

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: dev
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
```

## 멀티 테넌시 패턴

### 네임스페이스별 격리

- 각 팀/프로젝트별 네임스페이스
- ResourceQuota로 리소스 제한
- NetworkPolicy로 네트워크 격리
- RBAC으로 접근 제어

### 환경별 분리

```
production
  ├── frontend-prod
  ├── backend-prod
  └── database-prod

staging
  ├── frontend-staging
  ├── backend-staging
  └── database-staging

development
  ├── frontend-dev
  ├── backend-dev
  └── database-dev
```

## 네임스페이스 관리 모범 사례

### 명명 규칙

- 의미 있는 이름 사용
- 환경-애플리케이션 패턴
- 예: `prod-frontend`, `dev-backend`

### 레이블 활용

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: prod-frontend
  labels:
    environment: production
    team: frontend
    cost-center: engineering
```

### 리소스 관리

- 모든 네임스페이스에 ResourceQuota 설정
- LimitRange로 기본값 설정
- 주기적인 리소스 사용량 모니터링

## 네임스페이스 삭제

### 주의사항

```bash
# 네임스페이스 삭제 (내부 모든 리소스 삭제됨)
kubectl delete namespace dev

# 삭제 전 확인
kubectl get all -n dev
```

### 종료 중 상태 (Terminating)

```bash
# 강제 삭제
kubectl delete namespace dev --force --grace-period=0
```

## 교훈

1. **네임스페이스로 리소스를 논리적으로 분리**
2. **ResourceQuota로 리소스 사용량 제한**
3. **LimitRange로 기본값 설정**
4. **RBAC으로 네임스페이스별 접근 제어**
5. **NetworkPolicy로 네트워크 격리**
6. **환경별, 팀별 네임스페이스 전략 수립**
7. **네임스페이스는 완전한 격리를 제공하지 않음을 인지**
