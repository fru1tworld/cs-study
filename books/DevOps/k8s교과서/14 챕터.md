# 14 CI/CD와 GitOps

## CI/CD 개요

### Continuous Integration (CI)

- 코드 변경 자동 빌드 및 테스트
- 빠른 피드백
- 코드 품질 유지

### Continuous Deployment (CD)

- 자동화된 배포
- 안정적인 릴리스
- 빠른 시장 출시

## kubectl을 이용한 배포

### 기본 배포 전략

**Recreate**: 기존 파드를 모두 종료 후 새 파드 생성

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  strategy:
    type: Recreate
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: app
          image: myapp:2.0
```

**RollingUpdate**: 점진적 업데이트

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: app
          image: myapp:2.0
```

### 롤백

```bash
# 배포 이력 확인
kubectl rollout history deployment/myapp

# 이전 버전으로 롤백
kubectl rollout undo deployment/myapp

# 특정 리비전으로 롤백
kubectl rollout undo deployment/myapp --to-revision=2

# 롤아웃 상태 확인
kubectl rollout status deployment/myapp
```

## Helm

### Helm이란?

- 쿠버네티스 패키지 매니저
- Chart: 쿠버네티스 리소스 번들
- 버전 관리, 의존성 관리

### Helm 설치

```bash
# Helm 설치
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# 버전 확인
helm version
```

### Chart 생성

```bash
# Chart 생성
helm create myapp

# Chart 구조
myapp/
├── Chart.yaml
├── values.yaml
├── charts/
└── templates/
    ├── deployment.yaml
    ├── service.yaml
    ├── ingress.yaml
    └── _helpers.tpl
```

### values.yaml

```yaml
replicaCount: 3

image:
  repository: myapp
  tag: "1.0"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi
```

### Helm 명령어

```bash
# Chart 설치
helm install myapp ./myapp

# 특정 values 파일 사용
helm install myapp ./myapp -f values-prod.yaml

# 값 오버라이드
helm install myapp ./myapp --set replicaCount=5

# 업그레이드
helm upgrade myapp ./myapp

# 롤백
helm rollback myapp 1

# 삭제
helm uninstall myapp

# 목록 확인
helm list

# 이력 확인
helm history myapp
```

### Repository

```bash
# Repository 추가
helm repo add stable https://charts.helm.sh/stable

# Repository 업데이트
helm repo update

# Chart 검색
helm search repo nginx

# Chart 설치
helm install my-nginx stable/nginx-ingress
```

## Kustomize

### Kustomize란?

- 템플릿 없이 쿠버네티스 구성 커스터마이징
- 선언적 방식
- kubectl에 내장

### 기본 구조

```
base/
├── kustomization.yaml
├── deployment.yaml
└── service.yaml

overlays/
├── dev/
│   ├── kustomization.yaml
│   └── replica-patch.yaml
└── prod/
    ├── kustomization.yaml
    └── replica-patch.yaml
```

### base/kustomization.yaml

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml
  - service.yaml

commonLabels:
  app: myapp
```

### overlays/dev/kustomization.yaml

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
  - ../../base

namespace: dev

patches:
  - replica-patch.yaml

images:
  - name: myapp
    newTag: dev-latest
```

### 적용

```bash
# Dry-run
kubectl kustomize overlays/dev

# 적용
kubectl apply -k overlays/dev

# 삭제
kubectl delete -k overlays/dev
```

## GitOps

### GitOps 원칙

1. Git을 Single Source of Truth로
2. 선언적 구성
3. 자동화된 배포
4. 지속적인 동기화

### Argo CD

#### Argo CD 설치

```bash
# Argo CD 설치
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# CLI 설치
brew install argocd

# 포트 포워딩
kubectl port-forward svc/argocd-server -n argocd 8080:443

# 초기 비밀번호 확인
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
```

#### Application 생성

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/myapp
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: default
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

#### 명령어

```bash
# 로그인
argocd login localhost:8080

# Application 생성
argocd app create myapp \
  --repo https://github.com/myorg/myapp \
  --path k8s \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace default

# 동기화
argocd app sync myapp

# 상태 확인
argocd app get myapp

# 삭제
argocd app delete myapp
```

### Flux

#### Flux 설치

```bash
# Flux CLI 설치
brew install fluxcd/tap/flux

# 사전 확인
flux check --pre

# 설치
flux bootstrap github \
  --owner=myorg \
  --repository=fleet-infra \
  --branch=main \
  --path=./clusters/my-cluster \
  --personal
```

#### GitRepository

```yaml
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: GitRepository
metadata:
  name: myapp
  namespace: flux-system
spec:
  interval: 1m
  url: https://github.com/myorg/myapp
  ref:
    branch: main
```

#### Kustomization

```yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1beta2
kind: Kustomization
metadata:
  name: myapp
  namespace: flux-system
spec:
  interval: 10m
  targetNamespace: default
  sourceRef:
    kind: GitRepository
    name: myapp
  path: ./k8s
  prune: true
```

## CI/CD 파이프라인

### GitHub Actions

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Push to Registry
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push myapp:${{ github.sha }}

      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v1
        with:
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
          images: |
            myapp:${{ github.sha }}
```

### Jenkins

```groovy
pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'myapp'
        KUBECONFIG = credentials('kubeconfig')
    }

    stages {
        stage('Build') {
            steps {
                sh 'docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .'
            }
        }

        stage('Test') {
            steps {
                sh 'docker run --rm ${DOCKER_IMAGE}:${BUILD_NUMBER} npm test'
            }
        }

        stage('Push') {
            steps {
                sh 'docker push ${DOCKER_IMAGE}:${BUILD_NUMBER}'
            }
        }

        stage('Deploy') {
            steps {
                sh """
                    kubectl set image deployment/myapp \
                        app=${DOCKER_IMAGE}:${BUILD_NUMBER}
                """
            }
        }
    }
}
```

## 배포 전략

### Blue-Green 배포

```yaml
# Blue (현재 버전)
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
    version: blue
  ports:
    - port: 80

---
# Green (새 버전) 배포 후 selector를 green으로 변경
```

### Canary 배포

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: myapp
      track: stable
  template:
    metadata:
      labels:
        app: myapp
        track: stable
    spec:
      containers:
        - name: app
          image: myapp:1.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
      track: canary
  template:
    metadata:
      labels:
        app: myapp
        track: canary
    spec:
      containers:
        - name: app
          image: myapp:2.0
```

## 교훈

1. **Helm으로 쿠버네티스 패키지 관리**
2. **Kustomize로 환경별 구성 관리**
3. **GitOps로 선언적이고 자동화된 배포**
4. **Argo CD 또는 Flux로 GitOps 구현**
5. **Rolling Update로 무중단 배포**
6. **Canary/Blue-Green 배포로 안전한 릴리스**
7. **CI/CD 파이프라인으로 전체 과정 자동화**
