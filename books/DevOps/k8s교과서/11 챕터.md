# 11 쿠버네티스 보안

## 보안의 4C

### 계층적 보안 접근

```
┌─────────────────────────────────┐
│         Application (4)          │  애플리케이션 보안
├─────────────────────────────────┤
│         Container (3)            │  컨테이너 보안
├─────────────────────────────────┤
│         Kubernetes (2)           │  쿠버네티스 보안
├─────────────────────────────────┤
│         Cloud/Infrastructure (1) │  인프라 보안
└─────────────────────────────────┘
```

## 인증 (Authentication)

### 인증 방법

- **X.509 클라이언트 인증서**
- **베어러 토큰 (Bearer Token)**
- **인증 프록시**
- **HTTP 기본 인증**

### ServiceAccount

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: myapp-sa
  namespace: default
```

### Pod에서 ServiceAccount 사용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  serviceAccountName: myapp-sa
  containers:
    - name: app
      image: myapp:1.0
```

### ServiceAccount 토큰

```bash
# ServiceAccount 조회
kubectl get serviceaccounts

# 토큰 확인
kubectl describe serviceaccount myapp-sa

# 토큰 사용 예시
kubectl create token myapp-sa
```

## 인가 (Authorization) - RBAC

### Role: 네임스페이스 범위 권한

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
```

### ClusterRole: 클러스터 범위 권한

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]
```

### RoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
  - kind: ServiceAccount
    name: myapp-sa
    namespace: default
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

### ClusterRoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
  - kind: ServiceAccount
    name: myapp-sa
    namespace: default
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

### RBAC 권한 확인

```bash
# 특정 사용자의 권한 확인
kubectl auth can-i get pods --as=system:serviceaccount:default:myapp-sa

# 현재 사용자의 권한 확인
kubectl auth can-i create deployments

# 네임스페이스별 권한 확인
kubectl auth can-i get pods -n production
```

## Pod Security

### SecurityContext

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  containers:
    - name: app
      image: busybox
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        readOnlyRootFilesystem: true
```

### 컨테이너 보안 설정

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
spec:
  containers:
    - name: app
      image: myapp:1.0
      securityContext:
        runAsNonRoot: true
        runAsUser: 10000
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
          add:
            - NET_BIND_SERVICE
        readOnlyRootFilesystem: true
```

### Pod Security Standards

**Privileged**: 무제한
**Baseline**: 최소한의 제한
**Restricted**: 강력한 제한

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: secure-ns
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

## Secret 관리

### Secret 생성

```bash
# 리터럴 값으로 생성
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123

# 파일로부터 생성
kubectl create secret generic tls-secret \
  --from-file=tls.crt=path/to/tls.crt \
  --from-file=tls.key=path/to/tls.key
```

### Secret 사용

**환경 변수로 사용**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
    - name: app
      image: myapp:1.0
      env:
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
```

**볼륨으로 마운트**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-volume-pod
spec:
  containers:
    - name: app
      image: myapp:1.0
      volumeMounts:
        - name: secret-volume
          mountPath: /etc/secrets
          readOnly: true
  volumes:
    - name: secret-volume
      secret:
        secretName: db-secret
```

### Secret 암호화

```yaml
# EncryptionConfiguration
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <BASE64_ENCODED_SECRET>
      - identity: {}
```

## 네트워크 정책

### Ingress 제어

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-specific
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              role: frontend
        - namespaceSelector:
            matchLabels:
              name: production
      ports:
        - protocol: TCP
          port: 8080
```

### Egress 제어

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns-egress
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Egress
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
```

### 기본 거부 정책

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: default
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
```

## 이미지 보안

### Private Registry

```bash
# Docker Registry Secret 생성
kubectl create secret docker-registry regcred \
  --docker-server=my-registry.com \
  --docker-username=user \
  --docker-password=pass \
  --docker-email=user@example.com
```

### imagePullSecrets 사용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-reg-pod
spec:
  containers:
    - name: app
      image: my-registry.com/myapp:1.0
  imagePullSecrets:
    - name: regcred
```

### 이미지 정책

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-image-pod
spec:
  containers:
    - name: app
      image: myapp:1.0
      imagePullPolicy: Always # 항상 최신 이미지 pull
```

## Admission Controllers

### PodSecurityPolicy (deprecated)

```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  runAsUser:
    rule: MustRunAsNonRoot
  seLinux:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
```

### OPA Gatekeeper

```yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          properties:
            labels:
              type: array
              items: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels
        violation[{"msg": msg}] {
          provided := {label | input.review.object.metadata.labels[label]}
          required := {label | label := input.parameters.labels[_]}
          missing := required - provided
          count(missing) > 0
          msg := sprintf("Missing labels: %v", [missing])
        }
```

## 감사 로그 (Audit Log)

### 감사 정책

```yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
  - level: RequestResponse
    resources:
      - group: ""
        resources: ["secrets"]
  - level: Metadata
    resources:
      - group: ""
        resources: ["pods"]
```

## 보안 모범 사례

### Pod 보안

- root 사용자로 실행 금지
- readOnlyRootFilesystem 사용
- 불필요한 capability 제거
- 최소 권한 원칙 적용

### RBAC

- 최소 권한 원칙
- ServiceAccount별 권한 분리
- ClusterAdmin 역할 최소화
- 정기적인 권한 검토

### Secret 관리

- Secret을 Git에 커밋하지 않기
- 외부 Secret 관리 도구 사용 (Vault, Sealed Secrets)
- Secret rotation 정책 수립

### 네트워크

- NetworkPolicy로 최소 접근만 허용
- 기본 거부 정책 적용
- Ingress와 Egress 모두 제어

### 이미지

- 신뢰할 수 있는 레지스트리 사용
- 이미지 스캔 (Trivy, Clair)
- 최신 베이스 이미지 사용
- 태그 대신 다이제스트 사용

## 교훈

1. **다층 보안 접근 방식 적용**
2. **RBAC으로 최소 권한 원칙 구현**
3. **SecurityContext로 Pod 보안 강화**
4. **NetworkPolicy로 네트워크 격리**
5. **Secret을 안전하게 관리**
6. **Admission Controller로 정책 강제**
7. **정기적인 보안 감사 수행**
