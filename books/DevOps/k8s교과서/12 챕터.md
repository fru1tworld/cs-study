# 12 고급 스케줄링

## 스케줄링 개요

### 스케줄러의 역할

- 파드를 어느 노드에 배치할지 결정
- 리소스 요구사항, 제약 조건, 어피니티 규칙 고려
- 클러스터 전체의 균형 유지

## Node Selector

### 기본 사용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: node-selector-pod
spec:
  nodeSelector:
    disktype: ssd
    environment: production
  containers:
    - name: nginx
      image: nginx
```

### 노드에 레이블 추가

```bash
# 레이블 추가
kubectl label nodes node1 disktype=ssd
kubectl label nodes node1 environment=production

# 레이블 확인
kubectl get nodes --show-labels

# 레이블 제거
kubectl label nodes node1 disktype-
```

## Node Affinity

### Required (필수)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: affinity-required
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: disktype
                operator: In
                values:
                  - ssd
                  - nvme
  containers:
    - name: nginx
      image: nginx
```

### Preferred (선호)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: affinity-preferred
spec:
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 1
          preference:
            matchExpressions:
              - key: disktype
                operator: In
                values:
                  - ssd
  containers:
    - name: nginx
      image: nginx
```

### 연산자 종류

- **In**: 값이 리스트에 포함
- **NotIn**: 값이 리스트에 없음
- **Exists**: 키가 존재
- **DoesNotExist**: 키가 존재하지 않음
- **Gt**: 값이 더 큼 (숫자)
- **Lt**: 값이 더 작음 (숫자)

## Pod Affinity

### Pod Affinity (함께 배치)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-affinity
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - cache
          topologyKey: kubernetes.io/hostname
  containers:
    - name: app
      image: myapp:1.0
```

### Pod Anti-Affinity (분산 배치)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - web
              topologyKey: kubernetes.io/hostname
      containers:
        - name: nginx
          image: nginx
```

## Taints와 Tolerations

### Taint 설정

```bash
# Taint 추가
kubectl taint nodes node1 key1=value1:NoSchedule

# Taint 확인
kubectl describe node node1 | grep Taint

# Taint 제거
kubectl taint nodes node1 key1=value1:NoSchedule-
```

### Taint Effect

- **NoSchedule**: 새 파드 스케줄링 금지
- **PreferNoSchedule**: 가능한 한 스케줄링 안 함
- **NoExecute**: 기존 파드도 제거

### Toleration

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: toleration-pod
spec:
  tolerations:
    - key: "key1"
      operator: "Equal"
      value: "value1"
      effect: "NoSchedule"
    - key: "key2"
      operator: "Exists"
      effect: "NoExecute"
      tolerationSeconds: 3600
  containers:
    - name: nginx
      image: nginx
```

## 리소스 요청과 제한

### Requests와 Limits

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-pod
spec:
  containers:
    - name: app
      image: myapp:1.0
      resources:
        requests:
          memory: "64Mi"
          cpu: "250m"
        limits:
          memory: "128Mi"
          cpu: "500m"
```

### QoS 클래스

- **Guaranteed**: requests == limits
- **Burstable**: requests < limits
- **BestEffort**: requests와 limits 없음

```bash
# QoS 클래스 확인
kubectl get pod <pod-name> -o jsonpath='{.status.qosClass}'
```

## Priority Class

### Priority Class 정의

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "High priority class"
```

### Pod에 Priority 설정

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: high-priority-pod
spec:
  priorityClassName: high-priority
  containers:
    - name: nginx
      image: nginx
```

## Custom Scheduler

### 사용자 정의 스케줄러 사용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: custom-scheduler-pod
spec:
  schedulerName: my-custom-scheduler
  containers:
    - name: nginx
      image: nginx
```

## Topology Spread Constraints

### 파드 분산

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: spread-pod
  labels:
    app: myapp
spec:
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: DoNotSchedule
      labelSelector:
        matchLabels:
          app: myapp
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app: myapp
  containers:
    - name: app
      image: myapp:1.0
```

## DaemonSet

### 모든 노드에 파드 배포

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      tolerations:
        - key: node-role.kubernetes.io/master
          effect: NoSchedule
      containers:
        - name: fluentd
          image: fluent/fluentd:latest
```

## 스케줄링 실패 디버깅

### 이벤트 확인

```bash
# 파드 이벤트 확인
kubectl describe pod <pod-name>

# 모든 이벤트
kubectl get events --sort-by='.metadata.creationTimestamp'

# 스케줄링 실패 이벤트만
kubectl get events --field-selector reason=FailedScheduling
```

### 일반적인 실패 원인

- 리소스 부족
- NodeSelector/Affinity 조건 미충족
- Taint/Toleration 불일치
- PVC 바인딩 실패

## 모범 사례

### Affinity vs NodeSelector

- 간단한 조건: NodeSelector
- 복잡한 조건: Affinity
- 선호도 표현 필요: Preferred Affinity

### 고가용성

- Pod Anti-Affinity로 분산 배치
- Topology Spread Constraints 활용
- 여러 가용 영역에 배치

### 리소스 관리

- 항상 requests 설정
- limits는 신중히 설정
- QoS 클래스 이해하고 활용

### Taints/Tolerations 활용

- 특수 목적 노드 격리
- GPU 노드 관리
- 유지보수 시 노드 격리

## 교훈

1. **NodeSelector는 간단한 노드 선택에 사용**
2. **Affinity/Anti-Affinity로 고급 배치 전략 구현**
3. **Taints와 Tolerations로 노드 격리**
4. **리소스 요청과 제한으로 QoS 관리**
5. **Priority Class로 중요한 워크로드 우선 처리**
6. **Topology Spread Constraints로 균등 분산**
7. **DaemonSet으로 모든 노드에 파드 배포**
