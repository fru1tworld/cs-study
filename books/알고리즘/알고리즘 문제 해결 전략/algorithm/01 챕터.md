# 1장 - 문제 해결과 프로그래밍 대회

## 1.1 도입

알고리즘 문제 해결은 단순히 코딩 능력을 넘어서는 종합적인 사고력과 문제 분석 능력을 요구한다. 이 책은 프로그래밍 대회를 위한 전략과 문제 해결 기법을 다룬다.

## 1.2 프로그래밍 대회

프로그래밍 대회는 제한된 시간 내에 주어진 문제를 해결하는 능력을 겨루는 경진 대회다.

### 주요 프로그래밍 대회

- **ACM-ICPC**: 국제 대학생 프로그래밍 경시대회
- **Google Code Jam**: 구글에서 주최하는 전 세계 프로그래밍 대회
- **TopCoder**: 온라인 알고리즘 대회
- **Codeforces**: 정기적으로 열리는 온라인 대회
- **백준 온라인 저지**: 한국의 대표적인 온라인 저지

## 1.3 문제 해결 단계

1. **문제 읽고 이해하기**: 문제의 요구사항과 제약 조건 파악
2. **재정의와 추상화**: 문제를 자신의 언어로 재정의
3. **계획 세우기**: 해결 전략과 알고리즘 선택
4. **계획 검증하기**: 선택한 알고리즘의 시간 복잡도와 공간 복잡도 확인
5. **프로그램 구현하기**: 코드 작성
6. **회고하기**: 더 나은 해결 방법 고민

## 1.4 문제 해결 전략

### 1. 비슷한 문제를 풀어본 적이 있는가?

과거에 풀어본 문제와 유사한 패턴을 찾는다.

### 2. 단순한 방법에서 시작하기

무식하게 풀 수 있는 방법(brute-force)부터 시작한다.

### 3. 문제를 단순화하기

복잡한 문제를 더 작고 단순한 문제로 나눈다.

### 4. 그림으로 그려보기

문제를 시각화하면 해결의 실마리를 찾기 쉽다.

### 5. 수식으로 표현하기

문제를 수학적으로 모델링한다.

### 6. 문제를 분해하기

큰 문제를 작은 부분 문제들로 나눈다.

### 7. 뒤에서부터 생각해보기

목표 상태에서 시작해서 거꾸로 생각한다.

### 8. 순서를 강제하기

여러 선택지가 있을 때 체계적인 순서를 정한다.

### 9. 특정 형태의 답만 고려하기

답이 가질 수 있는 형태를 제한한다.

## 1.5 좋은 코드를 작성하는 요령

### 1. 간결한 코드

- 중복 제거
- 적절한 추상화
- 명확한 변수명

```cpp
// 나쁜 예
int a[100];
for(int i = 0; i < 100; i++) a[i] = i * 2;

// 좋은 예
vector<int> doubled(100);
for(int i = 0; i < 100; i++)
    doubled[i] = i * 2;
```

### 2. 적극적으로 코드 재사용하기

- 표준 라이브러리 활용
- 자주 사용하는 코드 템플릿 준비
- 함수로 분리

### 3. 표준을 따르기

- 일관된 코딩 스타일
- 변수명 규칙 준수
- 들여쓰기와 공백 규칙

### 4. 항상 같은 형태로 프로그래밍하기

- 입력 처리 방식 통일
- 디버깅 코드 작성 습관
- 테스트 케이스 검증 루틴

## 1.6 자주 하는 실수

### 1. 산술 오버플로우

```cpp
int a = 1000000;
int b = 1000000;
long long c = a * b; // 오버플로우 발생!
long long d = (long long)a * b; // 올바른 방법
```

### 2. 배열 범위 밖 원소 접근

```cpp
int arr[100];
arr[100] = 1; // 잘못된 접근
```

### 3. 일관되지 않은 변수 상태

```cpp
// 초기화 잊지 말기
int sum = 0; // 초기화
for(int i = 0; i < n; i++)
    sum += arr[i];
```

### 4. 스택 오버플로우

```cpp
// 재귀 깊이 제한 고려
int fibonacci(int n) {
    if(n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2); // 깊은 재귀
}
```

### 5. 다차원 배열 인덱스 순서

```cpp
// 2차원 배열
int arr[ROW][COL];
// arr[i][j]에서 i는 행, j는 열
```

## 1.7 디버깅과 테스팅

### 작은 입력부터 시작하기

```
입력 크기를 작게 시작해서 문제 파악
예: n=3, n=5 등의 작은 케이스
```

### 단언문 활용하기

```cpp
#include <cassert>

assert(n > 0); // n은 양수여야 함
assert(arr.size() == n); // 크기 확인
```

### 코드 검증하기

- 경계 조건 확인
- 코너 케이스 테스트
- 예외 상황 처리

## 1.8 시간 복잡도와 공간 복잡도

### Big-O 표기법

- O(1): 상수 시간
- O(log n): 로그 시간
- O(n): 선형 시간
- O(n log n): 선형로그 시간
- O(n²): 이차 시간
- O(2ⁿ): 지수 시간

### 입력 크기에 따른 알고리즘 선택

| 입력 크기      | 시간 복잡도 | 알고리즘 예시        |
| -------------- | ----------- | -------------------- |
| n ≤ 10         | O(n!)       | 순열, 조합           |
| n ≤ 20         | O(2ⁿ)       | 비트마스크 DP        |
| n ≤ 500        | O(n³)       | 플로이드-워셜        |
| n ≤ 5000       | O(n²)       | DP, 완전탐색         |
| n ≤ 1,000,000  | O(n log n)  | 정렬, 세그먼트 트리  |
| n ≤ 10,000,000 | O(n)        | 선형 탐색, 투 포인터 |

## 정리

문제 해결 능력은 많은 문제를 풀면서 길러진다. 꾸준한 연습과 다양한 문제 유형에 대한 경험이 중요하다.
