# 아키텍처

MySQL 서버는

- 사람의 머리 역할을 담당하는 MySQL엔진
- 손발 역할을 담당하는 스토리지 엔진으로 구분할 수 있습니다.

그리고 손과 발의 역할을 담당하는 스토리지 엔진은 핸들러 API를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있습니다.

## 4.1 MySQL 엔진 아키텍처

MySQL의 쿼리를 작성하고 튜닝할 때 필요한 기본적인 MySQL 엔진의 구조를 훑어보겠습니다.

MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특합니다.
이에 따른 다른 DBMS과 비교되는 장단점이 존재합니다.

### 4.1.1 MySQL의 전체구조

![MySQL 구조](../../../images/MySQL전체%20구조.png)

MySQL은 일반 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원합니다.
MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있습니다.

이 책에서는 MySQL의 쿼리파서나 옵티마이저 등과 같은 기능을 스토리지 엔진과 구분하고자 위 그림처럼 MySQL 엔진과 스토리지 엔진으로 구분했습니다.

그리고 이 둘을 모두 합쳐서 그냥 MySQL 또는 MySQL 서버라고 표현하곘다.

#### 4.1.1.1 MySQL 엔진

MySQL 엔진은 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.

또한 MySQL은 표준 SQL 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.

#### 4.1.1.2 스토리지 엔진

MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다.

MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

다음 예제와 같이 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리한다.

`mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB`

위 예제에서 test_table은 InnoDB 스토리지 엔진을 사용하도록 정의했다.

이제 test_table에 대해 INSERT, UPDATE, DELETE, SELEECT 등의 작업이 발생하면 InnoDB 스토리지 엔진이 그러한 처리를 담당한다.

그리고 각 스토리지 엔진은 성능향상을 위해 키 캐시(MyISAM 스토리지 엔진)이나 InnoDB버퍼 풀 (InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.

#### 4.1.1.3 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다.

이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 SHOW GLOBAL STATUS LIKE 'Handler%'; 명령으로 확인할 수 있다.

### 4.1.2 MySQL의 스레딩 구조

[MySQL 스레딩 구조](../../../images/MySQL의%20스레딩%20모델.png)

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

MySQL 서버에서는 실행 중인 스레드의 목록은 다음과 같이 performance_schema 데이터베이스의 threads 테이블을 통해 확인할 수 있다.

백그라운드 스레드는 MySQL의 설정 내용에 따라 가변적일 수 있고 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우다.

참고 엔터프라이즈 버전 혹은 Percona MySQL 서버에서는 스레드 풀 모델을 사용할 수도 있다. 가장 큰 차이점은 포그라운드 스레드와 커넥션의 관계다. 전통적인 스레드 모델에서는 커넥션 별로 포그라운드 스레드가 하나씩 생성되고 할당되지만 스레드 풀에서는 커넥션과 포그라운드 스레드가 1:!이 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담한다.

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수 만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다.
이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
이때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정한다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만(MyISAM 도 지연된 쓰기가 있지만 일반적인 방식은 아님) InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까찌 기록하는 작업은 백그라운드 스레드가 처리한다.

> MySQL에서 사용자 스레드와 포그라운드 스레드는 똑같은 의미로 사용된다. 클라이언트가 MySQL 서버에 접속하게 되면 MySQL 서버는 그 클라이언트의 요청을 처리해줄 스레드를 생성해 그 클라이언트에게 할당한다. 이 스레드는 DBMS의 앞단에서 사용자(클라이언트)와 통신하기 때문에 포그라운드 스레드라고 하며, 사용자가 요청한 작업을 처리하기 때문에 사용자 스레드라고 한다.

#### 4.1.2.2 백그라운드 스레드

MyISAM의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼를 병합하는 스레드
- **로그를 디스크로 기록하는 스레드**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

모두 중요한 역할을 하지만 가장 중요한 것은 로그 스레드(Log thread)와 버퍼 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드(write thread)일 것이다.

MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며, innodb_write_io_thread와 innodb_read_io_thread 시스템 변수로 스레드의 개수를 설정한다.

InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 일반적인 내장 디스크를 사용할 때는 2~4개 정도 DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.

그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재돼 있으며, InnoDB 또한 이러한 방식으로 처리한다.

하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다.

이러한 이유로 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 된다.

하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 4.1.3 메모리 할당 및 사용구조

![MySQL 메모리 구조](../../../images/MySQL서버의%20메모리%20구조.png)

### 4.1.4 플러그인 스토리지 엔진 모델

### 4.1.5 컴포넌트

### 4.1.6 쿼리 실행 구조

![MySQL 쿼리 실행 구조](../../../images/MySQL쿼리%20실행%20구조.png)

### 4.1.7 복제

### 4.1.8 쿼리 캐시

### 4.1.9 스레드 폴

### 4.1.10 트랜잭션 지원 메타데이터

## 4.2 InnoDB 스토리지 엔진 아키텍처

### 4.2.1 프라이머리 키에 의한 클러스터링

### 4.2.2 외래 키 지원

### 4.2.3 MVCC(Multi Version Concurrency Control)

### 4.2.4 잠금 없는 일관된 읽기(Non Locking Consistent Read)

### 4.2.5 자동 데드락 감지

### 4.2.6 자동화된 장애 복구

### 4.2.7 Inno 버퍼 풀

### 4.2.8 Double Write Buffer

### 4.2.9 언두 로그

### 4.2.10 체인지 버퍼

### 4.2.11 리두 로그 및 로그 버퍼

### 4.2.12 어댑티브 해시 인덱스

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

## 4.3 MyISAM 스토리지 엔진 아키텍처

### 4.3.1 키 캐시

### 4.3.2 운영체제의 캐시 및 버퍼

### 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

### 4.4.3 슬로우 쿼리 로그
