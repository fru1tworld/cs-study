# Chapter 9 운영체제 시작하기

### 운영체제란

프로그램에 실행에 마땅히 필요한 요소들을 시스템 자원 혹은 자원이라고 한다.

이전 CPU, 메모리, 보조기억 장치 등과 같은 컴퓨터 부품들은 모두 자원이라고 볼 수 있음

프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 바로 **운영체제**이다.

운영체제는 마찬가지로 프로그램이므로 메모리에 적재되어야한다.

매우 특별한 프로그램이므로 항상 메모리 내 **커널 영역**이라는 공간에 따로 적재된다.

커널 영역을 제외한 나머지 영역, 사용자가 이용하는 응용 프로그램이 적재되는 영역을 **사용자 영역**이라고 한다.

운영체제가 각각 겹치지 않게 응용 프로그램들을 메모리에 적재한다.

## 운영체제의 큰 그림

### 운영체제의 심장, 커널

운영체제는 현존하는 프로그램 중 규모가 가장 큰 프로그램이다.

프자원에 접근하고 조작하는 기능, 프로그램이 올바르고 안전하게 실행되게 하는 기능이 운영체제의 핵심 서비스에 속한ㄷ. 이러한 운영체제의 핵심 서비스를 담당하는 부분을 **커널**이라고 한다.

대부분 운영체제 전공서는 커널을 설명한다.

운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스도 있는데 대표적으로 **사용자 인터페이스**이다.

윈도우 바탕화면과 같이 사용자가 컴퓨터와 상호작용할 수 있는 통로이ㄷ.

사용자 인터페이스에는 **그래픽 유저 인터페이스와 커맨드 라인 인터 페이스**가 있다.

### 이중 모드와 시스템 호출

만약 응용 프로그램이 CPU, 메모리, 하드 디스크 등에 마음대로 접근하고 조작할 수 있다면 자원이 무질서하게 관리될 것이고 응용 프로그램이 조금만 실수해도 컴퓨터 전체에 큰 악영향을 끼칠 수 있다.

그래서 운영체제는 응용 프로그램이 자원에 접근하려고 할 때 오직 자신을 통해서만 접근하도록하여 자원을 보호한다.

응용 프로그램이 자원에 접근하기 위해서는 운영체제에 도움을 요청해야한다.

이때 도움을 요청한다는 것은 운영체제의 코드를 실행한다는 말과 같다.

이러한 문지기 역할을 이중 모드로써 구현이 된다.

이중 모드란 CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식이다.

**사용자 모드는** 운영체제 서비스를 제공받을 수 없는 실행 모드

사용자 모드로 실행되는 일반적인 응용 프로그램은 자원에 접근할 수 없다.

**커널 모드**는 운영체제 서비스를 제공받을 수 있는 실행 모드

커널 영역의 코드를 실행할 수 있는 모드

CPU가 사용자 모드로 실행 중인지, 커널 모드로 실행 중인지는 플래그 레지스터 속 슈퍼바이저 플래그를 보면 알 수 있다.

요컨대 사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 받으려면 커널 모드로 전환되어야 하는데 이러한 요청을 **시스템 호출(system call**)이라고 한다.

시스템 호출은 일종의 인터럽트이다. 정확히는 **소프트웨어적인 인터럽트**이다.

인터럽트는 특정 명령어에 의해 발생하기도 하는데 이를 **소프트웨어적 인터럽트**라고 한다.

그래서 CPU가 시스템 호출을 처리하는 순서는 인터럽트 처리 순서와 유사하다.

일반적으로 응용 프로그램은 실행 과정에서 운영체제 서비스들을 매우 빈번하게 이용한다.

그 과정에서 시스템 호출을 발생시키고 사용자 모드와 커널 모드를 오가며 실행된다.

### 운영체제의 핵심서비스

### 프로세스 관리

실행 중인 프로그램을 프로세스라 한다.

사용하는 동안 메모리에서 프로새스가 생성되고 사용되지 않는 프로세스는 메모리에서 삭제된다.

일반적으로 CPU는 한 번에 하나의 프로세스만 실행할 수 있기에 CPU는 이 프로세스들을 조금씩 번갈아 가며 실행한다. 다시 말해 CPU는 한 프로세스를 실행하다가 다른 프로세스로 실행을 전환하고, 그 프로세스를 실행하다가 또 다른 프로세스로 실행을 전환하는 것을 반복한다.

추가로 여러 프로세스가 동시에 실행되는 환경에서는 **프로세스 동기화**가 필수적이고, 프로세스가 꼼짝도 못하고 더 이상 실행되지 못하는 상황인 **‘교착 상태’**를 해결해야한다.

### 자원 접근 및 할당

### cpu

메모리에는 여러 프로세스가 적재되고 하나의 cpu는 한 번에 하나의 프로세스만 실행할 수 있다.

이에 운영체제는 프로세스들에 공정하게 CPU를 할당하기 위해 어떤 프로세스로부터 CPU를 이용할 지 얼마나 오래 이용할지 관리하는데 이를 CPU 스케줄링이라한다.

### 메모리

메모리에 적재된 프로세스들은 크기도 적재된 주소도 가지각색이다. 그래서 새로운 프로세스가 적재될 때 어느 주소에 적재해야할 지 결정한다.

### 입출력 장치

인터럽트 서비스 루틴은 운영체제가 제공하는 기능으로 커널 영역에 있다.

입출력장치가 발생시키는 하드웨어 인터럽트도 마찬가지이다. 운영체제는 인터럽트를 처리하는 프로그램을 제공함으로써 입출력작업을 수행한다.

### 파일 시스템 관리

파일을 열고 생성하고 삭제하는 파일들을 묶어 디렉토리로 관리를 하는데 이러한 파일 시스템도 운영체제가 지공하는 핵심 서비스이다.

### 좀 더 알아보기 : 가상 머신과 이중 모드의 발전

가상 머신을 설치하면 새로운 운영체제와 응용 프로그램을 설치하고 실행할 수 있다.

가상머신으로 작동하는 운영체제는 사용자 모드로 실행이 된다.

그래서 가상 머신을 위한 하이퍼 바이저 모드를 따로 둬서 가상 머신 상에서 작동하는 응용 프로그램들은 하이퍼 바이저 모드로써 가상 머신에 설치된 운영체제의 서비스를 받을 수 있다.

### 좀 더 알아보기 : 시스템 호출의 종류

리눅스 유닉스 등 POSIX 운영체제에서 사용하는 대표적인 시스템 호출의 예시

### 프로세스 관리

fork() : 새 자식 프로세스 생성

execve() : 프로세스 실행 (메모리 공간을 새로운 프로그램의 내용으로 덮어씌움)

exit() : 프로세스 종료

waitpid() : 자식 프로세스가 종료할 때까지 대기

### 파일 관리

open 파일 열기

close() 파일 닫기

read() 파일 읽기

write() 파일 쓰기

stat() 파일정보 획득

### 디렉터리 관리

chidir() 작업 디렉터리 변경

mkdir() : 디렉터리 생성

rmdir() : 비어있는 디렉터리 삭제

### 파일 시스템 관리

mount() : 파일 시스템 마운트

umount() : 파일 시스템 마운트 해제

# Chapter 10 프로세스와 스레드

### 프로세스 직접 확인하기

실행 중인 프로그램을 프로세스라 한다

사용자가 볼 수 있는 공간에서 실행되는 프로세스를 **포그라운드 프로세스**라 하고

사용자가 보지 못하는 편에서 실행되는 프로세스를 **백그라운드** **프로세스**라 한다.

백그라운드 프로세스 중에서는 사용자가 상호작용을 할 수 있는 백그라운드도 있고 상호작용을 하지않고 묵묵히 수행하는 백그라운드로 나뉜다. 이러한 백그라운드 프로세스를 유닉스 체계에서는 **데몬** , 윈도우 운영체제에서는 **서비스**라고 한다.

### 프로세스 제어 블록

프로세스 제어 블록 PCB를 이용하여 관리를 한다.

PCB는 커널 영역에서 생성 새로운 프로세스가 생성되었다는 말은 운영체제가 PCB를 생성했다는 말과 같다. 프로세스가 종료되었다는 말은 해당 PCB를 폐기했다는 말과 같다

PCB에 담기는 대표적인 정보들

### 프로세스 ID

특정 프로세스를 식별하기 위해 부여하는 고유번호 같은 프로그램을 실행해도 두번 실행하면 PID가 다른 두 개의 프로세스를 생성

### 레지스터 값

프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다

PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들을 담는다.

### 프로세스 상태

프로세스의 상태를 담는다.

### CPU 스케줄링 정보

프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록된다.

### 메모리 관리 정보

프로세스마다 메모리에 저장된 위치가 다르다. PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 있어야한다.

### 사용한 파일과 입출력장치 목록

프로세스가 실행 과정에서 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용이 명시된다. 즉 어떤 입출력 장치가 이 프로세스에 할당되었는지, 어떤 파일들을 열었는지에 대한 정보들이 PCB에 기록된다.

## 문맥 교환

하나의 프로세스에서 다른 프로세스로 실행순서가 넘어갈때 즉 A → B 로 넘어갈때 레지스터값, 메모리 정보 ,실행을 위해 열었던 파일이나 사용한 입출력장치 등 지금까지의 중간 정보를 백업해야한다.

이러한 중간 정보, 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 **문맥 (context)**라고 한다.

기존의 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위해 문맥을 PCB로 부터 복구하여 새로운 프로세스를 실행하는 것을 **문맥 교환**이라고 한다.

문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리이다.

### 프로세스의 메모리 영역

하나의 프로세스는 사용자 영역에 크게 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장된다.

### 코드영역

**code segment는 text segment** 라고도 부른다. 기계어로 이루어진 명령어가 저장되고 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기 금지이다. 즉 **읽기 전용 read only**

### 데이터 영역

데이터 영역 data segment는 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간으로 대표적으로 **전역 변수**가 대표적이다.

코드영역과 데이터 영역은 크게 변하지 않아서 **정적 할당 영역**이라고도 부른다.

힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변할 수 있어 **동적 할당 영역**이라고 한다.

### **힙 영역**

프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간으로 힙 영역에 메모리 공간을 할당햇다면 언젠가 해당 공간을 반환해야 한다.

메모리 공간을 반환하지 않으면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래하여 **메모리 누수 memory leak) 가 발생**

### 스택 영역

스택 영역은 데이터를 일시적으로 저장하는 공간으로 데이터 영역에 담기는 값과 달리 잠깐 쓰다가 말 값들이 저장되는 공간으로 **매개 변수, 지역 변수**가 대표적이다.

일시적으로 저장할 데이터는 스택 영역에 PUSH 되고 더 이상 필요하지 않은 데이터는 POP 됨으로써 스택 영역에서 사라진다.

**힙 영역은 낮은 주소에서 높은 주소로 할당**

**스택 영역은 높은 주소에서 낮은 주소로 할당**

## 프로세스 상태와 계층 구조

많은 운영체제는 동시에 실행되는 수많은 프로세스를 계층적으로 관리한다.

### 프로세스 상태

운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리한다. 대표적으로 다음과 같다.

### 생성 상태

프로세스를 생성 중인 상태를 **생성 상태(new)**라고 한다. 이제 막 메모리에 적재되어 PCB를 할당받은 상태를 뜻한다.

### 준비 상태

**준비 상태(ready)**는 당장이라도 CPU를 할당받아 실행할 수 있지만 아직 자신의 차례가 아니기에 기다리는 상태이다.

- 준비 상태 → 실행 상태로 전환되는 것을 **디스패치(dispatch)**라고 한다.

### 실행 상태

실행 상태는 CPU를 할당받아 실행 중인 상태를 의미한다. 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있다. 이때 프로세스가 할당된 시간을 모두 사용한다면(타이머 인터럽트가 발생하면) 다시 준비 상태가 되고 실행 도중 입출력 장치를 사용하여 입출력 장치의 작업이 끝날 떄까지 기다려야 한다면 대기 상태가 된다.

### 대기 상태

실행 도중 입출력 장치를 사용하는 경우가 있는데 입출력 작업은 CPU에 비해 처리 속도가 느리기에 입출력 작업을 요청한 프로세스는 입출력장치가 입출력을 끝낼 때까지 기다려야 한다. 이렇게 입출력장치의 작업을 기다리는 상태를 **대기 상태(blocked)**라고 한다.

### 종료 상태

종료 상태는 프로세스가 종료된 상태로 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

프로세스 상태 다이어그램

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2c74c6f1-df5f-4623-b721-3f5d3d308c58/ed351323-9b9e-41bd-9321-d01d4b3df448/Untitled.png)

### 추가 : 대기 상태의 일반적인 정의

프로세스가 대기 상태가 되는 이유에 입출력 작업만 있는 것이 아니다 일반적으로 특정 이벤트가 일어나길 기다릴 때 프로세스는 대기 상태가 된다. 다만 프로세스가 대기 상태가 되는 대부분의 원인이 입출력 작업이기 때문에 프로세스가 입출력 작업을 하면 대기 상태가 된다고 생각해도 무방하다.

## 프로스 계층 구조

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다. 이때 새 프로세스를 생성한 프로세스를 **부모 프로세스**라 하고 부모 프로세스에 의해 생성된 프로세스를 **자식 프로세스**라고 한다,.

부모 프로세스와 자식 프로세스는 다르므로 PID가 다르다. 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID (Parent PID)가 기록되기도 한다.

부모 프로세스로부터 생성된 자식 프로세스는 실행 과정에서 또 다른 자식 프로세스를 생성할 수 있고, 그 자식 프로세스는 실행 과정에서 또 다른 자식 프로세스를 생성할 수 있다.

컴퓨터가 부팅 될 때 실행되는 최초의 프로세스가 자식 프로세스들을 생성하고 다시 여러 프로세스들을 낳는 형식으로 동시에 실행된다.

이러한 트리 구조를 **프로세스 계층 구조**라 한다.

사용자가 컴퓨터를 켜고 로그인을 해서 bash 셸로 Vim 문서 편집기 프로그램을 실행했다고 가정하면

이 경우 사용자가 컴퓨터를 켠 순간 생성된 최초의 프로세스는 로그인을 담당하는 프로세스를 생성한 것이고 로그인 프로세스는 사용자 인터페이스 프로세스를 생성하고 사용자 인터페이스 프로세스는 VIM 프로세스를 생성한 셈이다.

### 추가 정보 : 최초의 프로세스

유닉스에서는 init , 리눅스에서는 systemd 맥OS에서는 launchd 라고 한다. 최초의 프로세스는 항상 PID 1이고 모든 프로세스 최상단에 있는 부모 프로세스이다.

### 프로세스 생성 기법

부모 프로세스를 통해 생성된 자식 프로세스들은 **복제와 옷 갈아입기**를 통해 실행된다.

부모 프로세스는 **fork**를 통해자신의 복사본을 자식 프로세스로 생성

만들어진 복사본은 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체

fork와 exec는 시스템 호출

fork는 자기 자신 프로세스의 복사본을 만드는 시스템 호출

fork를 통해 복사본이 만들어진 뒤 자식 프로세스는 exec 시스템 호출을 통해 새로운 프로그램으로 전환

결국 부모가 자식 프로세스를 실행하며 프로세스 계층 구조를 이루는 과정은 fork과 exec가 반복되는 과정

fork를 하고 부모와 자식 프로세스가 exec를 호출 하지 않으면 같은 코드를 병행하여 실행하는 프로세스가 된다.

# 스레드

스레드는 프로세스를 구성하는 실행의 흐름 단위이고. 하나의 프로세스는 여러 개의 스레드를 가질 수 있다.

### 프로세스와 스레드

실행의 흐름 단위가 하나인 스레드는 **단일 스레드 프로세스**라고 볼 수 있다.

스레드의 개념이 도입되어 하나의 프로세스가 여러 일을 동시에 처리할 수 있게 된다.

스레드는 프로세스 내에서 각기 다른 스레드 ID , 프로그램 카운터 값을 비롯한 레지스터 값, 스택으로 구성 그렇기에 각각 다른 코드를 실행할 수 있다.

중요한 점은 프로세스 자원을 공유하며 실행한다는 것이다.

즉

### 리눅스의 프로세스와 스레드

대부분 운영체제는 프로세스와 스레드를 구분하지만 리눅스는 명확하게 구분하지 않는다.

리눅스는 프로세스와 스레드 모두 실행의 문맥이라는 점에서 동등하다 간주하고 구분하지않고 테스크(task)라는 이름으로 통일하여 명명

### 멀티프로세스와 멀티스레드

여러 프로세스를 동시에 실행하는 것을 **멀티프로세스,** 여러 스레드로 프로세스를 동시에 실행하는 것을 **멀티스레드**라고 한다.

프로세스끼리는 자원을 공유하지 않지만 스레드끼리는 자원을 공유한다

프로세스를 fork 하여 같은 작업을 하는 동일한 프로세스 두 개를 동시에 실행하면 코드 영역 ,데이터 영역, 힙 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다. 한 마디로 PID, 저장된 메모ㅓ리 주소를 제외한 모든 것이 동일한 프로세스 두 개로 통째로 메모리에 적재

fork를 한 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서 동시에 프로세스 끼리 자원을 공유하지 않는 방법을 **copy on wirte**라고 한다.

이에 반해 스레드들은 각기 다른 스레드 ID 프로그램 카운터 ㄱ밧을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지고 있는 자원을 공유한다. 즉, 같은 프로세스 내의 모든 스레드는 아래 그림처럼 동일한 주소 공간의 코드,데이터, 힙 영역을 공유하고 열린 파일과 같은 프로세스 자원을 공유한다.

### 추가 정보: 프로세스 간 통신

프로세스끼리는 기본적으로 자원을 공유하지 않지만, 프로세스끼리도 충분히 자원을 공유하고 데이터를 주고받을 수 있다. 이를 프로세스 간 통신 (IPC)라고 한다.

컴퓨터 내 서로 다른 프로세스나 스레드 끼리 데이터를 주고 받는 것도 통신이라고 한다.

**파일을 통한 프로세스간 통신**

프로세스들은 서로 공유하는 메모리 영역을 두어 데이터를 주고 받을 수 있는데 이를 **공유 메모리**라고 한다.

이 외에도 프로세스들은 소켓,파이프 등을 통해 통신할 수 있다.

# Chapter 11 CPU 스케줄링

## 프로세스 우선순위

입출력 집중 프로세스 : 입출력 작업이 많은 프로세스

CPU 집중 프로세스 : CPU 작업이 많은 프로세스

입출력 집중 프로세스는 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 된다.

반대로 CPU는 대기 상태보다는 실행 상태에 더 많이 머무른다.

### CPU 버스트와 입출력 버스트

CPU를 이용하는 작업을 CPU 버스트라고 하고 입출력 장치를 기다리는 작업을 입출력버스트라고 부른다.

즉 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행된다고 볼 수 있다.

바꿔 말하면 입출력 집중 프로세스는 입출력 버스트가 많고 CPU 집중 프로세스는 CPU 버스트가 많다

따라서 CPU 집중 프로세스와 입출력 집중 프로세스가 동일한 빈도로 CPU를 사용하는 것은 비합리적이다. 따라서 입출력 집중 프로세스를 가능한 빨리 실행 시켜 그 다음 CPU 집중 프로세스를 CPU에 할당하는 것이 효율적이다. (입출력 집중 프로세스는 어차피 대기 상태가 될 예정이므로)

### 프로세스 우선 순위 직접 확인하기

입출력 작업이 많은 프로세스 외에도 실시간 프로세스, 일부 백그라운드 프로세스 등 다양한 프로세스가 우선순위가 높음 직접 우선 순위를 확인할 수 있다

### 스케줄링 큐

자료 구조 관점에서 FIFL 이지만 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없음

운영체제는 메모리로 적재되고 싶은 (새로 생성되는) 프로세스들을 큐에 삽입하여 줄을 세우고 CPU를 이용하고 싶은 프로세스들 또한 큐에 삽입하여 줄을 세우고 특정 입출력ㅈ아치를 이용하고 싶은 프로세스들 역시 큐에 삽입하여 줄을 세운다.

준비 큐 : CPU를 이용하고 싶은 프로세스이 push

대기 큐 : 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다

운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.

### 선점형과 비선점형 스케줄링

선점형 스케줄링 : CPU를 비롯한 자원을 사용하고 있더라도 프로세스가 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식

비선점형 스케줄링 : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식

선점형 스케줄링은 문맨 교환 과정에서 오버헤드가 발생할 수 있다.

비선점형 스케줄링은 문맥 교환 횟수가 선점형 스케줄링보다 적기 때문에 문맥교환에서 발생하는 오버 헤드는 적지만 당장 사용해야하는 상황에서 기다리는 수 밖에 없다.

## CPU 스케줄링 알고리즘

FCFS 스케줄링이라고도 부른다. 비선점형 스케줄링 방식으로 선입 선처리 스케줄링은 CPU를 먼저 요청한 프로세스부터 CPU에 할당하는 방식이다.

모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 호위 효과(convoy effect)

### 최단 작업 우선 스케줄링

CPU의 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식으로 **최단 작업 우선 스케줄링 혹은 SJF 스케줄링** 이라고 한다.

기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만 선점형으로 구현될 수 잇다.

### 라운드 로빈 스케줄링

라운드 로빈 스케줄링은 **선입 선처리 스케줄링**에 타임 슬라이스라는 개념이 더해진 스케줄링 방식으로 **타임 슬라이스**란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.

정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 프로세스

**최소 잔여 시간 우선 스케줄링**

최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링

정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업시간이 최소인 프로세스가 선택된다.

### 우선순위 스케줄링

프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행

우선순위가 같은 프로세스들은 선입 선처리로 스케줄링

최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ⊂ 우선순위 스케줄링

**기아 현상(stravation) 현상**

우선순위 높은 프로세스만 주구장창 실행 , 우선순위 낮은 프로세스는 실행 연기

이를 해결하기 위해 **에이징** 기법이 있는데 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.

### 다단계 큐 스케줄링

우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다.

우선순위 스케줄링의 발전된 형태

**우선순위별로 준비큐를 여러 개 사용하는 스케줄링** 방식으로

- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
- 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리

큐별로 타임슬라이스와 알고리즘을 다른 사용할 수 있다.

단점은 큐간 이동이 불가

### 다단계 피드백 큐 스케줄링

큐간 이동이 가능한 가능한 스케줄링이다.

새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 높은 큐에 삽입되고 타임 슬라이스 동안 실행된다. 그리고 만약 프로세스가 해당 큐에서 끝나지 않으면 다음 우선순위에 삽입되어 실행되고 이렇게 점점 내려간다.

CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐

너무 낮아지면 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.

# Chapter 12 프로세스 동기화

동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받아 자원의 일관성을 보장해야한다.

즉 **동기화**가 되어야한다.

## 동기화의 의미

**프로세스 동기화란 작업들 사이에 수행 시기를 맞추는 것을 의미한다**

실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기

상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

### 생산자와 소비자 문제

생산자는 ++를 하고 소비자를 —를 했을 때 둘이 각각 100,000번 실행하면

### 공유 자원과 임계 구역

공유 자원중에서 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원이 있다. 이러한 코드 영역을 **임계 구역이**라고 한다.

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야한다.

임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안되는 영역이지만 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우가 있다.

이를 **레이스 컨디션**이라 한다.

상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.

진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야한다.

유한 대기 : 한 프로세스가 임계구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다. (무한정 대기해서는 안된다)

## 동기화기법

### 뮤텍스 락

자물쇠 역할 : 프로세스들이 공유하는 전역변수 lock

임계 구역을 잠그는 역할 : acquire 함수

임계 구역의 잠금을 해제하는 역할 : release 함수

acquir는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수로

release 함수는 임계 구역에서 작업이 끝나고 호출하는 함수

매번 확인해서 확인 하는 방법은 바쁜 대기(busy wait) 라 한다.

### 세마포

하나의 공유 자원에 접근하는 프로세스를 상정한 방식

임계 구역에 진입할 수 있는 프로세스의 개수 전역 변수 S

임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수

임계 구역 앞에서 기다리는 프로세스에 ‘이제 가도 좋다’고 신호를 주는 signal 함수

실제로 세마포는 wait 함수는 사용할 수 없는 자원이 없을 경우 해당 프로세스 상태를 대기로 만들고 그 프로세스의 PCB를 세마포를 위한 대기큐에 넣고 다른 프로세스가 임계 구역의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨 준다.

### 모니터

인터페이스를 묶어 관리한다. 프로세스는 반드시 인터페이스를 통해 공유 자원에 접근하도록 한다.

이를 위해 모니터를 통해 공유 자원을 접근하고자 하는 프로세스를 큐에 삽입하고 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다.

항상 하나의 프로세스만 들어오도록하여 상호 배제를 위한 동기화를 제공한다.

모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다.

일시중단을 위해 조건 변수를 사용하는데 조건 변수와 모니터는 별개의 개념이다

# Chapter 13 교착상태

### 교착 상태 발생 조건

상호 배제, 점유와 대기, 비선점 , 원형 대기의 조건이 모두 만족하면 교착 상태가 발생한다.

상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때

점유와 대기 : 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태

비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗을 수 없을 때

원형 대기 : 프로세스들과 프로세스가 요청 및 할당받은 자원이 사이클인 경우 이런 것을 원형 대기

## 교착 상태 해결 방법

교착 상태 예방 : 상호 배제는 현실적으로 없애기 어렵고, 점유와 대기는 자원의 활용률이 낮아질 우려가 있다.

점유와 대기를 금지하면 또한 많은 자원을 사용하는 프로세스가 불리해진다.

비선점 조건을 없앨 경우 모든 자원이 선점할 수 있는 자원이 아니므로 범용성이 떨어진다.

따라서 원형 대기 조건을 없애야한다. 모든 자원에 번호를 붙이고 오름차순으로 자원을 할당하면 원형대기가 발생하지 않는다.

단점 : 모든 자원에 번호를 붙이는 것은 간단하지 않으며, 각 자원에 어떤 번호를 붙이지는 지에 따라 특정 자원의 활용률이 떨어질 수 있다.

따라서 교착상태를 사전 방지하는 교착 상태를 발생하지 않음을 보장하지만 여러 부작용이 있다.

### 교착상태 회피

교착 상태가 발생하지 않을 정도로만 자원을 할당하는 방식

모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태를 안전 상태라고 부르고 교착 상태가 발생할 수도 있는 상황을 불안전 상태라고 한다.

안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다.

이렇게 안전 순서열대로 프로세스들이 자원을 배분하여 교착 상태가 발생하지 않는 상태를 안전 상태라고 한다.

불안전 상태는 안전 순서열이 없는 상태이다. 이러한 경우 교착 상태가 발생할 수 있는 위험이 있다.

즉 시스템 상태가 안전 상태일 경우에만 자원을 할당하는 방식이다.

### 교착 상태 검출 후 회복

선점을 통한 회복 : 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식이다.

프로세스 강제 종료를 통한 회복 : 운영체제는 교착 상태에 놓인 프로세스를 모두 강제 종료할 수 있거나 하나씩 종료할 수 있다.

전자는 확실한 방식이지만 그만큼 많은 프로세스들이 작업을 잃을 수 잇고 후자는 교착 상태가 없어졌는지 확인하는 과정에서 오버헤드를 야기한다.

타조 알고리즘 : 잠재적 문제를 무시로 대처하는 방식

# Chapter 14 가상 메모리

연속 메모리 할당

### 스와핑

현재 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수 있다. 이렇게 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑이라 한다.

이때 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 스왑 영역이라고 하고 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 스왑 아웃 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 스왑 인이라고 한다.

스와핑을 이용하면 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.

### 메모리 할당

프로세스는 메모리 내 빈 공간에 할당되어야한다.

최초 적합 : 운영 체제가 빈공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치한다.

최적 적합 : 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.

최악 적합 : 빈 공간 중 가장 큰 공간에 프로세스를 배치하는 것을 의미한다.

### 외부 단편화

연속 메모리 할당은 외부 단편화라는 문제가 발생한다.

프로세스들이 메모리에 연속적으로 할당되는 환경에서 실행되고 종료되기를 반복하며 메모리 사이에 빈 공간들은 외부 단편화라고 한다.

이를 해결할 수 있는 방법은 압축이다.

압축은 메모리 조각 모음이라고도 부르는데 빈공간들을 하나로 모으는 방식이다.

단점 : 시스템은 하던 일을 중지하고 메모리에 있는 내용을 옮기는 작업은 많은 양을 요구한다.

### 페이징을 통한 가상 메모리 관리

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자르고 프레임에 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

프로세스 단위로 스왑 아웃/인 되는것이 아닌 페이지 단위로 스왑 아웃 인이 된다.

이런 경우 페이지 아웃/ 페이지 인이라 한다.

### 페이지 테이블

페이지 기법은 물리 주소가 불연속적이므로 CPU가 바라보는 논리 주소에 연속적으로 배치되도록 페이지 테이블이라는 것을 사용한다.

### 내부 파편화

모든 프로세스 크기가 페이지의 배수가 아니므로 내부 파편화 문제가 생긴다.

여기서 페이지 크기를 작게하면 페이지 테이블의 크기가 커지고 페이지가 커지면 내부 파편화 문제가 커진다.

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어있다.

그리고 CPU 내의 페이지 테이블 베이스 레지스터 (PBTR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

각 프로세스의 페이지 테이블 정보는 각 프로세스의 PCB에 저장된다.

페이지 테이블을 메모리에 두면 메모리 접근 시간이 두배로 늘어난다.

이를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) TLB라는 페이지 테이블의 캐시 메모리를 둔다.

TLB(Translation Lookaside Buffer)는 참조 지역성에 근거해 사용된 페이지 위주로 가져와 저장하고 TLB hit 와 TLB miss 가 있다.

### 페이징에서의 주소 변환

하나의 페이지 혹은 프레임은 여러 주소를 포괄한다.

그렇기에 특정 주소를 접근하기 위해 두 가지 정보가 필요하다

- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

페이징 시스템에는 모든 논리주소가 기본적으로 페이지번호와 변위(offset)로 이루어져 있다.

논리주소 <페이지 번호, 변위>는 페이지 테이블을 통해 <프레임 번호, 변위> 로 변환된다.

논리 주소의 변위와 물리주소의 변위 값은 같다.

### 페이지 테이블 엔트리

페이지 테이블의 각 엔트리, 즉 각각의 행은 페이지 테이블 엔트리라 한다.

페이지 테이블 엔트리에는 유효비트, 보호비트, 참조비트 ,수정 비트도 있음

### 유효비트

해당 페이지에 접근 가능한지 여부를 알려준다.

만약 CPU가 유효비트가 0인 메모리에 적재되어 있지 않은 페이지에 적재하면 페이지 폴트라는 예외가 발생한다.

CPU가 페이지 폴트를 처리하는 과정

1. CPU는 기존의 작업 내역을 백업한다.
2. 페이지 폴트 처리 루틴을 실행한다.
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경한다.
4. 페이지 폴트를 처리 후 CPU는 해당 페이지에 접근할 수 있다.

### 보호비트

페이지 보호 기능을 위해 존재한다.

보호 비트를 통해 해당 페이지가 읽기 쓰기가 모두 가능한지 읽기만 가능한지 알 수 있다.

보호비트는 세 개의 비트로 조금 더 복잡하게 구현할 수 있다.

읽기를 나타내는 r 쓰기를 나타내는 w 실행을 나타내는 x의 조합으로 읽기 쓰기 실행의 권한의 조합을 나타낼 수 있다.

### 참조 비트

CPU가 접근한 적이 있는지 여부를 나타낸다.

읽거나 쓴 페이지는 1로 세팅

### 수정 비트

해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.

더티 비트라고도 부른다.

1이면 변경된적이 있는 페이지이다.

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지 할 필요가 없는지 판단하기 위함

### 페이징의 이점

쓰기 시 복사

프로세스 간에 페이지를 공유할 수 있다. 대표적인 예씨로 쓰기 시 복사가 있다.

fork 호출 시 복사본이 자식 프로세스로 만들어진다.

프로세스간 기본적으로 자원 공유를 하지않아 다른 메모리 공간에 생성되는데 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 다음 그림과 같이 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.

부모 혹은 자식 프로세스가 페이지에 쓰기 작업하면 그 순간 별도의 공간으로 복제된다.

### 계층적 페이지

페이지 테이블을 패키징하여 여러 단계의 패키지를 두는 방식으로 여러 단계의 페이지를 둔다는 점에서 다단계 페이지 테이블 기법이라고도 부른다.

계층적 페이징 기법을 사용하지 않으면 이 프로세스 테이블은 전체가 메모리에 있어야 한다.

프로세스의 페이지 테이블을 여러 개의 페이지로 자르고 바깥 쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식이다.

페이지 테이블을 이렇게 게층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어진다.

다만 Outer 페이지 테이블은 항상 메모리에 유지해야한다.

바깥 페이지 번호에는 해당 항목은 CPU와 근접한 곳에 위치한 페이지 테이블 엔트리를 가리키고 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블 즉 페이지 테이블의 페이지 번호를 가리킨다.

바깥 페이지 번호를 통해 페이지 테이블의 페이지 찾기

페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로써 물리 주소 얻기

페이지 테이블의 계층은 2,3,4개 그 이상이 될 수 있다.

## 페이지 교체와 프레임 할당

### 요구 페이징

프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 요구 페이징이라고 한다.

아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있다. 이 경우 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다.

이를 순수 요구 페이징이라고 한다.

요구 페이징 시스템이 안정적으로 작동하려면 페이지 교체. 프레임 할당 문제를 해결해야한다.

요구 페이징 기법으로 적재하다보면 언젠가 메모리가 가득차는데 이때 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 보낸다.

어떤 페이지를 보낼지 결정하는 방법이 페이지 교체 알고리즘이다.

### 페이지 교체 알고리즘

페이지 폴트를 가장 적게 일으키는 알고리즘이 좋은 알고리즘으로 평가된다.

페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있다.

페이지 참조열의 개념은 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다. 가령

2 2 2 3 5 5 5 3 3 7 에서

2 3 5 3 7 이다.

중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문이다.

CPU가 특정 페이지에 열번 연속으로 접근한다고 해서 한 번 접근하는 것보다 페이지 폴트가 많이 발생하지 않는 것이다.

### FIFO 알고리즘

메모리에 가장 먼저 올라온 페이지부터 내 쫓는 방식

2차 기회 페이지 교체 알고리즘

가장 오래 머물렀던 페이지를 대상으로 내보낼 페이지를 선별한다. 차이가 있다면 페이지의 참조 비트가 1일 경우 당장 내쫓지 않고 참조비트를 0으로 만든뒤 현재 시간을 적재 시간으로 설정한다.

참조 비트가 1이라는 의미는 CPU가 접근한 적이 있다는 의미이므로 한 번 더 기회를 준다.

### 최초페이지 교체 알고리즘

최초 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 알고리즘이다.

앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적이다.

이 알고리즘이 최적 페이지 교체 알고리즘이다. 다만 실제 구현이 어려워서 이론상 성능을 평가할 목적으로 사용된다.

### LRU 페이지 교체 알고리즘

최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어를 토대로 만들어진 알고리즘이다.

### 스래싱과 프레임 할당

프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다.

반대로 프로세스가 사용할 수 있는 프레임 수가 많으면 일반적으로 페이지 폴트 빈도는 감소한다.

실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 **스래싱**이라 한다.

메모리에서 동시에 실행되는 프로세스이 수를 **멀티프로그래밍의 정도**라고 한다.

멀티프로그래밍의 정도를 늘린다고 해서 CPU 이용률이 그에 비례해서 증가하는 것이 아니다.

왜냐면 프레임의 수가 적어지기 때문에 페이지 폴트가 빈번하게 발생하기 때문이다.

각 프로세스를 무리없이 실행하기 위해 최소의 프레임수를 보장해야한다.

따라서 **프레임 할당 방식**을 생각해야할 필요가 있다.

**균등 할당 방식** : 균등하게 할당하는 방식

**비례 할당 방식** : 크기의 비례해서 할당하는 방식

프로세스를 실행해야 알 수 있는 방식이 있으므로 비례 할당 방식도 완벽하지 않다.

실행하는 과정에서 배분할 프레임을 결정하는 방식에는 크게

작업 집합 모델을 사용하는 방식와 페이지 폴트 빈도를 사용하는 방식이 있다.

프로세스가 일정 기간동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지한다.

일정 시간 동안 참조한 페이지의 집합을 **작업 집합**이라 한다.

작업 집합 : **실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합**

작업 집합을 구하는 방법

1. 프로세스가 참조한 페이지
2. 일정시간 간격

페이지 폴트를 기반으로 한 프레임 할당 방식

1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
2. 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다.

페이지 폴트율이 상한선과 하한선을 기준으로 높아지거나 낮아지는 경우 프레임을 더 할당하거나 회수하는 방식이다.

# Chapter 15 파일 시스템

## 파일과 디렉터리

파일이란 하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 논리적 단위를 의미한다.

이를 실행하기 위해 부가 정보가 있는데 이를 **속성** 또는 **메타 데이터**라고 한다.

### 파일 속성과 유형

유형 : 운영체제가 인지하는 파일의 종류를 나타낸다.

크기 : 파일의 현재 크기와 허용 가능한 최대 크기를 나타낸다.

보호 : 어떤 사용자가 해당 파일을 읽고, 쓰고, 실행할 수 있는지를 나타낸다.

생성 날짜 : 파일이 생성된 날짜를 나타낸다.

마지막 접근 날짜 : 파일에 마지막으로 접근한 날짜를 나타낸다.

마지막 수정 날짜 : 파일에 마지막으로 수정한 날짜를 나타낸다.

생성자: 파일을 생성한 사용자를 나타낸다.

소유자: 파일을 소유한 사용자를 나타낸다.

위치: 파일의 보조기억장치의 현재 위치를 나타낸다.

파일 속성 중 파일 유형은 운영체제가 인식하는 파일 종류를 나타낸다. 흔히 사용하는 방식은 파일 이름뒤에 붙는 **확장자(extension)**를 이용하는 것이다.

### 대표적인 파일 유형과 확장자들

실행 파일 : 없는 경우, exe, com, bin

목적 파일 : obj, o

소스 코드 파일 : c, cpp, cc, java, asm, py

워드 프로세서 파일 : xml, rtf, doc, docx

라이브러리 파일 lib, a, so, dll

멀티미디어 파일 : mpeg, mov , mp3 ,mp4 ,avi

백업/보관 파일 : rar, zip, tar

### 파일 연산을 위한 시스템 호출

파일 생성, 파일 삭제, 파일 열기, 파일 닫기, 파일 읽기, 파일 쓰기 등과 같은 시스템 호출을 제공한다.

### 디렉터리

파일을 일목요연하게 관리하기 위해 디렉터리를 이용할 수 있다.

옜날 운영체제에서는 하나의 디렉터리만 존재할 수 있어서 하나의 디렉터리 아래에 있었다. 이를 **1단계 디렉터리** 라고 부른다.

이후 **트리 구조 디렉터리**가 생겨났다.

트리 구조 디렉터리는 최상위 디렉터리가 있고 그 아래에 여러 서브 디렉터리가 있을 수 있다.

최상위 디렉터리는 흔히 루트 디렉터리라고 부르고 슬래시로 표현

경로(path)란 디렉터리를 이용해 파일 위치, 나아가 파일 이름을 특정 짓는 정보이다.

### 절대 경로와 상대 경로

루트 디렉터리에서 자기 자신까지 이르는 고유한 경로를 가지고 있고, 이러한 경로를 **절대 경로**라고 부른다.

상대 경로란 **현재 디렉터리부터 시작하는 경로**를 뜻한다.

### 디렉터리 연산을 위한 시스템 호출

디렉터리 생성,삭제, 열기, 닫기 읽기 등과 같은 시스템호출을 제공한다.

### 디렉터리 엔트리

디렉터리는 **특별한 형태의 파일**로 간주된다.

각각의 엔트리(행)에 담기는 정보는 파일 시스템마다 차이가 있으며, 파일 시스템별 디렉터리 엔트리는 공통으로 포함하는 정보가 있다면 그것은 디렉터리에 포함된 대상과 이름과 그 대상이 보조기억장치 내에 저장된 위치를 유추할 수 있는 정보가 담긴다는 점이다.

대부분의 운영체제는 현재 작업 디렉터리를 마침표 . 으로 나타내고 현재 작업 디렉터리의 상위 디렉터리를 마침표

두번으로 나타낸다.

루트디렉토리는 부모 디렉터리가 없기 때문에 루트 디렉터리의 ..은 자기 자신을 의미한다.

### 파일시스템

파일 시스템은 파일과 디렉터리를 보조기억장치에 일목요연하게 저장하고 접근할 수 있는 내부 프로그램이다.

파일 시스템이 보조기억장치에 어떻게 할당하고 접근하는지에 관한 이론을 먼저학습하고 이러한 이론을 바탕으로 만들어진 FAT 파일 시스템과 유닉스 파일 시스템을 알아보자

### 파티셔닝과 포매팅

보조기억장치를 사용하려면 파티션을 나누는 작업과 포맷 작업을 거쳐야한다. 이를 파티셔닝과 포매팅이라고 한다.

파티셔닝은 저장 장치의 논리적 영역을 구획하는 작업이다.

이렇게 나뉜 공간을 파티션이라고 한다.

포매팅은 저장 장치를 완전히 삭제하는 것이 아닌 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고 새로운 데이터를 쓸 준비를 하는 작업을 의미한다.

일반적으로 파티셔닝과 포매팅은 동시에 진행되거나 이미 포매팅까지 완료되어 판매하는 경우도 있음

### 파일 할당 방법

운영체제는 파일과 디렉터리를 블록 단위로 읽고 쓴다. 하드 디스크의 가장 작은 저장 단위는 섹터이지만 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리한다.

연속 할당, 불연속 할당으로 할당한다.

불연속 할당은 크게 연결 할당과 색인 할당으로 나뉜다.

\*현재는 불연속 할당 방식을 사용한다.

### 연속 할당

가장 단순한 방식으로 연속적인 블록에 파일을 할당하는 방식이다.

단점 : 외부 파편화를 야기한다.

### 연결 할당

연결 할당은 각 블록 일부에 다음 블록의 주소를 저장하여 블록이 다음 블록을 가리키는 형태로 할당하는 방식이다.

즉 파일을 이루는 데이터를 연결 리스트로 관리한다.

단점 : 연결리스트 이므로 첫 번째 블록부터 하나씩 차례때로 읽어야한다.

임의의 위치에 접근하는 속도 **임의 접근 속도**가 매우 느리다.

하드 웨어 고장이나 오류 발생시 해당 블록 이후 블록은 접근할 수 없다.

이를 해결하기 위해 그대로 구현하기보다 조금 변형하여 사용한다. 대표적으로 FAT 파일 시스템이 그러하다.

### 색인할당

색인 할당은 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식이다.

색인 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 **색인 블록 주소를** 명시한다.

이를 기반으로 만들어진것이 유닉스 파일 시스템이다.

### 파일 시스템 살펴보기

### FAT 파일 시스템

각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하여 파일 할당 테이블 (file Allocation Table) FAT이라 한다.

- 윈도우는 블록대신 클러스터라는 용어를 사용한다 즉 FAT 뒤에 오는 숫자는 클러스터를 표현하기 위한 비트이다.

FAT 파일 시스템에서는 FAT 은 파티션의 앞 부분에 만들어진다.

FAT은 하드 디스크 파티션의 시작 부분에 있지만 FAT은 실행하는 도중 메모리에 캐시될 수 있다. 메모리에 적재되면 다음 블록을 찾는 속도가 매우 빨라짐 FAT 파일 시스템의 디렉터리 엔트리에는 파일 이름과 더불어 파일 첫 번째 블록 주소가 명시되는데 이외에도 파일 속성과 관련된 다양한 정보가 있다.

### 유닉스 파일 시스템

유닉스 파일 시스템은 이 색인 블록을 index-node → i-node 라고 한다.

i-node에는 파일 속성 정보와 열다섯개의 블록 주소가 저장될 수 있다.

파일마다 이러한 i-node가 있고 i-node마다 번호가 부여되어 있다.

i-node크기는 유한하므로 열 다섯개의 블록을 차지하는 파일만 가리킬 수 있는데 그보다 더 큰 파일의 경우

다음과 같이 문제를 해결한다.

블록 주소 중 열두 개에는 직접 블록 주소를 저장한다.

i-node가 가리킬 수 있는 열다섯개의 블록 주소 중 처음 열두 개에는 파일 데이터가 저장된 블록주소가 직접적으로 명시된다. 이를 **직접 블록**이라고 한다.

첫 번째 내용으로 충분하지 않다면 열 세번째 주소에 단일 간접 블록 주소를 저장한다.

i-node의 열세번 째 블록 주소를 이용하여 저장된 블록이 아닌 파일 데이터를 저장한 블록 주소가 저장된 블록을 의미한다.

둘째 내용으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장한다.

i-node의 열 네번째 블록 주소를 이용한다. 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미한다.

즉 단일 간접 블록들의 주소를 저장하는 블록이 이중 간접 블록이다.

만약 세번째 내용으로 충분하지 않다면 열 다섯 번째 주소에 삼중 간접 블록 주소를 저장한다.

삼중 간접 블록 주소란 이중 간접 블록 주소가 저장된 블록으로 웬만한 크기의 파일을 표현할 수 있다.

i-node만 알면 파일 속성뿐만 아니라 파일 크기가 크더라도 파일 데이터를 모두 가리킬 수 있다.

유닉스 파일 시스템의 디렉터리 엔트리는 i-node 번호와 파일이름으로 구성된다.

파일 시스템은 방대하다. 대표적으로 윈도우에서 사용되는 NT파일 시스템 리눅스에서 사용되는 ext 파일 시스템 등이 있다.

### 저널링 파일 시스템

컴퓨터를 이용해 작업을 하던 도중 갑자기 전원이 나가거나 강제로 종료되면 시스템 크래시가 발생하면서 파일 시스템이 훼손될 수 있다.

저널링 파일 시스템이 있기 전에는 이런 상황이 발생하면 부팅 직후 파일 시스템을 검사하고 복구하는 프로그램을 실행 시켰다.

저널링 기법이란 작업 직전 파티션의 로그 영역을 수행하는 작업에 대한 로그를 남기고 로그를 남긴 후 작업을 수행한다. 작업을 끝나면 로그를 삭제한다. 이런 경우 파일 시스템 전체를 검사할 필요 없이 로그만 확인해도 된다.

### 마운트

저장 장치를 마운트한다는 표현을 많이 쓴다 이는 한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 편입시키는 작업을 의미한다.

유닉스와 리눅스는 다양한 저장 장치를 컴퓨터에 연결할때 mount 명령어로 빈번하게 마운트를 한다.
