# 1 자바 8,9, 10, 11: 무슨 일이 일어나고 있는가 ?

## 1.1

```java
Collection.sort(inventory, new Comparator<Apple>(){
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

```java
inventory.sort(comparing(Apple::getWeight));
```

자바는 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림이라는 새로운 API를 제공한다.

스트림을 사용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 훨씬 비싼 synchronized를 사용하지 않아도 된다.

스트림 API 덕분에 **코드를 전달하는 간결 기법(메서드 참조와 람다)**과 인터페이스의 **디폴트 메서드**가 존재할 수 있음을 알 수 있다.

> 코드를 전달하는 간결 기법
> 람다 표현식과 메서드 참조를 활용하여 코드 가독성을 높임.
> 디폴트 메서드
> 기존 인터페이스를 깨지 않고 새로운 기능을 추가할 수 있음.
> 스트림 API
> 병렬 연산을 지원하여 동기화 없이 멀티코어 CPU 활용 가능.

하지만 스트림 API 때문에 메서드에 코드를 전달하는 기법이 생겼다고 추리하는 것은 메서드에 코드를 전달하는 기법의 활용성을 제한할 수 있는 위험한 생각이다.

메서드에 코드를 전달하는 기법을 이용하면 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있다.

이러한 기법은 **함수형 프로그래밍**에 위력을 발휘한다.

- **1.1절**: 자바가 멀티코어 병렬성을 더 쉽게 이용할 수 있도록 진화하는 과정과 개념을 설명한다.
- **1.2절**: 자바 8에서 제공하는 코드를 메서드로 전달하는 기법이 어떠게 강력한 새로운 프로그래밍 도구가 될 수 있는지 설명한다.
- **1.3절**: 스트림 API가 어째서 강력하고 새로운 프로그래밍 도구인지 설명한다.
- **1.4절**: 디폴트 메서드라는 새로운 자바8의 기능을 인터페이스 라이브러리의 간결성 및 재컴파일을 줄이는 데 어떻게 호라용할 수 있는지 설명한다.
- **1.5절**: JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 제시한다.

### 1.2.2 스트림 처리

번스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 몽미이다.

이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.

즉 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

sort는 여러 행의 스트림을 입력으로 받아서 여러 행의 스트림을 출력으로 만들어낸다.

스트림 API의 핵심은 기존에는 한 번에 하나씩 처리했지만 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다.
스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

기존에는 메서드를 다른 메서드로 전달하는게 불가능했다.

이러한 기능을 동작 파라미터화라고 부른다.

### 1.2.4 병렬성과 공유 가변 데이터

병렬성을 얻는 대신 포기해야하는 것이 있는데 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.
보통 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다.

이러한 함수를 pure, side-effect free, stateless 함수라고 부른다.

공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다.

## 1.3 자바 함수

자바 프로그램에서 조작할 수 있는 값은 기본값, 객체의 참조 등이 있고 객체의 참조는 곧 클래스의 인스턴스를 가리킨다.

프로그래밍 언어의 핵심은 값을 바꾸는 것이다.

일반적으로 이 값을 일급 객체라고 부른다. 그러나 다양한 구조체(메서드, 클래스)는 값의 구조를 표현하는데 도움은 되지만 실행하는 동안 자유롭게 전달할 수 없고 이런 것을 이급 시민이다.

인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있지만 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다.

하지만 자바 8에서는 이급 시민을 일급 시민으로 바꾸는 기능을 추가했다.

### 1.3.1 메서드와 람다를 일급 시민으로

스칼라와 그루바 같은 언어에서 메서드를 일급값으로 사용하면 프로그래머가 활용할 수 있는 도구가 다양해지면서 프로그래밍이 수월해진다는 사실을 알아냈다.

그래서 자바 8의 설계자들은 메서드를 값으로 취급할 수 있게 설계했다.

첫 번째로 메서드 참조라는 새로운 자바 8의 기능을 소개한다.

```java
File [] hiddenFiles = new File(".").listFiles(new FileFilter(){
    public boolean accept(File file){
        return file.isHidden();
    }
})
```

```java
File [] hiddenFiles = new File(".").listFile(File::isHidden);
```

자바에서 메서드 참조라는 `::` (이 메서드를 값으로 사용하라는 의미)를 이용해서 listFiles에 직접 전달할 수 있다.

여기서 메서드가 아닌 함수라는 용어를 사용했다는 사실도 주목하다.

자바8은 더이상 이급값이 아닌 일급값이고 기존에는 객체 참조를 이용해서 객체를 이리저리 주고받았던 것처럼 자바8은 메서드 참조를 만들어서 전달할 수 있다.

#### 람다: 익명 함수

자바 8은 기명 메서드 뿐 아니라 람다(또는 익명 함수)를 포함하여 함수도 값으로 취급할 수 있다.

### 1.3.2 코드 넘겨주기: 예제

```java
  public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
```

> predicate ?
> 수학에서는 인수로 값을 받아 true나 false를 반환하는 것을 프레디케이트라고 한다. 자바 8에서도 Function(Apple, Boolean)같이 코드로 구현할 수 있지만 Predicate<Apple> 을 사용하는 것이 더 표준적이다. (boolean을 Boolean으로 변환하는 과정이 없으므로 효율적이기도 하다.)

### 1.3.3 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 유용하다.
그러나 사실 한 두번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다. 그래서 람다라는 것을 활용해서 다음과 같이 구현할 수 있다.

```java
filterApples(inventory, (Apple a)) -> GREE .equals(a.getColor());
filterApples(inventory, (Apple a)) -> GREE .equals(a.getWeight > 150 );
filterApples(inventory, (Apple a)) -> GREE .equals(a. getWeight() < 80 ||
                                                    RED.equlas(a.getColor()));
```

이러한 선택 기준은 코드의 명확성이 우선시되어야 할 것

자바 8은 filter와 비슷한 동작을 수행하는 연산집합을 포함하는 새로운 스트림 API과 비슷하며, 또한 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공한다.

## 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다.

하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다.

예를 들어 리스트에서 고가의 트랜잭션만 필터링한 다음에 통화로 결과를 그룹화한다고 가정해보자.

1. forking step: 어떤 CPU는 앞 어떤 CPU는 뒤를 처리한다.
2. 각각의 CPU는 자신이 맡은 절반의 리스트를 처리한다.
3. 마지막으로 하나의 CPU가 두 결과를 합친다.

컬렉션을 필러팅할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고 병렬로 처리한 다음에 리스트로 다시 복원하는 것이다.

## 1.5 디폴트 메서드와 자바 모듈

자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다.

그래서 JAR 같은 컴포넌트에 구조를 적용할 수 있으며, 문서화와 모듈 확인 작업이 용이해졌다.

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

예를 들어 자바8에서는 List에 직접 sort 메서드를 호출할 수 있다.

이는 자바8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

지금까지 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어를 살펴봤다.

하나는 메서드와 람다를 일급값으로 사용하는 것이고, 다른 하나는 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다는 것이다.

## 1.7
