## 2.1 들어가며

## 2.2 런타임 데이터 영역

자바 가상 머신은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.

이 영역들은 각각 목적과 생성/삭제 시점이 있다.

어떤 영역은 가상 머신 프로세스의 시작과 동시에 만들어지며, 어떤 영역은 사용자 스레드의 시작과 종료에 맞춰 생성/삭제 된다.

### 2.2.1 프로그램 카운터

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 `바이트코드 줄 번호 표시기`라고 생각하면 쉽다.

바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트 코드 명령어를 선택하는 식으로 동작한다.

예외 처리기나 스레드 복원 같은 기본 기능은 이 표시기를 활용해 이뤄진다.

멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되어있어서 각 코어는 한 스레드의 명령어만 실행하게 된다.

그래서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다.

따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다.

이 메모리 영역을 **스레드 프라이빗 메모리**라고 한다.

한편 스레드가 네이티브 메서드를 실행 중 일때 프로그램 카운터 값은 Undefined다.

### 2.2.2 자바 가상 머신 스택

프로그램 카운터처럼 자바 가상 머신 스택도 `스레드 프라이빗`하며, 연결된 스레드와 운명을 같이 한다(생성/삭제 시기가 일치한다.)

각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값등의 정보를 저장한다.

그런 다음 스택 프레임을 가상 머신 스택에 푸쉬하고, 메서드가 끝나면 팝하는 일을 반복한다.

지역 변수 테이블에는 JVM이 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다.

지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라 한다.

일반적으로 슬롯 하나의 크기는 32비트라서 Double과 같은 타입은 슬롯 2칸을 사용한다.

이때 필요한 공간은 컴파일 과정에서 할당된다.

자바 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기가 이미 완벽하게 결정되어 있다.

메서드 실행 중에는 절대 변하지 않는다.

여기서 이야기한 크기는 변수의 슬롯 개수임에 주의하자.

이때 JVM 스택 메모리 영역에서 두 가지 오류가 발생할 수 있다.

1. 스택 깊이가 허용보다 깊다 = StackOverFlow
2. 스택 용량을 동적으로 확장할 수 있는 JVM에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError를 던진다.

### 2.2.3 네이티브 메서드 스택

네이티브 메서드 스택은 가상 머신 스택과 매우 비슷한 역할을 한다.

차이점이라면 가상 머신 스택은 자바 메서드를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용하나는 것이다.

JVM 명세에는 이를 어떤 구조로 해야할지 아무것도 명시하지 않았다. 그래서 마음대로 구현할 수 있는데, 네이티브 메서드 스택과 JVM 스택을 합친 머신도 있다.

### 2.2.4 자바 힙

자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리다.

자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다.

이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것이고, 자바 세계의 거의 모든 객체 인스턴스가 이 영역에 할당된다.

JVM 명세에는 "모든 객체 인스턴스와 배열은 힙에 할당된다"라고 되어있다. 그럼에도 거의라고 표현한 이유는 다음과 같다.

자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보이는데, JIT 컴파일 기술이 발전하면서, 특히 탈출 분석 기술이 날로 발전하면서 스택 할당과 스칼라 치환 최적화 방식이 살짝 달라졌다.

그래서 모든 자바 객체 인스턴스가 힙에 할당된다는 설명이 절대적 진리라고 보기에는 조금씩 애매해지고 있다.

자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 어떤 문헌에서는 GC 힙이라고도 한다.

메모리 회수 관점에서 대다수 현대적 가비지 컬렉터는 세대별 컬렉션 이론을 기초로 설계됐다.

그래서 자바 힙을 설명할 때 신 세대(New Generation), 구 세대(Old Generation), 영구 세대, 에덴 공간(), 생존자 공간에서부터(from survivor space), 생존자 공간으로(to survivor space) 와 같은 용어들이 존재한다.

여기서 짚고 넘어가야 할 사실은 이 영역 구분은 가비지 컬렉터들의 일반적인 특성 또는 설계 방식일 뿐이다.

그래서 JVM 명세의 자바 힙 절에는 세부 영역 구분에 대한 이야기 자체가 없다.

메모리 할당 관점에서 자바 힙은 모든 스레드가 공유한다.

따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러 개로 나뉜다.

하지만 어떤 시각에서 보든 또는 어떻게 나누든 상관없이 데이터가 자바 힙에 저장된다는 사실을 달라지지 않는다.

어떤 세부 영역이든 객체의 인스턴스만 저장할 수 있다.

자바 힙을 다시 작게 구분하는 목적은 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.

JVM 명세에 따르면 힙은 논리적으로는 연속되어야 한다. 하지만 대다수 VM이 큰 객체는 물리적으로도 연속된 메모리 공간을 사용하도록 구현했다.

JVM 힙은 크기를 고정할 수도 확장할 수도 있게 구현할 수 있다.

### 2.2.5 메서드 영역

메서드 영역도 자바 힙처럼 모든 스레드가 공유한다.

메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드를 저장하는 데 이용된다.

JVM 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만 구분하기 위해 non-heap이라고 부르기도 한다.

### 2.2.6 런타임 상수 풀

런타임 상수 풀은 메서드 영역의 일부이다.

상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.

가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.

JVM은 클래스 파일의 각 영역별로 엄격한 규칙을 정해 놓았다.

가령 VM이 클래스 파일을 로드해 실행하려면 각 바이트에는 명세가 요구하는 데이터가 들어 있어야 한다.

다만 런타임 상수 풀에 대해서는 JVM 명세가 상세히 적어놓지 않아서 가상 머신 제공자가 입맛에 맞게 구현할 수 있다.

그렇지만 심벌 참조는 물론 심벌 창조로부터 번역된 직접 참조 역시 런타임 풀에 저장되는 게 일반적이다.

클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 중요한 특징이 하나 더 있다.

바로 동적이라는 것이다.

개발자들이 많이 사용하는 String 클래스의 intern 메서드에 바로 이 특성이 반영되어있다.

런타임 상수 풀은 메서드 영역에 속하므로 자연스럽게 메서드 영역을 넘어서까지 확장될 수는 없다.

그래서 상수 풀의 공간이 부족하면 OOM Error를 던진다.

### 2.2.7 다이렉트 메모리

JVM 런타임에 속하지 않으며 JVM 명세에 정의된 영역도 아니지만 OOM의 원인이 될 수 있어서 설명한다.

JDK 1.4에서 NIO가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개됐다.

NIO는 힙이 아닌 메모리에 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다.

따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선했다.

물리 메모리를 직접 할당하기 때문에 자바 힙 크기의 제약과는 무관하지만 이 역시 메모리라는 사실에는 변함이 없다.

따라서 하부 기기의 총 메모리 용량과 프로세서가 다룰 수 있는 주소 공간을 넘어설 수 없다.

사요오디는 모든 메모리 영역의 합이 물리 메모리 한계를 넘어서면 동적 확장을 시도 할 때 OOM Error가 발생되므로 유의해야한다.

## 2.3 핫스팟 가상 머신에서의 객체 들여다보기

핫스팟이 관리하는 자바 힙에서의 객체 생성, 레이아웃, 접근 방법등 전체 과정의 상세 내용이다. 차례대로 살펴보자.

### 2.3.1 객체 생성

자바는 객체 지향 프로그래밍 언어다.

자바 프로그램이 동작하는 동안 언제든 수시로 객체가 만들어진다.

언어 수준에서 객체 생성은 보통 단순히 new 키워드를 쓰기만 하면 된다(복사와 역직렬화 제외)

그렇다면 가상 머신 수준에서는 과연 어떤 과정을 거쳐 객체가 아닌 일반적인 자바 객체가 생성될까 ?

자바 가상 머신이 new 명령에 해당하는 바이트 코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.

그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석(resolve), 초기화(initialize)되었는지 확인한다.

준비되지 않은 클래스라면 로딩부터 해야 한다.

클래스 로딩 과정은 7장에서 자세하게 다룬다.

로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다.

객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다.

객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라 할 수 있다.

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에 여유 메모리는 반대편에 자리하며, 포인터가 두 경계인 가운데 지점을 가리키게 될 것이다.

이 상태에서 메모리를 할당하면 포인터를 여유 공간 쪽으로, 정확히는 객체 크기만큼 이동시키게 된다.

이러한 할당 방식을 포인터 밀치기라고 한다.

그러나 자바 힙은 규칙적이지 않다.

사용 중인 메모리와 여유 메모리가 뒤섞여 있어서 포인터를 밀쳐 내기가 그리 간단하지 않다.

그 대신 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리하며, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당한 후 목록을 갱신한다.

이 할당 방식은 여유 목록(free list)라 한다.

### 2.3.2 객체의 메모리 레이아웃

### 2.3.3 객체에 접근하기

## 2.4 OutOfMemoryError 예외

### 2.4.1 자바 힙 오버 플로

### 2.4.1 가상 머신 스택과 네이티브 메서드 스택 오버 플로

### 2.4.1 메서드 영역과 런타임 상수 풀 오버 플로

### 2.4.1 네이티브 다이렉트 메모리 오버플로

## 2.5 마치며
