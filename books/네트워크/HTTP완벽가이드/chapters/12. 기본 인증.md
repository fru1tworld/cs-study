# 12. 기본 인증

## 12.1 인증

인증은 당신이 누구인지 증명하는 것이다.

완벽한 인증이란 없다 비밀번호는 누군가가 추측하거나 엿들을 수 있고 신분증은 도둑맞거나 위조될 수 있다.

### 12.1.1 HTTP의 인증 요구/응답 프레임워크

HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

웹 애플리케이션이 HTTP 요청 메시지를 받으면 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 인증 요구로 응답할 수 있다.

사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야 한다. 만약 인증 정보가 맞지 않으면 서버는 클라이언트에 다시 인증 요구를 보내거나 에러를 낼 수 있다.

### 12.1.2 인증 포로토콜과 헤더

HTTP는 필요에 따라 고쳐쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.

HTTP에는 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.

참고: 현대에는 OAuth라는 인증 프로토콜을 사용한다.

단계

0. 요청 : 첫 번째 요청에는 인증 정보가 없다 : GET
1. 인증 요구 WWW.Authenticate: : 서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다. : 401 Unauthorized
2. 인증 Authorization : 클라이언트는 요청을 다시 보내는데, 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization 헤더를 함께 보낸다. : GET
3. 성공: Authentication-Info: 인증 정보가 정확하면 서버는 문서와 함께 응답한다. : 200 OK

### 12.1.3 보안 영역

기본 인증을 자세히 살펴보기에 앞서 HTTP가 어떻게 각 리소스마다 다른 접근을 다루는지 설명할 필요가 있다.

서버가 클라이언트로 인증 요구를 할 때 realm 지시자가 기술되어있는 WWW-Authenticate 헤더를 봤을 것이다. 웹 서버는 기밀분서를 보안 영역 그룹으로 나눈다.

보안 영역은 저마다 다른 사용자 권한을 요구한다.

예를 들어 웹 서버가 보안 영역을 두개 가진다고 가정해보자.

한 개는 회사의 재정 정보이고 다른 하나는 개인의 가족 문서다. 각 사용자는 서로 다른 영역으로 접근한다.

회사의 CEO는 판매 예측 자료에 접근할 수 있지만 그에게 가족 방학 사진에 대한 접근할 권할을 주지는 않을 것이다.

## 12.2 기본 인증

기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있다.

### 12.2.1 Base-64 사용자 이름/ 비밀번호 인코딩

HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고 base-64 인코딩 메서드를 사용해 인코딩한다.

### 12.2.1 프락시 인증

프락시 인증은 웹 서버의 인증과 ㅔ더와 상태 코드만 다르고 절차는 같다.

웹 서버와 프락시 인증에 쓰이는 상태 코드와 헤더들의 대조표다.

## 12.3 기본 인증의 보안 결함

기본 인증은 단순하고 편리하지만 안심할 수는 없다.

기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나 SSL 같은 기술과 혼용한다.

1. 기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에서 접근한다 base-64으로 인코딩하는 것은 사실상 그대로 보는 것과 마찬가지
2. 보안 비밀번호가 디코딩하기에 복잡한 방식으로 되어있다고 하더라도 여전히 제삼자는 읽기 힘든 사용자 이름과 비밀번호를 캡처한 다음 그것을 원 서버에 그대로 보내면 접근할 수 있다.
3. 메시지의 인증 헤더를 건드리지는 않지만 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리거나 프락시가 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.
4. 기본 인증은 가빠 서버의 위장에 취약하다
