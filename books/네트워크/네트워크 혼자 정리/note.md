# DHCP(Dynamic Host Configuration Protocol)

- DHCP는 네트워크에 연결된 장치(클라이언트)가 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소와 같은 네트워크 설정을 자동으로 할당받을 수 있도록 지원하는 네트워크 관리 프로토콜입니다.
- 이 프로토콜은 네트워크 관리자에게 수동으로 IP 주소를 설정할 필요 없이, 장치들이 네트워크에 쉽게 연결되도록 도와줍니다.

## DHCP의 주요 기능

### 자동 IP 주소 할당

- 네트워크에 연결된 장치(예: 컴퓨터, 스마트폰, 프린터)는 DHCP를 통해 사용 가능한 IP 주소를 자동으로 할당받습니다.
- 이 과정은 사용자가 직접 설정하지 않아도 이루어집니다.

### 중복 IP 주소 방지

- DHCP 서버는 네트워크에서 중복된 IP 주소가 할당되지 않도록 관리합니다.
- 이는 네트워크 충돌을 방지하고 안정성을 유지합니다.
  ### 네트워크 설정 정보 제공
- DHCP는 IP 주소 외에도 다음과 같은 정보를 제공할 수 있습니다:

- 서브넷 마스크: 네트워크와 호스트를 구분하는 데 사용.
- 기본 게이트웨이: 네트워크를 넘어 외부로 데이터를 전송하기 위한 라우터 주소.
- DNS 서버: 도메인 이름을 IP 주소로 변환하기 위한 서버 주소.

### 유지보수 단순화

- 장치가 많거나 자주 변경되는 네트워크 환경에서도 DHCP를 사용하면 IP 주소 관리가 간소화됩니다.

## DHCP 동작 과정

1. DHCP Discover (탐색)
   클라이언트(장치)가 네트워크에 연결되면 브로드캐스트 메시지로 "IP 주소를 주세요!"라는 요청을 DHCP 서버에게 보냅니다.
   메시지 형식: DHCP Discover.
2. DHCP Offer (제안)
   네트워크에 있는 DHCP 서버는 사용 가능한 IP 주소를 확인한 뒤, 클라이언트에게 IP 주소 제안 메시지를 보냅니다.
   메시지 형식: DHCP Offer.
   이 메시지에는 제안된 IP 주소와 함께 서브넷 마스크, 게이트웨이 주소 등의 정보가 포함됩니다.
3. DHCP Request (요청)
   클라이언트는 받은 제안을 확인하고, 자신에게 할당된 IP 주소를 수락하기 위해 DHCP Request 메시지를 보냅니다.
   이 과정에서 다른 DHCP 서버의 제안을 거절합니다.
4. DHCP Acknowledgement (확인)
   DHCP 서버는 클라이언트의 요청을 확인하고, IP 주소를 최종적으로 할당하며 네트워크 설정 정보를 전달합니다.
   메시지 형식: DHCP ACK(Acknowledgement).
   이 과정을 통해 클라이언트는 네트워크 연결에 필요한 정보를 얻고, 정상적으로 통신을 시작할 수 있습니다.

## DHCP의 구성 요소

### DHCP 서버

- 네트워크에 연결된 장치들에게 IP 주소와 기타 네트워크 정보를 제공하는 장치 또는 소프트웨어.
- 예: 라우터나 독립적인 DHCP 서버.

### DHCP 클라이언트

- 네트워크에 연결되어 DHCP 서버로부터 설정 정보를 요청하는 장치.
- 예: 컴퓨터, 스마트폰, IoT 장치.

### DHCP 리스(Lease)

- DHCP 서버가 IP 주소를 클라이언트에게 일정 기간 동안만 임시로 할당하는 방식.
- 리스 시간이 만료되면 클라이언트는 주소를 갱신하거나 새로운 주소를 요청합니다.

## HTTP Response Status Code

### 1xx: 정보 응답

- 100 Continue: 클라이언트가 요청을 계속 진행해도 됨을 나타냅니다.

### 2xx: 성공

- 200 OK: 요청이 성공적으로 처리되었음을 나타냅니다.
- 201 Created: 요청이 성공적으로 처리되었고 리소스가 생성되었음을 나타냅니다.
- 204 No Content: 요청은 성공했지만 반환할 데이터가 없음을 나타냅니다.

### 3xx: 리다이렉션

- 301 Moved Permanently: 요청된 리소스의 URI가 변경되었음을 나타냅니다. 클라이언트는 새 URI로 리소스를 요청해야 합니다.
- 302 Found: 요청된 리소스가 일시적으로 다른 URI에 있음을 나타냅니다.
- 304 Not Modified: 클라이언트가 캐시된 리소스를 사용할 수 있음을 나타냅니다.

### 4xx: 클라이언트 오류

- 400 Bad Request: 잘못된 요청입니다. 서버가 요청을 이해할 수 없습니다.
- 401 Unauthorized: 인증이 필요합니다.
- 403 Forbidden: 서버가 요청을 거부했습니다.
- 404 Not Found: 요청한 리소스를 찾을 수 없습니다.
- 429 Too Many Requests: 클라이언트가 너무 많은 요청을 보냈음을 나타냅니다.

### 5xx: 서버 오류

- 500 Internal Server Error: 서버에서 요청을 처리하는 동안 오류가 발생했습니다.
- 502 Bad Gateway: 게이트웨이 또는 프록시 서버가 잘못된 응답을 받았음을 나타냅니다.
- 503 Service Unavailable: 서버가 일시적으로 사용 불가능함을 나타냅니다.
- 504 Gateway Timeout: 게이트웨이 또는 프록시 서버가 응답을 기다리다 시간 초과됨을 나타냅니다.

#

## 3-way Handshake에서 교환되는 추가 정보와 정책

1. SYN 패킷 (클라이언트 → 서버)
   클라이언트는 연결 요청과 함께 초기 설정 및 옵션 정보를 전달합니다:

### MSS (Maximum Segment Size):

- 클라이언트가 한 번에 전송할 수 있는 TCP 세그먼트의 최대 크기를 제안합니다.
- 이는 IP 패킷 크기(기본적으로 MTU)에서 TCP/IP 헤더 크기를 뺀 값입니다.
- 예: Ethernet의 MTU가 1500바이트라면 MSS는 일반적으로 1460바이트.

### Window Size:

- 클라이언트가 수신 가능한 데이터의 크기를 나타냅니다.
- 이를 통해 흐름 제어(flow control)를 지원합니다.

### Selective Acknowledgment (SACK) Permitted:

- 선택적 ACK 옵션 지원 여부를 표시합니다.
- 이 옵션이 활성화되면, 패킷 손실 시 효율적으로 재전송할 수 있습니다.

### Timestamps (옵션):

- RTT(Round Trip Time) 측정 및 PAWS(Protect Against Wrapped Sequence)와 같은 기능 지원. 2. SYN-ACK 패킷 (서버 → 클라이언트)
- 서버는 클라이언트 요청을 수락하며 자신만의 설정과 옵션 정보를 추가로 전달합니다:
- MSS: 서버도 자신의 MSS 값을 제안합니다.
- Window Size: 서버가 수신 가능한 데이터 크기를 설정합니다.
- SACK Permitted: 서버 측에서도 SACK 옵션을 사용할 수 있음을 알립니다.
- Timestamps: 서버가 지원하는 경우, 해당 값을 추가로 포함합니다. 3. ACK 패킷 (클라이언트 → 서버)

- ACK 패킷은 연결을 최종적으로 확정하며, 클라이언트와 서버 간 정책 및 옵션 설정이 완료됩니다.
- 이 단계에서는 추가적인 설정은 포함되지 않고, 주로 ACK 정보만 전달됩니다.

## 교환되는 주요 정책 요약

### 옵션/정책 설명

- MSS 한 번에 전송 가능한 최대 세그먼트 크기
- Window Size 흐름 제어를 위한 수신 창 크기
- SACK Permitted 선택적 ACK를 통한 효율적인 재전송 지원 여부
- Timestamps RTT 측정 및 PAWS를 위한 시간 정보
- Nagle Algorithm 소량의 데이터를 합쳐 전송할지 여부 (일반적으로 handshake 단계에서 협상되지 않지만 중요한 TCP 정책 중 하나)

## 정리

- TCP 3-way handshake 과정은 단순히 연결을 설정하는 것뿐만 아니라, 전송 효율성과 신뢰성을 높이기 위한 옵션 및 정책을 교환하는 단계입니다. 이를 통해 클라이언트와 서버는 최적의 통신 환경을 협상하게 됩니다.

# TLS 인증서

- TLS는 서버와 클라이언트 간의 신뢰를 보장하기 위해 디지털 인증서를 사용합니다.
- 디지털 인증서는 인증 기관(CA, Certificate Authority)이 발행하며, 클라이언트는 이를 통해 서버가 신뢰할 수 있는 엔터티인지 확인합니다.

1. 인증서 구성 요소
   **공개 키 (Public Key)**: 서버의 공개 키를 포함하며, 클라이언트가 데이터를 암호화하거나 신원을 확인하는 데 사용합니다.
   **인증서 서명(Signature)**: 상위 인증 기관의 개인 키로 서명하여 인증서의 무결성을 보장합니다.
   **도메인 정보**: 해당 인증서가 유효한 도메인을 포함합니다.
   유효 기간: 인증서의 만료일이 명시됩니다.
2. 인증서 알고리즘
   디지털 인증서에서 사용되는 주요 알고리즘에는 다음이 포함됩니다:

### RSA (Rivest-Shamir-Adleman):

- 가장 널리 사용되는 공개 키 암호화 알고리즘 중 하나입니다.
- 주로 서버 인증서와 클라이언트 암호화에 사용됩니다.
- TLS 1.3에서는 RSA 키 교환이 사용되지 않지만, 인증서 서명에는 여전히 사용될 수 있습니다.

### ECDSA (Elliptic Curve Digital Signature Algorithm):

- RSA보다 더 짧은 키 길이로 높은 보안을 제공합니다.
- 효율적인 키 교환과 디지털 서명에 적합하며, TLS 1.3에서 선호되는 알고리즘 중 하나입니다.

### EdDSA (Edwards-Curve Digital Signature Algorithm):

- 최신 알고리즘으로, TLS 1.3에서 도입되었습니다.
- 높은 보안성과 속도를 제공하며, Ed25519와 같은 곡선이 자주 사용됩니다. 3. 하위 인증 기관과 루트 인증서
- 루트 인증서: 신뢰 체계의 최상위 인증 기관에서 발급하는 인증서로, 클라이언트가 기본적으로 신뢰합니다.
- 중간 인증서: 루트 인증 기관이 직접 인증서를 발급하지 않고, 중간 인증 기관을 통해 서명하여 계층적인 신뢰 체계를 만듭니다.

### 요약

- TLS는 인터넷 보안을 책임지는 핵심 프로토콜로, 암호화, 인증, 무결성을 제공합니다.
- TLS 1.3은 보안 강화와 성능 개선을 위해 설계되었으며, 구식 알고리즘을 제거하고 핸드셰이크 과정을 간소화했습니다.

### 디지털 인증서는 공개 키 기반 알고리즘(RSA, ECDSA 등)을 사용하여 신뢰성을 보장합니다. TLS 1.3에서는 더욱 안전하고 효율적인 알고리즘이 사용됩니다.

- 체크섬(checksum)은 데이터 통신에서 데이터 무결성을 검증하기 위해 사용되는 기법입니다.
- 네트워크에서 데이터를 전송하는 과정에서 오류가 발생할 수 있는데, 체크섬은 이러한 오류를 감지하는 데 유용합니다.
- 아래에 체크섬의 개념, 작동 방식, 활용 사례 등을 자세히 설명하겠습니다.

1. 체크섬의 정의
   체크섬은 송신 측에서 데이터를 기반으로 특정 알고리즘을 사용해 생성된 값입니다. 이 값은 데이터를 전송할 때 함께 보내지며, 수신 측에서 동일한 알고리즘으로 데이터를 검증하여 오류를 확인합니다.

2. 체크섬의 생성과 검증 과정
   (1) 체크섬 생성 (송신 측)
   전송할 데이터를 특정 크기의 블록으로 나눕니다.
   각 블록의 값을 합산하거나 특정 연산(예: XOR, CRC 등)을 수행하여 하나의 값(체크섬)을 생성합니다.
   이 체크섬 값을 원래 데이터와 함께 전송합니다.
   (2) 체크섬 검증 (수신 측)
   수신된 데이터와 함께 전달된 체크섬 값을 분리합니다.
   수신된 데이터에 대해 동일한 알고리즘을 적용해 체크섬 값을 계산합니다.
   계산한 체크섬 값과 수신된 체크섬 값을 비교합니다.
   일치: 데이터가 손상되지 않음.
   불일치: 데이터가 전송 중 손상되었음.
3. 체크섬의 활용 사례
   (1) 네트워크 프로토콜
   IP 헤더 체크섬 (IPv4)
   IP 패킷 헤더의 무결성을 검증하기 위해 사용됩니다. 각 필드의 값을 합산한 뒤, 1의 보수 값을 계산해 체크섬으로 사용합니다. IPv6에서는 보다 강력한 오류 검출을 위해 체크섬이 사용되지 않습니다.

### TCP/UDP 체크섬

- TCP와 UDP는 데이터 페이로드와 헤더를 포함하여 체크섬을 계산합니다.
  이를 통해 애플리케이션 계층까지 전달되는 데이터의 무결성을 보장합니다.

### (2) 파일 전송

- 파일 전송 프로토콜에서 데이터가 손상 없이 전달되었는지 확인하기 위해 체크섬이 사용됩니다. 예: FTP, HTTP(S).

### (3) 저장 및 복구

- 데이터가 저장되는 동안 발생할 수 있는 손상을 감지하기 위해 체크섬이 사용됩니다. 예: RAID, 디스크 저장 시스템.

### (4) 무선 통신

- 데이터 패킷이 전송되는 도중 간섭이나 잡음으로 인해 오류가 발생했는지 검증합니다. 4. 체크섬의 종류

### (1) 단순 합산 방식

- 데이터를 일정 크기 블록으로 나누어 모든 값을 단순히 합산하여 계산. 계산 속도가 빠르지만 오류 검출 능력이 떨어질 수 있음.

### (2) XOR 방식

- 각 블록을 XOR 연산하여 결과를 생성. 단순 오류 감지에 적합.

### (3) CRC (Cyclic Redundancy Check)

- 이진 다항식으로 데이터를 나누는 방식. 오류 검출 능력이 매우 뛰어나며, 네트워크 및 저장 시스템에서 널리 사용됨.

### (4) MD5, SHA-1 등

- 암호학적 해시 함수로, 데이터를 고정 크기의 해시 값으로 변환. 데이터 변경이 민감하게 반영되지만, 체크섬보다는 보안 목적에 더 적합. 5. 체크섬의 한계
- 오류 수정 불가능

- 체크섬은 오류를 감지할 수 있지만, 데이터를 복구하거나 수정하지는 못합니다.
- 데이터 복구에는 별도의 방식(예: ECC, 리드 솔로몬 코드 등)이 필요합니다.

### 한계적인 검출 능력

- 체크섬은 데이터의 손상이 특정 방식으로 발생할 경우 감지하지 못할 수 있습니다.
- 예: 값의 교환, 특정 패턴의 오류.

### 충돌 가능성

- 서로 다른 데이터가 동일한 체크섬 값을 가질 가능성이 있으며, 이는 충돌(collision)이라고 합니다. 6. 체크섬의 장점
- 간단한 구현: 알고리즘이 간단하여 구현 및 계산 속도가 빠릅니다.
- 낮은 오버헤드: 전송 데이터에 추가되는 체크섬 값이 작아 네트워크 대역폭에 큰 영향을 미치지 않습니다.
- 오류 감지 효율성: 단순한 오류를 효과적으로 감지할 수 있습니다.

# 서브넷(Subnet)

- 서브넷은 하나의 네트워크를 더 작은 네트워크로 나누는 방식입니다.
- 서브넷을 통해 네트워크 자원을 효율적으로 관리하고, 네트워크 트래픽을 줄이며 보안을 강화할 수 있습니다.

## 서브넷의 핵심 개념

### 네트워크와 호스트 분리

- IP 주소는 네트워크 부분과 호스트 부분으로 나뉩니다.
- 서브넷 마스크는 이를 구분하는 데 사용됩니다.
- 예: 서브넷 마스크 255.255.255.0은 처음 24비트가 네트워크 부분이고, 나머지 8비트가 호스트 부분임을 나타냅니다.

### 서브넷 마스크(Subnet Mask)

- 네트워크와 호스트를 구분하는 데 사용되는 32비트 값.
- 이진수에서 1은 네트워크 부분, 0은 호스트 부분을 나타냅니다.
- 예:
- 255.255.255.0 = 11111111.11111111.11111111.00000000

### 서브넷 계산 예제

- IP 주소: 192.168.1.0
- 서브넷 마스크: 255.255.255.0
- => 네트워크에는 256개의 주소(2^8)가 포함됩니다.
- 호스트 주소: 254개 (256 - 2):
- 한 주소는 네트워크 식별, 다른 하나는 브로드캐스트 용도로 사용되므로 실제 사용 가능한 호스트는 254개입니다.
- 클래스 기반 IP 주소(Classful Addressing)
- 초기에는 IP 주소를 관리하기 위해 클래스(Classful Addressing)가 사용되었습니다. 클래스는 네트워크 크기에 따라 IP 주소를 분류합니다.

### 클래스의 구분

#### 클래스 A

- 범위: 1.0.0.0 ~ 126.255.255.255
- 서브넷 마스크: 255.0.0.0 (네트워크 부분 8비트, 호스트 부분 24비트)
- 사용 예: 대규모 네트워크 (수십만 개의 호스트 가능).

#### 클래스 B

- 범위: 128.0.0.0 ~ 191.255.255.255
- 서브넷 마스크: 255.255.0.0 (네트워크 부분 16비트, 호스트 부분 16비트)
- 사용 예: 중규모 네트워크.

#### 클래스 C

- 범위: 192.0.0.0 ~ 223.255.255.255
- 서브넷 마스크: 255.255.255.0 (네트워크 부분 24비트, 호스트 부분 8비트)
- 사용 예: 소규모 네트워크.

#### 클래스 D

- 범위: 224.0.0.0 ~ 239.255.255.255
- 사용 목적: 멀티캐스트.

#### 클래스 E

- 범위: 240.0.0.0 ~ 255.255.255.255
- 사용 목적: 연구/실험용.

### 클래스 기반의 한계

- 네트워크 크기 조정이 비효율적입니다.
- 예: 클래스 A는 너무 큰 네트워크를 할당하고, 클래스 C는 너무 작은 네트워크를 할당합니다.
- 이로 인해 IP 주소 낭비가 발생합니다.

## CIDR(Classless Inter-Domain Routing)

- CIDR는 클래스 기반의 한계를 극복하기 위해 도입된 방식으로, 네트워크 주소를 유연하게 나누고 IP 주소를 효율적으로 관리할 수 있도록 합니다.

## CIDR의 특징

### 슬래시 표기법 (Slash Notation)

- CIDR은 IP 주소 뒤에 **슬래시(/)**와 함께 네트워크 비트 수를 표시합니다.
- 예:
- 192.168.1.0/24: 네트워크 부분이 24비트이고, 호스트 부분이 8비트입니다.
- 10.0.0.0/8: 네트워크 부분이 8비트이고, 호스트 부분이 24비트입니다.

### 유연한 네트워크 크기

- 네트워크를 클래스에 의존하지 않고 필요한 크기만큼 나눌 수 있습니다.
- 예:
  25는 128개의 IP 주소를 가짐.
  26은 64개의 IP 주소를 가짐.

### IP 주소 블록 할당

- ISP는 CIDR을 사용해 고객에게 필요한 크기의 IP 주소 블록을 할당합니다.
- 예: 192.168.1.0/27은 32개의 IP 주소를 포함.

### CIDR과 서브넷팅의 차이

서브넷팅: 기존 네트워크를 더 작은 네트워크로 나눕니다.
CIDR: 새로운 방식으로 네트워크 크기를 자유롭게 정의합니다.

### 서브넷과 CIDR의 사용 사례

#### 서브넷팅

- 대규모 네트워크를 소규모 네트워크로 나누어 트래픽과 보안을 관리.
- 예: 회사 내 부서별로 독립적인 네트워크 구성.

#### CIDR

- 인터넷 서비스 제공자(ISP)가 고객에게 필요한 크기의 IP 블록을 할당.
- 예: 소규모 기업에 /29(8개 IP 주소) 제공.
