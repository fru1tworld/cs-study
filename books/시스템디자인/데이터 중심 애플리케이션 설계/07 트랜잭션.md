# 7 트랜잭션

트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 단순화하는 메커니즘으로 채택돼 왔다.

트랜잭션은 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.

## 7.1 애매모호한 트랜잭션의 개념

#### 일관성

일관성이란 단어는 굉장히 여러 의미로 쓰인다.

- 복제 일관성과 비동기식으로 복제되는 시스템에서 발생하는 최종적 일관성
- 일관성 해시는 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법이다
- CAP 정리에서 일관성이라는 단어는 선형성을 의미한다
- ACID의 맥락에서 일관성은 데이터베이스가 좋은 상태에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킨다

ACID 일관성의 아이디어는 항상 진실이어야 하는 데이터에 관한 어떤 선언이 있다는 것이다.

예를 들어 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야한다.

트랜잭션이 이런 불변식이 유효한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.

#### 지속성

지속성은 트랜잭션이 성공적으로 커밋됐다면 기록한 데이터는 손실되지 않는다는 뜻이다.

참고로 완벽한 지속성은 존재하지 않는다.

> 복제와 지속성
>
> - 데이터를 디스크에 기록하면 장비가 죽었을 때 데이터가 손실되지는 않지만 장비를 수리하거나 디스크를 다른 장비에 옮겨 달 때까지 접근할 수 없다. 복제 구성된 시스템이라면 여전히 데이터를 사용할 수 있다.
> - 연관성이 있는 결함, 예를 들어 정전이나 특정한 입력을 받을 때 모든 노드를 죽이는 버그는 한 번에 모든 복제 서버를 죽여버려서 메모리에만 저장된 데이터를 손실시킬 수 있다.
> - 비동기식으로 복제되는 시스템에서는 리더가 동작할 수 없는 상태가 되면 최근에 쓴 데이터가 손실될 수 있다.
> - 전원이 갑자기 나가면 특히 SSD에서 제공해야 하는 보장을 위반하는 사례가 종종 있었다. fsync 조차 올바르게 동작한다고 보장되지 않는다.
> - 저장 엔진과 파일시스템 구현 사이의 미묘한 상호 작용은 추적하기 어려운 버그를 유발할 수 있으며 장비가 죽은 후 디스크에 있는 파일이 오염될 수 있다.
> - 디스크에 있는 데이터는 모르는 사이에 점차적으로 오염될 수 있다. 데이터가 얼마나 오염된 상태에 있었다면 복제와 최근 백업도 오염됐을지 모른다. 이런 경우에는 과거의 백업을 써서 데이터 복원을 시도해야 한다.
> - 한 연구에서 30%에서 80% 사이의 SSD는 사용한 지 4년 이내에 적어도 하나의 배드 블록이 생긴다는 게 발견됐다 자기 하드디스크는 SSD보다 배드 섹터 비율은 낮지만 완전한 장애가 발생하는 비율은 높다.
> - SSD의 전원이 끊어지면 온도에 따라서 몇 주 내에 데이터 손실이 생기기 시작할 수 있다.
>   따라서 절대적 보장을 제공하는 한 가지 기법은 없다.

## 7.3 직렬성

### 7.3.2 2단계 잠금(2PL)

2PL two-phase locking
앞에서 더티 쓰기를 막는데 잠금이 자주 사용된다고 했다.

트랜잭션이 동시에 같은 객체에 접근하려고 하면 잠금은 나중에 쓰는 쪽이 진행하기 전에 먼저 쓰는 쪽에서 트랜잭션을 완료할 때까지 기다리도록 보장해준다.

2단계 잠금도 비슷하지만 잠금 요구사항이 훨씬 강력하다.

쓰기를 실행하는 트랜잭션이 없는 객체에 여러 트랜잭션에서 동시에 읽을 수 있다.

그러나 누군가 어떤 객체에 쓰려고 하면 독점적인 필요하다.

2PL은 쓰기 트랜잭션은 다른 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다.

스냅숏 격리는 읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다는 원칙이 있는데 이게 스냅숏 격리와 2단계 잠금의 중요한 차이이다.

#### 구현

- S-Lock, X-Lock을 모두 사용한다.

- 이렇게 락이 많이 사용되므로 데드락이 발생할 수 있다.

- Abort된 트랜잭션은 어플리케이션에서 재시도해야한다.

### 7.3.3 직렬성 스냅숏 격리

직렬성 스냅숏 격리는 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 손해가 있다.

오늘날 SSI는 단일 노드 데이터베이스와 분산 데이터베이스 모두 사용된다.

#### 비관적 동시성 제어 대 낙관적 동시성 제어

2PL은 이른바 비관적 동시성 제어 메커니즘이다.

다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 상호 배제와 비슷하다(MUTEX)

직렬 실행은 어떻게 보면 극단적으로 비관적이다.

반대로 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다.

이 맥락에서 낙관적이란 뭔가 위험한 상황이 발생할 가능성이 있을 때 트랜잭션이 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻이다.

트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지 확인한다. 만약 그렇다면 어보트되고 재시도해야 한다.

낙관적 동시성 제어는 장단점이 오랜 시간 동안 논의됐다.

경쟁이 심하면 어보트시켜야 할 트랜잭션의 비율이 높아지므로 성능이 떨어진다.

시스템이 이미 최대 처리량에 근접했다면 재시도되는 트랜잭션으로부터 발생하는 부가적인 트랜잭션 부하가 성능을 저하시킬 수 있다.

그러나 예비 용량이 충분하고 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.

경쟁은 가환 원자적 연산을 써서 줄일 수 있다.

이를테면 여러 트랜잭션이 동시에 카운터를 증가시키려고 할 때 증가 연산을 어떤 순으로 적용하는지는 관계 없다. (같은 트랜잭션에서 읽지 않는 이상) 따라서 동시에 실행되는 증가 연산들은 충돌ㅇ 없이 적용될 수 있다.

#### 뒤처진 전제에 기반한 결정

앞에서 스냅숏 격리에서 나타나는 쓰기 스큐를 설ㅇ명할 때 반복되는 패턴을 봤다.

트랜잭션이 데이터베이스에서 어떤 데이터를 읽고 그 질의 결과를 조사한 후 관찰한 결과를 기반으로 어떤 동작을 취할지 결정한다.

그러나 스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최신이 아닐 수 있다.

도중에 데이터가 변경됐을 수 있기 떄문이다.

바꿔 말하면 트랜잭션은 어떤 전제(트랜잭션을 시작할 때는 참)을 기반으로동작한다.

나중에 해당 트랜잭션이 커밋하려고 할 때 원래 데이터가 바뀌어서 그 전제가 더 이상 참이 아닐 수 있다.

데이터베이스가 어떻게 질의 결과가 바뀌었는지 알 수 있을까 ? 두 가지 상황을 고려해야 한다.

- 오래된 MVCC 객체 버전을 읽었는지 감지하기 (읽기 전에 커밋되지 않은 쓰기가 발생했음)
- 과거의 읽기에 영향을 미치는 쓰기 감ㅈ하(읽은 후 쓰기가 실행됨)

#### 오래된 MVCC 읽기 감자하기

스냅숏 격리는 MVCC로 구현한다는 점을 다시 떠올려보자,

트랜잭션으 MVCC 데이터베이스의 일관된 스냅숏에서 읽으면 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시한다.

이러한 현상을 막으려면 데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 한다.

트랜잭션이 커밋된게 있다면 트랜잭션은 어보트돼야 한다.

왜 커밋할 때까지 기다려야 할 까 ?

왜 오래된 읽기가 감지됐을 때 트랜잭션43을 바로 어보트 시키지 않을까 ?

왜냐면 읽기 전용 트랜잭션이라면 쓰기 스큐의 위험이 없으므로 어보트될 필요가 없다.

트랜잭션43이 읽기를 실행하는 시점에 데이터베이스는 그 트랜잭션이 나중에 쓰기를 실행할 지 알 수 없다.

게다가 트랜잭션 42는 어보트될 수 있고 트랜잭션이 43 커밋되는 시점에 아직 커밋되지 않았 을 수 있다.

따라서 결국에는 읽기가 오래되지 않은 것으로 밝혀질지도 모른다.

SSI는 불필요한 어보트를 피해서 일관된 스냅숏 읽기에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지한다.

#### 과거의 읽기에 영향을 미치는 쓰기 감지하기

고려해야 하는 두 번째 경우는 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 수 있다.

#### 직렬성 스냅숏 격리의 성능

어보트 비율에 따라 성능이 결정된다
