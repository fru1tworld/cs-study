# 08 분산 시스템의 골칫거리

이번 장은 분산 시스템에서 잘못될지도 모르는 것에 관한 지독하게 비관적이며 우울한 개요다.

네트워크와 시계 및 타이밍 문제를 조사하고 이것들을 어느 정도로 회피할 수 있는지 설명한다.

그리고 분산 시스템의 상태에 대해 생각하는 방법과 무슨 일이 일어났는지 추론하는 방법을 알아본다.

## 8.1 결함과 부분 장애

한 컴퓨터에서 프로그램을 작성할 때 보통 상당히 예측 가능한 방식으로 동작한다.

단일 컴퓨터에서 실행되는 소프트웨어를 믿지 못할 근본적인 이유는 없다.

하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 내는 결정적이다.

하드웨어 문제가 있으면 보통 시스템이 완전히 실패하는 결과를 낳는다.

좋은 소프트웨어가 설치된 각각의 컴퓨터는 보통 완전하게 동작하거나 전체 장애가 발생하지 그 중간 상태가 되지는 않는다.

분산 시스템에서는 시스템의 어떤 부분은 잘 작동하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것도 무리가 아니다.

이를 부분 장애라고 하고 부분 장애는 비결정적이라서 어렵다.

### 8.1.1 클라우드 컴퓨팅과 슈퍼컴퓨팅

대규모 컴퓨팅 시스템 구축 방법에 관한 몇 가지 철학이 있다.

- 대규모 컴퓨팅의 한쪽 끝에는 고성능 컴퓨팅 분야가 있다. 수천개의 CPU를 가진 슈퍼컴퓨터 등이 있다.
- 다른 극단에는 클라우드 컴퓨팅이 있다. 멀티 테넌트 데이터센터, IP 네트워크로 연결된 상용 컴퓨터, 신축적/지문식 자원 할당, 계량 결제와 흔히 관련돼 있다.
- 전통적인 기업형 데이터센터는 이 두 극단의 중간 지점에 있다.

## 8.2 신뢰성 없는 네트워크

이 책에서 다루는 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비다.

네트워크는 이 장비들이 통신하는 유일한 수단이다.

네트워크 순단을 다루는 흔한 방법은 타임아웃이다.

### 8.2.1 현실의 네트워크 결함

EC2 같은 클라우드는 일시적 네트워크 결함이 자주 발생하는 것으로 악명이 높다.

심지어 상어가 해저 케이블을 물어 뜯어서 손상시키기도 한다.

다른 놀랄 만한 결함으로 가끔 수신 패킷은 모두 누락하지만 송신 패킷은 잘 보내는 네트워크 인터페이스가 있다.

네트워크 링크가 한 방향으로 동작한다고 해서 반대 방향도 동작하리라고 보장되는 것은 아니다.

> 네트워크 분단
> 네트워크 결함 때문에 네트워크 일부가 다른 쪽과 차단되는 것을 네트워크 분단이나 네트워크 분리라고 부른다.
> 이 책은 일반적인 용어인 네트워크 결함를 사용하곘다.

꼭 네트워크 결함을 견뎌내도록 처리할 필요는 없다.

평상시 잘 동작한다면 사용자에게 그냥 오류 메시지를 보여주는 것도 타당한 방법이다.

그러나 소프트웨어가 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다.

고의로 네트워크 문제를 유발하고 시스템의 반응을 테스트하는 것은 일리가 있다. (카오스 몽키)

### 8.2.2 결함 감지

많은 시스템은 결함이 있는 노드를 자동으로 감지할 수 있어야 한다. 예를 들어

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다. (즉, 죽은 노드는 순번에서 빠찐 것으로 간주해야 한다.)
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.

불행하게도 네트워크에 관한 불확실성 때문에 노드가 동작 중인지 아닌지 구별하기 어렵다.

- 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 운영체제가 친절하게 RST 나 FIN 패킷을 응답으로 보내서 TCP 연결을 닫거나 거부한다. 그러나 노드가 요청을 처리하다 죽었따면 원격 노드에서 데이터가 실제로 얼마나 처리됐는지 알 방법이 없다.
- 노드 프로세스가 죽었지만 노드의 운영체제는 아직 실행 중이라면 스크립트로 다른 노드에게 프로세스가 죽었따고 알려서 다른 노드가 타임아웃되기를 기다릴 필요 없이 빠르게 역할을 넘겨받을 수 있게 할 수 있다. (예를 들어 HBase)
- 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근할 수 있으면 질의를 보내 하드웨어 수준의 링크 장애를 감지할 수 있다. 인터넷을 통해 연결하거나 스위치 자체에 대한 접근을 할 수 없는 경우 공용 데이터센터를 사용하거나 네트워크 문제 때문에 관리 인터페이스에 연결할 수 없다면 이 선택지는 배제된다.
- 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP 패킷으로 응답할 수 있따. 그러나 라우터가 마법 같은 장애 감지 능력이 없다면 네트워크의 다른 참여자들과 동일한 제한이 적용된다.

원격 노드가 다운되고 빠른 피드백은 유용하지만 여기에 의존할 수 없다 TCP에 ack를 받더라도 애플리케이션이 그것을 처리하기 전에 죽을 수도 있다.

요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야한다.

역으로 뭔가 잘못되면 스택의 어떤 수준에서 오류 응답을 받을지도 모르지만 일반적으로 아무 응답도 받지 못할 것이라고 가정해야 한다.

### 8.2.3 타임아웃과 기약 없는 지연

타임아웃이 확실한 수단이라면 얼마나 길어야 할까 ?

길면 기다리는 시간이 길어지고 짧으면 결함은 빨리 발견하지만 멀쩡한 노드가 죽었다고 잘못 선언할 경우가 높아진다.

대부분은 어떤 것도 보장하지 않아서 기약 없는 지연도 있다.

그래서 대부분 어떤 최대 시간 내에 요청을 처리한다고 보장할 수 없다.

시스템 대부분의 시간이 빠르다는 것은 장애 감지에 충분치 않다.

타임아웃이 낮으면 왕복 시간이 순간적으로 급증하기만 해도 시스템의 균형을 깨뜨린다.

응답 시간과 그들의 변동성을 측정하고 타임아웃을 자동으로 조절하게 하는 것이다.

파이 증가 장애 감지기를 쓰면 된다.

TCP 재전송 타임아웃도 비슷하게 동작한다.

### 8.2.4 동기 네트워크 대 비동기 네트워크

패킷 전송 지연 시간의 최대치가 고정돼 있고 패킷을 유실하지 않는 네트워크에 기댈 수 있다면 분산 시스템은 훨씬 더 단순했을 것이다.

전화 네트워크에서 통화를 할 때는 회선이 만들어진다.

이런 종류의 네트워크는 동기식이다.

그래서 큐 대기가 없으므로 네트워크 종단 지연 시간의 최대치가 고정돼 있다.

이를 제한 있는 지연이라고 한다.

#### 네트워크 지연을 예측 가능하게 만들 수는 없을까 ?

전화 네트워크의 회선은 TCP 연결과 매우 다르다는 점을 주목하기 바란다.

왜 데이터센터 네트워크와 인터넷은 패킷 굫놔을 사용할까 이들은 순간적으로 몰리는 트래픽에 최적화됐기 때문이다.

회선은 통화를 하는 동안 보내는 초당 비트 개수가 상당히 고정돼 있는 음성과 영상 통화에 적합하다.

반면 웹 페이지 요청 이메일 전송 파일 전송은 특별한 대역폭 요구사항이 없다.

#### 결론

현재 배포된 기술로는 네트워크의 지연과 신뢰성에 대해 어떤 보장도 할 수 없다 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 것이라고 가정해야 한다. 결과적으로 타임아웃에 올바른 값은 없으며 실험을 통해 결정해야 한다.

## 8.3 신뢰성 없는 시계

시계와 시간은 중요하다

지속 시간을 측정하거나, 시점(특정 날짜의 특정 시간에 발생한 이벤트)가 있다.

분산 시스템에서는 통신이 즉각적이지 않으므로 시간은 다루기 까다롭다.

메시지가 네트워크를 거쳐서 한 장비에서 다른 장비로 전달되는데 시간이 걸린다.

메시지를 받은 시간은 항상 보낸 시간보다 나중이지만 네트워크의 지연의 변동성 때문에 얼마나 나중인지 알 수 없다.

게다가 네트워크에 있는 개별 장비는 자신의 시계를 가지고 있다.

이 장치는 완벽히 정확하지는 않아서 각 장비는 자신만의 시간 개념이 있으며 이는 다른 장비보다 약간 빠를 수도 느릴 수도 있다.

### 8.3.1 단조 시계 대 일 기준 시계

현대 컴퓨터는 최소 두 가지 종류의 시계를 갖고 있다.

일 기준 시계와 단조 시계다.

#### 일 기준 시계

일 기준 시계는 직관적으로 시계에 기대하는 일이다. 벽 시간이라고도 한다. 예를 들어 리눅스와 자바는 epoch 이래로 흐른 초를 반환한다. 윤초는 세지 않으며 에포크는 UTC 1970-1-1 자정을 가리킨다. 일 기준 시계는 보통 NTP(Network Time Protocol)로 동기화된다.

한 장비의 타임스탬프는 다른 장비의 타임스탬프와 동일한 의미를 지닌다는 뜻이다.

그러나 로컬 시계가 NTP 서버보다 너무 앞서면 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보일 수 있따.

이런 뜀은 윤초를 종종 무시한다는 사실과 일 기준 시간이 경과 시간을 측정하는 데는 적합하지 않게 만든다.

일 기준 시계는 역사적으로 매우 거친 해상도를 가진다.

예를 들어 윈도우 시스템에서는 10ms 단위로 흐른다.

#### 단조 시계

단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간을 재는 데 적합하다.

단조 시계는 항상 앞으로 흐른다는 사실에서 나왔다.

한 시점에서 단조 시계의 값을 확인하고 어떤 일을 한 후 나중에 다시 시계를 확인할 수 있다.

두 값 사이의 차이로 두 번의 확인 사이에 시간이 얼마나 흘렀는지 알 수 있다.

그러나 시계의 절대적인 값은 의미가 없다.

컴퓨터가 시작한 이래 흐른 나노초 수일 수도 있고 비슷한 어떤 것일 수도 있다.

특히 두 대의 다른 컴퓨터에서 나온 단조 시계 값을 비교하는 것은 의미가 없다.

이들은 동일한 것을 의미하지 않기 때문이다.

예를 들어 여러 개의 CPU 소켓이 있는 경우 서버는 CPU 마다 독립된 타이머가 있을 수 있다.

NTP는 컴퓨터의 로컬 시계까 NTP 서버보다 빠르거나 느리다는 것을 발견하면 단조 시계가 진행하는 진도수를 조정할 수 있다. (시계를 돌린다고 한다. )

기본적으로 NTP는 시계 속도를 0.05%까지 올리거나 내리는 것을 허용하지만 단조 시계가 앞이나 뒤로 뛰게 할 수는 없다.

단조 시계 해상도는 보통 상당히 좋다.

대부분의 시스템에서 시간 구간을 마이크로초나 그 이하의 단위로 측정할 수 있다.

따라서 분산 시스템에서 경과 시간을 재는데 단조 시계를 쓰는 것은 일반적으로 괜찮다.

### 8.3.2 시계 동기화와 정확도

단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞춰 설정돼야 유용하다.

유감스럽게도 시계가 정확한 시간을 알려주게 하는 방법은 기대만큼 신뢰성이 있거나 정확하지도 않다.

예시는 다음과 같다.

- 윤초가 발생하면 1분의 길이가 59초나 61초가 되어 윤초를 고려하지 않고 설계된 시스템에서는 시간에 관한 가정이 엉망이 된다. 현실에서 실제 NTP 서버의 동작은 다양하지만 최선의 방법은 윤초 조정을 하루에 걸쳐서 서서히 수행함으로써 NTP 서버가 거짓말을 하게 하는 것일 수 있다(문지름이라 한다.)
- 가상 장비에서 하드웨어 시계는 가상화돼서 정확한 시간 엄수가 필요한 애플리케이션에게 추가적인 어려움이 생긴다. CPU 코어가 가상 장비 사이에서 공유될 때 각 VM은 다른 VM이 수행되는 동안 수십 밀리초 동안 멈춘다. 애플리케이션 관점에서 이 중단은 시계까 갑자기 앞으로 뛰는 문제로 나타난다.

### 8.3.3 동기화된 시계에 의존하기

#### 이벤트 순서화용 타임스탬프

### 8.3.4 프로세스 중단

## 8.4 지식, 진실, 그리고 거짓말

### 8.4.1 진실은 다수결로 결정된다.

### 8.4.2 비잔틴 결함

### 8.4.3 시스템 모델과 현실
