1. 소켓을 작성한다.
2. 서버에 접속한다.
3. 데이터를 송수신한다.
4. 서버에서 연결을 끊어 소켓을 말소한다.
5. IP와 이더넷의 패킷 송수신 동작
6. UDP 프로토콜을 이용한 송수신 동작

# .1 소켓을 작성한다.

### .1.1 프로토콜 스택의 내부 구성

OS에 내장된 네트워크 제어용 소프트웨어(프로토콜 스택)와 네트워크용 하드웨어(LAN 어댑터)를 알아본다.

TCP/IP 소프트웨어는 계층구조로 위의 계층이 아래의 계층에 작업을 의뢰하도록 되어있다.

네트워크 애플리케이션 (웹 브라우저, 메일러, 웹 서버, 메일 서버등)

Socket 라이브러리[리볼버 내장]

프로토콜 스택( TCP, UDP , IP)

LAN 드라이버

LAN 어댑터

OS의 내부에는 프로토콜 스택이 있다.

윗부분에는 TCP 라는 프로톸로을 사용하여 데이터 송수신을 담당하는 부분과 UDP라는 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 있으며 이 둘이 애플리케이션에서 보낸 의뢰를 받아 데이터 송수신을 동작을 실행한다

브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송수신하는 경우에는 TCP

DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송수신할 경우에는 UDP

그 아래에는 IP 프로토콜을 사용하여 패킷 송수신 동작을 제어하는 부분이 있으며, 패킷이라는 형태로 운반을 하는데 패킷을 통신 상대까지 운반하는 역할이 IP의 주 역할이다.

그리고 IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 포함되어 있다.

**ICMP :** 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지

**ARP** : IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용한다.

**MAC 주소** : (IEEE에서 표준화된 LAN 방식의 기기는 모두 같은 형식의 주소를 사용하고 이 주소를 MAC 주소라한다.

IP의 아래에 있는 LAN 드라이버는 LAN 어댑터의 하드웨어를 제어한다. 그리고 그 아래에 있는 LAN 어댑터가 실제 송 수신 동작 즉 케이블에 대해 신호를 송수신하는 동작을 실행한다.

### 02 소켓의 실체는 통신 제어용 정보

프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록한다.

대표적으로 IP 주소, 포트 번호 , 통신 동작이 어떠 진행 상태에 있는가 하는 것이다.

본래 소켓은 개념적인 것이어서 실체가 없으므로 굳이 말하면 이 제어 정보가 소켓의 실체라고 할 수 있다.

프로토콜 스택은 소켓에 기록된 제어 정보를 참조하며 움직인다.

### 03 Socket을 호출했을 때의 동작

TCP가 처음으로 담당하는 일은 소켓을 만드는 단계이다.

소켓을 만들 때 한 개의 메모리 영역을 확보하고 초기 상태라는 것을 이 영역에 기록한다.

소켓이 만들어지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.

디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송 수신을 동작을 의뢰할 때 디스크립터를 통지한다.

그리고 그것이 어떤 상태로 있는지 등의 정보가 전부 기록되어 있으므로 디스크립터가 어느 소켓인지를 나타내면 필요한 정보는 전부 프로토콜 스택쪽에서 알 수 있기때문에 통신 상대의 정보를 애플리케이션에서 일일이 통지받을 필요가 없다.

# 서버에 접속한다.

### 01 접속의 의미

소켓을 만들면 애플리케이션은 connect를 호출한다.

그러면 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속한다.

socket을 호출하여 소켓을 만드는 동작만으로 프로토콜 스택에는 아무 것도 전달되지 않기 때문에 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데 이것이 접속 동작의 한가지 역할이다.

서버측에도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지이므로 클라이언트에서 ip주소와 포트 번호, 데이터 송수신 여부를 알려서 통신하려는 클라이언트가 있다는 것을 서버측에 전달한다.

이와 같이 클라이언트 측에서 서버측에 통신 동작의 개시를 전달하는 것도 접속 동작의 역할 중 하나이다.

접속의 동작의 첫 번째는 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것이다.

IP 주소, 포트번호를 구체적인 예이다.

데이터 송수신 동작을 실행할때에 송수신하는 데이터를 일시적으로 저장하는 메모리 영역이 필요한데 이 메모리 영역을 버퍼 메모리라고 한다.

버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 ‘접속’한다는 동작의 의미이다.

### 02 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.

제어 정보에는 크게 나누어 두 종류가 있다.

하나는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보이다. 이것은 데이터를 송수신하는 동작이나 연결을 끊는 동작도 포함하여 어떤 정보가 필요한지 검토하여 내용을 TCP 프로토콜의 사양으로 규정하고 있다.

이 제어 정보를 패킷의 맨 앞 부분에 배치하는 곳부터 헤더라고 부른다.

이 경우에는 TCP 헤더, 이더넷 헤더, IP 헤더와 같이 무엇의 헤더인지를 알 수 있도록 써야한다.

제어 정보는 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보가 더 있다.

여기에는 애플리케이션에서 통지된 정보 통신 상대로부터 받은 정보 등이 수시로 기록된다.

송수신 동작의 진행 상황 등도 수시로 기록되고, 프로토콜 스택은 하나하나 차례로 정보를 참조하면서 움직인다.

그러므로 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화되어 있다고 해도 좋다.

소켓에 기록한 제어 정보는 상대측에서 볼 수 없다 왜냐하면 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면 그것으로 클라이언트와 서버가 서로 연락을 취하기 때문이다.

예를 들어 내부 구조가 다른 윈도우와 리눅스는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다를 것이지만 양자가 문제 없이 통신할 수 있으며, 컴퓨터와 휴대전화로 통신할 때도 마찬가지이다.

소켓에 기록한 제어 정보는 프로토콜 스택을 만드는 사람에 따라서 달라지므로 간단히 설명할 수 없다.

그러나 소켓의 제어 정보 중에서 중요한 것은 명령에 의해 표시할 수 있는데 이것은 어느 OS의 프로토콜 스택에도 공통이다.

통신 동작에 이용하는 제어 정보는 다음의 두 종류이다.

- 헤더에 기입되는 정보
- 소켓에 기록되는 정보

### 03 접속 동작의 실제

Socket 라이브러리의 connect를 호출하는 곳으로 시작된다.

여기에 서버측의 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.

TCP 담당 부분은 IP 주소로 표시된 상대 즉 서버의 TCP 담당 부분 사이에 제어 정보를 주고 받는다.

먼저 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만든다.

헤더에는 다수의 항목이 있는데 중요한 것은 **송수신처**와 수신처의 **포트 번호**이다.

접속해야 하는 소켓이 어느 것인지 확실히 하고 컨트롤 비트인 SYN이라는 비트를 1로 만든다.

요약하면

접속 동작의 첫 걸음은 TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만드는 것이다.

그리고 TCP 헤더의 송수신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다.

TCP 헤더를 만들면 이것을 IP 담당 부분에 건네 송신되도록 의뢰

IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다.

접속을 기다리는 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당 소켓이다.

해당 소켓이 발견되면 여기에 필요한 정보를 기록하고 접속 동작이 진행 중이라는 상태가 된다.

클라이언트와 마찬가지로 송신처와 수신처의 포트번호나 SYN 비트 등을 설정한 TCP 헤더를 만든다.

그리고 응답을 돌려보낼 때 ACK 라는 컨트롤 비트도 1로 만든다.

네트워크에는 오류가 있을 수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작이 진행된다.

패킷이 도착한 것을 확인하면서 동작을 진행하는데 이것을 확인하기 위해 ACK 비트를 1로 만드는 것이다.

그리고 TCP 헤더를 IP 담당 부분에 건네주어 클라이언트에 반송하도록 의뢰한다.

패킷이 클라이언트에 돌아오고 IP 담당 부분을 경유하여 TCP 담당 부분에 도착한다.

SYN이 1이면 성공이므로 소켓에 서버 IP 주소나 포트 번호 등과 함꼐 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.

이로써 클라이언트측은 끝나지만 먼저 서버가 응답을 돌려보낼 때 ACK 비트를 1로 만들었는데 이것과 같이 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송한다.

이로써 소켓은 데이터를 송수신할 수 있는 상태가 되고 이런 작업을 커넥션이라고 한다.

커넥션은 데이터 송수신 동작을 계속하고 있는 동안 close를 호출하여 연결을 끊을 때까지 계속 존재한다.

이렇게 커넥션이 이루어지면 프로토콜 스택의 접속 동작이 끝난다.

# 데이터를 송수신한다.

### 01 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.

connect에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어간다.

이 동작은 애플리케이션이 write를 호출하여 송신 데이터를 프로토콜 스택에 건제누는 곳부터 시작된다.

프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장한다.

어느 정도까지 저장한 후 송신 동작을 할 지는 OS의 종류나 버전에 따라 달라지므로 한 마디로 말할 수 없지만 다음과 같은 요소를 바탕으로 판단한다.

- 한 패킷에 저장할 수 있는 데이터의 크기

프로토콜 스택은 MTU라는 매개변수를 바탕으로 판단한다.

**MTU** : 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이로 이더넷에서는 보통 1,500바이트가 된다.

MTU에는 헤더가 포함되어 있으므로 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 최대 길이가 되고 이것을 **MSS**라고 한다.

애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신 동작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.

- 타이밍

애플리케이션의 송신 속도가 느려지는 경우 MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야한다.

따라서 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신한다.

판단 요소는 두 가지이지만 전자를 중시하면 패킷 길이가 길어져서 네트워크의 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신이 지연될 우려가 있다.

반대로 후자를 중시하면 지연은 적어지지만 이용 효율이 떨어지므로 양자를 절충해서 적당한 시간을 가늠하여 송신 동작을 실행해야한다.

이와 같이 프로토콜 스택에만 맡긴다면 좋지 않은 일이 생길 수 있으므로 애플리케이션 측에서 송신의 타이밍을 제어하는 여지도 남겨두었다.

### 02 데이터가 클 때는 분할하여 보낸다

HTTP 리퀘스트 메시지는 보통 그다지 길지 않으므로 한 개의 패킷에 들어가지만, 폼을 사용하여 긴 데이터를 보낼 경우 한 개의 패킷에 들어가지 않을 만큼 긴 것도 있다.

이 경우 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 있다.

MSS의 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어 송신한다.

이렇게 조각의 모습을 가늠하여 송신하면 TCP 헤더를 부가한다. 그리고 소켓에 기록되어있는 제어 정보를 바탕으로 송신처 포트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고 IP 담당 부분에 건네주어 송신 동작을 실행한다.

### 03 ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 송신한 후에는 확인 동작으로 넘어간다.

조각으로 분할한 경우 통신 개시부터 따져서 몇 번째 바이트에 해당하는지 세어둔다. 그리고 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데 **시퀀스 번호**라는 항목에 해당한다.

데이터의 크기도 수신측에 전달하지만 여기에서는 헤더에 기록하여 수신측에 알리지 않고 패킷 전체의 길이에서 헤디 길이를 빼면 데이터의 크기를 계산할 수 있으므로 이 방법에 따라 크기를 산출한다.

이렇게 하면 수신측에서 패킷이 누락되었는지 확인할 수 있다.

누락이 없는 것을 확인하면 수신측은 그 이전에 수신한 데이터와 합쳐서 데이터를 몇 번째 바이트까지 수신한 것인지 계산하고 그 값을 TCP 헤더의 **ACK** 번호에 기록하여 송신측에 알려준다.

이 ACK 번호를 되돌려주는 동작을 수신 확인 응답이라고 부르며 송신측은 이것을 통해 상대가 어디까지 수신했는지 파악한다.

실제로 이 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다.

앞서 SYN이라는 제어 비트를 1로 하여 서버에 보내는 장면이 있는데 그것이 초기값을 통지하는 것을 나타낸다.

사실 SYN에 1을 설정할 때 시퀀스 번호에도 값을 설정하게 되어 있어 시퀀스 번호의 값이 초기값을 나타낸다

이것이 시퀀스 번호와 ACK 번호를 사용한 확인 방법의 개념이다.

실제 동작은 다음과 같다.

시퀀스 번호의 초기값을 클라이언트에서 산출하여 서버로 보낸다.

그러면 초기값으로부터 ACK 번호를 산출하여 클라이언트에 반송한다.

이때 서버에서 클라이언트에서 보내는 데이터에 관한 시퀀스 번호의 초기값을 서버에서 산출하여 이 값도 함께 클라이언트에 통지한다.

그러면 클라이언트에서도 서버와 마찬가지로 받은 시퀀스 번호의 초기값으로부터 ACK 번호를 산출하여 서버에 반송한다.

이로써 시퀀스 번호와 ACK 번호가 준비되었으므로 데이터 송수신 동작에 들어간다.

데이터 송수신 동작은 본래 양방향으로 데이터를 보낼 수 있지만, 웹의 경우 최초에 클라이언트에서 서버로 메시지를 보낼 것이고, 데이터와 함께 시퀀스 번호를 보낸다.

그러면 데이터를 수신한 서버에서 ACK 번호를 반송한다.

서버에서 클라이언트에 데이터를 보내는 경우에는 그 반대가 된다.

TCP는 이 방법으로 상대가 데이터를 받은 것을 확인하는데 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해둔다.

그리고 송신한 데이터에 대응하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 보낸다.

이 구조는 수신 측에 패킷이 올바르게 도착한 것을 확인하고 도착하지 않으면 다시 보내므로 네트워크의 어디에서 오류가 발생했더라도 그것을 전부 검출하여 회복 처리를 취할 수 있다.

반대로 구조가 이렇기 때문에 다른 곳에서 오류를 회복 조치할 필요가 없다.

이 때문에 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 취하지 않는다.

오류를 검출하면 그 패킷을 버리기만 하면 되는데 애플리케이션도 마찬가지이다.

TCP에 맡겨두면 오류가 발생해도 데이터가 문제 없이 상대에게 도착하므로 애플리케이션의 송신 동작은 송신한채로 끝난다.

단 도중에 케이블이 분리되거나 서바가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않는 경우가 있는데 한 없이 다시 보내면 곤란하므로 TCP는 몇 번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

### 04 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

이것이 기본이지만 실제 오류 검출과 회복의 원리는 꽤 복잡하기 때문에 요점이 되는 부분만 설명하면

먼저 ACK 번호가 돌아오는 것을 기다리는 시간을 타임아웃 값이라 한다.

네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연되므로 이것을 예측하여 대기 시간을 어느 정도 길게 설정해야한다.

그러지 않으면 ACK 번호가 돌아오기 전에 다시 보내야하는 사태가 된다.

이 소모적인 다시 보내기는 단순히 낭비로만 끝나지는 않는다.

ACK 번호의 반송이 지연되도록 한 사태는 혼잡이 원인인 경우가 많으므로 거기에 헛된 패킷을 보내면 혼잡이 악화된다.

그렇다고 대기 시간이 긴 쪽은 속도 저하의 원인이 되기 때문에

대기 시간은 너무 짧지도 길지도 않은 적절한 값으로 설정해야 하는데 이것은 간단하지가 않다.

서버가 가까운지 먼지에 따라 ACK 번호가 돌아오는 차이가 크고 정체시의 지연도 가미하여 생각해야 하기 때문이다.

사내 LAN 이라면 수 밀리초 안에 돌아오지만 인터넷의 경우는 혼잡하면 수백 밀리초를 넘는 경우도 있다.

이렇게 차이가 크다면 대기 시간을 일정하게 설정하는 방법은 적절하지 않다.

그래서 TCP는 동적으로 대기 시간을 변경하는 방법을 취하고 있다.

ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단한다

### 05 윈도우 제어 방식을 효율적으로 ACK 번호를 관리한다.

ACK 번호가 돌아올때까지 아무 일도 하지 않고 기다리는 것은 시간 낭비이므로 TCP는 윈도우 제어라는 방식에 따라 송신과 ACK 번호 통지의 동작을 실행한다.

윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 복수의 패킷을 보내는 방법으로 ACK 번호가 돌아올 때까지 시간이 낭비되지 않는다.

그렇지만 주의할 점이 핑퐁 방식이라면 수신측은 수신 처리가 끝난 후 ACK 번호를 돌려보내고 ACK 번호를 받고 나서 송신측이 다음 패킷을 보내므로 수신측의 능력을 초과하여 패킷을 보내는 일은 없다.

그러나 ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 사태가 일어날 수 있다.

구체적으로 수신측의 TCP는 패킷을 수신하면 일단 수신용 버퍼 메모리에 데이터를 일시 보관한다.

수신측에서는 ACK 번호를 계산하거나 조각을 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주어야 한다.

따라서 처리가 끝나지 않은 상태에서 다음 패킷이 도착해도 곤란하지 않도록 수신 버퍼를 설치하고 여기에 수신된 데이터를 일시보관하는 것이다.

그런데 애플리케이션에 건네주는 속도보다 빠른 속도로 데이터가 도착하면 수신 버퍼에 데이터가 차곡차곡 쌓여서 넘쳐버린다. 넘친 데이터는 없어져 버리므로 패킷이 도착해도 오류가 발생한 것처럼 되는데

이것은 수신측의 능력을 초과한다는 의미이다.

이 사태는 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 수신측은 이 양을 초과하지 않도록 송신 동작을 실행하는데 이것이 윈도우 제어 방식의 개념이다.

TCP 헤더의 윈도우 필드에서 이것을 송신측에 알린다.

실제 동작은 시퀸스 번호 및 ACK 번호와 같이 양방향 대화가 된다. 또한 수신 가능한 데이터 양의 최대값을 윈도우 사이즈라고 부르며 TCP를 정밀 조정하는 매개변수의 하나로 알려져 있다.

### 06 ACK 번호와 윈도우를 합승한다.

송수신 동작의 효율성을 높이기 위해 ACK 번호와 윈도우를 통지하는 타이밍을 고려해야한다.

만약 이것을 따로 보낸다면 어떤 일이 발생하는가

윈도우 통지의 동작은 수신 데이터가 수신 버퍼에 보관되면 윈도우를 하나하나 차례대로 수신측에 통지할 필요가 없다.

윈도우의 값은 송신측이 데이터를 송신할 때마다 송신한 데이터만큼 감산하여 스스로 산출할 수 있기 때문이다.

윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때이다.

이 동작은 수신측의 애플리케이션에서 보낸 의뢰가 계기가 되어 일어나므로 언제 일어날지 송신측에서 알 수 없다.

그러므로 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때 이것을 송신측에 통지해야 하는데 이것이 윈도우 통지의 타이밍이다.

ACK 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보낸다.

즉 데이터를 수신한 후 즉시 보낸다고 생각하면 된다.

이 두 가지를 조합해보면 송신측에서 보낸 데이터가 수신측에 도착하여 수신 동작이 정상적으로 완료되었을 때 ACK 번호를 송신측에 통지하고 잠시 후 데이터를 애플리케이션에 건네주었을 때 윈도우를 송신측에 통지하는 상태가 된다. 본래의 개념을 그대로 실현하면 데이터의 패킷을 수신할 때마다 ACK 번호 통지와 윈도우 통지의 패킷이 하나씩 따로따로 송신측에 보내진다. 이렇게 해서는 수신측에서 송신측에 보내는 패킷이 많아져 효율이 저하된다.

수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다.

이렇게 기다리는 사이에 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보낸다.

예를 들어 ACK 번호 송신을 대조할 때 윈도우 통지가 일어나면 ACK 번호와 윈도우를 한 개의 패킷에 합승시켜서 통지하여 패킷의 수를 줄일 수 있다.

복수의 ACK 번호 통지가 일어난 경우에도 ACK 번호는 데이터를 어디까지 받았는지 즉 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK번호가 연속해서 일어나면 최후의 것만 통지하여 도중의 것은 생략해도 상관이 없다.

윈도우 통지가 연속된 경우도 마찬가지로 애플리케이션에 데이터를 건네주는 동작이 연속해서 일어나고 수신 버퍼의 빈 영역이 점점 늘어나고 있는 상황이라고 할 수 있다. 이 경우에도 ACK 번호와 마찬가지로 도중을 생략하고 최후의 것만 통지하면 된다.

### 07 HTTP 응답 메시지를 수신한다.

브라우저의 의뢰를 받아 프로토콜 스택이 HTTP 리퀘스트 메시지를 보내는 일련의 동작은 이것으로 끝이지만

HTTP 리퀘스트 메시지를 보내면 웹 서버에서 응답 메시지가 돌아오기를 기다리고 응답 메시지가 돌아오면 그것을 수신한다.

이 떄의 프로토콜 스택의 동작은 웹 서버에 액세스하는 동작을 차례대로 추적한다는 탐험 여행의 취지에 따라 설명한다.

브라우저는 리퀘스트 메시지를 송신해달라고 의뢰하고, 이것이 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다.

데이터를 수신할때도 데이터를 송신할 때와 마찬가지로 데이터를 일시 보고나하는 수신 버퍼를 사용하므로 여기에서의 동작은 다음과 같이 될 것이다.

먼저 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네준다.

이때 리퀘스트 메시지의 송신을 완료하고 나서 얼마 안 된 시점이라면 아직 응답 메시지가 돌아오지 않았을 것이다.

응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 수신 버퍼에 데이터가 들어가지 않을 것이다.

이 상태에서는 더이상 작업을 진행할 수 없다.

그래서 프로토콜 스택은 의뢰받은 작업,즉 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는 작업을 잠시 보류한다.

정리 :

수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 도중에 데이터가 누락되었는지 검사하고, 문제가 없으면 ACK 번호를 반송한다. 그리고 데이터 조각을 수신 버퍼에 일시 보관하고, 조각을 연결하여 데이터를 원래 모습으로 복원 후 애플리케이션에 건네준다.

구체적으로는 수신 데이터를 애플리케이션이 지정한 메모리 영역에 옮겨 기록한 후 애플리케이션에 제어를 되돌려준다.

그리고 애플리케이션에 데이터를 건네주고 나서 타이밍을 가늠하여 윈도우를 송신측에 통지한다.

# .4 서버에서 연결을 끊어 소켓을 말소한다.

## .4.1 데이터 보내기를 완료했을 때 연결을 끊는다.

데이터 송수신을 종료한다는 것은 애플리케이션이 송신해야 하는 데이터를 모두 송신 완료했다고 판단했을 때이다.

그러면 송신을 완료한 측이 연결 끊기 단계로 들어가는데 어디에서 끝나는지 애플리케이션에 따라 다르다.

예를 들어 웹이라면 브라우저에서 웹 서버에 리퀘스트 메시지를 보내고, 서버가 이것에 응답하여 응답 메시지를 반송 완료하면 데이터 보내기가 완료된 것이다.

이 경우 서버측이 연결 끊기 단계에 들어간다.

데이터 보내기를 완료한 쪽에서 연결 끊기 단계에 들어가는데, 여기에서는 서버측에서 연결 끊기 단계에 들어가는 것을 간주하고 설명한다.

이 경우 서버측의 애플리케이션이 먼저 Socket 라이브러리의 close를 호출한다.

그러면 서버측의 프로토콜 스택이 TCP 헤더를 만들고 여기에 연결 끊기를 나타내는 정보를 설정한다.

구체적으로는 컨트롤 비트의 FIN 비트에 1을 설정하고 IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 한다.

이와 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.

다음은 클라이언트 측이다. 서버에 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록한다.

그리고 FIN을 1로 설정한 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고 이 것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다린다.

잠시 후 애플리케이션이 read를 호출하여 데이터를 가지러 올 것이다.

그러고 나면 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신완료햇다는 사실을 클라이언트측의 애플리케이션에게 알린다.

웹의 동작은 서버가 응답을 반송하면 끝나도록 규칙이 정해져 있으므로 데이터를 전부 수신 완료하면 클라이언트도 종료한다.

그래서 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송수신 동작을 끝낸다.

### .4.2 소켓을 말소한다.

### .4.3 데이터 송 수신 동작을 정리한다.

## IP와 이더넷의 패킷 송수신 동작

## UDP 프로토콜을 이용한 송수신 동작
