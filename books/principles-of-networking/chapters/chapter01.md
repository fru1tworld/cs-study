1. HTTP 리퀘스트 메시지를 작성한다.
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다.
3. 전 세계의 DNS 서버가 연대한다.
4. 프로토콜 스택에 메시지 송신을 의뢰한다.

# 01 HTTP 리퀘스트 메시지를 작성한다.

### 1 URL 입력부터 시작한다.

URL은 ftp: file: mailto: 등 여러가지가 있을 수 있음

웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많지만 그 외에도 파일을 다운로드/업로드하는 FTP의 클라이언트 기능이다 메일의 클라이언트 기능도 갖고 있음

모든 URL은 http: , ftp: 등 액세스하는 방법을 나타낸다. 액세스할 때의 프로토콜 종류가 쓰여있음

### 2 브라우저는 URL을 해독한다.

http: + // + [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) + / + dir1 + / + file1.html

http : 프로토콜

“//” :나중에 이어지는 문자열이 서버의 이름임을 나타냄

[‘/’ 디렉토리명 ‘/’ 파일] : 생략가능함

### 3 파일명을 생략한 경우

**(a) http:/www.lab.cyber.co.kr/dir/**

dir 뒤 파일명을 생략한 경우 서버 측에서 index.html 또는 default.html 등의 파일을 따로 설정함 해당 파일에 액세스함

**(b) http:/www.lab.cyber.co.kr/**

끝에 ‘/’ 가 있으므로 / 라는 디렉토리( ‘/’ 만 쓰면 루트 디렉토리)가 지정된 것으로 /indext.html /default.html 이라는 파일에 액세스함

**(c) http:/www.lab.cyber.co.kr**

경로명이 아무 것도 없는 경우에는 루트 디렉토리의 아래에 있는 미리 설정된 파일 (홈페이지)에 액세스됨

(**d) http:/www.lab.cyber.co.kr/whitisthis**

끝에 /가 없으므로 파일로 볼 수 있으나 디렉토리의 끝의 있는 / 를 생략할 수 있다 따라서 파일 혹은 디렉토리로 찾아서 본다. \*같은 이름을 가진 파일과 디렉토리를 둘 다 만들 수 없으므로 가능함

### **4 HTTP의 기본 개념**

URL 을 해독하면 어디에 액세스를 해야할지 판명된다. 그 후 브라우저는 HTTP 프로토콜을 사용하여 웹 서버에 액세스한다.

HTTP프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이지만 기본 개념은

클라이언트에서 서버를 향해 리퀘스트 메시지를 보낸다.

리퀘스트 메시지에는 ‘무엇을’ ‘어떻게 해서’ 라는 내용이 있는데 ‘무엇을’에 해당하는 것이 URI 이라 하는데, 보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일명을 URI 로 쓴다.

\*CGI 프로그램

웹 서버 소프트웨어에서 프로그램을 호출할 때의 규칙을 정한 것이 CGI 이며 CGI 규칙에 맞게 움직이는 프로그램을 CGI 프로그램이라한다.

‘어떻게 해서’에 해당하는 것이 메소드로 메소드에 의해 웹 서버에 어떤 동작을 하고 싶은지 전달한다.

리퀘스트 메시지가 웹 서버에 도착하면 웹 서버는 그 속에 쓰여있는 내용을 해독해서 URI 와 메시지를 조사하여 무엇을 어떻게 하는지 판단한 후 요구에 따라 동작하고 결과 데이터를 응답 메시지에 저장한다.

응답 메시지 앞에는 **스테이터스 코드가** 있다.

액세스했을 때는 파일이 발견되지 않고 404 Not Found와 같이 표시될 수 있는데 이것이 스테이터스 코드이다. 그 후 헤더 파일과 페이지의 데이터가 이어지고 이 응답 메시지를 클라이언트에 반송한다.

GET, POST, HEAD, OPTIONS, PUT, DELET , TRACE , CONNECT

### 5 HTTP 리퀘스트 메시지를 만든다

URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP의 리퀘스트 메시지를 만든다.

먼저 리퀘스트 메시지의 첫 번째 행에 있는 리퀘스트 라인을 쓰는데 이 행에서 중요한 것은 맨 앞에 있는 메소드이다.

URL 입력 상자에 URL을 입력하고 해당 페이지를 표시하는 것을 전제로 진행되는데 웹 서버에 리퀘스트 메시지를 보내는 것은 웹 페이지 안에 포함된 하이퍼링크 혹은 폼에 데이터를 기입하여 송신 버튼을 누를 때와 같은 몇 가지 장면에 따라 메소드의 종류가 달라짐

메소드를 썼으면 한 칸 띄운 다음 URI를 쓴다. 경로명은 보통 URL에 포함되어있으므로 URL에서 경로명을 추출하여 복사한다. 첫 번째 행의 끝 메시지가 HTTP의 어느 버전의 사양을 바탕으로 쓴 것인지를 나타내기 위해 버전 번호를 써서 첫 번째 행을 완료한다.

두 번째 행부터는 **메시지 헤더**로 이어지는데 첫 번째 행에서 대략 알 수 있지만 부가적인 자세한 정보가 필요한 경우 써두는 역할을 뜻한다.

예를 들어 날짜, 클라이언트 측이 취급하는 데이터의 종류, 언어 ,압축 형식, 클라이언트나 서버의 소프트웨어 명칭이나 버전 등에 해당한다.

메시지 헤더를 쓰면 그 뒤에 아무 것도 쓰지 않는 하나의 공백행을 넣고 그 뒤 송신할 데이터를 쓴다.

이부분을 **메시지 본문**이라 한다.

### 6 리퀘스트 메시지를 보내면 응답이 되돌아온다.

응답 메시지의 포맷은 기본적으로 리퀘스트 메시지와 같다 단 첫 번째 행이 다르다.

응답의 경우는 스테이터스 코드와 응답 문구를 첫 번째 행에 써야한다.

이 둘은 내용이 같지만 용도가 다르다.

응답 메시지가 돌아오면 그때부터 데이터를 추출한 후 화면에 표시하여 웹 페이지를 눈으로 볼 수 있다.

영상 등을 포함한 경우 문장 안에 영상 파일을 나타내는 태그라는 제어 정보가 포함되어 있으므로 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다.

## 02 웹 서버의 IP주소를 DNS 서버에 조회한다.

### 1 IP 주소의 기본

HTTP의 메시지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에 송신한다. 브라우저는 URL 해독 및 HTTP 메시지를 만들지만 메시지를 네트워크에 송출하는 기능이 없으므로 OS에 의뢰하여 송신한다.

이때 URL 안에 쓰여있는 서버의 도메인명에서 IP 주소를 조사해야 한다.

HTTP 메시지를 만드는 동작의 다음은 도메인 명에서 IP주소를 조사하는 동작이 된다.

IP주소에 대해서

TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체네트워크가 들어진다.

여기서 서브넷이란 허브에 몇 대의 PC가 속된 것이라 생각해도 좋다.

이것을 한 개의 단위로 생각하여 ‘서브넷’이라 한다.

네트워크 주소와 호스트 번호를 합쳐서 IP 주소라고 한다.

액세스 대상의 서버까지 메시지를 운반할 때는 이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다.

송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반하고 송신측에서 가장 가까운 라우터까지 도착해서 라우터가 상대를 확인하여 다음 라우터를 판단하고 거기에 보내도록 지시하여 송신 동작을 실행한 후 다시 서브넷의 허브가 라우터까지 메시지를 보낸다.

**IP 주소의 표기법**

(a) IP 주소 본체의 표기 방법 10.11.12.13

(b) IP 주소 본체와 같은 방법으로 네트워크를 표기하는 방법 10.11.12.13 / **255.255.255.0 (넷마스크)**

(c) 네트워크 번호의 비트 수로 넷마스크를 표기하는 방법 10.11.12.13/**24 (넷마스크)**

(d) 서브넷을 나타내는 주소 10.11.12.**0**/24 (호스트 번호 부분의 비트가 모두 0인것은 서브넷 자체를 나타냄)

(e) 10.11.12.**255**/24 (호스트 번호 부분의 비트가 모두 1인 것은 서브넷 전체에 대한 브로드캐스트를 나타냄)

네트워크를 구축할 때 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧 붙이는데 이를 넷 마스크라고 한다.

넷마스크는 32비트 부분의 디지털 데이터이며 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값이 된다.

넷마스크가 1인 부분은 네트워크 부분이며, 0인 부분은 호스트 번호를 나타낸다 이 넷 마스크를 IP 주소와 같이 8비트씩 구분하여 표기하고 IP 주소의 오른쪽에 병기한 것이 **(b) 에 해당**

이렇게 되면 너무 길어지므로 한 부분의 비트 수를 10진수로 나타내고 IP 주소의 오른쪽에 병기한 것이 **(c)에 해당**

호스트 번호 부분의 비트값이 모두 0 혹은 1인 경우 **서브넷 (d)** 혹은 서브넷에 있는 기기 전체에 패킷을 보내는 **브로드캐스트(e)**가 된다.

### 2 도메인명과 IP 주소를 구분하여 사용하는 이유

도메인 명을 사용하는 이유 : 기억하기 어려움

IP 주소를 사용하는 이유 : 실행 효율 관점에서 문자를 처리해야하는 점에서 부하가 많이 걸림

따라서 양쪽의 장점을 모두 취하여서 DNS를 사용한다.

### 3 Socket 라이브러리가 IP 주소를 찾는 기능을 한다.

DNS 서버에 조회하여 조회 메시지를 보내고 거기에 반송되는 응답 메시지를 받는다 이를 DNS 서버에 대한 클라이언트로 볼 수 있다.

DNS 클라이언트에 해당하는 것을 DNS 리졸버, 리졸버라고 부른다.

참고로 리졸버는 Socket라이브러리라는 OS에 포함되어있는 네트워크 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것이다.

### 4 리졸버를 이용하여 DNS 서버를 조회한다.

리졸버를 호출하면 리볼저가 DNS 서버에 조회 메시지를 보내고 DNS 서버에서 응답 메시지를 받는다 이 응답 메시지 속에는 IP주소가 포함되어 있으므로 리졸버는 이것을 추출하여 브라우저에서 지정한 메모리 영역에 써넣는다.

### 5 리졸버의 내부 작동

리졸버를 호출하면 제어가 리졸버의 내부로 넘어간다.

리졸버는 DNS 서버에 문의하기위한 메시지를 만드는데 이것은 HTTP 의 리퀘스트 메시지를 보내는 것과 유사하다.

메시지 송신 동작은 리졸버가 스스로 동작하는 것이 아닌 프로토콜 스택을 호출하여 실행을 의뢰한다.

## 03 전 세계의 DNS 서버가 연대한다

### 1 DNS 서버의 기본 동작

조회 메시지에는 다음과 같은 정보가 포함되어있다.

(a) 이름 : 서버나 메일 배송 목적지와 같은 이름

(b) 클래스 : 인터넷 이외의 네트워크를 고려하여 클래스라는 정보를 구현했지만 현재 인터넷만 남아있어 항상 IN이라는 값이 된다.

(c) 타입 : A타입이면 IP 주소가 지원되는 것을 나타내며 MX면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다.

이렇게 3가지 타입으로 보내면 여기에 일치하는 것을 찾아서 IP 주소로 답장한다.

이름을 붙이고 A라는 타입으로 DNS 서버에 등록하면 그것이 웹 서버의 이름이 된다.

IP 주소를 조회할땐 A 타입을 사용하지만 메일 배송 목적지를 조회할 때는 MX라는 타입을 사용한다.

MX인 경우 메일 서버의 우선순위와 메일 서버의 이름이라는 항목으로 회답한다. 추가로 메일 서버의 IP 주소도 회답한다.

즉 이름과 타입에 따라 조사하는 정보를 지정하고 그것에 따라 해당하는 것을 찾아 클라이언트에 회답하는 것이 DNS 서버의 기본 동작이다.

그 외에도 다양한 타입이 존재한다.

### 2 도메인의 계층

정보를 분산시켜서 다수의 DNS 서버에 등록하고 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조이다.

우선 도메인명이라는 계층적 구조를 가지며, 계층화된 도메인의 서버에 등록하는데 한 개의 도메인 정보를 일괄적으로 DNS 서버에 등록하고 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가하다.

단 한 대의 DNS서버에 복수 도메인의 정보를 등록할 수 있다.

예를 들어 kr은 대한민국에 할당된 도메인이다. 그리고 하위에 있는 co 라는 도메인은 국내의 도메인을 분류하기 위해 설치된 도메인이며, 회사를 나타낸다.

### 3 담당 DNS 서버를 찾아 IP 주소를 가져온다.

인터넷의 도메인은 루트 도메인이라는 도메인이 있다. 루트 도메인을 명시적으로 작성해야하는 경우 끝에

[www.naver.com](http://www.naver.com). 처럼 끝에 마침표를 찍어서 루트 도메인을 나타내지만 보통 그렇게 쓰지는 않음

트리 구조와 유사함

루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록해서 어느 DNS 서버도 루트 도메인을 액세스할 수 있다.

### 4 DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.

DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답할 수 있다. 그렇다면 그 정보부터 내려가서 탐색하는데 이것이 루트 도메인부터 찾는 것보다 더 편리하다.

조회한 이름이 도메인에 등록되어 있지 않은 경우 이름이 존재하지않는 다는 회답이 돌아오지만 그것을 캐시에 보존할 수 있다.

이렇게 해서 존재하지 않는 경우에도 빠르게 회답할 수 있다.

다만 캐시는 저장후 정보가 변경될 수 있으므로 올바르다고 단언할 수 없다. 따라서 DNS 서버에 등록하는 정보는 유효 기한을 설정하고 캐시에 저장한 데이터의 유호기간이 지나면 데이터를 삭제한다.

또한 조회에 회답할때 이것이 캐시에 저장된 것인지 등록처 DNS 서버에서 회답한 것인지 알려준다

## 04 프로토콜 스택에 메시지 송신을 의뢰한다.

### 01 데이터 송 수신 동작의 개요

IP 주소를 조사했으면 IP 주소의 상대, 여기에서는 액세스 대상 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 프로토콜 스택에 의뢰한다.

여기에서도 Socket 라이브러리에 들어있는 프로그램 부품을 이용한다.

데이터를 송수신하기전 파이프와 같이 연결하여 데이터를 양방향으로 흘릴 수 있는 데 양자 사이를 연결하는 작업도 필요하다.

양끝에 있는 데이터의 출입구를 소켓이라고 부르는데 이 소켓을 만들고 연결한다.

실제로는 소켓을 만들고 소켓에 클라이언트가 파이프를 연결하기를 기다린다.

이렇게 해서 서버측이 기다리고 있는 동안 클라이언트 측에서 파이프를 연결한다.

데이터를 전부 보내고나면 연결했던 파이프가 분리된다.

요약하면

1. 소켓 작성 단계
2. 서버측의 소켓에 파이프를 연결 (접속 단계)
3. 데이터를 송수신(송수신 단계)
4. 파이프를 분리하고 소켓을 말소( 연결 끊기 단계)

이 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다.

### 02 소켓 작성단계

DNS 서버에 조회를 보낼 때와 같이 Socket 라이브러리의 프로그램 부품을 호출하는 것이 요점이다.

DNS 서버의 경우 gethostbyname 라는 이름의 리졸버를 호출했지만

이번에는 몇 개의 프로그램 부품을 결정된 순번대로 호출한다.

먼저 socket 이라는 프로그램 부품만 호출된다.

socket을 호출한 후의 동작은 리볼버를 호출했을 때와 같이 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행하고 이것이 끝나면 애플리케이션에 제어가 돌아온다.

소켓이 생기면 디스크럽터라는 것이 돌아오므로 애플리케이션은 이것을 받아서 메모리에 기록한다.

디스크럽터는 소켓을 식별하는 용도인데 다음과 생각할 수 있다.

컴퓨터 내부에서는 복수의 데이터 송수신 동작이 동시에 진행되는 경우가 있는데 브라우저에서 2개의 창을 열어 2개의 웹 서버에 동시에 액세스하는 장면을 생각할 수 있다.

이 경우 하나하나의 소켓을 식별해야하는데 이것이 디스크럽터이다.

Socket = 라이브러리

socket = 프로그램 부픔

소켓 = 파이프의 양 끝에 있는 출입구

### 03 파이프를 연결하는 접속 단계

소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다. 애플리케이션은 Socket 라이브러리의 connect라는 프로그램 부품을 호출하여 이 의뢰 동작을 실행한다.

connect 를 호출할 때 지정하는 디스커럽터. 서버의 IP 주소, 포트 번호라는 세가지 값이다.

최초의 디스크럽터는 소켓을 만들고 돌아온 디스크럽터이다.

여기서 지정한 디스크럽터는 connect가 프로토콜 스택에 통지한다.

그리고 프로토콜 스택이 통지받은 디스크럽터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행한다.

다음으로 IP 주소는 DNS 서버에 조회하여 조사한 액세스 대상 서버의 IP 주소이다.

IP주소로는 소켓까지 지정할 수 없다. 따라서 포트 번호로 어느 컴퓨터의 어느 소켓과 접속할지 지정할 수 있다.

참고로 디스커럽터를 사용하면 소켓을 지정할 수 있다고 생각할 수 있지만 디스커럽터는 소켓을 만들도록 의뢰한 애플리케이션에 건네주는 것이지 접속 상대에게 건네주는 것이 아니므로 접속 상대측에서는 그 값을 모른다

참고로 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다는 규칙이 있다.

서버에서도 클라이언트의 소켓의 번호가 필요할 텐데 이 부분은 프로토콜 스택이 적당한 값을 골라서 할당한다.

디스커럽터 : 애플리케이션이 소켓을 식별하는 것

IP 주소와 포트 번호 : 클라이언트와 서버 간에 상대의 소켓을 식별하는 것

### 04 메시지를 주고받는 송수신 단계

연결 후에는 애플리케이션은 소켓을 직접다룰 수 있으므로 Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰한다. 그래서 write 라는 프로그램 부품을 사용하는데 구체적으로 다음과 같다.

애플리케이션은 송신 데이터를 메모리에 준비하는데 여기서 URL 을 바탕으로 만든 HTTP 리퀘스트가 송신데이터이다. 그리고 write를 호출할 때 디스크립터와 송신 데이터를 지정한다. 그러면 프로토콜 스택이 송신 데이터를 서버에서 송신한다.

소켓에는 연결된 삳ㅇ대가 기록되어있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신한다. 그리고 적절한 처리 후 응답 메시지를 반송한다.

이 메시지가 돌아오면 Socket 라이브러리의 read 라는 프로그램 부품을 통해 프로토콜 스택에 수신 동작을 의뢰한다.

이때 저장하기 위한 메모리 영역을 지정하는데 이 메모리 영역을 수신 버퍼라고 부른다.

그러면 응답 메시지가 돌아올 때 read가 받아서 수신 버퍼에 저장한다.

### 05 연결 끊기 단계에서 송수신이 종료된다.

브라우저가 데이터 수신을 완료하면 Socket의 close 라이브러리를 통해 연결 끊기 단계로 들어가도록 의뢰한다. 그러면 파이프와 같은 것이 분리되고 소켓도 말소된다.

HTTP 프로토콜에서는 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행하므로 먼저 웹 서버측에서 close를 호출하여 연결을 끊는다. 그러면 이것이 클라이언트 측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.

\*종류에따라 클라이언트와 서버 중 close를 먼저 실행하는지 차이가 있을 수 있다.

HTTP 의 본래 동작은 따라서 데이터를 읽을 때마다 접속, 리퀘스트 메시지 송신, 응답 메시지 수신, 연결 끊기 라는 동작을 반복한다.

이후에는 비효율적이므로 한 번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법도 나중에 마련되어 있다.
