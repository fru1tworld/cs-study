# 2컴퓨터의 구조와 성능 향상

## 2.1. 컴퓨터의 기본 구성

### 2.1.1 하드웨어의 구성

CPU, 메인 메모리, 입출력장치, 저장 장치
이 중에서 CPU와 메인 메모리는 필수 장치 그 외는 보조장치

### 2.1.2 폰노이만 구조

- 폰노이만 구조는 CPU 메모리 입출력장치 저장장치가 버스로 연결된 구조를 의미
- 가장 중요한 특징은 모든 프로그램은 메모리에 올라와야 실행할 수 있다.
- 운영체제도 프로그램이라서 메모리에 올라와야 실행할 수 있음

### 2.1.3 요리사 모형

요리사는 CPU
도마는 메모리
보관 장치는 저장 장치
그 외 보조 요리사도 있음

운영체제의 작업은 크게 프로세스 관리, 메모리 관리 , 저장 장치 관리로 나뉨

### 2.1.4 기초 용어 정리

#### 클록과 헤르츠

- 컴퓨터에서 일정한 박자를 맞추는게 클록이고 틱,펄스, 클록 틱 등으로 불려짐
- CPU가 작업할 때도 펄스에 맞추어 진행됨
- 참고로 CPU의 성능은 헤르츠인데 3GHz의 CPU는 초당 3 \* 10^9임

#### 시스템 버스와 CPU 버스

- 시스템 버스는 메모리와 주변장치를 연결하는 버스
- FSB 3.2GHz는 메인 보드의 버스 클록이 최대 3.2GHz라는 뜻

- CPU 내부에도 여러 장치가 있는데 이들은 CPU 내부 버스로 연결된다.
- 이러한 연결 장치를 BSB 혹은 후면 버스라 한다.

#### 프로그램과 언어

컴파일은 고급언어를 기계어로 번역하는 과정
컴파일을 담당하는 프로그램이 컴파일러
인터프리터는 소스코드를 한 번에 한 문장씩 번역하여 실행

## 2.2 CPU와 메모리

### 2.2.1 CPU의 구성과 동작

#### 산술 논리 연산장치

ALU(Arithmetic and Logic Unit)이라는 산술 논리 연산장치가 데이터를 연산함

#### 제어 장치

CPU에서 작업을 지시하는 부분을 제어장치라 한다.

#### 레지스터

작업에 필요한 데이터를 CPU 내부에 보관하는 곳

#### CPU의 명령어 처리 과정

```
LOAD mem(100), register 2 // 메모리 100을 R2로 이동
LOAD mem(120), register 3 // 메모리 120를 R3으로 이동
ADD register 5, register 2, register 3 R2와 R5를 더하고 R5에 저장
MOVE register 5, mem(160) R5의 결과를 160으로 저장

```

#### 레지스터의 종류

- **데이터 레지스터(DR)** : 메모리에서 가져온 데이터를 임시 보관할 때 사용 대부분 데이터 레지스터라 일반, 범용 레지스터라 함

- **주소 레지스터(AR)** : 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터에 저장

- **프로그램 카운터(PC)** : CPU는 다음에 어떤 명령어를 처리해야 할 지 알아야 한다. 다음에 실행할 명령어의 주소를 가리키기 때문에 프로그램 카운터를 명령어 포인터라 한다.

- **명령어 레지스터(IR)** : 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.

- **메모리 주소 레지스터(MAR)**: 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정하는 데 사용된다. 명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 데이터를 저장한다.

- **메모리 버퍼 레지스터(MBR)**: 메모리에서 가져온 데이터나 메모리로 옮겨갈 데이터를 임시 저장 따라서 항상 메모리 주소 레지스터와 함께 동작

- **프로그램 상태 레지스터(PSR)**: 연산 결과를 저장한다(부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그 등)

#### 버스의 종류

시스템 버스(FSB)는 제어 버스 주소 버스 데이터 버스로 나뉜다.

메모리, 주변 장치는 제어, 주소, 데이터 버스를 모두 참조

---CPU 내부 버스 (BSB)--

제어 장치 -> 제어 버스

메모리 주소 레지스터 -> 주소 버스

메모리 버퍼 레지스터 -> 데이터버스

##### 제어 버스

어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
주변 장치도 마찬가지로 하드디스크에 저장 명령을 내리거나 사운드카드에 소리를 내라는 명령어를 내릴 때 제어 버스를 통해 전달 된다.
제어 버스의 신호는 **CPU, 메모리, 주변장치와 양방향**으로 오고 간다.

##### 주소 버스

메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지 알려주는 정보가 오고 간다.

메모리 주소 레지스터와 연결되어 있으며 **단방향**이다.

CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없다.

##### 데이터 버스

제어 버스가 어떤 작업을 할지 신호를 주고 주소 버스가 위치 정보를 전달하면 데이터가 데이터 버스에 실려 목적지까지 이동한다.
**메모리 버퍼 레지스터와 연결되어 있으며 양방향**이다.

##### CPU 비트의 의미

CPU가 처리할 수 있는 데이터의 최대 크기를 word라고 한다.
32bit CPU는 1word가 32bit
64bit CPU는 1word가 64bit

### 2.2.2 메모리의 종류와 부팅

메모리 주소는 바이트 단위로 저장된다.
메모리 종류는 다양하고 휘발성 비휘발성으로 나뉜다.
휘발성은 보통 캐시로 처리되고 메인메모리는 시간마다 다시 재생해야하는 DRAM 등을 사용
SDRAM은 클록 틱마다 데이터를 저장하는 동기 DRAM

DDR은 클록틱 한번에 2개의 데이터를 전송할 수 있고 현재는 DDR4로 16배 빨라짐

#### 메모리 보호

시분할 시스템에서 메모리 보호를 위해 CPU는 작업의 메모리 범위를 경계 레지스터(시작 주소)와 한계 레지스터(메모리 크기)로 관리
작업 중 메모리 접근이 이 범위를 벗어나면 하드웨어가 이를 감지해 보호
벗어나면 인터럽트를 발생 인터럽트가 바랭하면 모든 작업이 중단되고 운영체제를 깨워서 문제를 처리하고 강제 종료

#### 부팅

운영체제가 메모리에 올려서 실행하는데 운영체제는 누가 메모리에 올려서 실행할까 ?

사용자가 컴퓨터의 전원을 켜면 롬에 저장된 바이오스(BIOS: Basic Input/Output System)이 실행된다.
바이오스는 CPU, 메모리, 하드디스크,키보드, 마우스와 같은 주요 하드웨어가 작동하는지 확인하고 이상이 있으면 삐~ 소리와 함께 오류 메시지를 출력

하드디스크의 마스터 부트 레코드(MBR)에 저장된 작은 프로그램을 메모리로 가져와 실행하는데 운영체제를 실행하기 위한 코드인 **부트스트랩**이 저장되어있음

## 2.3 컴퓨터 성능 향상 기술

### 2.3.1 버퍼

데이터를 하나씩 옮기는거는 효율이 안 좋아서 한꺼번에 전송함으로써 각 장치의 속도를 완화하는게 버퍼

#### 스풀

CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어로 프린터에 사용되는 스풀러가 대표적 인쇄할 내용을 순차적으로 출력하는 소프트웨어로 출력 명령을 내린 프로그램과 독립적으로 작동함
스풀러가 없으면 워드프로세서로 작업하고 출력할 때 출력이 다 될때까지 워드프로세서를 쓸 수 없음

스풀러는 따라서 일종의 버퍼인데 다른점은 프로그램이 버퍼를 공유하기 때문에 어떤 프로그램의 데이터이든 버퍼가 다 차면 이동이 시작된다. 반면 스풀러는 완료될 때까지 끼어들 수 없어 배타적임

#### 하드웨어 안전 제거

버퍼를 사용하면 저장장치 간의 데이터 전송이 지연되는데 따라서 복사해서 바로 제거하면 안되고 종료 버튼 누르지 않고 코드를 뽑는 경우도 마찬가지 fflush를 사용하면 버퍼를 강제로 내보냄

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소

#### 캐시

캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소
즉 버퍼의 일종
CPU가 앞으로 사용할 것으로 예상되는 것을 미리 가져다 놓는데 이걸 prefetch라 함
캐시 히트 / 캐시 미스 보통 적중률은 90%

컴퓨터 성능을 향상하려면 적중률이 높아야하는데 그 방법은 하나는 그냥 캐시 크기를 늘리면 됨 그런데 비싸서 한계가 있고 지역성 이론이 있음

> NOTE: goto를 사용하면 캐시에 미리 저장된 데이터가 쓸모 없어짐 (다음행이 아니라서)

캐시는 데이터 정합성의 문제도 있는데 캐시의 변경된 데이터를 메모리에 반영하는 방법은 2개이다.

즉시 쓰기와 지연 쓰기

- 즉시 쓰기 : 변경되면 바로 반영 단점 : 느림
- 지연 쓰기 : 모아서 주기적으로 반영 -> 카피백이라 함 근데 캐시와 메모리 간의 불일치가 발생할 수 있음

Todo / 프로그램 명령어

### 2.3.2 저장 장치의 계층 구조

### 2.3.3 인터럽트

### 2.3.4 직접 메모리 접근

### 2.3.5 메모리 맵 입출력

### 2.3.6 사이클 훔치기

## 2.4 멀티 프로세싱

### 2.4.1 멀티코어 시스템

### 2.4.2 CPU 멀티 스레드
