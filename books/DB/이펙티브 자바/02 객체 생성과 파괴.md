# 객체 생성과 파괴

이번 장은 객체의 생성과 파괴를 다룬다.

객체를 만들어야 할 떄와 만들지 말아야할 때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고, 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아본다.

## 아이템 1 생성자 대신 정적 패터리 메서드를 고려하라

클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자다.

하지만 모든 프로그래머가 꼭 알아둬야 할 기법이 하나 더 있는데 클래스는 생성자와 별도로 정적 팩터리 메서드(static factor method)를 제공할 수 있다.

그 클래스의 인스턴스를 반환하는 단순한 정적 메서드 말이다.

```java
public static Boolean valueOf(bollean b){
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

> 지금 얘가하는 정적 팩터리 메서드는 디자인 패턴에서의 팩터리 메서드와 다르다. 디자인 패턴 중에는 이와 일치하는 패턴이 없다.

클래스는 클라이언트에 public 생성자 대신 정적 팩터리 메서드를 제공할 수 있다.

이 방식에는 장점과 단점이 모두 존재한다.

먼저 정적 팩터리 메서드가 생성자보다 좋은 장점 다섯 가지를 알아보자.

- **첫 번째, 이름을 가질 수 있다.**:
  생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다.

반면 정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.

예컨대 생성자인 BigInteger(int, int Random)과 정적 팩터리 메서드인 BigInteger.probalemPrime 중 어느 쩍 값이 소수인 BigInteger를 반환한다.
는 의미를 더 잘 설명할 것 같은지 생각해 보라.

하나의 시그니처로는 생성자를 하나만 만들 수 있다.

입력 매개변수들의 **순서를 다르게 한 생성자를 새로 추가하는 식**으로 이 제한을 피해볼 수도 있지만 **좋지 않은 발상**이다.

그런 API를 사용하는 개발자는 각 생성자가 어떤 역할을 하는지 정확히 기억하기 어려워 엉뚱한 것을 호출하는 실수를 할 수 있다.

코드를 읽는 사람도 클래스 설명 문서를 찾아보지 않고는 의미를 알지 못할 것이다.

이름을 가질 수 있는 정적 팩터리 메서드는 이러한 제약이 없다.

한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자.

- **두 번째, 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**:

이 덕분에 불변 클래스(immutable class: 아이템 17)는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있따.

대표적인 예인 Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다.

따라서 (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어올려 준다.

**플라이웨이트 패턴**도 이와 비슷한 기법이라고 할 수 있다.

- **세 번째**:
- **네 번째**:
- **다섯 번째**:
