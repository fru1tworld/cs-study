# 12 쿼리 종류별 잠금

## MySQL의 잠금 개요

MySQL에서 잠금(Lock)은 동시성 제어를 위해 필수적이다. 쿼리 유형에 따라 다른 잠금 전략이 사용된다.

## SELECT 쿼리의 잠금

### 일반 SELECT (잠금 없음)

```sql
-- 일반적인 SELECT는 잠금 없이 실행
SELECT * FROM users WHERE user_id = 1;

-- InnoDB의 MVCC로 인해 잠금 없이 일관된 읽기 가능
```

### SELECT ... FOR UPDATE

```sql
-- 배타적 잠금 (X-Lock) 획득
SELECT * FROM accounts
WHERE account_id = 1
FOR UPDATE;

-- 다른 트랜잭션은 해당 행을 읽기/쓰기 불가
-- 트랜잭션이 커밋되거나 롤백될 때까지 대기
```

### SELECT ... FOR SHARE (LOCK IN SHARE MODE)

```sql
-- 공유 잠금 (S-Lock) 획득
SELECT * FROM users
WHERE user_id = 1
FOR SHARE;

-- 다른 트랜잭션도 읽기 가능
-- 쓰기는 불가 (UPDATE, DELETE)
```

### NOWAIT와 SKIP LOCKED (MySQL 8.0)

```sql
-- 잠금 대기하지 않고 즉시 오류 반환
SELECT * FROM orders
WHERE order_id = 1
FOR UPDATE NOWAIT;

-- 잠겨 있는 행은 건너뛰고 나머지만 반환
SELECT * FROM queue_items
WHERE status = 'pending'
FOR UPDATE SKIP LOCKED
LIMIT 10;
```

## INSERT 쿼리의 잠금

### 일반 INSERT

```sql
-- 새 행에 대한 배타적 잠금
INSERT INTO users (name, email)
VALUES ('John', 'john@example.com');

-- Insert Intention Lock 사용
-- 다른 트랜잭션의 INSERT는 대부분 차단되지 않음
```

### INSERT ... SELECT

```sql
-- SELECT 부분은 읽기 잠금
-- INSERT 부분은 쓰기 잠금
INSERT INTO archive_orders
SELECT * FROM orders
WHERE order_date < '2023-01-01';

-- 대량 데이터 이동 시 주의 필요
```

### INSERT ... ON DUPLICATE KEY UPDATE

```sql
-- 중복 키 발생 시 UPDATE 수행
INSERT INTO counters (page_id, view_count)
VALUES (1, 1)
ON DUPLICATE KEY UPDATE view_count = view_count + 1;

-- 배타적 잠금 필요
-- 데드락 발생 가능성 있음
```

## UPDATE 쿼리의 잠금

### 단일 행 UPDATE

```sql
-- WHERE 조건의 행에 배타적 잠금
UPDATE users
SET last_login = NOW()
WHERE user_id = 1;

-- 인덱스 사용 시: 해당 행만 잠금
-- 풀 테이블 스캔 시: 검사한 모든 행에 잠금
```

### 다중 행 UPDATE

```sql
-- 여러 행에 배타적 잠금
UPDATE products
SET price = price * 1.1
WHERE category = 'electronics';

-- 잠금 순서가 중요 (데드락 방지)
-- 인덱스 사용이 중요
```

### UPDATE with JOIN

```sql
-- 조인된 모든 테이블에 잠금 필요
UPDATE orders o
INNER JOIN customers c ON o.customer_id = c.id
SET o.status = 'vip_shipping'
WHERE c.customer_level = 'VIP';

-- 양쪽 테이블의 관련 행 모두 잠금
```

## DELETE 쿼리의 잠금

### 단일 행 DELETE

```sql
-- 삭제할 행에 배타적 잠금
DELETE FROM sessions
WHERE session_id = 'abc123';

-- 인덱스 레인지와 레코드 모두 잠금
```

### 다중 행 DELETE

```sql
-- 범위 내 모든 행에 배타적 잠금
DELETE FROM logs
WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 대량 삭제 시 잠금 시간 길어짐
-- 배치 처리 권장
```

### 외래 키 제약이 있는 DELETE

```sql
-- 부모 테이블 삭제
DELETE FROM customers WHERE customer_id = 1;

-- 자식 테이블(orders 등)도 확인/잠금
-- CASCADE 옵션에 따라 동작 다름
```

## REPLACE 쿼리의 잠금

### REPLACE 동작

```sql
-- DELETE + INSERT와 유사
REPLACE INTO users (user_id, name, email)
VALUES (1, 'John', 'john@example.com');

-- 1. 중복 키 확인을 위한 잠금
-- 2. 존재하면 DELETE 잠금
-- 3. 새 행 INSERT 잠금
```

## 트랜잭션과 잠금

### 트랜잭션 격리 수준별 잠금

#### READ UNCOMMITTED

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 잠금 거의 없음
-- Dirty Read 발생 가능
SELECT * FROM users;
```

#### READ COMMITTED

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 읽은 행만 공유 잠금, 즉시 해제
-- Non-Repeatable Read 가능
SELECT * FROM users WHERE user_id = 1;
```

#### REPEATABLE READ (InnoDB 기본)

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 트랜잭션 시작 시점의 스냅샷 읽기
-- 잠금은 필요 시에만
-- Phantom Read는 Next-Key Lock으로 방지
SELECT * FROM users WHERE age > 20;
```

#### SERIALIZABLE

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 모든 SELECT에 자동으로 FOR SHARE 적용
-- 가장 강력한 잠금
SELECT * FROM users;
```

## 인덱스와 잠금

### 인덱스 사용 시

```sql
-- 인덱스 사용: 필요한 행만 잠금
UPDATE users
SET status = 'inactive'
WHERE user_id = 1;  -- user_id가 PRIMARY KEY

-- 잠금 범위 최소화
```

### 인덱스 미사용 시

```sql
-- 풀 테이블 스캔: 검사한 모든 행 잠금
UPDATE users
SET status = 'inactive'
WHERE email = 'john@example.com';  -- email에 인덱스 없음

-- 성능 저하 및 잠금 경합 증가
```

### 범위 조건과 Next-Key Lock

```sql
-- 범위 잠금
SELECT * FROM products
WHERE price BETWEEN 100 AND 200
FOR UPDATE;

-- Gap Lock으로 범위 내 삽입 방지
-- Phantom Read 방지
```

## 데드락

### 데드락 발생 예제

```sql
-- 트랜잭션 1
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 대기...
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 트랜잭션 2
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
-- 대기...
UPDATE accounts SET balance = balance + 100 WHERE id = 1;

-- 데드락 발생!
```

### 데드락 감지 및 해결

```sql
-- 데드락 정보 확인
SHOW ENGINE INNODB STATUS;

-- 데드락 발생 시 InnoDB가 자동으로 하나를 롤백
-- ERROR 1213: Deadlock found when trying to get lock
```

### 데드락 방지 전략

```sql
-- 1. 잠금 순서 일관성
-- 항상 id 오름차순으로 잠금
START TRANSACTION;
SELECT * FROM accounts WHERE id IN (1, 2) ORDER BY id FOR UPDATE;

-- 2. 짧은 트랜잭션
-- 잠금 유지 시간 최소화

-- 3. 인덱스 활용
-- 잠금 범위 최소화

-- 4. 격리 수준 조정
-- READ COMMITTED 사용 고려
```

## 잠금 모니터링

### 현재 잠금 상태

```sql
-- 잠금 대기 프로세스
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;

-- 잠금 정보 조회
SELECT
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

### 잠금 타임아웃

```sql
-- 잠금 대기 시간 설정 (초)
SET innodb_lock_wait_timeout = 50;

-- 타임아웃 발생 시
-- ERROR 1205: Lock wait timeout exceeded
```

## 잠금 최적화

### Best Practices

```sql
-- 1. 트랜잭션 최소화
START TRANSACTION;
-- 필요한 작업만 수행
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 2. 적절한 인덱스 사용
-- 잠금 범위 최소화

-- 3. 배치 처리
-- 대량 UPDATE/DELETE는 작은 단위로 분할
DELETE FROM logs WHERE created_at < '2023-01-01' LIMIT 1000;
-- 반복 실행

-- 4. SELECT ... FOR UPDATE 신중히 사용
-- 필요한 경우에만 사용

-- 5. 적절한 격리 수준 선택
-- READ COMMITTED 고려
```

## 특수 케이스

### Auto-increment Lock

```sql
-- Auto-increment 잠금은 매우 짧은 시간만 유지
INSERT INTO orders (customer_id, amount)
VALUES (1, 100);

-- innodb_autoinc_lock_mode 설정
-- 0: traditional (테이블 레벨 잠금)
-- 1: consecutive (기본값)
-- 2: interleaved (가장 빠름, 복제 주의)
```

### 메타데이터 잠금 (Metadata Lock)

```sql
-- DDL 작업 시 발생
ALTER TABLE users ADD COLUMN age INT;

-- 모든 활성 트랜잭션이 끝날 때까지 대기
-- 온라인 DDL로 완화 가능
```

## 결론

쿼리 유형별로 적절한 잠금 전략을 이해하고 사용하는 것이 MySQL 성능과 동시성 제어의 핵심이다. 인덱스 활용, 트랜잭션 최소화, 데드락 방지가 중요하다.
