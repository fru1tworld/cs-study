# 11 1. 쿼리 작성 및 최적화 (~ing)

애플리케이션에 입력된 데이터를 데이터베이스에 저장하거나 데이터베이스로부터 필요한 데이터를 가져오려면 SQL이라는 정형화된 문장을 사용해야한다.

데이터베이스나 테이블의 구조를 변경하기 위한 문장을 DDL(Data Definition Language)이라 하며

테이블의 데이터를 조작하기 위한 문장을 DML(Data Manipulation Language)이라고 한다.

[11.1 쿼리 작성과 연관된 시스템 변수 ](https://www.notion.so/11-1-fe719ca13d1b477a90be287a7d8c6b84?pvs=21)

# 11.1 쿼리 작성과 연관된 시스템 변수

대소문자 구분, 문자열 표기 방법 등과 같은 SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라진다.

### .1.1 SQL 모드 (~ing)

sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.

구분자(,)를 이용해 다음에 에 설정할 수 있다.

주의

MySQL 서버의 sql_mode 시스템 변수에 설정된 값은 서버 내부적으로 자동 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있다. 그래서 일단 MySQL서버에 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 가능한 한 sql_mode 시스템 변수의 내용을 변경하지 않는 것이 좋다.

그리고 하나의 복제 그룹에 속한 모든 MySQL 서버들은 동일한 sql_mode 시스템 변수를 유지하는 게 좋다.

변경해야 하는 경우 MySQL서버가 자동으로 실행하는 데이터 타입 변환이나 기본 값 제어에 영향을 미치는지 확인한후 적용하는 것이 좋다.

만약 MySQL 서버에 익숙하지 않다면 가능한 기본값을 그대로 사용하는 것도 좋은 방법이다.

### .1.2 영문자 대소문자 구분

MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.

이는 MySQL의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.

즉 윈도우는 대소문자를 구분하지않지만 유닉스 계열의 운영체제는 구분한다.

MySQL 서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 하려면 설정 파일에 lower_case_table_names 시스템 변수를 설정하면 모두 소문자로만 저장되고 대소문자 구분을 하지않게 해준다.

기본값은 0으로 대소문자를 구분한다.

또한 윈도우 혹은 macOS에서는 2를 설정할 수 있는데 이 경우에는 저장은 대소문자를 구분해서 하지만 MySQL의 쿼리에서는 대소문자를 구분하지 않게 해준다. **이러한 설정 자체를 떠나서 가능하면 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.**

### .1.3 MySQL 예약어

생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표 ‘나 쌍따옴표로 감싸야 한다.

MySQL 에서 이미 등록된 예약어의 개수는 적지 않으며, 예약어별로 문제가 되지않는 키워드들도 있다.

가장 좋은 방법은 매뉴얼을 통해 확인하는 것도 좋지만 **직접 MySQL에서 테이블을 생성해 보는 것이다.**

역따옴표로 둘러싸면 예약어를 사용해도 그대로 생성해버리므로 항상 역따옴표로 둘러싸지않고 생성하는 것을 권장한다.
[11.2 매뉴얼의 SQL 문법 표기를 읽는 방법](https://www.notion.so/11-2-SQL-af25cba078cd40fcb6070581363bd326?pvs=21)

## 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법

**대문자로 표현된 단어는 모두 키워드를 의미한다**. 키워드는 대소문자를 구분하지않고 사용할 수 있다.

**이탤릭체로 표현한 단어는 사용자가 선택해서 작성하는 토큰**을 의미하는데 대부분 테이블명이나 칼럼명 또는 표현식을 사용한다.

**대괄호 ‘[]’ 는 해당 키워드나 표현식 자체가 선택사항**임을 의미한다.

**파이프 ‘|’ 는 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택**해서 사용할 수 있다 .

**중괄호는 ‘{}’ 괄호 내의 아이템 중에서 반드시 하나를 사용해야** 하는 경우를 의미한다.

**“…” 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음**을 의미한다.
[11.3 MySQL 연산자와 내장함수 (~ing) ](https://www.notion.so/11-3-MySQL-ing-f5562bdaa36c495eb9f05a78e6e4b39e?pvs=21)
ANSI 표준형태가 아닌 MySQL 에서만 사용가능한 연산자가 많이 있는데 가능하면 SQL의 가독성을 위해 ANSI 표준 형태의 연산자를 사용하는 것이 좋다.

# 3.1 리터럴 표기법 문자열

- **.3.1.1 문자열**
  SQL 표준에서 문자열은 항상 홑따옴표(’) 를 사용해서 표시한다. 하지만 MySQL 에서는 쌍따옴표 (”) 를 사용할 수 있다.
  문자열값에 홑따옴표가 있는 경우 표준은 홑따옴표를 두번 사용하지만 MySQL에서는 쌍따옴표를 사용해서 이러한 문제를 해결함
  식별자가 키워드랑 충돌할 때 오라클이나 PostgreSQL 에서는 쌍따옴표나 대괄호로 감싸서 충돌을 피하지만 MySQL은 역따옴표 (`) 를 사용해서 예약어와 충돌을 피할 수 있음
  시스템 변숫값이 ANSI_QUOTES를 설정하면 쌍따옴표를 리터럴 표기에 사용할 수 없다.
  그리고 테이블 명이나 충돌을 피하려면 역따옴표가 아니라 쌍따옴표를 사용해야 한다.
  전체적으로 MySQL 서버의 고유한 방법은 배제하고 SQL 표준 표기법만 사용할 수 있게 강제하려면 sql_mode 시스템 변숫값에 ANSI를 사용하면 된다.
  하지만 대부분 쿼리 작동에 영향을 주므로 프로젝트 초기에 적용하는 것이 좋다.
- **.3.1.2 숫자**
  숫자를 상수로 SQL 에 사용할 때는 다른 DBMS와 마찬가지로 ‘ “ 없이 숫자 값을 입력하면 되는데 문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자값이거나 숫자 타입의 칼럼이면 자동으로 숫자 값으로 변환한다.
  하지만 숫자와 문자열과 같이 다른 타입으로 비교할 경우 숫자 타입을 우선시하므로 문자열 값이 숫자 값으로 변환한 후 비교를 수행한다.
  원친적으로 숫자 값은 숫자 타입의 칼럼에만 저장해야한다.
  주로 코드나 타입과 같은 같은 값을 저장하는 칼럼에서 이 같은 현상이 자주 발생한다.
- .3.1.3 날짜
  MySQL 에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE()와 같은 함수를 사용하지 않아도 된다.
  BOOL BOOLEAN 이라는 타입이 있지만 이는 TINYINT 타입과 동의어이다.
  0 또는 1로 매핑해서 사용한다.
  C언어와의 차이점은 0과 1이 아닌 0과 ‘1’만을 의미한다 따라서 다른 값을 조회되지 않는다.

# 3.2 MySQL 연산자

- .3.2.1 동등(Equal) 비교 (= )
  동등 비교는 다른 DBMS 에서와 마찬가지로 “=”를 사용해 비교를 수행하면 된다. 하지만 MySQL 에서는 “<=>” 연산자도 제공한다. 기본적으로 =와 같으며 부가적으로 NULL 값에 대한 비교까지 수행한다.
  이를 NULL-Safe 라고 한다.

  ```sql
  1 = 1    // 1
  NULL = NULL  // NULL
  1 = NULL   // NULL

  1 <=> 1   // 1
  NULL <=> NULL // 1
  1 <=> NULL  // 0

  ```

  NULL을 하나의 값으로 인식하교 비교하는 방법으로 볼 수 있음

- .3.2.2 부정(Not-Equal) 비교( <> , != )
  같지 않다는 <> 를 많이 사용한다. 이와 함께 != 도 제공하는데 가독성을 위해 하나만 사용하는 방법을 권장한다.
- .3.2.3 NOT 연산자 (!)
  TRUE FALSE 연산의 결과를 반대로 만드는 NOT을 사용한다 하지만 C/C++에서 처럼 “!” 를 같은 목적으로 사용할 수 있다.
  불리언 값 외에도 사용할 수 있지만 결과를 정확히 예측할 수 없는 경우에는 사용을 자제하는 것이 좋다.
- .3.2.4 AND(&&)와 OR(||) 연산자
  불리언 표현식의 결과를 결합하기 위해 AND 나 OR를 사용할 수 있다.
  MySQL 에서는 &&와 || 의 사용을 허용한다.
  오라클에서는 문자열 결합연산으로 이용하는데 오라클을 MySQ로 이관한다거나 문자열 결합 연산을 사용하고 싶을 경우 sql_mode에서 PIPES_AS_CONCAT을 설정하면 된다.
  ```sql
  mysql > SET sql_mode = 'PIPES_AS_CONCAT'
  abc || def // abcdef
  ```
  - OR 와 AND는 순서와 상관없이 AND 연산자를 먼저 처리한다.
- .3.2.5 나누기(/ ,DIV) 와 나머지(%, MOD) 연산자
  나누기 연산자는 일반적으로 “/” 연산자를 사용하며, 나눈 몫의 정수 부분만 가져오려면 DIV 연산자를 사용하고
  나머지는 % , MOD 를 사용한다.
- .3.2.6 REGEXP 연산자
  문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이며, RLIKE는 REGEXP와 똑같은 비교를 수행하는 연산자다. RLIKE는 가끔 문자열 값의 오른쪽 일치용 LIKE 연산자로 혼동할 때가 있는데.
  MySQL의 RLIKE는 정규표현식을 비교하는 연산자이다.
  ```sql
  mysql> SELECT 'abc' REGEXP '^[x-z]';  // 0
  ```
  정규 표현식은 POSIX 표준으로 구현돼 있다.
  REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다. 따라서 WHERE 조건절에 REGEXP 연산자를 사용한 조건을 단독으로 사용하는 것은 성능상 좋지 않다.
  가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 사용하는 것이 좋다.
- .3.2.7 LIKE 연산자
  LIKE 연산자는 정규 표현식을 검사하는 것이 아니라 어떤 상수 문자열이 있는지 없는지 정도를 판단한다.
  ```sql
  mysql> SELECT 'abcdef' LIKE 'abc%'; // 1
  mysql> SELECT 'abcdef' LIKE '%abc'; // 0
  ****mysql> SELECT 'abcdef' LIKE '%def'; // 1
  ```
  \_ 는 정확히 1개의 문자열이 일치하는지 확인한다.
  ```sql
  mysql> SELECT 'abcdef' LIKE '__c%'; // 1
  세번째 자리가 c인 경우
  ```
  와일드카드 문자인 %나 \_ 문자 자체를 비교한다는 ‘/’를 추가해야할 수 있다. 다만 와일드카드가 검색어의 앞에 있다면 찾을 수 없으므로 주의해야함
  %rist 와 같이 와일드카드가 앞에 있으면 인덱스 풀 스캔 방식으로 쿼리가 처리된다.
- .3.2.8 BETWEEN 연산자
  BETWEEN 연산자는 “크거나 같다”와 “작거나 같다” 라는 두 개의 연산자를 하나로 합친 연산자다.

  ```sql
  SELECT * FROM dept_emp
  WHERE dept_no = 'd003' AND emp_no=10001;

  SELECT * FROM dept_emp
  WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
  ```

  deot_emp 테이블에는 (dept_no, emp_no) 칼럼으로 구성된 프라이머리 키가 존재한다.
  첫 번째 쿼리는 dept_no 와 emp_no 조건 모두 인덱스를 이용해 범위를 줄여주는 방법으로 사용할 수 있다.
  하지만 두 번째 쿼리에서 사용한 BETWEEN은 대소 관계 비교와 같이 범위를 읽어야 하는 연산자라
  ‘d003’ 보다 크거나 같고 ‘d005’보다 작거나 같은 모든 인덱스의 범위를 검색해야만 한다.
  결국 BETWEEN이 사용된 두 번째 쿼리에서 emp_no10001 조건은 비교 범위를 줄이는 역할을 하지 못한다.
  BEWTEEN 과 IN 을 동일한 비교 연산자로 생각하는 사람도 있는데 사실 BETWEEN은 크다와 작다를 비교를 하나로 묶어둔 것에 가깝다. 그리고 IN 연산자의 처리 방법은 동등 비교(=)와 비슷하다.
  IN은 여러개의 동등 비교를 하나로 묶은 것과 같은 연산자라서 IN과 동등 비교 연산자는 같은 형태로 인덱스를 사용한다.
  따라서 다음과 바꾸면 emp_no =10001 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있게 된다.

  ```sql
  SELECT * FROM dept_emp
  WHERE dept_no IN('d003', 'd004', 'd005')
   AND emp_no=10001;
  ```

  BETWEEN이 선형으로 인덱스를 검색해야하는 것과 달리 IN은 동등 비교를 여러 번 수행하는 것과 같은 효과가 있기 때문에 dept_emp 테이블의 인덱스를 최적으로 사용할 수 있는 것이다.
  BETWEEN과 IN을 사용한 쿼리 둘 다 인덱스 레인지 스캔을 하고 있지만 실행 계획의 rows 칼럼에 표시된 레코드 건수는 매우 큰 차이가 있음을 알 수 있다.
  MySQL 8.0 버전 부터 다음과 같이 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.

  ```sql
  SELECT *
  FROM dept_emp USE INDEX(PRIMARY)
  WHERE dept_no IN(
  	SELECT dept_no
  	FROM departments
  	WHERE dept_no BETWEEN 'd003' AND 'd005')
  AND emp_no = 10001;
  ```

- .3.2.9 IN 연산자
  IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자이다. 여러 개의 값이 비교되지만 범위로 검색하는게 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.
  다음과 같은 경우를 고려해볼 수 있다.
  상수가 사용된 경우
  서브 쿼리가 사용된 경우
  IN 연산자에 상수가 사용된 경우는 동등 비교와 동일하게 작동하기 때문에 매우 빠르게 쿼리가 처리될 것이다.
  NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데 동등이 아닌 부정형 비교여서 인덱스를 이용해 범위를 줄이는 조건으로는 사용할 수 없기 때문이다.

# 3.3 MySQL 내장 함수

MySQL 함수는 MySQL 에서 기본으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수로 구분된다.

C/C++ API를 이용해서 사용자가 원하는 기능을 직접 추가할 수 있는데 이를 사용자 정의함수라 한다.

여기서 언급하는 내장 함수나 사용자 정의함수는 스토어드 프로그램으로 작성되는 프로시저나 스토어드 함수와는 다르다.

- .3.3.1 NULL 값 비교 및 대체(IFNULL, ISNULL)
  IFNULL()은 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL 이면 다른 값으로 대체하는 용도로 사용할 수 있는 함수이다.
  두 개의 인자를 전달하는데 비교하려는 칼럼이나 표현식을 , NULL인 경우 대체할 값이나 칼럼을 설정한다.
  ISNULL() 함수는 이름 그대로 인자로 전달한 표현식이나 칼럼의 값이 NULL 인지 아닌지 비교하는 함수다. 반환되는 값은 인자의 표현식이 NULL 이면 TRUE(1), 아니면 FALSE(0)을 반환한다.
  ```sql
  SELECT IFNULL(NULL, 1); // 1
  SELECT IFNULL(0, 1); // 1
  SELECT ISNULL(0); // 0
  SELECT ISNULL(1/0); // 1;
  ```
- .3.3.2 현재 시각 조회(NOW, SYSDATE)
  두 함수 모두 현재의 시간을 반환하는 함수로서 같은 기능을 수행한다.
  하지만 작동 방식은 둘의 큰 차이가 있는데
  하나의 SQL에서 NOW는 모두 같은 값을 가지지만 SYSDATE는 호출되는 시점에 따라 결괏값이 달라진다.

  ```sql
  SELECT NOW(), SLEEP(2), NOW();
  // 2020-08-23 14:55:20 , 0 , 2020-08-23 14:55:20

  SELECT SYSDATE(), SLEEP(2), SYSDATE();
  // 2020-08-23 14:55:23 , 0 , 2020-08-23 14:55:25
  ```

  두 가지 큰 잠재적 문제가 있다.

  - SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
  - SYSDATE() 함수가 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다
    SYSDATE() 는 사실 실행마다 다른 값을 반환하므로 사실은 상수가 아니다
    따라서 인덱스를 스캔할 때도 매번 비교되는 레코드마다 함수를 실행해야 한다. 하지만 NOW()함수는 쿼리가 실행되는 시점에서 실행되고 값을 할당받아서 그 값을 SQL 문장의 모든 부분에서 사용하기 때문에 쿼리가 1시간 동안 실행되더라도 실행되는 위치나 시점에 관계없이 항상 같은 값을 보장한다.
    따라서 SYSDATE() 를 사용하지 않는 편이 좋겠지만 sysdate-is-now 등과 같은 설정으로 동일하게 작동하게 설정할 수 있다.

- .3.3.3 날짜와 시간의 포맷 (DATE_FORMAT, STR_TO_DATE)
  DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 반환해야 할 때는 DATE_FORMAT() 함수를 이용하면 된다.

  ```sql
  %Y // 4자 연도
  %m // 2자 숫자 표시의 월
  %d // 2자 숫자 표시의 일자
  %H // 2자 숫자 표시의 시
  %i // 2자 숫자 표시의 분
  %s // 2자 숫자 표시의 초

  그 외 메뉴얼 참조
  ```

  위의 지정자를 이용해 다음과 같이 필요한 포맷 또는 필요한 부분만의 문자열로 변환할 수 있다. 날짜 포캣 변경을 위한 **지정자는 모두 대소문자를 구분해야한다.**

  ```sql
  SELECT DATE_FORMAT(NOW(), '%Y-%m-%d') AS currnt_dt;
  ```

  SQL 에서 표준 형태(년-월-일 시:분:초)로 입력된 문자열은 필요한 경우 자동으로 DATETIME 타입으로 변환되어 처리된다.
  하지만 그렇지 않은 형태는 명시적으로 날짜 타입으로 변환해야 한다 이때 STR_TO_DATE() 함수를 사용한다.

  ```sql
  SELECT STR_TO_DATE('2020-08-23','%Y-%M-%D;) AS current_dt;

  ```

- .3.3.4 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
  특정 날짜에서 연도나 월일 또는 시간을 더하거나 뺄 때 사용된다.
  사실 ADD 함수로 더하거나 빼는 처리를 모두 할 수 있기 때문에 DATE_SUB()은 크게 필요하지 않는다.
  둘다 모두 두 개의 인자가 필요하다
  - 연산을 수행할 날짜
  - 더하거나 빼고자하는 월의 수나 일자의 수 등
- .3.3.5 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
  UNIX_TIMESTAMP() 함수는 1970-01-01 00:00:00 으로부터 경과된 초의 수를 반환하는 함수다.
  UNIX_TIMESTAMP() 함수는 인자가 없으면 현재 날짜와 시간의 타임스탬프 값을, 인자로 특정 날짜를 전달하면 그 날짜와 시간의 타임스탬프를 반환한다..
  FROM_UNIXTIME() 함수는 반대로 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 반환하는 함수다.
  MySQL 의 TIMESTAMP 타입은 4바이트 숫자 타입으로 저장되기 때문에 실제로 가질 수 있는 값의 범위는
  1970-01-01 00:00:00 부터 2038-01-09 03:14:07 까지의 날짜 값만 사용이 가능하다.
  두 함수 모두 이 범위의 날짜 안에서만 사용할 수 있다.
- .3.3.6 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
  RPAD, LPAD() 함수는 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수다.
  이때 3개의 인자가 필요하다.
  패딩 처리할 문자열이며, 두 번째 인자는 몇 바이트까지 패딩할 것인지. 세 번째 인자는 어떤 문자를 패딩할 것인지 의미한다.
  LTRIM과 RTRIM 은 우측 또는 좌측에 연속된 공백문자를 제거하는 함수다.
  TRIM()은 LTRIM과 RTRIM을 동시에 수행한다.
- .3.3.7 문자열 결합(CONCAT)
  여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수로 인자의 개수 제한이 없다.
  숫자 값으로 전달하면 자동으로 변환하지만 의도된 결과가 아닌 경우에는 명시적으로 CAST()를 통해 타입을 문자열로 변환하는 것이 안전한다.
  비슷한 함수로 CONCAT_WS()라는 함수가 있는데 각 문자열을 연결할 때 구분자( , ) 를 넣어준다는 점을 제외하면 동일하다.
- .3.3.8 GROUP BY 문자열 결합(GROUP_CONCAT)
  COUNT() 나 MAX(), MIN(), AVG() 등과 같은 그룹 함수중 하나다. (Aggregate, 여러 레코드의 값을 병합해서 하나의 값을 만들어내는 함수) 중 하나다.
  주로 GROUP BY와 함께 사용하며, GROUP BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어낸다.
  GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용된다.

  ```sql
  SELECT GROUP_CONCAT(dept_no) FROM departments;
  GROUPT_CONCAT(dept_no)
  d009,d005,d002,d003,d001,d004,d006,d008,d007

  SELECT GROUP_CONCAT(dept_no SEPARATOR '|') FROM departments;
  GROUPT_CONCAT(dept_no SEPARATOR '|' )
  d009|d005|d002|d003|d001|d004|d006|d008|d007

  SELECT GROUP_CONCAT(dept_no ORDER BY emp_no DESC)
  	FROM dept_no;
  	WHERE emp_no BETWEEN 100001 and 100003;
  GROUPT_CONCAT(dept_no ORDER BY emp_no DESC)
  d005, d008,d008,d005

  SELECT GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC)
  	FROM dept_no;
  	WHERE emp_no BETWEEN 100001 and 100003;
  GROUPT_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC)
  d008, d005

  ```

  GROUP_CONCAT() 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다.
  어떤 쿼리에서 GROUP_CONCAT() 함수의 결과가 시스템 변수에 지정된 크기를 초과하면 쿼리에서 경고 메시지가 발생한다.
  MySQL 클라이언트 또는 TOAD 나 SQLyog 같은 GUI 도구를 이용해 실행하느 ㄴ경우 단순히 경고만 발생하고 쿼리의 결과는 출력되지만 JDBC로 실행하는 경우 에러로 취급되어 쿼리가 실패한다.
  기본적으로 시스템 변수로 조정할 수 있다.
  MySQL 8.0 이후 부터는 레터럴 조인이나 윈도우 함수를 이용할 수 있다

  - 10명씩 GROUP_CONCAT() 실행 혹은 최대 5개 부서만 실행 등

- .3.3.9 값의 비교와 대체(CASE WHEN … THEN … END)
  CASE WHEN은 함수가 아니라 SQL 구문이지만 여기서 함께 설명한다.
  CASE WHEN은 프로그래밍 언어에서 제공하는 SWITCH 구문과 같은 역할을 한다.
  CASE로 시작하고 END로 끝나야 하며 WHEN THEN은 필요한 만큼 반복해서 사용할 수 있다.
  사용 방법은 크게 2가지 방법으로 사용할 수 있는데 예제를 통해 확인 해보자

  ```sql
  SELECT emp_no, first_name,
  	CASE gender WHEN 'M' THEN 'Man'
  			 gender WHEN 'F' THEN 'WOMAN'
  							ELSE 'Unknown; END AS gender
  		FROM employees
  		LIMIT 10;
  ```

  이 방식은 동등 연산자로 비교할 수 있을때 비교하고자 하는 칼럼이나 표현식을 CASE 와 WHEN 키워드 사이에 두고, 비교 기준값을 WHEN 뒤에 입력해서 사용하는 방식이다.
  일반적인 SWITCH 문법과 같은 방식으로 사용한다.

  ```sql
  SELECT emp_no, first_name,
  	CASE WHEN hire_date <'1995-01-01' THEN 'Old'
  							ELSE 'new' END AS employee_type
  		FROM employees
  		LIMIT 10;
  ```

  이 방식은 단순히 두 비교 대상 값의 동등 비교가 아니라 크다 또는 작다 비교와 같이 표현식으로 비교할 때 사용하는 방식이다. CASE와 WHEN 사이에는 아무것도 입력하지 않고, WHEN 절에 불리언 값을 반환할 수 있는 표현식을 적어 주면 된다.
  CASE WHEN 구문에서 한 가지 중요한 사실은 CASE WHEN 절이 일치하는 경우에만 THEN 이하의 표현식이 실행된다는 점이다.
  따라서 CASE WHEN으로 서브 쿼리를 감싸면 필요한 경우에만 서브쿼리를 실행할 수 있다.

  ```sql
  SELECT de.detp_no, e,first_name, e.gender,
  	(SELECT s.salary FROM salaries s
  	WHERE s.emp_ no = e.emp_no
  	ORDER BY from_date DESC LIMIT 1) AS last_salary
  	FROM dept_emp de, employees e
  	WHERE e.emp_no=de.emp_no
  			AND de.dept_no = 'd001';

  SELECT de.dept_no, e.first_name, e.gender,
  			CASE WHEN e.gender='F' THEN
  							(SELECT s.salary FROM salaries s
  							WHERE s.emp_no = e.emp_no
  							ORDER BY from_date DESC LIMIT 1)
  				ELSE 0 END AS last_salary
  	FROM dept_emp de employes e
  	WHERE e,emp_no = de.emp_no
  				AND de.dept_no ='1001';

  ```

- .3.3.10 타입의 변환(CAST, CONVERT)
  프리페어 스테이트먼트를 제외하면 SQL은 텍스트(문자열) 기반으로 작동하기 때문에 SQL에 포함된 모든 입력값들은 문자열처럼 취급된다. 이럴 때 명시적으로 타입의 변환이 필요하다면 CAST() 함수를 이용하면 된다.
  CONVERT() 함수는 똑같이 CAST()와 같이 타입을 변환하는 용도와 문자열의 문자 집합을 변환하는 용도라는 두 가지로 사용할 수 있다.
  타입 변환은 변환하려는 값이나 표현식을 첫 번째 인자로 변환하려는 데이터 타입을 두 번째 인자로 명시하면 된다.
- .3.3.11 이진값과 16진수 문자열 변환
  HEX() 함수는 이진값을 사람이 읽을 수 있는 형태의 16진수 문자열로 변환하는 함수고 UNHEX()는 16진수의 문자열을 이진값으로 변환하는 함수이다. 여기서 이진값을 문자열이나 숫자가 아니라 바이너리 값이다.
  이 함수의 사용법은 뒤에서 다룰 MD5() 함수의 예제를 참조하기 바란다.
- .3.3.12 암호화 및 해시 함수(MD5, SHA, SHA2)
- .3.3.13 처리 대기(SLEEP)
- .3.3.14 벤치마크 (BENCHMARK)
- .3.3.15 IP 주소 변환INET_ATON, INET_NTOA)
- .3.3.16
- .3.3.17
- .3.3.18
- .3.3.19
- .3.3.20
- .3.3.21
- .3.3.22

[11.4 SELECT ](https://www.notion.so/11-4-SELECT-da2a08fa728349878619bed69e9434a2?pvs=21)
[11.5 INSERT ](https://www.notion.so/11-5-INSERT-642c8f0e22214691bdf76e763f53efa2?pvs=21)
[11.6 UPDATE와 DELETE ](https://www.notion.so/11-6-UPDATE-DELETE-fbd1027e400346049685bd1c8019fd00?pvs=21)
[11.7. 스키마 조작(DDL)](https://www.notion.so/11-7-DDL-7cea630fedb0497d87f84560aa49cdb5?pvs=21)
[11.8 쿼리 성능 테스트 ](https://www.notion.so/11-8-b9afb55239334dac9086ed7c57d7a369?pvs=21)
