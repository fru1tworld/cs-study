# 10 실행 계획

## 10.1 통계 정보

MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.

여기서는 테이블 및 인덱스에 대한 통계 정보와 히스토그램을 나누어 살펴보겠다.

### 10.1.1 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다.

통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리가 실행할 수 있기 때문이다.

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테입르의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다.

이러한 이유로 MySQL 5.6버전부터는 통계 정보의 정확성을 높일 수 있는 방법이 제공되기 시작했지만 아직도 많은 사용자가 기존 방식 그대로 사용한다.

#### 10.1.1.1 MySQL 서버의 통계 정보

InnoDb 스토리지 엔진을 사용하는 테이블에 대한 통계정보를 영구적으로 관리할 수 있게 개선됐다.

기존에는 메모리로 관리되고 있어서 껐다 키면 휘발됐었다.

통계 정보의 각 칼럼은 다음과 같은 값을 저장하고 있다.

- 인덱스가 가진 유니크한 값의 개수
- 인덱스의 리프 노드 페이지 개수
- 인덱스 트리의 전체 페이지 개수
- 테이블의 전체 레코드 건수
- PK의 크기 (InnoDB 페이지 개수)
- 프라이머리 키를 제외한 인덱스의 크기(InnoDB 페이지 개수)

MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에만 저장되며, MySQL 서버가 재시작되면 통계 정보가 초기화됐다.

그래서 MySQL 서버가 시작되면 모든 테이블의 통계 정보는 다시 수집돼야 했다.

그리고 사용자나 관리자가 알지 못하는 순간에 다음과 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신됐다.

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우(전체 레코드 중에서 1/16이 UPDATE, INSERT, DELETE 되는 경우)
- ANALYZE TABLE 명령이 실행되는 경우
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
- InnoDB 모니터가 활성화되는 경우
- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우

이렇게 자주 테이블 통계 정보가 갱신되면 응용 프로그램의 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 MySQL 서버가 어느날 갑자기 풀 테이블 스캔으로 실행되는 상황이 발생할 수 있다.

그러나 영구적인 통계 정보가 도입되면서 이렇게 의도하지 않은 통계 정보 변경을 막을 수 있게 됐다.

5.5 버전에서는 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는지 옵션으로 있었는데 5.6 버전부터는 이 옵션이 없어졌다.

### 10.1.2 히스토그램

MySQL 5.7

### 10.1.3 코스트 모델

## 10.2 실행 계획 확인

## 10.2.1 실행 계획 출력 포맷

## 10.2.2 쿼리의 실행 시간 확인

## 10.3 실행 계획 분석

### 10.3.1 id 칼럼

### 10.3.2 select_type 칼럼

### 10.3.3 table 칼럼

### 10.3.4 partitions 칼럼

### 10.3.5 type 칼럼

### 10.3.6 possible_keys 칼럼

### 10.3.7 key 칼럼

### 10.3.8 key_len 칼럼

### 10.3.9 ref 칼럼

### 10.3.10 rows 칼럼

### 10.3.11 filtered 칼럼

### 10.3.12 Extra 칼럼
