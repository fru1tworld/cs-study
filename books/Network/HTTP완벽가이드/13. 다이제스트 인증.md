# 13. 다이제스트 인증

기본 인증은 편리하고 유연하지만 안전하지 않고 거의 평문이나 다를바 없다 그래서 SSL과 결합해서 사용하는 것인데
다이제스트는 기본 인증과 호환되는 더 안전한 대체재로서 개발되었다.

다이제스트 인증은 널리 쓰이지 않지만, 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다.

## 13.1 다이제스트 인증의 개선점

- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
- 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
- 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

널리 쓰이지 않지만 기본 인증을 사용하고 있는 모든 서비스는 다이제스트로 전환해야한다고 조언한다.

### 13.1.1 비밀번호를 안전하게

특징은 다음과 같다 "절대로 비밀번호를 네트워크를 통해 보내지 않는다"

이것을 비가역적으로 뒤섞은 '지문'혹은 '요약(digest)'를 보낸다.

클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.

요약만 주어진 상황에서 악당은 세상에 존재하는 모든 비밀번호를 호출하지 않고는 원래 어떻게 되어있는지 알아내기 어렵다.

### 13.1.2 단방향 요약

요약은 `정보 본문의 압축`이다.

요약은 단방향 함수로 동작하고 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.

요약 함수 중 하나인 MD5는 2^128의 경우의 수가 존재한다.

요약 함수는 보통 암호 체크섬으로 불리며, 단방향 해시함수이거나 지문 함수이다.

### 13.1.3 재전송 방지를 위한 난스 사용

단방향 요약은 비밀번호를 그대로 전송해야 할 필요성에서 우리를 해방시켜 준다.

우리는 그 대신 그냥 비밀번호에 대한 요약을 보내주고, 악의적인 집단이 쉽게 요약에서 원래 비밀번호를 해독할 수 없음을 보장 받기만 하면 된다.

불행히도 불투명 자체로는 위험에서 지켜줄 수 없는데 왜냐면 가로채서 서버로 몇 번이고 재전송할 수 있기 때문이다.

이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 난스(임시 혹은 당분간 이란 뜻이다. )라고 불리는 특별한 그리고 자주 바뀌는 증표를 건네주는데, 난스를 비밀번호에 섞으면 난스가 바뀔때마다 요약도 바뀌게 만들어준다.

이것은 재전송 공격을 막아주는데, 왜냐면 저장된 비밀번호 요약은 특정 난스 값에 대해서만 유효하고 비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않기 때문이다.

다이제스트 인증은 난스를 사용할 것을 요구하는데 왜냐면 자잘한 재전송 공격들이 난스를 쓰지 않는 다이제스트를 기본 인증만큼 허약하게 만들기 때문이다.

### 13.1.4 다이제스트 인증 핸드 셰이크

1. 서버가 난스를 생성한다.
2. 인증요구: WWW-Authenticate 에서 영역, 난스, 알고리즘을 보낸다.
3. 클라이언트: 알고리즘을 선택한다.
4. 응답: 클라이언트가 응답 요약을 보낸다.[알고리즘과 난스를 보낸다]
5. 서버: 요약을 검증한다.[다음 난스를 생성한다]
6. 정보: 서버가 다음번 나스를 보낸다 클라이언트 rspauth 요약을 보낸다.

## 13.2 요약 계산

다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한분 난스값을 조합한 단방향 요약이다.

### 13.2.1 요약 알고리즘 입력 데이터

- 단방향 해시함수 H와 요약함수 KD(s,d) 여기서는 s는 비밀, d는 데이터를 의미한다.
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 A1이라 칭한다.
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 A2라 칭한다.
  A1 , A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

### 13.2.2 H와 KD 알고리즘

다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다 RFC 2617에서 제안된 두 알고리즘은 MD5 와 MD5-sess(세션) 이 이며 정해진게 없으면 MD5가 기본값이다.

H 함수는 데이터의 MD5를 계싼하며 KD 요약함수는 콜론으로 연결된 비밀 데이터와 일반 데이터 MD5를 계산한다.

### 13.2.3 보안 관련 데아터

A1로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.

A1은 메시지 자체가 아닌 비밀 정보와만 관련되어 있다.

### 13.2.4 메시지 관련 데이터

A2로 불리는 데이터 덩어리는 본문과 같은 메시지 자체를 나타낸다.

### 13.2.6 다이제스트 인증 세션

Authorization 헤더를 만들기 위해 사용될 인증 세션과 연관된 알아보기 힘든 값들을 기억해야 한다.

난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하 오래된 AUthorization 헤더 정보를 받아들이는 것을 택할 수 있다.

아니면 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다.

이때 응답에 stale=true를 정의함으로써 서버는 클라이언트에게 사용자 이름과 비밀 번호를 새로 입력하라고 할 필요 없이 새로운 난스값으로 다시 요청을 보내라고 말해줄 수 있다.

### 13.2.7 사전 인가

일반적인 인증은 트랜잭션이 완료되기 전에 요청/인증 요구 사이클을 필요로 한다.
만약 클라이언트가 다음 난스가 무엇이 될지 미리 알아서 물어보기 전에 올바른 인증 헤더를 생성할 수 있다면 생략할 수 있다.

사전 인가는 기본 인중에서는 사소하고 흔한 것이다. 브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라이언트 측 데이터베이스를 관리한다.

사용자가 어떤 사이트에 한 번 인증을 하면, 브라우저는 흔히 그 URL에 대한 다음 번 요청 때 올바른 Authorization 헤더를 전송한다.

다이제스트 인증에서의 사전 인가는 약간 더 복잡한데, 왜냐면 난스 기술은 재전송 공격을 저지하기 위한 것이기 때문이다.

서버는 임의의 난스를 생성하기 때문에, 인증 요구를 받기 전에는 클라이언트가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다.

- 다이제스트는 여러 안전한 기능을 유지하면서 사전 인가를 인가할 수 있는 몇 가지 방법을 제안하는데 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
- 서버가 짧은 시간 동안 난스를 재사용하는 것을 허용한다.
- 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.

#### 다음 난스 미리 생성하기

미리 제공하면 되는데 실제로는 요청 인증 요구 사이클에서는 벗어날 수 있지만 서버에 다중 요청 파이프라이닝하는 능력을 실질 적으로 쓸모가 없어진다.

다음 요청을 보내기 전에 반드시 다음 난스 값을 받아야 하기 때문이다.

파이프라이닝은 latency 회피를 위한 기반 기술이기 때문에 성능상 불이익이 더 크다.

#### 제한된 난스 재사용

예를 들어 한 서버는 난수를 다섯 번 혹은 10초간 재사용하도록 허락할 수 있다.

난스 재사용 수명은 절대 재사용 안함부터 잠재적으로 오랫동안 재사용까지 통제 가능하기 때문에 취약점과 성능 간 트레이드오프가 있을 수 있다.

추가적으로 카운터 증가나 IP 주소 검사와 같이 재전송 공격을 더 어렵게 만들 수 있는 다른 기능들을 채택할 수도 있다.

#### 동기화된 난스 생성

제3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다

- 그런데 이 알고리즘들은 다이제스트 인증 명세의 범위를 넘어서는 것이다.

### 13.2.8 난스 선택

난스의 내용은 불투명하고 구현 의존적이다.

그러나 성능 수준, 보안, 편의성은 현명한 선택에 달렸다.

한 사용자가 여러 프락시를 거쳐 요청을 할 수도 있기 때문에, 이는 프락시 팜을 망가뜨리게 될 수도 있을 것이다.
재전송 공격을 방지하기 위해 어떤 구현은 이전에 사용된 난스나 요청을 받아들이지 않도록 결정할 수도 있다.

또한 POST나 PUT 요청에 의해 일회성 난스나 요약을 사용하고, GET 요청을 위해 타임스탬프를 사용할 수도 있다.

### 13.2.9 상호 인증

RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다.

이는 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록 클라이언트 난스 값을 제공함으로써 가능해진다.

이후 서버는 이 요약을 Authentication-Info 헤더를 통해 클라이언트에 전달한다.

이 상호 인증은 qop 지시자가 존재할 때는 항상 수행하여야 하고, 없다면 수행하지 말아야 한다

> qop(Quality of Protection) 지시자는 **HTTP 다이제스트 인증(Digest Authentication)**에서 사용되는 보안 매개변수 중 하나입니다. 클라이언트와 서버 간의 인증 요청에서 데이터 보호 수준을 정의하는 역할을 합니다.

## 13.3 보호 수준(qop) 향상

qop 필드는 요약 헤더의 세 가지 헤더에 모두 존재할 수 있다.

qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.

예를 들어 몇몇 트랜잭션은 전송 속도가 크게 떨어지는 것을 감수하고서라도 메시지 본문의 무결성을 간단하게 검사하려고 할 수도 있다.

qop 사용이 선택사항인 것으로 되어있기는 하지만, 그건 오로지 오래된 RFC 명세와 호환을 유지하기 위해서고 현대적인 요약 구현은 qop 옵션을 지원해야 한다.
