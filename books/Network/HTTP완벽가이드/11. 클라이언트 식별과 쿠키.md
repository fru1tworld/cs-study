# 11. 클라이언트 식별과 쿠키

웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.

이 장에서는 서버가 통신하는 대상을 식별하는데 사용하는 기술을 알아본다.

## 11.1 개별 접촉

HTTP는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜이다.

서버는 클라이언트가 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 한다.

네트워크로 연결된 사용자들에 대해 더 많은 것을 알고 싶어 하고사용자들은 브라우징하는 것을 기록하고 싶어 한다.

### 개별 인사

온라인 쇼핑이 개인에게 맞처ㅜ져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.

### 사용자 맞춤 추천

온라인 상점은 고객의 흥미가 무엇인지 학습해서 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다.

고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 한다.

### 저장된 사용자 정보

온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어한다.

이러한 정보를 데이터베이스에 저장하는 온라인 상점이 있다.

#### 세션 추적

HTTP 트랜잭션은 상태가 없어서 각 요청 및 응답은 독립적으로 발생한다.

그래서 웹 사이트는 상태를 유지하려면 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 뚱뚱한 URL
- 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

## 11.2 HTTP 헤더

사용자에 대한 정보를 전달하는 가장 일반적인 일곱 가지 HTTP 요청 헤더가 기술되어있다.

| 헤더 이름       | 헤더 타입  | 설명                                     |
| --------------- | ---------- | ---------------------------------------- |
| From            | 요청       | 사용자의 이메일 주소                     |
| User-Agent      | 요청       | 사용자의 브라우저                        |
| Referer         | 요청       | 사용자의 현재 링크를 타고 온 근원 페이지 |
| Authorization   | 요청       | 사용자 이름과 비밀번호                   |
| Client-ip       | 확장(요청) | 클라이언트의 IP 주소                     |
| X-Forwarded-For | 확장(요청) | 클라이언트의 IP 주소                     |
| Cookie          | 확장(요청) | 서버가 생성한 ID 라벨                    |

From 헤더는 사용자의 이메일 주소를 포함한다.
이상적으로는 각 사용자가 서로 다른 이메일 주소를 가지고 있으므로 사용자를 식별할 수 있지만

악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 보내는 브라우저는 많지 않다.

실제로 로봇이나 스파이더는 데이터를 수집하는 과정에서 본의 아니게 웹 사이트에 문제를 일으켰을 때 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 From 헤더에 이메일 주소를 기술한다.

User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우에는 운영체제에 대한 정보까지 포함하여 서버에게 알려준다.

이는 특정 브라우저에게 제대로 동작하도록 그것들의 속성에 맞추어 콘텐츠를 최적화하는 데 유용할 수 있지만 특정 사용자를 식별하는데 큰 도움이 안된다.

Refer 헤더는 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다.

Refer 헤더 자체만으로 사용자를 식별할 수 없지만 이전에 어떤 페이지를 방문했는지 알려준다.

이 헤더를 통해서 사용자의 웹 사용 행태나 사용자의 취향을 더 잘 파악할 수 있다.

예를 들어 야구 사이트에서 현재 웹 서버로 접근한 것이라면, 서버는 접속한 사용자가 야구 애호가라고 유추할 수 있다.

## 11.3 클라이언트 IP 주소

초기 웹 선구자들은 사용자 식별에 클라이언트 IP 주소를 사용하려 했다.

이 방식은 사용자가 확실한 IP 주소를 가지고 있고 절대 바뀌지 않고 요청마다 IP를 알 수 있었다면 문제 없이 동작한다.

보통 IP주소는 HTTP 헤더에 없지만(어떤 프락시는 Client-Ip 헤더를 기술한다. 하지만 이는 HTTP 표준이 아니다.) 웹 서버는 HTT 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다.

예를 들어 유닉스 시스템에서 getpeername 함수를 호출하면 클라이언트의 IP 주소를 받을 수 있다.

그러나 다음과 같은 약점이 존재한다.

- 클라이언트는 IP주소가 아닌 사용하는 컴퓨터를 가리킨다. 만약 여러 사용자가 같은 컴퓨터를 사용한다면 그들을 식별할 수 없을 것이다.
- 많은 인터넷 서비스 제공자는 사용자가 로그인하면 동적으로 IP 주소를 할당한다. 로그인한 시간에 따라 사용자는 매번 다른 주소를 받으므로, 웹 서버는 사용자를 IP 주소로 식별할 수 없다.
- 보안을 강화하고 부족한 주소들을 관리하려고 많은 사용자가 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용한다. 이 NAT 장비들은 실제 IP 주소를 숨기고 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP주소로 변환한다.
- 보통 HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 본다. 일부 프락시는 원본 IP주소를 보존하려고 Client-IP 혹은 X-Forwarded-For HTTP 같은 확장 헤더를 통해 해결하려고 했으나 모든 프락시가 이런 식으로 동작하진 않는다.

아직도 세션 간에 사용자를 추적하려고 클라이언트 IP 주소를 사용하는 웹사이트가 있지만 이 방식은 제대로 동작하지 않기 때문에 사용하지 않는다.

어떤 웹사이트는 보안 기능으로 IP 주소를 사용하여 특정 IP 주소로부터 오는 사용자에게만 문서를 전달하기도 한다.

하지만 인터넷에서는 IP주소를 임의로 변경할 수 있기 때문에 문제가 발생할 수 있다.

## 11.4 사용자 로그인

IP 주소로 사용자를 식별하려는 수동적인 방식보다 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.

웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.

한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

이 HTTP 인증에 대한 내용은 12장에서 자세히 다룬다.

서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에게 보낼 수 있다.

브라우저는 로그인 대화상자를 보여주고 다음 요청부터 Authorization 헤더에 그 정보를 기술하여 보낸다.

- 이 시점에 사용자 이름과 비밀번호를 포함한 Authorization 헤더를 추가하는데 사용자 이름과 비밀번호를 암호화해서 네트워크상의 관찰자가 보지 못하게보호한다.

하지만 웹 사이트 로그인은 귀찮은 일인데 각 사이트를 옮겨다닐 때마다 서로 다른 사용자 이름과 비밀번호를 기억해야 한다는 것이다.

## 11.5 뚱뚱한 URL

어떤 웹사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.

그래서 사용자가 돌아다니면 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

그래서 이러한 URL을 뚱뚱한 URL이라고 한다.

웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 세션 혹은 방문으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다.

그런데 심각한 문제가 있다.

- **못생긴 URL**: 브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.
- **공유하지 못하는 URL**: 뚱뚱한 URL은 사용자와 세션에 대한 상태 정보를 포함한다. 만약 그 주소를 누군가에게 메일로 보낸다면 누적된 개인 정보를 본의 아니게 공유하게 되는 것이다.
- **캐시를 사용할 수 없음**:URL로 만드는 것은 URL이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미한다.
- **서버 부하 가중**: 서버는 뚱뚱한 URL 에 해당하는 HTML 페이지를 다시 그려야 한다.
- **이탈**: 사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL 세션에서 이탈하기 쉽다. 사용자는 서비스를 사용하는 동안, 사전에 세션 정보가 추가된 링크만을 사용해야 뚱뚱한 URL이 문제 없이 동작할 수 있다. 사용자가 이탈하게 되면 지금까지의 진척 상항들(아마도 상품으로 채워진 장바구니)가 초기화되고 처음부터 다시 해야한다.
- **세션 간 지속성의 부재**: 사용자가 특정 뚱뚱한 URL을 북카밍하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.

쿠키는 앞서 설명한 기술들이 가지고 있던 문제점들을 겪지 않지만, 쿠키만으로 하기 힘든 일에는 앞서 설명한 기술들을 함께 사용하기도 한다.

쿠키는 넷스케이프가 최초로 개발했지만. 지금은 모든 브라우저에서 지원한다.

쿠키는 매우 중요한 웹기술일 뿐만 아니라 새로운 HTTP 헤더를 정의하므로, 앞 서 다룬 기술들보다 더 자세히 살펴볼 것이다.

쿠키는 캐시와 충돌할 수 있어서 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

이어지는 절에서 이에 대해 좀 더 자세히 다룬다.

### 11.6.1 쿠키의 타입

쿠키는 크게 세션 쿠키와 지속 쿠키 두 가지 다입으로 나눌 수 있다.

세션 쿠키는 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키다.

세션 쿠키는 사용자가 브라우저를 닫으면 삭제된다.

지속 쿠키는 삭제 되지 않고 더 길게 유지될 수 있다. 지속 쿠키는 디스크에 저장되어, 브라우저를 닫거나 재시작하더라도 남아있다.

지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.

세션 쿠키와 지속 쿠키의 다른 점은 파기되는 시점 뿐이다.

쿠키는 Discard 파라미터가 설정되어 있거나, 파기되기까지 남은 시간을 가리키는 Expires 혹은 Max-Age 파라미터가 없으면 세션 쿠키가 된다.

### 11.6.2 쿠키는 어떻게 동작하는가

쿠키는 서버가 사용자에게 "안녕, 내 이름은" 하고 적어서 보내는 스티커와 같다.

사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.

처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다.

웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.

쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.

쿠키는 어떤 정보든 포함할 수 있지만 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.

예를 들어 id=123132라는 쿠키를 사용자에게 할당한다.

서버는 쿠키 값으로 데이터베이스에서 사용자 정보를 찾는데 사용할 수 있다.

하지만 쿠키는 단순히 ID 번호에만 국한되지 않는다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태

쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하는 것이다.

브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 클라이언트 측 상태라고 한다.

쿠키 명세에서 이것의 공식 명식은 HTTP State Management MEchanism 이다.

#### 구글 크롬 쿠키

각 브라우저는 각기 다른 방식으로 쿠키를 저장한다.

구글 크롬은 Cookies라는 SQLite 파일에 쿠키를 저장한다.

SQLite 파일에 있는 각 행이 쿠키 한개에 해당한다.

총 13개의 필드가 있는데 몇 몇 주요 필드의 의미는 다음과 같다.

- **creation_urc**: 쿠키가 생성된 시점을 알려주는데 그 값은 1970 00:00:00 GMT로부터 생성된 시간을 초 단위로 기술한다.
- **host_key**: 쿠키의 도메인이다.
- **name**: 쿠키의 이름이다.
- **value**:쿠키의 값이다.
- **path**: 쿠키와 관련된 도메인에 있는 경로다.
- **expire_utc**:쿠키의 파기 시점을 알려준다.
- **secure**:이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다.

#### 익스 플로러 쿠키

익스플로러는 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장한다.

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 수백 수천 개의 쿠키를 가질 수 있지만 그렇다고 브라우저가 쿠키 전부를 보내는게 아니다.

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

많은 웹사이트는 광고를 관리하는 협력업체와 계약을 한다.

이 광고들은 웹사이트 자체의 일부인 것처럼 제작되고, 지속 쿠키를 만들어낸다.

같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송한다.

이는 지속 쿠키의 도메인이 같기 때문이다.

광고사는 이 기술에 Referer 헤더를 접목하여 사용자의 프로필과 웹 사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다.

최신 브라우저들은 개인정보 설정 기능을 통해 협력업체의 쿠키 사용 방식에 제약을 가할 수 있도록 하고 있다.

#### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.

예를 들어 HTTP 응답 헤어는 브라우저가 user="mary17"이라는 쿠키를 .airtravelbargains.com 도메인을 가지고 있는 모든 사이트에 전달한다는 의미다.

#### 쿠키 Path 속성

웹 사이트 일부에만 쿠키를 적용할 수 있다.

따라서 쿠키는 일종의 상태 정보라고 할 수 있으며, 서버가 생성하여 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리한다.

쿠키의 기술과 표준에 대해서 더 자세히 알아보자

### 11.6.5 쿠키 구성 요소

현재 쿠키 명세는 Version 0 쿠키 (흔히 넷스케이프 쿠키라고 불린다.)와 Version 1 쿠키(RFC 2965)가 있다. Version 1은 Version 0의 확장으로 잘 쓰이지 않는다.

### 11.6.6 Version 0 쿠키

최초의 쿠키 명세는 넷스케이프가 정의했다.

이 Version 0 쿠키는 Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는데 필요한 필드들을 정의하였다.

Version 0 쿠키는 다음과 같은 형태다.

```
Set-Cookie: name=value [; expires=data] [; path=path] [;domain=domain] [; secure]

Cookie: name1=value1 [; name2=value2] ...
```

Set-Cookie 헤더는 쿠키의 이름과 값을 가져야 한다.

이는 쿠키 옵션 속성들에 세미콜론으로 이어 기술한다.

| Set-Cookie 속성 | 설명과 용례                                                                                                                                                                                                                                                                                                                               |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 이름=값         | 필수 속성, 이름 값 모두 큰 따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열이다. 그 어떤 이름 값이든 만들 수 있다.                                                                                                                                                                                                  |
| Expires         | 선택적 속성. 쿠키의 생명주기를 가리키는 날짜 문자열을 기술한다. 사용할 수 있는 타임존은 GMT뿐이다.                                                                                                                                                                                                                                        |
| Domain          | 선택적인 속성: 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송한다. 이는 서버가 특정 도메인에만 쿠키를 제한적으로 전달하게 한다. 명시                                                                                                                                                                       |
| Path            | 선택적인 속성: 이 속성으로 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다. 만약 Path 속성에 기술된 값이 URL 경로의 앞 부분과 일치하면 쿠키를 전달한다. 명시된 도메인에 해당하는 도메인들만이 쿠키를 설정할 수 있고 같은 형식의 도멩니을 기술하는 것을 방지하고자, 두 개에서 세 개 영역을 가지는 도메인을 기술해야 한다. (.com .edu 방지) |
| Secure          | 선택적인 속성 HTTPS 보안일 때만 사용할 쿠키를 전송한다.                                                                                                                                                                                                                                                                                   |

#### Version 0 Cookie 헤더

클라이언트가 서버에 요청을 보낼 때는 Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서 아직 파기되지 않은 쿠키들을 함께 보낸다.

모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보낸다.

### 11.6.7 Version 1 쿠키

쿠키의 확장된 버전은 RFC 2965에 정의되어 있다.

Set-Cookie2와 Cookie2 헤덜르 소개하고 있ㅇ며, Version 0과 호환된다.
좀 더 복잡하고 모든 브라우저나 서버가 완전히 지원하지는 않는다.
주요 변경 사항은 다음과 같다.

- 쿠키마다 그 목적을 설명하는 설명문이 있다.
- 파기 주기에 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제할 수 있.
- 절대 날짜 값 대신 초 단위의 상대 값으로 쿠키의 생명주기를 결정할 수 있는 Max-Age
- 단순히 도메인과 경로뿐 아니라 URL의 포트번호로도 쿠키를 제어할 수 있다.
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다.
- 호환되는 버전 번호
- 사용자 이름과 추가적인 키워드를 구별하기 위해 Cookie 헤더에 $ 접두어가 있다.

#### Version 1 Set-Cookie2 헤더

Version 1 쿠키 표준에는 넷스케이프 표준보다 더 많은 속성이 있다.

| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 이름=값 | 필수 속성, 이름 값 모두 큰 따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열이다. 그 어떤 이름 값이든 만들 수 있다. |
| Version | 필수 속성, 이 속성의 값은 쿠키 명세의 버전을 가리키는 정수 값이다. RFC 2965의 버전은 1이다.|
| Comment | 선택적인 속성. 이 속성에는 서버가 쿠키를 사용하려는 의도를 기술한다. 사용자는 한 세션 동안. 이 쿠키의 사용 여부를 결정하려고 Comment 속성에 기술되어 있는 정책을 읽어볼 수 있다. 이 값은 반드시 UTF-8 로 인코딩되어 있어야 한다.|
| Path | 선택적인 속성. |
| Discard | 이 속성이 있으면 클라이언트 프로그램이 종료될 때 클라이언트가 해당 쿠키를 삭제한다.|
| Domain | 선택적인 속성. 브라우저는 이 속성에 기술된 도메인에 해당하는 서버 호스트들에게만 쿠키를 전송한다.|
|Max-Age|쿠키의 생명 주기를 초 단위로 설정할 수 있다.|
|Path|선택적인 속성. 이 속성으로 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다.|
|Port|선택적인 속성 이 속성은 값이 없이 속성의 키워드만 기술할 수도 있고, 쿠키가 적용될 포트 한개 이상을 콤바로 구분하여 기술할 수 도 있다.|
|Secure| 선택적인 속성 HTTPS가 SSL 보안 연결을 할떄만 쿠키가 전송|

#### Version 1 Cookie 헤더

각 쿠키에 추가 정볼르 담는데, 추가 정보에는 해당 쿠키가 가지고 있떤 필터 중에서 현재의 사이트에 들어맞는 필터를 기술한다.

#### Version 1 Cookie2 헤더와 버전 협상

Cookie 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용한다.

Cookie2 헤더는 사용자 에이전트가 새로운 형식의 쿠키를 지원하며, 해당 쿠키 표준의 버전 정보를 서버에 제공한다.

만약 서버가 새로운 형식의 쿠키를 인식하면. Cookie2 헤더를 받고 나서 Seet-Cooki2 응답 헤더를 보내야 한다.

만약 Version 0 쿠키와 Version 1 쿠키를 모두 지원하더라도 브라우저는 Version 0의 Set-Cookie 헤더를 받으면, 클라이언트는 Version 0 Cookie 헤더를 보내야만 한다.

그러나 클라이언트는 해당 서버에 업그레이드할 수 있다는 의미로 Cookie2:$Version-"1"를 보내야 한다.

### 11.6.8 쿠키와 세션 추적

쿠키는 웹 사이트에 수 차례 트랜잭션을 만들어내는 사용자를 추적하는데 사용한다.

전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 쇼핑 카트를 유지하려 세션 쿠키를 사용한다.

유명 쇼핑 사이트인 Amazon.com의 예를 통해 살펴보자

브라우저에 입력하면 일련의 리다이렉트, URL 라라이트, 쿠키 설정을 통해 서버가 식별 정보를 첨부하기 위한 연속적인 트랜잭션을 시작한다.

### 11.6.9 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.

이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다.

쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않다.

다음은 캐시를 다루는 기본 원칙에 대한 안내다.

- **캐시되지 말아야 할 문서가 있다면 표시하라**: 문서를 캐시하면 될지 안될지는 문서의 소유가 가장 잘 안다. 만약 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 Cache-Control:no-cache="Set-Cookie"를 기술해서 명확히 표시한다.
- **Set-Cookie 헤더를 캐시 하는 것에 유의하라**: Set-Cookie 헤더를 가지고 있으면 본문을 캐시할 수 있지만, 캐시하는 것은 주의를 기울여야만 한다. 같은 헤더를 여러 사용자에게 보내면 사용자 추적에 실패할 것이기 때문이다. 어떤 캐시는 응답을 저장하기 전에 Set-Cookie 헤더를 제거하기 때문에 그 캐시 데이터를 받는 클라이언트는 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
- **Cookie 헤더를 가지고 있는 요청을 주의하라**: 요청이 Cookie 헤더와 함께 오면, 결과 콘텐츠가 개인 정보를 담고 있을 수도 있다는 힌트다. 개인 정보는 캐시되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다.보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다. **다시 말하지만 이미지는 캐시를 하지만 텍스트는 캐시를 하지 않는 캐시도 있다. 더 효율적인 방식은 캐시 이미지에 파기 시간이 0인 Cookie 헤더를 설정해서 매번 재검사를 하도록 강제하는 것이다.**

### 11.6.10 쿠키, 보안 그리고 개인정보

쿠키를 사용하지 않도록 비활성화시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므로 그 자체가 보안상으로 엄청나게 위험한 것은 아니다.

사실, 원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 하면 예민한 데이터가 오가는 것을 줄일 수 있다.
