# 4장 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허용한다.

HTTP 메시지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달된다.

어떤 경우에는 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있다.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려 받는다.

단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면 객체가 여러 개 있는 웹페이지를 더 빠르게 다운받을 수 있다.

하지만 하나의 커넥션으로 객체들을 로드할 때의 대역폭 제한과 대기 시간을 줄일 수 있다면 더 빠르게 로드할 수 있을 것이다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

일반적으로 더 빠르지만 항상 그렇지 않을 수 있다.

예를 들어 네트워크의 대역폭이 좁을 때 대부분 시간을 데이터를 전송하는 데만 쓸 것이다.

여러개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상 장점이 거의 없다.

또 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.

복잡한 웹 페이지는 수십 개에서 수백 개의 객체를 포함한다.

클라이언트가 수백 개의 커넥션을 열수도 있지만 서버는 다른 여러 사용자의 요청도 함께 처리해야하므로 수백 개의 커넥션을 허용하는 경우는 드물다.

실제로 브라우저는 적은 수의 병렬 커넥션만 사용한다.

서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우 그것을 임의로 끊어버릴 수 있다.

### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다.

로딩이 더 빠르더라도 여러개가 동시에 보이면서 내려받고 있는 상황이 더 빠르게 느껴진다고 생각될 수 있다.

## 4.5 지속 커넥션

HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청을 하게 될 것이다.

이러한 특성을 사이트 지역성이라고 한다.

### 4.5.1 지속 커넥션과 병렬 커넥션

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
- 각각의 새로운 커넥션은 TCP 느린 시작때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

HTTP 1.0+ 에 kepp alive와 지속 커넥션이 있다.

### 4.5.2 Kepp Alive 커넥션

커넥션을 맺고 끊음에 대한 비용이 없어서 시간이 단축됐다

### 4.5.3 Keep Alive 동작

HTTP/1.1 부터는 사용하지 않기로 결심해서 명세에서는 빠졌지만 아직도 핸드셰이크가 널리 사용되어서 지원을 해야한다.

클라이언트가 요청 헤더에 Connection:Keep-Alive 를 포함시킨다. 이것을 받으면 응답 헤더에 보내거나 보내지 않는데 없는 경우 클라이언트는 서버 커넥션이 끊을 것이라 추정한다.

### 4.5.4 Keep-Alive 옵션

클라이언트가 커넥션을 유지하기 바라기 위한 요청일 뿐이다.

그래서 무조건 보냈다고 해서 따라야할 이유는 없다.

max, timeout 등의 옵션으로 제어할 수 있음

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- 기본적으로 동작하지 않으므로 쓰고 싶으면 요청 헤더를 보내야한다.

- 커넥션을 유지하려면 모든 메시지 헤더에 추가해서 보내야한다.

- 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다.

- 프락시와 게이트웨이는 Connection 헤더 규칙을 철저히 지켜야 한다.

- 정석대로면 Connection 헤더를 못 읽는 프락시 서버와는 맺어지면 안된다. 그러나 현실적으로 쉽지 않음

### 4.5.6 Keep-Alive와 dumb 프락시

웹 클라이언트 요청에 Connection Keepl Alive가 있으면 클라이언트는 현재 연결하고 있는 TCP 커넥션을 끊지 않고 계속 유지하려는 것이다.

#### Connection 헤더의 무조건 전달

특히 문제는 프락시에서 시작되는ㄷ 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로 다음 프락시에 전달한다.

오래되고 단순한 수많은 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다.

웹 클라이언트가 무조건 전달을 하는 멍청한 프락시를 거쳐서 웹 서버에 메시지를 전송한다고 생각해보자.

그래서 프락시는 Kepp Alive가 무엇인지 모르기 때문에 다음 서버에 메시지를 그대로 전송한다.

서버는 keep alive 요청을 받았기 때문에 커넥션을 끊지 않는다.

이러한 잘못된 통신 때문에 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다.

#### 프락시와 홉별 헤더

이런 종류의 잘못된 통신을 피하려면 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들을 절대 전달하면 안된다.

따라서 프락시가 Connection:Keep-Alive 헤더를 받으면 Connection 헤더뿐만 아니라 Keep-Alive란 이름의 헤더도 전달하면 안된다.

### 4.5.8 HTTP/1.1 의 지속 커넥션

HTTP/1.1 에서는 kepp -alive를 지원하지 않는 대신 설계까 더 개선된 지속 커넥션을 지원하고 같지만 그에 비해 더 잘 동작한다.

그리고 HTTP/1.1은 기본적으로 활성화가 되어있다.

따라서 별도 설정을 하지 않는 한 모든 커넥션은 지속 커넥션으로 취급한다.

그래서 연결을 끊으려면 Connection:close 헤더를 명시해야 한다.

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection:close 헤더를 포함해 보냈으면 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 클라이언트가 해당 커넥션으로 추가 요청을 보내지 않을 것이라면 close를 보내야한다.
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션을 지속시킬 수 있다. 예를 들어 엔터티 본문을 정확해 Content-Length 값을 가지거나 청크 전송 인코딩으로 인코드 되어 있어야한다.
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.

## 4.6 파이프라인 커넥션

## 4.7 커넥션 끊기에 대한 미스터리

### 4.7.1 마음대로 커넥션 끊기

- 보통 커넥션은 메시지를 다 보낸 다음 끊지만, 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있다.
- 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있다. 이 상황은 일정 시간 동안 요청을 전송하지 않고 유후 상태에 있으면 서버는 그 커넥션을 끊을 수 있다.

### 4.7.2 Content-Length와 Truncation

각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.

만약 수신자가 캐시 프락시일 경우 응답(잠재적인 에러가 복합적으로 발생하는 것을 최소화하기 위해)을 캐시하면 안된다.

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

클라이언트는 POST와 같이 멱등성이 아닌 요청에 대해서는 파이프라인을 통해 요청하면 안된다.

그렇지 않으면 전송 커넥션이 예상치 못하게 끊겼을 때 알 수 없는 결과를 초래할 수 있다.

### 4.7.4 우아한 커넥션 끊기

TCP는 양방향이다 따라서 양쪽에 입력 큐와 출력 큐가 잇다.

#### 전체 끊기와 절반 끊기

애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘다 끊을 수 있다.

close를 하면 둘다 끊기 suhdown을 하면 절반 끊기이다.

#### TCP 끊기와 리셋 에러

단순한 HTTP 애플리케이션은 전체 끊기만을 사용할 수 있다.

클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다.

이미 끊긴 채널에 데이터를 보내려고 하면 TCP 'connection reset by peer' 메시지를 클라이언트에 보낼 것이다.

이렇게 되면 OS에서 심각한 에러로 취급하며 버퍼에 저장된 아직 읽히지 않은 데이터를 모두 삭제한다.

이러한 상황은 파이프라인 커넥션에서 더 악화된다.

#### 우아하게 커넥션 끊기

HTTP 명세어세는 클라이언트나 서버가 예기치 않게 커넥션을 끊어야한다면 우아하게 끊어야한다고 하지만 그 방법은 설명하지 않고 있다.

일반적으로 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료된다.

안타깝게도 상대방이 절반 끊기를 구현했다는 보장도 없고 절반 끊기를 검사해준다는 보장도 없다.
