# 14. 보안 HTTP

이 장에서는 디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술을 제시한다.

## 14.1 HTTP를 안전하게 만들기

사람들은 웹 트랜잭션을 중요한 일에 사용한다.

강력한 보안이 없다면 사람들은 온라인 쇼핑이나 인터넷 뱅킹을 할 때 안심할 수 없을 것이다.

제한된 접근이 가능하지 않다면, 회사 들은 중요한 문서를 웹 서버에 올려놓을 수 없을 것이다.

웹은 안전한 방식의 HTTP를 필요로 한다.

- **서버 인증**: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
- **클라이언트 인증**: 서버는 자신이 가짜가 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
- **무결성**: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- **암호화**: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- **효율**: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- **편재성**: 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- **관리상 확장성**: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- **적응성**: 현재 알려진 최선의 보안 방법을 지원해야 한다.
- **사회적 생존성**: 사회의 문화적, 정치적 요구를 만족 시켜야 한다.

### 14.1.1 HTTPS

HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.

HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.

이 보안 계층은 안전한 소켓(Secure Sockets Layer, SSL) 혹은 전송 계층 보안(Transport Laye Security, TLS)을 이용하여 구현된다.

SSL과 TLS은 매우 비슷하기 때문에, 이 책에서는 SSL과 TLS 양쪽 모두를 표현하는 용어로 엄밀하지는 않지만 SSL이란 단어를 사용한다.

어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 클라이언트와 서버는 프로토콜을 처리하는 로직을 크게 변경할 필요가 없다.

대부분의 경우 TC 입출력 호출을 SSL 호출로 대체하고 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 된다.

## 14.2 디지털 암호학

HTTPS에 대해 이야기하기전에 SSL과 HTTPS 에 이용되는 암호 인코딩 기법에 대해 약간의 배경 지식을 제공할 필요가 있다.

- **암호**: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- **키**: 암호의 동작을 변경하는 숫자로 된 매개 변수
- **대칭키 암호 체계**: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- **비대칭키 암호 체계**: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- **공개키 암호법**: 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- **디지털 서명**: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- **디지털 인증서**: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술이다. 사람들은 수천 년간 암호법의 방법론을 비밀 메시지를 보내는데 적용했고, 변조를 방지하기 위해 사용할 수 도 있다.

### 14.2.2 암호

암호법은 암호라 불리는 비밀 코드에 기반한다.

암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.

인코딩되기 전의 원본 메시지는 흔히 텍스트 혹은 평문이라고 불린다.

암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.

수천 년간 암호는 비밀 메시지를 만들기 위해 사용되어 왔다.

### 14.2.3 암호 기계

암호는 상대적으로 간단한 알고리즘으로 시작했는데 점차 복잡하지만 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기 시작했다.

### 14.2.4 키가 있는 암호

코드 알고리즘과 기계가 적에 손에 들어갈 수 있으므로 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다.

누군가 기계를 훔치더라도 올바른 다이얼 설정 없이는 디코더가 동작하지 않을 것이다.

### 14.2.5 디지털 암호

디지털 계싼의 도래로, 두 가지 주요한 발전이 있었다.

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 매우 큰 키를 지원하는 것이 가능해져서 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다. ㄷ키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워 진다.

## 14.3 대칭키 암호법

어떤 키와 암호가 함께 동작하는지 좀 더 자세히 이야기해보자 많은 암호 알고리즘은 대칭키 암호라 불리는데, 왜냐하면 그들이 인코딩할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.

### 14.3.1 키 길이와 열거 공격

인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로 키만이 유일한 비밀이다.

대칭키 암호에서 40비트는 쉽게 깨진다. 128비트 대칭키는 매우 강력한 것으로 알려져있다.

### 14.3.2 공유키 발급하기

대칭키 암호의 단점 중 하나는 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.

완전 그래프에서 각각의 개인키를 가지려면 대략 N^2개의 비밀 키가 필요하다 이것은 상당히 어려운 일이다.

## 14.4 공개키 암호법

한 쌍의 호스트가 하나의 인코딩 및 디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.

하나는 호스트 메시지를 인코딩하기 위한 것이고, 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다.

인코딩 키는 모두를 위해 공개되어 있다.(그래서 공개키라고 한다.)

하지만 호스트만이 개인 디코딩 키를 알고 있다.

메시지를 디코딩하는 능력은 소유자에게만 부여한다.

### 14.4.1 RSA

공개키 비대칭 암호의 과제는 누가 아래의 내용을 알고 있다해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다.

- 공개키
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

이 모든 요구를 만족하는 공개키 암호 체계중 유명한 것은 RSA이다.

### 14.4.2 혼성 암호 체계와 세션 키

비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭하다.

그러나 공개키 암호 방식은 계산이 느린 경향이 있고 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.

예를 들어 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

## 14.5 디지털 서명

지금까지 우리는 우리로 하여금 비밀 메시지를 대칭 그리고 비대칭 키를 사용해서 암호화하고 해독할 수 있게 해주는 여러 종류의 암호에 대해 이야기했다.

암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하돌고 하는데 이용될 수 있다.

디지털 서명이라고 불리는 이 기법은 다음 절에 논의할 인터넷 보안 인증서에게 중요하다.

### 14.5.1 서명은 암호 체크섬이다.

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.

이들은 두가지 이점을 가진다.

- 서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 서명처럼 동작한다.
- 서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

## 14.6 디지털 인증서

여기서는 인터넷의 신분증인 디지털 인증서에 대해 이야기할 것이다.
디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

### 14.6.1 인증서의 내부

디지털 인증서에는 또한 공식적으로 인증 기관에 대해 디지털 서명된 정보의 집합이 담겨있다.

기본적인 디지털 인증서는 보통 다음과 같이 인쇄된 ID에도 흔히 들어가게 되는 기본적인 것들을 담고 있다.

- 대상의 이름
- 유효 기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명

추가적으로 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 보통 대상의 공개키도 담고 있다.

그래서 누구나 디지털 인증서를 만들 수 있지만 그 모두가 인증서의 정보를 보증하고 인증서를 개인 키로 서명할 수 있는 널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다.

### 14.6.2 X.509.v3 인증서

불행히도, 디지털 인증서에 대한 전 세계적인 단일 표준은 없다.

그러나 대부분 X.509라 불리는 표준화된 서식에 저장하고 있다는 것이다.

X.509 기반 인증서에는 웹 서버 인증서, 클라이언트 이메일 인증서, 소프트웨어 코드사인 인증서, 인증 기관 인증서를 비롯한 몇 가지 변종이 있다.

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.

만약 서버가 인증서를 갖고 있지 않다면 보안 커넥션은 실패한다.
서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저가 인증서를 받으면 서명 기관을 검사한다.

만약 그 기관이 신뢰할만한 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며(브라우저는 미리 설치된 상태에서 출하된다.)

브라우저는 그 서명을 검증할 수 있다.

만약 브라우저가 서명 기관을 모른다면 신뢰할지 확신이 없으므로 대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화 상자를 보여준다.

서명 기관은 같은 사용자가 다니는 회사의 IT 부서이거나 혹은 소프트웨어 개발사일 수도 있을 것이다.

## 14.7 HTTPS의 세부사항

HTTPS는 HTTP의 가장 유명한 보안 버전이다.

### 14.7.1 HTTPS의 개요

HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP다.

### 14.7.2 HTTPS 스킴

오늘날 보안 HTTP는 선택적이다.
만약 URL이 https 스킴을 갖고 있다면 443 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 TLS 보안 매개변수를 교환하면서 핸드셰이크를 하고 암호화된 HTTP 명령이 뒤를 잇는다.

SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와 완전히 다르다. 그 트래픽은 다른 포트로 전달된다.

만약 SSL과 HTTP트래픽 모두 80으로 온다면 대부분의 웹 브라우저는 바이너리 SSL을 잘못된 HTTP로 해석하고 닫아버린다.

### 14.7.3 보안 전송 셋업

HTTPS는 클라이언트는 먼저 웹 서버의 443 포트로 연결하고 TCP 연결이 되고 나면 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.

### 14.7.4 SSL 핸드 셰이크

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

### 14.7.5 서버 인증서

SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.

그러나 오늘 날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다.

한편 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.

서버인증서는 X.509 v3에서 파생된 인증서이다.

### 14.7.6 사이트 인증서 검사

SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만 최신 웹브라우저는 대부분 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.

넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 기초를 구축했다 다음과 같다.

- 날짜 검사
- 서명자 신뢰도 검사
- 서명 검사
  한 번 서명 기관이 믿을만하다고 판단하면 브라우저는 서명 기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.
- 사이트 신원검사

### 14.7.7 가상 호스팅과 인증서

가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.

몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다.

이러한 문제를 피하기 위해 소유자는 보안 트랜잭션을 시작하는 모든 사용자를 리다이렉트한다. 가상 호스팅되는 사이트의 인증서 관리는 다소 까다로울 수 있따.

## 14.9 프락시를 통한 보안 트래픽 터널링

많은 회사가 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위한 프락시를 설치한다.
이 프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 콘텐츠 제어를 수행할 것이다.
