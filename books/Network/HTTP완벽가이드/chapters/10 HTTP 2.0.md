# 10. HTTP/2.0

## 10.2 개요

HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다.
이때 HTTP 헤더는 압축되어 담긴다.

프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다.

한 개의 스트림이 한 쌍의 요청과 응답을 처리한다.

하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능하다.

HTTP/2.0 은 이들 스트림에 대한 흐름 제어와 우선순위 부여 기능 제공도 한다.

HTTP/2.0은 기존의 요청-응답과 다른 새로운 상호작용 모델인 서버 푸시를 도입했다.

필요에 따라서 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있다.

기존 웹 애플리케이션과 호환성을 최대한 유지하기 위해 HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있다.

HTTP/2.0에서도 Content-Length 헤더는 본문의 길이를 의미하며 404 Not Found는 찾을 수 없음을 의미한다.

다만 이를 표현하는 문법은 변경되었다. 예를 들어

Content-Length는 .content-length가 되었으며, 404 Not Found는 .status 헤더로 표현하게 되었다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. 프레임은 8바이트의 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.
프레임 헤더의 각 필드는 다음과 같다.

- **R**: 예약된 2비트 필드 값의 의미가 정의되어 있지 않으며 반드시 0이어야 한다. 받는 쪽에서는 이 값을 무시해야 한다.
- **길이**: 페이로드의 길이를 나타내는 14비트 무부호 정수, 이 길이에 프레임 헤더는 포함되지 않는다.
- **종류**: 프레임의 종류
- **플래그**: 8비트 플래그, 플래그 값의 의미는 프레임의 종류에 따라 다르다.
- **R**: 예약된 1비트 필드 첫번째와 마찬가지로 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다. 받는 쪽에선 이 값을 무시해야한다.
- **스트림 식별자**: 31비트 스트림 식별자 특별히 0은 커넥션 전체와 연관된 프레임임을 의미한다.

HTTP/2.0은 DATA, HEADERS, PRIORITY, RST, PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION이라는 총 10가지 프레임을 정의하고 있으며, 페이로드의 형식이나 내용은 프레임 종류에 따라 다르다.

### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트과 서버 사이에 교환되는 프레임들의 독립된 양방향 시퀀스다.
한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이뤄진다. 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다.

요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보낸다. 그러고 나면 스트림이 닫히게 된다.

HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 때 그에 대한 응답이 도착해야 보낼 수 있었다. 그래서 회전을 줄이기 위해 여러개의 TCP 커넥션을 만들어서 보내는 방법을 사용했는데 그렇다고 무작정 TCP 커넥션을 만들 수 없어서 회전 지연이 늘어나는 것을 피하기 어렵다.

HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
따라서 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있기 때문에 이 문제는 수비게 해결되었다.
또한 스트림은 우선순위도 가질 수 있다.

모든 스트림은 31비트의 무부호 정수로된 고유한 식별자를 갖는ㄷ. 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수여야 하며, 서버라면 짝수여야한다.

또한 새로 만들어지는 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야한다.

서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만든다.

이는 스트림을 만들때 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미한다.

HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.

커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데, 그런 경우엔 커넥션을 다시 맺으면 된다.

### 10.3.3 헤더 압축

HTTP/1.1 에서는 헤더는 아무런 압축없이 그대로 전송되었다.

HTTP/2.0 에서는 HTTP 메시지의 헤더를 압축하여 전송한다.

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송된다.

HPACK은 헤더를 압축하고 해제할 때 압축 콘텍스트를 사용한다.

### 10.3.4 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.

이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.

예를 들어 HTML 문서를 요청 받은 서버는 HTML 문서가 링크하고 있는 iamge,css,js 파일 등의 리소스를 클라이언트에게 푸시할 수 있을 것이다.

이는 HTML 파싱 후 다시 재요청하는 트래픽과 회전 지연을 줄여준다.

서버 푸시는 다음에 주의해야한다.

- 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다. 서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 SOP에 따라 검사해야 한다.
- 마지막으로, 서버 푸시를 끄고 싶다면, 관련 설정 값을 0으로 하면 된다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐 공격

HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1로 변환할 때 메시지의 의미가 변질될 가능성이 있다. 1.1과 달리 HTTP/2.0는 헤더 필드의 이름과 값을 바이너리로 인코딩한다.

이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다.

이는 정상적인 HTTP/2.0요청이 불법적이거나 위조된 HTTP/1.1 로 번역되는 것을 유발할 수 있다.

다행히 HTTP/1.1 메시지를 HTTP/2.0으로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다. 이것은 개인 정보의 유출에 악용될 가능성이 있다.

예를 들어 어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성도 있다.

이것은 HTTP가 현재 갖고 있는 문제이기도 하지만, 짧게 유지되는 커넥션에서는 위험이 적다
