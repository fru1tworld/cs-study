# 6. 교착 상태

## 6.1. 교착 상태

### 6.1.1 교착 상태의 정의

다른 작업이 끝나기만을 기다리는 상태

아사와 유사하지만 다름 잘못된 정책으로 자원을 못 받는게 문제인 반면 여러 프로세스가 진행을 하다보니 발생하는 자연적인 현상

#### 시스템 자원

교착 상태는 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생한다.

어떤 프로세스가 임계구역으로 보호되는 프린터, 스캐너 등 동시에 같이 사용할 수 없는 시스템 자원을 할당받은 후 양보하지 않는 경우를 예로 들 수 있다.

프로세스 P1은 프린터를 할당받은 후 스캐너를 기다리고 프로세스 P2는 스캐너를 할당받은 후 프린터를 기다리면 교착 상태가 발생한다.

#### 잠금

P1이 lock1을 true로 만든 다음 P2가 lock2를 true로 만들었다고 가정해 보자. 이후 P1은 while(lock=2==true)가 실행되어 무한 반복을 하고, P2도 while(lock1==true)가 실행되어 무한 반복하게 된다.

이 경우 P1과 P2 둘 다 임계구역에 들어가지 못하는 교착 상태가 발생한다.

이처럼 한 변수를 할당받은 상태에서 다른 변수를 기다리면 교착 상태가 발생한다.

#### 응용 프로그램

데이터베이스 같은 응용 프로그램에서도 교착 상태가 발생한다.

여러 프로세스가 데이터베이스에 저장된 데이터를 사용할 때는 일관성을 유지해야 한다.

5장에서 예금 5만 원이 사라진 예가 바로 일관성이 깨진 경우다.

데이터베이스는 데이터의 일관성을 유지하기 위해 잠금을 사용하는데, 이때 교착 상태가 발생할 수 있다.

### 6.1.2 자원 할당 그래프

자원 할당 그래프는 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것이다.

식사하는 철학자 문제
철학자 4명이 둥근 식탁에 앉아 식사를 하는데 왼쪽에 있는 포크를 잡은 뒤 오른쪽에 있는 포크를 잡아야만 식사가 가능하다는 조건이 있다.
철학자들은 음식을 먹기 위해 왼쪽의 포크를 잡은 뒤 오른쪽 포크를 잡으려고 오른쪽을 볼텐데 이미 포크를 들고있는 다른 철학자가 앉아 있다.
이 문제의 결과는 오른쪽 포크를 잡지 못해 철학자가 모두 굶어 죽는다는 것이다.

교착 상태가 발생하는 조건은 다음과 같다.

1. 서로 자원을 공유할 수 없다.
2. 자원을 빼앗을 수 없으면 자원을 놓을 때 까지 기다린다.
3. 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태가 발생한다.
4. 자원을 요구하는 방향 그래프가 사이클이 되면 교착 상태가 발생한다.

## 6.2. 교착 상태 필요조건

### 6.2.1 교착 상태 필요조건

네 가지 조건을 모두 만족해야 교착 상태가 발생한다.

- **상호 배제**: 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다. 배타적인 자원은 임계구역으로 보호되기 때문에 다른 프로세스가 동시에 사용할 수 없다. 배타적인 자원을 사용하면 교착 상태가 발생한다.
- **비선점**: 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다. 어떤 자원을 빼앗을 수 있다면 시간 간격을 두고 자원을 공유할 수 있다. 하지만 빼앗을 수 없으면 공유할수도 없으므로 교착상태가 발생한다.
- **점유와 대기**: 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 한다. 다른 프로세스의 작업 진행을 방해하는 교착 상태가 발생하려면 다른 프로세스가 필요로 하는 자원을 점유하면서 또 다른 자원을 기다리는 상태가 되어야 한다.
- **원형 대기**: 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다. 프로세스가 특정 자원에 대해 점유와 대기를 한다고 해서 모두 교착 상태에 빠지는 것은 아니다. 점유와 대기를 하는 프로세스들이 서로 방해하는 방향이 원을 이루면 프로세스들이 서로 양보하지 않기 때문에 교착 상태에 빠진다.

상호 배제와 비선점 조건은 자원에 어떤 특징이 있는지를 나ㅏ타낸다.
교착 상태가 발생한다. 점유와 대기, 원형 대기 조건은 프로세스가 어떤 행위를 하고 있는지를 나타낸다.
사용하는 자원을 동시에 공유할 수 없고 중간에 빼앗을 수없다면 자원을 가진 프로세스가 자원을 내놓을 때까지 무작정 기다리는 교착 상태가 발생한다.

### 6.2.2 식사하는 철학자 문제와 교착 상태 필요조건

상호 배제 : 식사 하는 철학자 문제에서 포크는 한 사람이 사용하면 다른 사람이 사용할 수 없는 배타적 자원
비선점 : 식사하는 철학자 문제중 누가 힘이 월등하여 옆 사람의 포크를 빼앗을 수 있다면 교착 상태가 발생하지 않는다.
상해 보제와 비선점 조건은 임계구역과 관련이 있다.
임계구역의 자원을 사용하는 프로세스들이 점유와 대기, 원형 대기 상황에 처할 때 교착 상태가 발생한다.

점유와 대기: 한 철학자가 두 자원을 모두 점유하거나 반대로 두 자원을 모두 기다리는 상태라면 교착이 발생하지 않는다.
원형대기 : 식사하는 철학자들은 둥근 원탁에서 식사를 한다. 만약 둥근 식탁이 아닌 사각형 식탁에서 한줄로 앉아서 식사하면 발생하지 않는다.

중요한 점은 아사와 데드락은 다르다는 것

## 6.3. 교착 상태 해결 방법

교착 상태를 해결하는 방법은 예방, 회피, 검출이며, 추가적으로 교착 상태가 발견된 후에 자원을 회복하는 방법도 있다.

교착 상태 예방

- 네 가지 조건이 발생하지 않도록 무력화하는 방식 그러나 실효성이 없어 잘 사용되지 않음
  교착 상태 회피
- 자원 할당량을 조절하여 교착 상태를 해결하는 방식
- 그러나 얼마나 항당해야 발생하지 않는다는 보장이 없기 때문에 실효성이 적다.
  교착 상태 검출과 회복
- 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식
- 발생하면 교착 상태 회복 단계가 진행된다.

### 6.3.1 교착 상태 해결

#### **상호배제 예방**

시스템 내에 있는 상호 배타적인 모든 자원, 즉 독점적으로 사용할 수 있는 자원을 없애버리는 방법이다.

시스템 내의 모든 자원을 공유할 수 있다면 교착 상태가 발생하지 않는다.

식사하는 철학자 문제에서도 모든 철학자가 포크를 공유할 수 있다면 교착 상태가 발생하지 않을 것이다.

변수나 파일도 공유하면 발생하지 않는다.

그러나 현실적으로 모든 자원은 공유할 수 없고 보호해야하는 자원이 있어 상호배제를 무력화할 수는 없다.

#### **비선점 예방**

모든 자원을 빼앗을 수 있도록 하는 방법이다.그런데 임계구역을 보호하기 위해 잠금을 사용하면 빼앗을 수 없을 뿐만 아니라 상호 배제 예방도 보장할 수 없다.

사실상 시스템의 모든 자원을 빼앗기는 어렵다.

설사 어떤 자원을 빼앗을 수 있도록 할지라도 어떤 기준으로 빼앗을지, 빼앗은 시간 중 얼마나 사용할지 정하기 어렵다.

게다가 이러한 방법은 아사 현상을 일으킨다.

에이징을 적용한다 하더라도 비선점 자원이 되어 다시 교착 상태에 빠질 수 있다.

#### **점유와 대기 예방**

프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법이다.

다시 말해 전부 할당하거나 아예 할당하지 않는 방식을 적용한 것이다.

이를 위해 프로세스는 작업 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하나, 그렇지 못할 경우 자원을 모두 반납해야 한다.
그러나 임계구역으로 보호 받는 자원에 대한 제약을 풀기는 어렵다.
점유와 대기 예방은 자원이 아닌 프로세스의 자원 사용 방식을 바꿔 교착 상태를 처리한다는 점에서 의미가 있다. 한편 점유와 대기 예빵에는 다음과 같은 단점이 있다.

##### **프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.**

- 프로세스가 필요한 자원을 모두 확보한 후 실행했는데 추가로 필요한 자원이 생기면 이를 다시 확보하기가 어렵다.

##### **자원의 활용성이 덜어진다.**

- 프로세스가 앞으로 사용할 자원까지 선점해버리기 때문에 그자원을 필요로 하는 다른 프로세스의 작업이 진행되지 않는다. 당장 사용하지도 않을 자원을 선점하므로 자원 낭비가 심하다.

##### **많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다.**

- 자원을 많이 사용하는 프로세스는 적게 사용하는 프로세스보다 자원을 동시에 확보하기가 어렵다. 그러므로 많은 자원을 사용하는 프로세스의 작업이 지연되는 아사 현상이 발생한다.

##### **결국 일괄 작업 방식으로 동작한다.**

- 점유와 대기 예방을 실제로 구현하면 거의 모든 프로세스가 일괄 작업 방식으로 처리된다. 키보드, 마우스 등의 시스템 자원은 대부분의 프로세스가 필요로 하는 자원인데, 이 자우너들을 확보한 순서대로 실행한다면 그 자원을 획득한 프로세스가 작업을 끝내야 다른 프로세스가 작업할 수 있다 . 결국 모든 작업이 일괄 작업 방식이 되어 효율이 떨어진다.

#### **원형대기 예방**

점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 막는 방법이다.

프로세스들이 한 줄로 길게 늘어선다면 그 줄의 맨 끝에서부터 문제가 해결될 것이다.
자원을 한 방향으로만 사용하도록설정하면 원형 대기를 예방할 수 있다.
모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원을 할당하는 것이다.

##### **프로세스 작업 진행에 유연성이 떨어진다.**

- 프린터를 사용한 다음 마우스를 할당받으려면 운영체제가 이를 거부할 수 있는데 사용자 입장에서는 이러한 자원 사용을 납득하기가 어렵다.

##### **자원에 번호를 어떻게 부여할지가 문제다.**

- 자원에 어떻게 번호를 붙이는 자원 사용에 제약이 따른다.

결국 자원을 보호해야 하므로 상호 배제 예방과 비선점 예빵은 사용하기 어렵고, 점유와 대기 예방, 원형 대기 예방은 프로세스 작업 방식을 제한하고 자원을 낭비하기 때문에 사용할 수 없다.

### 6.3.2 교착 상태 예방

#### **교착 상태 회피의 개념**

교착 상태 회피는 프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어주는 방법이다.

교착 상태가 발생하지 않는 범위 내에서만 자원을 할당하고, 교착 상태가 발생하는 범위에 있으면 프로세스를 대기시킨다.

교착 상태 회피에서는 할당되는 자원의 수를 조절하여 교착 상태를 피한다.

교착 상태 예방은 프로세스의 작업 방식을 제약하기 때문에 사용할 수 없었는데, 교착 상태 회피는 시스템의 운영 방식에 변경을 가하지 않기 때문에 예방보다는 좀 더 유연하다.

시스템에 총 20개의 자원이 있다고 가정했을 때 1개의 자원을 할당하면 교착 상태가 발생하지 않고 20개의 자원을 발생하면 확률이 올라간다.

그래서 안정 상태와 불안정 상태로 나누고 시스템이 안정 상태를 유지하도록 자원을 할당한다.

교착 상태 회피에서는 안정 상태를 유지할 수 있는 범위 내에서 자원을 할당함으로써 교착 상태를 피한다.

#### **은행원 알고리즘**

교착 상태 회피를 구현하는 여러가지 방법 중 하나인데 은행원 알고리즘이다.
은행이 대출 가능 범위 내라면 대출이 허용되지만 그렇지 않으면 거부되는 것과 유사하다.

Total(전체 자원) : 시스템 내 전체 자원 수
Available(가용 자원) : 시스템 내 현재 사용할 수 있는 자원의 수 | 가용 자원 = 전체 자원 - 모든 프로세스의 할당 자원
Max(최대 자원) : 각 프로세스가 현재 할당된 자원의 수
Allocation(할당 자원) : 각 프로세스에 현재 할당된 자원의 수
Expect(기대 자원) : 각 프로세스가 앞으로 사용할 자원의 수 | 기대 자원= 최대 자원 0 할당 자원

각 프로세스에 할당된 자원의 수는 할당 자원에 표시된다. 프로세스마다 자신이 선언한 최대 자원에서 현재 할당된 자원의 수를 빼면 기대 자원이 된다.

전체 자원에서 각 프로세스에 할당되고 남은 자원의 수는 가용 자원이다.

자원 할당 기준은 다음과 같다.

- 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당한다. 가용 자원이 기대 자원보다 크다는 것은 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미이므로 안정 상태다.
- 가용 자원이 어떤 기대 자원보다도 크지 않으면 자원을 할당하지 않는다. 이는 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없다는 의미이므로 불안정 상태다.

#### **교착 상태 회피의 문제점**

##### **프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.**

- 교착 상태 회피 방식을 사용하려면 모든 프로세스가 자신이 사용할 자원을 미리 선언해야 하는데 이는 쉬운 일이 아니다.

##### **시스템의 전체 자원 수가 고정적이어야 한다.**

- 시스템의 전체 자원 수가 고정적이어야 한다. 그러나 시스템의 자원 수가 유동적이다.

##### **자원이 낭비된다.**

모든 불안정 상태가 교착이 아님에도 불구하고 자원을 할당하지 않는 것은 자원 낭비다.
드물지만 프로세스에 따라 최대 자원을 사용하지 않고 작업을 마치는 경우도 있다.

### 6.3.4 교착 상태 검출

#### **타임 아웃**

타임아웃을 이용한 교착 상태 검출은 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리하는 방법이다.
교착 상태가 자주 발생하지 않을 것이라는 가정하에 하는 것이라 특별한 알고리즘 없이 구현할 수 있다.
그래서 타임아웃을 가벼운 교착 상태 검출이라고 하고
자원 할당 그래프를 검사하는 것을 무거운 교착 상태 검출이라고 한다.

그러나 다음과 같은 문제가 있다.

##### **엉뚱한 프로세스가 강제 종료될 수 있다.**

타임 아웃을 이용하면 교착 외 다른 이유로 작업이 진행되지 못하는 모든 프로세스가 강제로 종료될 수 있다.

##### **모든 시스템에 적용할 수 없다.**

-하나의 운영체제 내에서 동작하는 프로세스들은 그 상태를 운영체제가 감시하기 때문에 타임아웃 방법을 적용할 수 있다.

분산 데이터베이스는 데이터가 여러 시스템에 나뉘어 있고 각 시스템이 네트워크로 연결되어 있다.

이러한 시스템에서는 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지, 네트워크 문제 때문인지, 단순히 처리가 늦어지는 것인지 정확히 알 수 없다. 그러므로 타임아웃 방법을 적용하여 교착 상태를 파악하기 어렵다.

교착 상태를 해결할 때 가장 큰 문제가 되는 것은 시스템에 따라 교착 상태가 발생하는 빈도나 시스템에 미치는 영햐이 다르다는 것이다.

공장 운영 시스템, 원자로 제어 시스템, 무기 제어 시스템 등에서 교착 상태가 발생하면 매우 위험하다.

그러나 일반인이 사용하는 운영체제에서는 교착 상태를 찾아 해겨하기 위해 노력과 시간을 들이기 보다 차라리 진행이 안되는 프로세스를 죽이거나 최악의 경우 전체 시스템을 재부팅시키는 것이 효율적이다.

그래서 유닉스나 윈도우 같은 대중적인 운영체제에서는 타임아웃 방식을 사용한다.

데이터베이스의 교착 상태 처리는 운영체제보다 복잡하다.

타임아웃으로 데이터의 일관성이 깨지는 문제를 해결하기 위해 데이터베이스에서는 체크포인트와 롤백을 사용한다.

체크포인트는 작업을 하다가 문제가 발생하면 저장된 상태로 되돌아오기 위한 표시다.

현재의 시스템 상태가 하드디스크로 저장되며 이런 것을 스냅샷이라 한다.

롤백이 일어나면 스냅샷을 복원하여 시스템을 체크포인트 시점으로 되돌린다.

#### **자원 할당 그래프를 이용한 교착 상태 검출**

교착 상태를 검출하는 또 다른 방법은 자원 할당 그래프를 이용하는 것이다.

##### **교착 상태가 없는 자원 할당 그래프**

사이클이 존재하지 않으면 교착 상태가 발생하지 않는다.

##### **교착 상태가 있는 자원 할당 그래프**

사이클이 발생하면 교착 상태가 검출된 것으로 판단한다.

다중 자원을 사용하는 경우에는 사이클이 있다고해서 모두 교착 상태라고 판단할 수 없다.

그래서 자원 할당 그래프를 즉시 반영하는 비용이 있으므로 할당될 때마다 사이클 검사를 하는 것이 아니라 일정 시간 마다 하는 방법도 있다.

### 6.3.5 교착 상태 회복

검출되면 푸는 후속 작업을 회복이라고 한다.

##### **교착 상태를 일으킨 모든 프로세스를 동시에 종료한다.**

이 방법을 사용하는 경우 종료된 프로세스들이 동시에 작업하면 다시 교착 상태를 일으킬 가능성이 크다. 모든 프로세스를 강제로 종료 한 후 다시 실행할 때는 순차적으로 실행해야 한다. 이때 어떤 프로세스를 먼저할지 기준을 정해야 한다.

##### **교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료한다.**

교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료하면서 나머지 프로세스의 상태를 파악하는 방법이다.
프로세스 종료 순서를 정할 때는 다음과 같은 기준이 필요하다.

- 우선순위가 낮은 프로세스를 먼저 종료한다.
- 우선순위가 같으면 작업 시간이 짧은 프로세스를 먼저 종료한다.
- 위의 두 조건이 같으면 자원을 많이 사용하는 프로세스를 먼저 종료한다.

회복 단계에서는 단순히 종료뿐 아니라 다시 실행되기 전에 시스템을 복구하는 일도 해야하는데 실행 될때마다 체크포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 식으로 한다.

그래서 이 방법은 작업량이 상당하여 시스템에 부하를 주므로 체크포인트를 무분별하게 사용하지 말고 선택적으로 사용해야 한다.
