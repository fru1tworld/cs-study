# 7. 물리 메모리 관리

## 7.1 메모리 관리의 개요

폰 노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리 공간에 올라와야 실행할 수 있다.
모든 프로그램은 하드디스크나 SSD와 같은 보조 저장 장치에 보관되어 있다. 프로그램이 실행되어 프로세스가 된다는 것은 저장 장치에 있던 프로그램이 메모리로 올라온다는 뜻이다.

이 책에서는 메인 메모리를 메모리라 한다. 의미를 분명하게 나타내야 하는 경우에만 메인 메모리나 물리 메모리라 표기한다.

### 7.1.1 메모리 이해하기

메모리의 구조는 1바이트 크기로 나뉜다. 1B로 나뉜 각 영역은 주소로 구분되는데 보통 0번지부터 시작한다.
CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다.

운영체제도 프로그램이므로 메모리에 올라와야 실행할 수 있다.
전원 버튼을 누르면 사용자가 컴퓨터를 사용할 수 있는 환경을 마련하는 과정 즉 부팅이 이뤄지는데 이때 하드디스크에 저장된 운영체제가 메모리에 올라간다.

CPU 입장에서 메모리는 매우 느리다. CPU 안에 있는 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 몇 배 이상 느리다.
예를 들어 CPU 안에 있는 레지스터에 접근하려면 1~2클록이면 되지만 메모리에 있는 데이터를 CPU로 가져오려면 그 10배 이상의 클록이 필요하다.
이러한 속도 차이를 극복 하기 위해 CPU 안에 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와(prefetch) 작업한다.

또는 하드디스크나 SSD 같은 저장 장치를 메인 메모리의 보조 저장장치로 활용한다.

> **메모리에 있는 데이터를 CPU로 가져오는 과정**
> CPU가 메모리에 있는 데이터를 가져오기까지 필요한 과정을 생각해보면 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다. 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다. 메모리 버퍼 레지스터에 있는 데이터가 레지스터로 옮겨지면 메모리 접근 작업이 끝난다. FSB의 속도를 고려하면 CPU가 메모리에 접근하는 작업은 10클록 이상 걸린다

### 7.1.2 메모리 관리의 이중성

메모리 관리 시스템(MMS)이 메모리 관리를 한다.
현대 운영체제는 시분할 시스템으로 운영되어 모든 응용 프로그램이 메모리에 올라와 실행되므로 메모리 관리가 복잡하다.

프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데
이를 메모리 관리의 이중성이라 한다.

### 7.1.3 소스코드의 번역과 실행

프로그램은 메모리 관리와 밀접한 관련이 있다.

#### **소스코드의 번역 방식**

컴퓨터에서 작동하는 응용 프로그램은 프로그래밍 언어로 만들며, 작성한 프로그램은 보통 컴파일러를 사용하여 실행 가능한 코드로 변경한다.

언어 번역 프로그램은 고급언어로 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어로 번역한다.

대표적으로 컴파일러와 인터프리터다.

#### **컴파일러**

##### **오류 발견**

컴파일러는 오류를 찾기 위해 심벌 테이블을 사용한다. 심벌 테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블로 선언하지 않은 변수를 사용하지 않았는지, 변수에 다른 종류의 데이터를 저장하지 않았는지 알 수 있다.

##### **소스 코드 최적화**

컴파일러 방식을 사용하는 두 번째 목적은 최적화다. 소스코드에서도 군더더기와 사용하지 않는 변수를 삭제하면 더욱 간결해져 실행 속도가 빨라진다.

컴파일러는 실행 전 소스 코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.

그러나 인터프리터는 한 행씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하거나 필요 없는 변수를 확인할 수 없다.

#### **컴파일러의 컴파일 과정**

컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다. 이렇게 해서 만들어진 기계어 코드가 목적 코드로 확장자는 obj다

기계어라고 하지 않고 목적 코드라고 하는 이유는 아직 처리할 단계가 남아있기 때문이다.

목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.

라이브러리는 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로 프로그래머가 직접 만들기 어렵거나 만드는데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것이다.

C 언어 코드에는 printf()문이 있는데 컴파일러는 라이브러리 연결 단계에서 printf() 문에 해당하는 기계어 코드를 <stdio.h> 라이브러리에서 가져와 목적 코드에 삽입한다.

printf 문에 더 좋은 기능이 추가되었다고 가정하자.

과거에는 새로운 printf()문의 실행 코드가 담긴 stdio.h 라이브러리를 가져와 다시 컴파일 해야 했다. 하지만 매번 새로운 라이브러리를 가져와 다시 컴파일 하는 것은 번거로운 일이다.

오늘날의 프로그래밍에서는 printf() 문의 자리를 비워놓고 컴파일 한 후 printf() 문의 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용한다

이렇게 실행할 때 삽입되는 라이브러리를 동적 라이브러리라고 한다.

동적 라이브러리 방식에서는 함수가 변경되어도 새로 컴파일할 필요 없이 새로운 라이브러리만 사용하여 실행하면 된다.

윈도우에서 동적 라이브러리 파일을 DLL이라고 한다. 윈도우에서 함수의 변경이 일어나면 DLL 파일을 특정 폴더에 삽입하여 새로운 기능을 사용할 수 있다.

### 7.1.4 메모리 관리 작업

메모리 관리 작업은 크게 가져오기, 배치, 재배치로 구분된다.

#### **메모리 가져오기**

실행할 프로세스와 데이터를 메모리로 가져오는 작업이다.

그런데 어떤 상황에서는 데이터의 일부만 가져와 실행하기도 한다.

예를 들어 용량이 큰 동영상을 실행해야 하는데 메모리가 충분하지 않다면 동영상 플레이어를 먼저 가져와 실행하고 동영상 데이터는 필요할때마다 수시로 가져와 실행한다.

#### **메모리 배치**

가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다.

배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다. 같은 크기로 자르느냐, 실행되는 프로세스의 크기에 맞게 자르느냐에 따라 복잡성이 달라지기 때문이다.

같은 크기를 자르는 것을 페이징이라고 하고 프로세스의 크기에 맞게 자르는 것을 세그먼테이션이라고 한다.

효율적인 정책을 고려하는 것이 중요하다.

#### **메모리 재배치**

새로운 프로세스를 가져와야 하는데 꽉 찼다면 기존 메모리에 있는 프로세스를 하드 디스크로 옮겨놓아야 새로운 프로세스를 메모리에 가져올 수 있다.

이처럼 꽉찬 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 보내는 작업을 재배치 작업이라고 한다.

그런데 자주 사용할 프로세스를 내보내면 성능이 떨어진다.

그래서 교체 알고리즘이 따로 있따.

## 7.2 메모리 주소

메모리에 접근 할 때는 주소를 이용한다.

메모리 주소는 물리 주소와 논리 주소로 나뉜다.

이 절에서는 두 주소의 차이와 주소를 지정하는 방법을 살펴보자.

### 7.2.1 32bit CPU와 64bit CPU의 차이

CPU를 나타낼 때의 비트는 CPU가 한 번에 달루 수 있는 데이터의 최대 크기를 의미한다.

CPU의 비트는 메모리 주소 공간의 크기와도 연관이 있다.

CPU의 경우 메모리 주소 레지스터의 크기가 2^32개인데 약 4GB이다.
그래서 32bit CPU는 최대 4GB 까지 쓸 수 있다.

64bit의 CPU는 레지스터의 크기 버스의 대역폭 한 번에 처리되는 데이터의 최대 크기 등이 2배인데 16,777,216TB이기 때문에 크게 사용할 수 있따.

컴퓨터에는 메모리가 설치되고 각 메모리에는 주소 공간이 있다.

메모리의 주소 공간을 물리 주소 공간이라고 하는데 이는 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.

반대로 사용자 입장에서 바라본 주소 공간을 논리 주소 공간이라고 한다.

### 7.2.2 논리 주소와 물리 주소

#### **메모리 영역의 구분**

메모리 관리를 설명하기 위해 단순 메모리 구조를 살펴보자, 메모리 관리자는 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다.

운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에 사용자가 운영체제가 침범하지 못하도록 분리해서 관리한다.

그림에서 운영체제가 0~359번지를 사용하고 사용자가 360~999번지를 사용한다.

사용자 운영체제는 운영체제 영역을 피하여 메모리에 적재된다.

360번지부터 적재되는데 만약 운영체제 영역을 399번지까지 사용한다면 사용자 프로세스가 400번지부터 적재돼야 한다.

그런데 이처럼 운영체제의 크기에 따라 매번 적재되는 주소가 달라지면 번거롭다.

이를 개선한 방법이 사용자 프로세스의 최상위부터 사용하는 것이다.

즉 메모리를 최상위에서 운영체제 방향으로 내려오면서 사용한.

이 방법을 쓰면 운영체제의 크기에 상관없이 사용자 영역의 시작점을 결정할 수 있으나 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡해진다.

사용자 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요한데 이는 CPU 내에 있는 경계레지스터가 담당한다.

경계 레지스터는 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진다.

메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 경계 레지스터가 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료한다.

#### **논리 주소와 물리 주소의 변환**

`char alp = 'A'` 이러한 프로그램 코드를 실행시켜보면 메모리의 어딘가에 A가 저장된다

그 주소를 40번지라고 해보자

코드가 컴파일되어 실행 파일이 만들어졌다.

해당 실행 파일에는 40번지에 A를 넣는 기계어 코드가 있다.

해당 코드가 실행되면 프로세스가 메모리에 올라온다.

여기서 메모리는 물리적으로 설치된 메인 메모리를 말한다.

물리 메모리도 0번지부터 시작하는 주소를 가지고 있다.

중요한 것은 실행 파일에 40번지의 A가 들어간다고 해서 실제 물리 메모리의 40번지에 A가 들어가는 것은 아니라는 점이다.

실행을 위해 프로세스가 메모리에 올라오면 이 메모리는 빈 공간에 배치된다.

빈 공간의 시작 주소는 물리 메모리 주소의 100번지 일 수 있고 300번지 일 수도 있다.

물리 메모리의 360번지부터 프로세스가 사용한다고 가정해 보자.

이 경우 40번지는 물리 메모리의 주소 400번지가 된다.

여기서 400번지는 물리 주소다.

물리 주소는 메모리의 입장에서 바라본 주소다.

즉 메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소를 말한다.

40번지는 논리 주소이며, 이는 시작점을 0으로 놓았을 때 40번지의 위치에 있는 주소를 말한다.

프로세스 입장에서는 0번지부터 시작하는 논리주소가 편하다.

기억할 것은 프로그램이 실행될 때마다 시작하는 물리 주소는 매번 바뀐다는 점이다.

이렇듯 논리 주소와 물리 메모리에서 사용하는 물리 주소 사이에 차이가 발생한다.

프로세스가 사용하는 논리 주소는 논리 주소 공간에 있다.

논리 주소 공간은 항상 0번지부터 시작하며 컴퓨터가 허용하는 최대의 주소 크기를 가진다.

컴파일러는 논리 주소 공간의 0번지부터 변수들을 배치한다.

물리 주소 공간도 0 번지부터 시작하지만 최대 주소 크기는 컴퓨터에 설치된 메모리 크기에 따라 달라진다.

다시 말해, 컴퓨터에 실제로 설치된 메모리의 크기가 마지막 주소가 된다.

논리 주소로 이루어진 프로세스를 실행하면 이를 물리 주소로 변환하는 작업이 필요하다.

이 작업은 메모리 관리 유닛이 담당한다.

메모리 관리 유닛은 CPU 안에 존재하며 프로세스가 논리 주소에 접근할 때마다 이를 물리 주소로 변환하는 작업을 한다.

메모리 관리 유닛이 논리 주소를 물리 주소로 변환하는 과정은 다음과 같다.

1. 사용자 프로세스가 논리 주소 40번지에 있는 데이터를 요청한다.
2. CPU는 메모리 관리 유닛에 40번지에 있는 내용을 가져오라고 명령한다.
3. 메모리 관리 유닛은 재배치 레지스터를 사용하여 메모리 400번지에 저장된 데이터를 가져온다.

재배치 레지스터는 주소 변환의 기본이 되는 주소 값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소 값이 저장된다.

사용자 영역의 시작 주소 값이 360이므로 360번지가 재배치 레지스터에 저장된다.

사용자 프로세스 입장에서는 메모리 관리자가 재배치 레지스터를 사용하여 논리 주소를 물리 주소로 변환하기 때문에 메모리가 항상 0번지부터 시작하는 연속된 작업 공간으로 보인다.

## 7.3 단일 프로그래밍 환경의 메모리 할당

### 7.3.1 메모리 오버레이

과거에 메모리가 값비싼 장비였기 때문에 MS-DOS가 기본 메모리가 640KB로 한정되어있는데 이는 640KB를 넘을 수 없을 것이라 생각해서 그렇다.
과거에는 작은 메모리로 큰 메모리의 프로그램을 어떻게 작동할것인가의 문제였다.

실제로 메모리보다 큰 메모리도 적당한 크기로 잘라서 가져오는 기법을 메모리 오버레이라고 한다.

오버레이는 하나의 메모리를 여러 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말한다.

모듈을 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다.

전체 프로그램을 올려놓고 실행하기에는 메모리의 크기가 작기 때문에 실행하는 데 필요한 모듈만 올려놓고 나머지는 필요할 때마다 메모리에 가져와 사용하는 것이다.

이 방식은 프로그램 전체를 메모리에 올리는 것보다 느리지만 메모리가 프로그램보다 작을 때도 실행할 수 있어서 유용하다.

이때 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 프로그램 카운터가 결정한다.

해당 모듈이 메모리에 없으면 메모리 관리자에게 요청하여 가져오게 한다.

한정된 메모리에서 메모리보다 큰 프로그램을 실행할 수 있다.

프로그램 전체가 아니라 일부만 메모리에 올라와도 실행할 수 있다.

프로그램은 개념적으로 한 덩어리지만 일부부만으로도 실행할 수 있다.

이는 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미이기도 하다.

### 7.3.2 스왑

메모리 오버레이가 처리해야할 문제는 남아있는데

도마의 크기가 작아 고깃덩어리를 잘라서 손질했다 이런 상황에서 다른 고깃덩어리를 가져와 손질하려면 현재 도마에 있는 고깃덩어리를 치워야한다.

어디로 치우는 것이 좋을까 ?

보관 창고에 가져다 놓되 다른 고기와 섞이지 않도록 별도의 공간에 임시로 저장하면 된다.

모듈 B를 가져올 때 먼저 메모리에 올라온 모듈 A를 어딘가에 보관해야 한다.

쉽게 생각하면 모듈 A를 원래의 하드디스크 위치에 옮겨 놓으면 되겠지만,

다시 사용할지도 모르고 아직 작업이 끝나지 않았기 때문에 저장장치의 별도 공간에 보관해야 한다.

이처럼 메모리가 모자라서 쫓겨난 프로세스의 저장장치의 특별한 공간에 모아두는데 이러한 영역을 **스왑 영역이**라 한다.

스왑 영역에서 메모리로 데이터를 가져오는 작업을 스왑인 메모리에서 스왑 영역으로 데이터를 내보내는 작업을 스왑 아웃이라고 한다.

스왑 영역은 메모리 관리자가 관리한다.

원래는 하드디스크 같은 저장장치는 저장장치 관리자가 관리하지만

스왑 영역은 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리한다.

메모리 오버레이에서는 메모리보다 큰 프로그램을 실행할 때

프로그램을 메모리보다 작은 크기의 모듈로 나누어서 사용한다.

여기에 스왑을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식된다.

사용자는 실제 메모리와 스왑 영역의 크기를 합쳐서 전체 메모리의 크기로 인식하고 사용할 수 있다.

예를 들어 실제 메모리의 크기가 1GB, 스왑의 크기아 3GB라면 사용자가 인식하는 메모리 크기는 4GB다. 실제 메모리가 4GB인 컴퓨터보다 속도가 느리겠지만 스왑을 사용하여 실제 메모리의 모자란 부분을 보충할 수 있다.

사용자 입장에서는 실제 메모리의 크기에 상관없이 큰 프로그램을 실행할 수 있다.

유닉스 운영체제는 하드디스크의 분리된 파티션에 스왑 영역을 배정하기 때문에 스왑 영역을 확인하기가 어렵다.

스왑 영역을 확인하려면 free 명령을 사용해야 한다.

free는 메모리의 상태를 보여주는 명령어이며 -m은 메가바이트 단위로 출력하라는 의미다.

보통 유닉스 계열의 운영체제에서는 스왑 영역의 크기를 메모리의 2배 정도로 잡는다.

## 7.4 다중 프로그래밍 환경의 메모리 할당

한 번에 한 프로세스만 실행되는 단순 메모리 구조에서 메모리 오버레이와 스왑 개념을 살펴보았다.
이 절에서는 한 번에 여러 프로세스가 실행되는 구조의 메모리 문제를 살펴본다.

### 7.4.1 메모리 분할 방식

메모리를 어떤 크기로 나눌것인가는 메모리 배치 정책에 해당한다.
메모리에 여러 개의 프로세스를 배치하는 방법은 크게 가변 분할 방식과 고정 분할 방식으로 나뉜다.

- **가변 분할 방식**: 프로세스의 크기에 따라 메모리를 나눈다.
- **고정 분할 방식**: 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눈다.

#### **메모리 분할 반식의 구현과 장단점**

**가변 분할 방식의 구현**

가변 분할 방식에서는 프로세스의 크기에 맞게 메모리가 분할되므로 프로세스가 차지하는 메모리 영역의 크기가 40KB에서 17KB까지 다 다르다. 가변 분할 방식에서는 한 프로세스가 메모리의 연속된 공간에 배치되기 때문에 연속 메모리 할당이라고 한다.

물리 메모리에서 하나의 프로세스에 해당하는 주소 공간이 연속적으로 이어지기 때문이다.

**고정 분할 방식의 구현**

고정 분할 방식에서는 프로세스의 크기에 상관없이 20KB의 같은 크기로 나뉜다.

따라서 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다.

고정 분할 방식에서는 40KB인 프로세스 A가 20KB의 프로세스 A1과 20KB의 프로세스 A2가 나뉘어 배치된다.

30KB의 프로세스 C도 20KB의 프로세스 C1과 10KB의 프로세스 C2로 나뉘는데 물리 메모리 내에는 프로세스 C1만 있다.

물리 메모리가 부족하기 때문에 프로세스 C2는 스왑 영역에 있다. 고정 분할 방식에서는 하나의 프로세스가 여러 개로 나뉘어 배치되기 때문에 비연속 메모리 할당이라고 한다.

**가변 분할 방식의 구현**

가변 분할 방식의 장점은 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치할 수 있다는 점이다.

그러나 메모리 관리가 복잡하다는 단점이 있다.

가변 분할 방식에서 프로세스 B와 D가 작업을 마치면 각각 18KB와 17KB의 빈 공간이 생긴다.

이때 19KB 이상의 프로세스를 메모리에 배치할 수 없다.

19KB 이상의 프로세스에 연속적인 공간을 할당하려면 떨어져 있는 빈 공간들을 합쳐야 한다.

이 과정에서 프로세스 C의 자리도 옮겨야 한다.

이처럼 가변 분할 방식은 메모리 통합 등의 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.

**고정 분할 방식의 장단점**
고정 분할 방식은 메모리를 일정 크기로 나누기 때문에 메모리관리가 편하다는 장점이 있다.

메모리 통합 같은 부가적인 작업을 할 필요가 없다.

고정 분할 방식의 단점은 하나의 프로세스가 여러 곳으로 나뉠 수 있다는 점이다.

그러나 앞에서 메모리 오버레이를 다룰 때 프로세스가 여러 곳에 나뉘어 배치되거나 일부만 물리 메모리에 있고 나머지는 스왑 영역에 있어도 실행에는 문제가 없다고 설명하였다.

따라서 고정 분할 방식은 가변 분할 방식보다 메모리 관리 측면에서 유리하다.

이러한 이유로 현대 운영체제에서 메모리 관리는 기본적으로 고정 분할 방식을 사용한다.

### 7.4.2 가변 분할 방식의 메모리 관리

#### **가변 분할 방식의 특징**:

가변 분할 방식은 프로세스의 크기에 맞춰 메모리를 할당하는 방법으로 \*\*\*\*세그먼 테이션 메모리 관리 기법이라고 한다.

프로세스를 하나의 연속된 주소로 다룬다는 장점이 있다.

프로세스들이 메모리에 올라와 작업하다가 종료되면 빈 공간이 생긴다.

가변 분할 방식의 가장 큰 문제점은 빈 공간의 크기가 일정하지 않다는 것이다.

프로세스가 A~E가 실행되다가 프로세스 B와 D가 종료되면 각각 B,D 만큼의 빈 공간이 생긴다. 이 상태에서는 그 용량을 넘는 프로세스를 할당할 수 없고 이를 \**외부 단편화*화라고 한다.

그래서 이러한 문제를 해결하기 위해 메모리 배치 방식, 조각 모음을 사용한다.

메모리 배치 방식은 작은 조각이 발생하지 않도록 프로세스를 배치하는 것이며, 조각 모음은 조각이 발생했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업이다.

가변 분할 방식에서 메모리 배치 방식은 선처리에 해당하고 조각 모음은 후처리에 해당한다.

#### **메모리 배치 방식**:

가변 분할 방식의 외부 단편화 문제를 해결하기 위한 대표적인 메모리 배치 방식으로 최초 배치, 최적 배치, 최악 배치가 있다.
이 외에도 버디 시스템이 있다.

#### **조각 모음**:

##### **최초 배치**: 단편화를 고려하지 않는 방식으로, 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 놓음.

##### **최적 배치**: 메모리의 빈 공간을 모두 확인한 후 가장 비슷한 곳에 프로세스를 배치하는 방법이다.

##### **최악 배치**: 빈 공간을 모두 확인 한 후 가장 큰 공간에 프로세스를 배치하는 것으로 최적 배치와 정 반대되는 개념이다.

최초 배치 방식은 빈 공간을 찾아다닐 필요가 없다는 장점이 있다.

최적 배치 방식을 사용하면 빈 공간을 모두 확인하는 부가적인 작업이 있지만 딱 맞는 공간을 찾을 경우 단편화가 일어나지 않는다.

그러나 딱 맞는 공간이 없을 때는 아주 작은 조각을 만들어낸다는 단점이 있다.

최악배치 방식은 최적 배치와 반대로 접근한다.
최적 배치 방식에서는 프로세스를 배치하고 남은 공간이 작아 이 공간이 쓸모없지만, 최악 배치 방식에서는 프로세스를 배치하고 남은 공간이 작아 이 공간이 쓸모없지만 남은 공간이 크기 때문에 이 공간이 쓸모가 있다.

그래서 빈 공간의 크기가 클 때는 효과적이지만 빈 공간의 크기가 점점 줄어들면 최적 배치처럼 작은 조각을 만들어내므로 효과가 떨어진다.

#### **조각 모음**

가변 분할 방식에서는 메모리에 올라오는 프로세스가 차례대로 배치되기 때문에 공간 사용에는 큰 문제가 없다.

그러나 작은 프로세스가 작업을 마치고 나가면 그 공간이 조각으로 남아 쓸모없어질 가능성이 크다.

이렇게 단편화가 발생하면 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만들어야 하는데 이를 조각 모음이라고 한다.

메모리 통합이라 부르기도 한다.

1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.

2. 프로세스를 적단한 위치로 이동한다. 프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 논리 주소 값을 바꾼다.

3.앞의 1,2 작업을 다 마친 후 프로세스를 다시 시작한다.

조각 모음을 하려면 프로세스를 멈추고, 이동하고, 주소를 바꾸고, 다시 시작하는 작업을 해야 하므로 많은 시간이 걸린다.

이처럼 가변 분할 방식은 외부 단편화로 인해 조각 모음 같은 부가적인 작업이 필요하므로 메모리 관리가 복잡하다

> 하드디스크의 조각 모음과 SSD
> 외부 단편화는 하드디스크와 같은 저장장치에서도 발생한다. 하드디스크에는 동영상과 같은 큰 파일도 저장되고 문서와 같은 작은 파일도 저장된다. 빈 하드디스크에 데이터를 채우면 데이터가 차곡차곡 쌓이다가 삭제와 저장을 반복하면 데이터가 여러 공간에 나뉘어 저장된다. 이러한 현상은 시간이 흐를 수록 심해지고 결국 하드디스크의 데이터 입출력 속도를 떨어뜨려 컴퓨터의 성능을 저하하는 원인이 된다. 따라서 하드디스크와 같은 저장장치도 성능을 유지하려면 주기적으로 조각 모음을 실행해야 한다. 하드디스크와 달리 플래시 메모리를 사용하는 SSD는 단편화 때문에 성능이 저하되지 않는다. 따라서 과거에는 하드디스크 조각 모음을 하는 프로그램이 많았으나 SSD가 대중화된 오늘날에는 조각 모음의 중요성이 현저히 떨어졌다.

### 7.4.3 고정 분할 방식의 메모리 관리

고정 분할 방식을 사용하여 물리 메모리를 나누는 방식을 페이징 메모리 관리 기법이라고 한다.

한 책에서 모든 페이지의 크기가 같기 때문에 페이징이라고 부른다.

가변 분할 방식과 달리 고정 분할 방식은 프로세스의 크기에 상관없이 메모리를 같은 크기로 나누기 때문에 관리하기가 편하다.

그래서 현대의 메모리 관리는 페이징을 기본으로 한다.

고정 분할 방식을 물리 메모리에 적용한 모습이다.

분할된 크기가 20KB 이므로 40KB는 A1, A2로 나뉘고, 30KB C는 C1,C2로 나뉘는데 C2는 공간이 없어서 스왑 영역으로 옮겨진 상태다.

이러한 분할 방식의 단점은 나뉜 메모리 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생긴다는 점이다.

20kb로 나누었다고 가정하자 18kb인 프로세스 B와 17kb인 프로세스 D에서 사용할 수 없는 메모리 영역이 각각 2kb, 3kb가 생겼다 이처럼 각 메모리 조각에 프로세스를 배치하고 공간이 남는 것을 **내부 단편화**라고 한다.

가변 분할 방식의 외부 단편화는 조각 모음으로 조정했으나 고정 분할 방식에서는 내부 단편화를 해결하기 위해 조각 모음을 할 수 없고 남은 공간을 다른 프로세스에 배정할 수도 없다.

따라서 고정 분할 방식에서는 내부 단편화를 줄이기 위해 메모리를 어떤 크기로 나눌지 신중하게 결정해야 한다.

| 구분             | 가변 분할 방식                   | 고정 분할 방식             |
| ---------------- | -------------------------------- | -------------------------- |
| 메모리 관리 기법 | 세그먼테이션                     | 페이징                     |
| 특징             | 연속 메모리 할당                 | 비연속 메모리 할당         |
| 장점             | 프로세스를 한 덩어리로 관리 가능 | 메모리 관리가 편함         |
| 단점             | 빈 공간 관리가 어려움            | 프로세스가 분할되어 처리됨 |
| 단편화           | 외부 단편화                      | 내부 단편화                |

### 7.4.4 버디 시스템

가변 분할 방식의 단점인 외부 단편화를 완화하는 방법으로 버디 시스템이 있다.

버디 시스템은 가변 분할 방식과 고정 분할 방식의 중간 구조다.

버디 시스템의 작동 방식은 다음과 같다.

1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치한다.
2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

버디 시스템에서 메모리에 프로세스를 배치할 때는 프로세스의 크기에 맞게 메모리를 1/2 크기로 잘라나간다.

버디 시스템에서는 사용이 끝나면 주변을 하나의 덩어리로 만든다.

**버디 시스템 특징**

가변 분할 방식과 고정 분할 방식의 특징을 모두 가지고 있다.

가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉘며, 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다.

가변 분할 방식에 비해 버디 시스템에서 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여 있어 통합하기 쉽기 때문이다.

가변 분할 방식에서는 작은 조각이 큰 조각 사이사이에 있어 조각을 모으려면 큰 덩어리를 옮겨야 한다.

그러나 버디 시스템에서는 비슷한 크기의 조각이 서로 모여있기 때문에 작은 조각을 통합하여 큰 조각을 만들기가 쉽다.

효율적인 공간 관리 측면에서 보면 고정 분할 방식과 버디 시스템은 비슷한 수준이다.
그러나 메모리 관리 측면에서 공간을 1/2로 나누어가며 메모리를 배분하는 버디 시스템보다 모든 공간을 똑같은 크기로 나누는 고정 분할 방식이 단순하기 때문에 버디 시스템보다 고정 분할 방식을 많이 사용한다.

## 7.5 분할 컴파일과 메모리 관리

이 절에서는 컴파일 과정에서 메모리가 어떻게 배정되는지를 살펴본다.

### 7.5.1 분할 컴파일

C나 자바로 작성한 소스코드는 컴파일 과정을 거쳐 목적 코드가 된다.

컴파일러는 고급 언어로 소스코드를 기계어로 번역하면서 여러 가지 작업을 수행한다.

요류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다.

이렇게 만들어진 기계어 코드가 목적 코드다.

기계어 코드라고 하지 않고 목적 코드라고 하는 이유는

기계어 코드로 가기전 초벌 번여 상태라고 생각하면 된다.

여러 개의 소스코드 파일을 사용하여 하나의 실행 파일을 만드는 것을 다중 소스 코드라고 하고, 여러 개의 소스 코드를 각각 컴파일하여 하나의 실행 파일로 만드는 것을 분할 컴파일이라고 한다.

다중 소스코드 방식으로 커다란 코드를 2명이 나누어 작성하는 팀 프로젝트를 수행한다 가정했을 때.

한 명은my_main.c other.c를 만든다. 그리고 컴파일 하기 위해 두 코드를 붙여 하나로 만들었다.

이 처럼 2개의 소스코드를 한쪽에 복사하여 하나의 소스코드로 만든후 컴파일 해보면 상당히 오류가 발생하는데.

한 명이 해도 어려운데 합치니까 더 어려운 일

분할 컴파일의 경우를 생각해보자 실행 파일이 만들어지기 전에 일차적으로 목적 파일이 만들어진다.

목적 파일은 오류 검사를 거쳐 만든 중간 파일이고, 외부 함수가 비어 있는 상태다.

프로젝트를 담당하는 두 사람은 자신의 코드를 컴파일하여 목적 코드를 만든다. other.obj와 my_main.obj가 만들어진다.

목적 코드는 이미 검사가 끝난 코드라서 다시 검사할 필요가 없어서 같이 컴파일하면 오류 없는 실행 파일이 만들어지는데

이러한 방식이 분할 컴파일이다.

### 7.5.2 변수와 메모리 할당

이러한 과정을 살펴본 이유는 컴파일과 메모리 사이에 연관 관계가 있기 때문이다.
컴파일 과정에서 가장 중요한 것은 메모리를 확보하고 정리하는 부분이다.
다음 코드 선언 부를 살펴보자.

```cpp
char str='a';
int vol=7;
float pri=2.3;
```

기계어는 메모리 주소를 사용한다.

따라서 기계어에서 메모리 주소 0번지에 a로 넣으라는 명령으로 번역되어 컴파일러는 0번지에 a를 넣고 이곳을 문자형이 들어가는 공간으로 기억한다.

다른 명령도 마찬가지다. int vol=7;은 메모리의 1번지부터 4번지까지 확보한 후 그곳에 정수 7을 넣는다.

float pri=2.3도 메모리 5번지 부터 12번지까지 확보한 후 실수 2.3를 넣는다.

char, int, float은 보관하는 자료의 형태가 아니라 사용하려는 메모리의 크기를 나타내기도 한다. (cpp에서 float은 4바이트인데 책이 잘못됨)

기억해야할 점은 변수가 메모리 주소의 또 다른 이름이라는 점이다.
