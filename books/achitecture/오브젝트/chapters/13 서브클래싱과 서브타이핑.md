# 13 서브클래싱과 서브타이핑

## 타입

### 타입이란?
- 개념의 분류
- 타입은 개념을 대표하는 심볼
- 타입에 속하는 객체는 해당 개념의 인스턴스

### 프로그래밍 언어의 타입
- 비트 열을 특정한 데이터 타입으로 해석
- 메모리 안의 데이터가 어떤 의미를 가지는지 결정
- 어떤 연산을 적용할 수 있는지 결정

## 객체지향 패러다임의 타입

### 타입의 세 가지 요소
1. **심볼**: 타입의 이름
2. **내연**: 타입의 정의 (타입에 속하는 객체들이 가지는 공통적인 속성)
3. **외연**: 타입에 속하는 객체들의 집합

### 객체의 타입
- 객체가 수신할 수 있는 메시지의 집합
- 퍼블릭 인터페이스가 타입을 결정
- 동일한 퍼블릭 인터페이스 = 동일한 타입

## 서브타입

### 서브타입이란?
- 타입 계층을 구성하는 두 타입 사이의 관계
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주

### is-a 관계
- 서브타입은 슈퍼타입의 한 종류
- "is-a" 관계로 표현
- 예: 펭귄 is-a 새

### 행동 호환성
- 핵심은 행동의 호환성
- 퍼블릭 인터페이스가 호환되어야 함
- 대체 가능성 (substitutability)

## 서브클래싱과 서브타이핑

### 서브클래싱 (Subclassing)
- **상속의 목적**: 코드 재사용
- 구현 상속 (implementation inheritance)
- 타입 계층과 무관
- **나쁜 상속**

### 서브타이핑 (Subtyping)
- **상속의 목적**: 인터페이스 상속
- 타입 계층 구축
- 다형성을 위한 상속
- **좋은 상속**

## 리스코프 치환 원칙 (LSP)

**서브타입은 그것의 기반 타입으로 치환 가능해야 한다**

### 클라이언트와 격리
- 클라이언트는 차이점을 몰라야 함
- 동일하게 행동해야 함
- 대체 가능해야 함

### 행동 호환성
- 메서드의 시그니처만 같다고 되는 것이 아님
- 행동이 호환되어야 함
- 클라이언트의 관점에서 대체 가능

## 계약에 의한 설계 (Design by Contract)

### 계약의 구성 요소
1. **사전조건 (Precondition)**: 메서드 실행 전에 만족해야 할 조건
2. **사후조건 (Postcondition)**: 메서드 실행 후에 만족해야 할 조건
3. **클래스 불변식 (Class Invariant)**: 항상 유지되어야 하는 조건

### 서브타입의 계약 규칙
- **사전조건을 강화할 수 없다**: 더 약한 사전조건 허용
- **사후조건을 약화할 수 없다**: 더 강한 사후조건 허용
- **슈퍼타입의 불변식을 유지해야 한다**

### 예시
```java
// 슈퍼타입
class Rectangle {
    // 사전조건: width > 0
    // 사후조건: getWidth() == width
    void setWidth(int width) { ... }
}

// 서브타입
class Square extends Rectangle {
    // 잘못된 예: 사전조건 강화 (width == height만 허용)
    void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width);  // 추가 제약
    }
}
```

## 가변성 규칙

### 공변성 (Covariance)
- 서브타입의 반환 타입은 슈퍼타입보다 더 구체적일 수 있음
- `S <: T`이면 `f(S) <: f(T)`

### 반공변성 (Contravariance)
- 서브타입의 파라미터 타입은 슈퍼타입보다 더 추상적일 수 있음
- `S <: T`이면 `f(T) <: f(S)`

### 무공변성 (Invariance)
- 타입이 정확히 같아야 함

## 리스코프 치환 원칙 위반 사례

### 정사각형-직사각형 문제
```java
Rectangle r = new Square();
r.setWidth(10);
r.setHeight(20);
// Square는 width와 height가 항상 같아야 하므로
// Rectangle의 행동을 제대로 구현할 수 없음
```

### 펭귄-새 문제
```java
Bird bird = new Penguin();
bird.fly();  // 펭귄은 날 수 없음!
// Penguin은 Bird의 행동을 모두 지원할 수 없음
```

## 클라이언트와 대체 가능성

### 클라이언트의 기대
- 슈퍼타입의 계약을 만족하는 행동
- 예상 가능한 결과
- 일관성 있는 동작

### 행동의 호환성
- 단순히 메서드 시그니처가 같다고 되는 것이 아님
- 클라이언트가 기대하는 행동을 만족해야 함
- 놀라움이 없어야 함 (Principle of Least Surprise)

## 서브타이핑 판단 기준

### is-a 관계만으로는 부족
- "펭귄 is-a 새"라고 해서 상속이 적절한 것은 아님
- 행동의 호환성이 핵심

### 행동 호환성 확인
1. 클라이언트를 파악한다
2. 클라이언트가 기대하는 행동을 식별한다
3. 서브타입이 그 행동을 만족하는지 확인한다
4. 리스코프 치환 원칙을 만족하는지 검증한다

## 클라이언트 분리

### 인터페이스 분리 원칙 (ISP)
- 비대한 인터페이스를 분리
- 클라이언트 특화 인터페이스
- 클라이언트가 사용하는 메시지만 포함

### 해결 방법
```java
interface Flyable {
    void fly();
}

interface Walkable {
    void walk();
}

class Bird implements Walkable { ... }
class FlyingBird extends Bird implements Flyable { ... }
class Penguin extends Bird { ... }
```

## 조건부 로직과 다형성

### 조건부 로직의 문제
- 타입 체크 (instanceof)
- 클라이언트가 서브타입을 알게 됨
- 변경에 취약

### 다형성으로 대체
- 조건부 로직을 다형성으로 변환
- 새로운 타입 추가 시 기존 코드 변경 불필요
- 개방-폐쇄 원칙 (OCP) 준수

## 교훈

1. **서브타이핑을 위한 상속을 사용하라**
2. **리스코프 치환 원칙을 준수하라**
3. **행동의 호환성에 집중하라**
4. **클라이언트의 관점에서 설계하라**
5. **is-a 관계만으로 상속을 결정하지 마라**
6. **계약에 의한 설계를 활용하라**
7. **인터페이스를 분리하라**
