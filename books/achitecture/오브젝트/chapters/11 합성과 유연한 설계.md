# 11 합성과 유연한 설계

## 상속을 합성으로 변경하기

### 상속의 문제점 복습
1. 불필요한 인터페이스 상속 문제
2. 메서드 오버라이딩의 오작용 문제
3. 부모 클래스와 자식 클래스의 동시 수정 문제

### 합성으로 해결
- 구현이 아닌 인터페이스에 의존
- 런타임에 객체 사이의 관계 결정
- 변경에 유연한 설계

## 상속으로 인한 조합의 폭발적인 증가

### 문제 상황
- 하나의 기능을 추가하기 위해 많은 서브클래스 생성
- 기능 조합이 늘어날수록 클래스 수가 기하급수적으로 증가
- **클래스 폭발(Class Explosion)** 문제

### 예시
```
할인 정책 + 세금 정책의 조합
- RegularDiscountTaxableMovie
- AmountDiscountTaxableMovie
- PercentDiscountTaxableMovie
- RegularDiscountTaxFreeMovie
- AmountDiscountTaxFreeMovie
- PercentDiscountTaxFreeMovie
```

## 합성을 이용한 문제 해결

### 기본 방법
1. 역할을 인터페이스로 정의
2. 인터페이스를 구현하는 클래스 작성
3. 합성으로 런타임에 객체 조합

### 장점
- 조합 가능한 행동들을 독립적으로 구현
- 실행 시점에 동적으로 조합
- 클래스 폭발 문제 해결

## 믹스인

### 믹스인이란?
- 다른 코드를 포함시킬 수 있는 방법
- 상속과 달리 독립적으로 작성
- 필요한 시점에 코드를 섞어 넣음

### 스칼라의 trait
```scala
trait TaxableMovie extends Movie {
    override def calculateFee(screening: Screening): Money = {
        val fee = super.calculateFee(screening)
        fee.plus(fee.times(taxRate))
    }
}
```

### 믹스인의 특징
- 코드 재사용을 위한 설계 기법
- 클래스를 독립적으로 작성
- 조합을 통해 새로운 기능 구현

## 쌓을 수 있는 변경

### 데코레이터 패턴
- 객체의 행동을 동적으로 추가
- 기본 객체에 추가 기능을 '장식'
- 투명하게 기능 추가

### 구현
```java
public abstract class MovieDecorator implements Movie {
    private Movie movie;
    
    public MovieDecorator(Movie movie) {
        this.movie = movie;
    }
    
    @Override
    public Money calculateFee(Screening screening) {
        return movie.calculateFee(screening);
    }
}
```

### 장점
- 기본 기능을 확장
- 여러 장식을 쌓을 수 있음
- 런타임에 기능 조합 가능

## 컴파일타임 의존성과 런타임 의존성

### 유연한 설계
- 컴파일타임: 추상화에 의존
- 런타임: 구체 클래스 인스턴스 사용
- 두 의존성의 차이가 클수록 유연

### 트레이드오프
- 유연성 증가 ↔ 복잡성 증가
- 이해하기 쉬움 ↔ 변경하기 어려움
- 상황에 맞는 선택 필요

## 믹스인과 포워딩

### 포워딩
- 동일한 메서드를 호출하기 위해 다른 객체에게 요청을 전달
- 자신의 일부로 캡슐화된 다른 객체에게 요청 전달

### 위임 (Delegation)
- 포워딩 + 요청을 받은 객체가 self 참조를 전달한 경우
- 엄밀한 의미의 위임

## 유연성에 대한 고민

### 유연성이 필요한 경우
- 요구사항이 자주 변경될 때
- 다양한 조합이 필요할 때
- 확장 가능성이 높을 때

### 유연성이 불필요한 경우
- 요구사항이 명확하고 안정적일 때
- 단순한 구조로 충분할 때
- 성능이 중요할 때

### 기본 원칙
- 일단 단순하게 시작
- 변경이 필요할 때 유연하게 개선
- 과도한 유연성은 오히려 복잡성 증가

## 패턴 적용

### TEMPLATE METHOD 패턴
- 상속을 이용한 해결책
- 알고리즘의 구조를 정의
- 일부 단계를 서브클래스로 연기

### STRATEGY 패턴
- 합성을 이용한 해결책
- 알고리즘을 캡슐화
- 실행 중에 알고리즘 변경 가능

### DECORATOR 패턴
- 합성을 이용한 해결책
- 동적으로 책임 추가
- 투명한 인터페이스

## 교훈

1. **상속보다는 합성을 사용하라**
2. **클래스 폭발 문제를 경계하라**
3. **믹스인을 활용하라**
4. **데코레이터 패턴으로 기능을 조합하라**
5. **유연성과 단순성의 균형을 찾아라**
6. **작은 객체들의 조합으로 설계하라**
7. **코드 재사용보다 객체 조합에 집중하라**
