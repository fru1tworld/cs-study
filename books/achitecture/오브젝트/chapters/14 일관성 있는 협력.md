# 14 일관성 있는 협력

## 설계에 일관성 부여하기

### 일관성의 중요성
- 코드를 이해하기 쉬움
- 유지보수가 쉬움
- 예측 가능한 설계
- 팀원 간의 의사소통 원활

### 일관성 있는 설계란?
- 유사한 기능을 유사한 방식으로 구현
- 동일한 변경은 동일한 위치에서
- 예측 가능한 구조

## 핵심 원칙

### 1. 변하는 개념을 변하지 않는 개념으로부터 분리하라
- 변경이 예상되는 부분을 식별
- 변하지 않는 부분과 분리
- 추상화를 통한 분리

### 2. 변하는 개념을 캡슐화하라
- 변경을 캡슐화
- 외부로부터 감춤
- 인터페이스를 통한 접근

## 조건 로직 대 객체 탐색

### 조건 로직의 문제
```java
if (type == MovieType.AMOUNT_DISCOUNT) {
    // 금액 할인
} else if (type == MovieType.PERCENT_DISCOUNT) {
    // 비율 할인
} else {
    // 할인 없음
}
```

**문제점:**
- 새로운 타입 추가 시 모든 조건문 수정
- 변경에 취약
- 개방-폐쇄 원칙 위반

### 객체 탐색으로 전환
```java
discountPolicy.calculateDiscountAmount(screening);
```

**장점:**
- 다형성 활용
- 새로운 타입 추가 시 기존 코드 변경 불필요
- 개방-폐쇄 원칙 준수

## 일관성 있는 기본 정책 구현

### TEMPLATE METHOD 패턴
```java
public abstract class DiscountPolicy {
    public Money calculateDiscountAmount(Screening screening) {
        // 변하지 않는 부분
        for(DiscountCondition condition : conditions) {
            if (condition.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        return screening.getMovieFee();
    }
    
    // 변하는 부분 - 추상 메서드
    abstract protected Money getDiscountAmount(Screening screening);
}
```

### 일관성의 기준
- 유사한 기능은 유사한 구조
- 변하는 부분과 변하지 않는 부분의 분리
- 추상화를 통한 일반화

## 변경 분리하기

### 변경의 캡슐화
- 변경이 발생하는 부분을 식별
- 별도의 개념으로 분리
- 인터페이스를 통해 접근

### 예시: 할인 조건
```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}

// 순번 조건
class SequenceCondition implements DiscountCondition { ... }

// 기간 조건
class PeriodCondition implements DiscountCondition { ... }
```

## 일관성 있는 협력 패턴

### 협력 패턴의 구성 요소
1. **추상화된 인터페이스**: 변하지 않는 부분
2. **구체적인 구현 클래스**: 변하는 부분
3. **합성 또는 상속**: 관계 맺기

### 패턴의 반복
- 유사한 문제는 유사한 패턴으로 해결
- 팀 내에서 공유된 패턴
- 예측 가능한 구조

## 추상화 수준에서의 협력 패턴

### 높은 추상화 수준
- 도메인 개념을 표현
- 변하지 않는 본질
- 정책과 알고리즘의 구조

### 낮은 추상화 수준
- 구체적인 구현
- 변하는 세부사항
- 실제 동작

## 패턴을 따르는 설계

### STRATEGY 패턴 활용
```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

### 일관성 유지
- 동일한 패턴을 여러 곳에서 사용
- 할인 정책, 할인 조건, 가격 계산 등
- 예측 가능한 구조

## 유연성 추가하기

### NULL 객체 패턴
```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```

**장점:**
- null 체크 불필요
- 예외 케이스를 일반 케이스로 취급
- 일관성 유지

### TEMPLATE METHOD vs STRATEGY
- TEMPLATE METHOD: 상속을 통한 재사용
- STRATEGY: 합성을 통한 재사용
- 합성이 더 유연하지만 더 복잡

## 일관성 검증

### 설계 검토 질문
1. 유사한 기능이 유사한 방식으로 구현되었는가?
2. 변경이 한 곳에서만 일어나는가?
3. 새로운 기능 추가 시 기존 코드를 변경하지 않아도 되는가?
4. 팀원이 구조를 쉽게 이해할 수 있는가?

## 책임 주도 설계 적용

### 설계 절차
1. 책임을 찾는다
2. 적절한 객체를 찾는다
3. 협력을 설계한다
4. 패턴을 적용한다
5. 일관성을 검증한다

### 지속적인 개선
- 코드 리뷰를 통한 일관성 확인
- 리팩터링을 통한 개선
- 패턴의 공유와 확산

## 교훈

1. **유사한 기능은 유사한 구조로 구현하라**
2. **변하는 것과 변하지 않는 것을 분리하라**
3. **변경을 캡슐화하라**
4. **조건 로직을 객체 탐색으로 대체하라**
5. **일관성 있는 협력 패턴을 만들고 유지하라**
6. **추상화를 통해 일반화하라**
7. **팀 내에서 패턴을 공유하라**
