# 6장 메시지와 인터페이스

## 협력과 메시지

### 클라이언트-서버 모델

협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.

메시지를 전송하는 객체를 **클라이언트**, 메시지를 수신하는 객체를 **서버**라고 부른다.

협력은 클라이언트가 서버의 서비스를 요청하는 **단방향 상호작용**이다.

### 메시지와 메시지 전송

**메시지(message)**는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

**메시지 전송(message sending)** 또는 **메시지 패싱(message passing)**은 한 객체가 다른 객체에게 도움을 요청하는 것을 의미한다.

메시지 전송은 다음으로 구성된다:

- **메시지 수신자(receiver)**
- **메시지 이름(message name)**
- **인자(argument)**

### 메시지와 메서드

메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드**라고 부른다.

메시지와 메서드를 구분하는 것은 매우 중요하다.

**메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.**

**메시지 수신자는 누가 전송했는지 알 필요가 없다.**

### 퍼블릭 인터페이스와 오퍼레이션

객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스**라고 부른다.

프로그래밍 언어의 관점에서 **퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션(operation)**이라고 부른다.

**메서드(method)**는 메시지를 수신했을 때 실제로 실행되는 코드다.

### 시그니처

**시그니처(signature)**는 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 부르는 이름이다.

오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.

메서드는 시그니처와 구현을 포함한다.

## 인터페이스와 설계 품질

좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족해야 한다.

**최소한의 인터페이스**: 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.

**추상적인 인터페이스**: 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법:

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

### 디미터 법칙

**디미터 법칙(Law of Demeter)**은 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.

"낯선 자에게 말하지 말라(don't talk to strangers)" 또는 "오직 인접한 이웃하고만 말하라(only talk to your immediate neighbors)"로 요약할 수 있다.

디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다:

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

디미터 법칙을 위반하는 전형적인 코드는 **기차 충돌(train wreck)**이다:

```java
screening.getMovie().getDiscountConditions();
```

### 묻지 말고 시켜라

**묻지 말고 시켜라(Tell, Don't Ask)**는 메시지 전송자가 메시지 수신자의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 수신자의 상태를 변경해서는 안 된다는 것이다.

객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 **객체의 캡슐화를 위반**한다.

**묻지 말고 시켜라** 원칙에 따라 설계하면 객체는 자신이 관리하는 데이터를 직접 처리하게 되고, 자연스럽게 **정보 전문가**에게 책임이 할당된다.

### 의도를 드러내는 인터페이스

**의도를 드러내는 선택자(Intention Revealing Selector)**는 메서드 이름을 짓는 두 가지 방법 중에서 **'어떻게'가 아니라 '무엇'을 하는지 드러내는** 메서드 이름을 선택하라는 것이다.

```java
public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening) { ... }
}

public class SequenceCondition {
    public boolean isSatisfiedBySequence(Screening screening) { ... }
}
```

위 코드보다는:

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```

이렇게 **무엇을 하는지**를 드러내는 이름이 더 좋다.

### 함께 모으기

**의도를 드러내는 인터페이스**를 사용하면:

- 클라이언트 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있다
- 클라이언트는 서로 다른 타입의 객체를 동일한 방식으로 사용할 수 있다

## 원칙의 함정

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

```java
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```

위 코드는 여러 개의 도트(.)를 사용하지만 디미터 법칙을 위반하지 않는다.

IntStream을 다른 IntStream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐을 깨뜨리지 않는다.

### 결합도와 응집도의 충돌

**묻지 말고 시켜라**와 **디미터 법칙**을 무작정 따르면 응집도가 낮은 객체로 변모하게 될 가능성이 높다.

모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.

클래스는 하나의 변경 원인만을 가져야 한다는 **단일 책임 원칙**을 위반하게 된다.

## 명령-쿼리 분리 원칙

**명령-쿼리 분리(Command-Query Separation) 원칙**: 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다.

- **명령(Command)**: 객체의 상태를 수정하는 오퍼레이션
- **쿼리(Query)**: 객체와 관련된 정보를 반환하는 오퍼레이션

명령과 쿼리를 엄격하게 분리하면 다음과 같은 장점이 있다:

- 코드가 예측 가능하다
- 쿼리는 몇 번을 호출하든 상관없다
- 명령은 단 한 번만 호출해야 하지만 상태 변경을 예측할 수 있다

### 명령-쿼리 분리와 참조 투명성

명령과 쿼리를 분리함으로써 **참조 투명성(referential transparency)**의 장점을 제한적이나마 누릴 수 있다.

**참조 투명성**이란 "어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성"을 의미한다.

수학에서는 모든 함수를 참조 투명하게 만드는 기법:

- 부수효과를 발생시키지 않는다
- 불변성을 보장한다

## 정리

- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다
- 좋은 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족하다
- 유연하고 재사용 가능한 퍼블릭 인터페이스를 만들기 위해서는 종종 의도를 드러내는 인터페이스를 통해 수정해야 한다
- 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 인터페이스의 조건을 명시하면 설계의 유연성을 떨어뜨리지 않고도 협력을 명확하게 문서화할 수 있다
