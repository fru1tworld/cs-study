# 10 상속과 코드 재사용

## 상속과 중복 코드

### DRY 원칙 (Don't Repeat Yourself)
- 모든 지식은 시스템 내에서 단일하고, 명백하며, 신뢰할 수 있는 표현을 가져야 한다
- 중복 코드는 변경을 방해하는 요인

### 중복 코드의 문제
- 코드를 수정할 때 여러 곳을 변경해야 함
- 일관성이 깨지기 쉬움
- 버그 발생 가능성 증가

## 상속을 이용한 중복 코드 제거

### 상속의 기본 개념
- 부모 클래스의 구현을 재사용
- 중복 코드를 제거할 수 있음

### 상속의 문제점
- 부모 클래스와 자식 클래스 사이의 결합도가 높음
- 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 수 있음
- 캡슐화를 위반할 수 있음

## 취약한 기반 클래스 문제

### 정의
- 부모 클래스의 변경이 자식 클래스를 망가뜨리는 현상
- 상속의 근본적인 취약성

### 발생 원인
1. **불필요한 인터페이스 상속 문제**
   - 부모의 public 메서드를 모두 상속받음
   - 자식에게 부적절한 메서드도 포함

2. **메서드 오버라이딩의 오작용 문제**
   - 자식이 부모의 메서드를 오버라이드
   - 부모의 내부 구현에 강하게 결합

3. **부모 클래스와 자식 클래스의 동시 수정 문제**
   - 부모를 변경하면 자식도 변경해야 함
   - 결합도가 높음

## 추상화에 의존하자

### 추상 클래스 사용
- 변하지 않는 부분은 부모 클래스로
- 변하는 부분은 추상 메서드로
- 자식 클래스에서 구체화

### 차이를 메서드로 추출
1. 중복 코드 안에서 차이점을 별도의 메서드로 추출
2. 공통적인 부분은 부모 클래스로
3. 차이가 나는 부분은 추상 메서드로

### 변경으로부터 보호
- 추상화를 통해 변경을 캡슐화
- 자식 클래스는 추상 메서드만 구현
- 부모 클래스 변경의 영향 최소화

## 상속보다는 합성

### 합성이란?
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함
- 새로운 기능을 추가하기 위해 기존 기능을 재사용

### 합성의 장점
1. **낮은 결합도**
   - 인터페이스를 통해 약하게 결합

2. **캡슐화 유지**
   - 내부 구현을 효과적으로 캡슐화

3. **유연한 설계**
   - 런타임에 관계 변경 가능

### 상속 vs 합성

**상속 (is-a 관계)**
- 클래스 사이의 정적인 관계
- 컴파일 시점에 결정
- 화이트박스 재사용

**합성 (has-a 관계)**
- 객체 사이의 동적인 관계
- 런타임에 결정
- 블랙박스 재사용

## 설계 가이드라인

### 상속을 사용하는 경우
- is-a 관계일 때
- 자식이 부모의 특수한 경우일 때
- 리스코프 치환 원칙을 만족할 때

### 합성을 사용하는 경우
- has-a 관계일 때
- 기능을 재사용하고 싶을 때
- 유연한 설계가 필요할 때

## 믹스인 (Mixin)

### 개념
- 객체를 생성할 때 코드 일부를 섞어 넣을 수 있는 기법
- 다중 상속의 대안
- 코드를 다른 코드 안에 포함시키는 방법

### 특징
- 상속과 다르게 독립적으로 작성
- 필요에 따라 믹스인을 추가
- 재사용 가능한 코드 조각

## 교훈

1. **상속은 캡슐화를 위반한다**
2. **설계는 변경을 위한 것이다**
3. **상속보다는 합성을 사용하라**
4. **추상화에 의존하라**
5. **차이점을 메서드로 추출하라**
6. **중복 코드를 제거하라**
7. **유연하고 확장 가능한 설계를 추구하라**
