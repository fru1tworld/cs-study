# 15 디자인 패턴과 프레임워크

## 디자인 패턴

### 디자인 패턴이란?
- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대한 해결책
- 검증된 설계 원리
- 의사소통의 도구

### 패턴의 구성 요소
1. **이름**: 패턴을 지칭하는 명칭
2. **문제**: 패턴이 해결하는 문제
3. **해법**: 설계의 구조와 협력 방법
4. **결과**: 패턴 적용의 장단점

## GoF 디자인 패턴

### 생성 패턴 (Creational Patterns)
객체 생성 메커니즘을 다룸

#### ABSTRACT FACTORY
- 관련된 객체군을 생성하는 인터페이스
- 구체적인 클래스를 지정하지 않고 객체 생성

#### BUILDER
- 복잡한 객체의 생성 과정을 단계별로 분리
- 동일한 생성 절차로 다른 표현 생성

#### FACTORY METHOD
- 객체 생성을 서브클래스로 위임
- 어떤 클래스의 인스턴스를 만들지 서브클래스에서 결정

#### SINGLETON
- 클래스의 인스턴스가 하나만 존재하도록 보장
- 전역적인 접근점 제공

### 구조 패턴 (Structural Patterns)
클래스와 객체의 구조를 다룸

#### ADAPTER
- 호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있게 함
- 기존 클래스의 인터페이스를 다른 인터페이스로 변환

#### BRIDGE
- 추상화와 구현을 분리
- 독립적으로 확장 가능

#### COMPOSITE
- 부분-전체 계층을 표현
- 개별 객체와 복합 객체를 동일하게 취급

#### DECORATOR
- 객체에 동적으로 새로운 책임을 추가
- 서브클래싱 대신 유연한 확장

#### FACADE
- 서브시스템의 복잡성을 감춤
- 통합된 인터페이스 제공

#### PROXY
- 다른 객체에 대한 대리자 역할
- 접근 제어, 지연 로딩 등

### 행위 패턴 (Behavioral Patterns)
객체 간의 협력과 책임 할당을 다룸

#### CHAIN OF RESPONSIBILITY
- 요청을 처리할 수 있는 객체의 체인
- 요청을 전달하며 처리

#### COMMAND
- 요청을 객체로 캡슐화
- 요청의 매개변수화, 큐잉, 로깅, 취소 가능

#### INTERPRETER
- 언어의 문법을 정의하고 해석
- 간단한 언어 구현

#### ITERATOR
- 내부 구조를 노출하지 않고 순차적 접근
- 컬렉션의 요소들을 탐색

#### MEDIATOR
- 객체 간의 상호작용을 캡슐화
- 객체 간의 직접 참조를 제거

#### MEMENTO
- 객체의 내부 상태를 저장하고 복원
- 캡슐화를 위반하지 않고 상태 관리

#### OBSERVER
- 객체 간의 일대다 의존 관계
- 상태 변경 시 자동 통지

#### STATE
- 객체의 내부 상태에 따라 행동 변경
- 상태를 객체로 캡슐화

#### STRATEGY
- 알고리즘을 캡슐화하고 교체 가능하게 함
- 실행 중에 알고리즘 선택

#### TEMPLATE METHOD
- 알고리즘의 골격을 정의
- 일부 단계를 서브클래스로 연기

#### VISITOR
- 객체 구조의 요소에 대한 연산을 정의
- 구조를 변경하지 않고 새로운 연산 추가

## 프레임워크

### 프레임워크란?
- 애플리케이션의 아키텍처를 제공
- 재사용 가능한 설계와 구현
- 제어의 역전 (IoC)

### 라이브러리 vs 프레임워크

**라이브러리:**
- 개발자가 제어 흐름을 관리
- 필요할 때 호출

**프레임워크:**
- 프레임워크가 제어 흐름을 관리
- 개발자는 특정 부분만 구현
- **제어의 역전 (Inversion of Control)**

## 제어의 역전 (IoC)

### 개념
- 프레임워크가 애플리케이션 코드를 호출
- 개발자는 프레임워크가 제공하는 확장 포인트를 구현
- 할리우드 원칙: "Don't call us, we'll call you"

### 구현 방법

#### TEMPLATE METHOD 패턴
```java
public abstract class ApplicationTemplate {
    public void run() {
        init();
        process();
        cleanup();
    }
    
    protected abstract void init();
    protected abstract void process();
    protected abstract void cleanup();
}
```

#### STRATEGY 패턴
```java
public interface ProcessStrategy {
    void process();
}

public class Framework {
    public void run(ProcessStrategy strategy) {
        strategy.process();
    }
}
```

## 상속 vs 합성

### 화이트박스 프레임워크
- 상속을 통한 확장
- TEMPLATE METHOD 패턴 활용
- 코드 재사용이 명시적
- 결합도가 높음

### 블랙박스 프레임워크
- 합성을 통한 확장
- STRATEGY 패턴 활용
- 인터페이스를 통한 재사용
- 결합도가 낮음
- 더 유연함

## 의존성 주입

### Spring 프레임워크의 예
```java
@Component
public class MovieService {
    private final DiscountPolicy discountPolicy;
    
    @Autowired
    public MovieService(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

### 장점
- 결합도 감소
- 테스트 용이성
- 유연한 설계
- 설정의 중앙화

## 아키텍처 패턴

### MVC (Model-View-Controller)
- Model: 데이터와 비즈니스 로직
- View: 사용자 인터페이스
- Controller: 사용자 입력 처리

### MVP (Model-View-Presenter)
- MVC의 변형
- Presenter가 View와 Model 사이를 중재

### MVVM (Model-View-ViewModel)
- ViewModel이 View의 상태와 행동을 담당
- 데이터 바인딩 활용

## 도메인 주도 설계 (DDD)

### 핵심 개념
- 도메인 모델을 중심으로 설계
- 유비쿼터스 언어
- 계층화된 아키텍처

### 빌딩 블록
- Entity: 식별자를 가진 객체
- Value Object: 값으로 구분되는 객체
- Aggregate: 일관성 경계
- Repository: 영속성 추상화
- Service: 상태 없는 연산

## 패턴 적용의 함정

### 과도한 패턴 사용
- 필요하지 않은 곳에 패턴 적용
- 불필요한 복잡성 증가
- YAGNI (You Aren't Gonna Need It)

### 패턴 강요
- 문제를 패턴에 맞추려는 시도
- 문제가 먼저, 패턴은 해결책

### 올바른 적용
- 문제를 먼저 파악
- 적절한 패턴 선택
- 단순함 유지
- 팀과의 소통

## 교훈

1. **디자인 패턴은 의사소통의 도구다**
2. **프레임워크는 제어의 역전을 구현한다**
3. **상속보다는 합성을 선호하라**
4. **의존성 주입으로 결합도를 낮춰라**
5. **패턴을 맹목적으로 따르지 마라**
6. **문제를 먼저 이해하고 패턴은 나중에**
7. **단순함을 유지하라**
8. **협력과 책임 할당이 우선이다**
