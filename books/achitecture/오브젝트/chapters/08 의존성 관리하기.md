# 08 의존성 관리하기

## 의존성 이해하기

### 의존성이란?
어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재한다.

### 의존성의 종류
- 실행 시점: 의존하는 객체가 정상 동작하기 위해 런타임에 필요
- 구현 시점: 의존하는 객체가 변경될 때 영향을 받음
- 코드 시점: 코드에서 명시적으로 드러남

## 의존성 전이

### 직접 의존성
- 한 요소가 다른 요소에 직접 의존

### 간접 의존성
- 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향을 받음

### 의존성 전이 특징
- 의존성은 함께 존재할 때만 전파
- 의존성은 전이될 수 있다
- 의존성은 전이되지 않을 수도 있다

## 런타임 의존성과 컴파일타임 의존성

### 컴파일타임 의존성
- 코드에 작성된 의존성
- 추상 클래스나 인터페이스에 의존

### 런타임 의존성
- 실제 실행 시점의 의존성
- 구체 클래스의 인스턴스에 의존

### 유연한 설계
- 컴파일타임 의존성과 런타임 의존성이 다를수록 유연
- 하지만 코드 이해가 어려워질 수 있음
- 트레이드오프 존재

## 컨텍스트 독립성

### 개념
- 클래스가 특정 문맥에 강하게 결합되지 않음
- 다양한 환경에서 재사용 가능

### 구현 방법
- 구체 클래스에 대한 의존성 제거
- 인터페이스나 추상 클래스에 의존
- 생성자나 메서드를 통해 의존성 주입

## 의존성 해결하기

### 의존성 해결 방법

#### 1. 생성자 주입
```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Movie(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

#### 2. Setter 주입
```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

#### 3. 메서드 주입
```java
public class Movie {
    public Money calculateFee(Screening screening, DiscountPolicy discountPolicy) {
        return discountPolicy.calculateDiscountAmount(screening);
    }
}
```

## 의존성과 결합도

### 바람직한 의존성
- 다양한 환경에서 재사용 가능
- 컨텍스트 독립적
- 변경에 유연

### 바람직하지 않은 의존성
- 특정 컨텍스트에 강하게 결합
- 재사용이 어려움
- 변경에 취약

## 지식이 결합을 낳는다

### 추상화 정도
- 구체 클래스 의존성 (최악)
- 추상 클래스 의존성
- 인터페이스 의존성 (최선)

### 명시적 의존성
```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Movie(DiscountPolicy discountPolicy) {  // 명시적
        this.discountPolicy = discountPolicy;
    }
}
```

### 숨겨진 의존성
```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Movie() {
        this.discountPolicy = new AmountDiscountPolicy();  // 숨겨진 의존성
    }
}
```

**항상 명시적 의존성을 사용하라!**

## new는 해롭다

### new의 문제점
1. 구체 클래스에 의존하게 됨
2. 생성자 인자를 알아야 함
3. 결합도가 높아짐

### 해결책
- 생성 책임을 클라이언트로 이동
- FACTORY 패턴 사용
- 의존성 주입 프레임워크 활용

## 가끔은 생성해도 무방하다

### 주의사항
- 트레이드오프 존재
- 협력하는 기본 객체를 설정하는 경우
- 추가 확장이 필요 없는 경우

## 조합 가능한 행동

### 유연한 설계의 핵심
- 작은 객체들의 조합
- 의존성 관리를 통한 재사용
- 다양한 행동의 조합

## 교훈

1. **의존성을 명시적으로 드러내라**
2. **추상화에 의존하라**
3. **new는 가능한 사용하지 마라**
4. **생성자를 통해 의존성을 주입하라**
5. **컨텍스트에 독립적인 객체를 설계하라**
6. **유연한 설계와 이해 가능성 사이의 트레이드오프를 고려하라**
