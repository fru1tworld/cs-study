# 09 유연한 설계

## 개방-폐쇄 원칙 (OCP)

소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

### 확장에 열려 있다
- 애플리케이션의 요구사항이 변경될 때 새로운 동작을 추가하여 기능을 확장할 수 있다

### 수정에 닫혀 있다
- 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다

### 구현 방법
- 추상화를 이용
- 변하는 부분을 인터페이스나 추상 클래스로 추상화
- 추상화의 구체 클래스를 추가해서 확장

## 생성 사용 분리

### 문제점
- 객체를 생성하는 책임과 사용하는 책임이 함께 있으면 결합도가 높아짐

### 해결책
- 생성과 사용을 분리
- 생성 책임을 클라이언트로 옮김

### FACTORY 패턴
```java
public class Factory {
    public Movie createAvatarMovie() {
        return new Movie("아바타",
            Duration.ofMinutes(120),
            Money.wons(10000),
            new AmountDiscountPolicy(...)
        );
    }
}
```

### PURE FABRICATION (순수한 가공물)
- 도메인 개념이 아닌 설계 상의 편의를 위한 객체
- FACTORY가 대표적인 예

## 의존성 주입

### 의존성 해결 방법
1. 생성자 주입
2. Setter 주입
3. 메서드 주입
4. 인터페이스 주입

### SERVICE LOCATOR 패턴
- 의존성을 해결할 객체들을 보관하는 저장소
- 필요할 때 꺼내서 사용
- 의존성을 감추기 때문에 권장하지 않음

## 의존성 역전 원칙 (DIP)

상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.
둘 모두 추상화에 의존해야 한다.

### 상위 수준과 하위 수준
- 상위 수준: 정책을 결정하는 모듈
- 하위 수준: 정책에 의해 결정된 모듈

### 의존성 역전
- 추상화를 사이에 둠으로써 의존성의 방향을 역전
- 모두 추상화에 의존

## 유연성에 대한 조언

### 유연한 설계는 복잡하다
- 단순하고 명확한 설계가 먼저
- 변경이 필요할 때 유연하게 만들기
- 불필요한 유연성은 불필요한 복잡성

### 협력과 책임이 중요하다
- 설계를 유연하게 만들기 위해 협력에 집중
- 객체들의 역할과 책임, 협력 방식을 고민
- 유연성은 협력을 개선한 결과

## 추상화가 핵심이다

### 구체 클래스보다 추상 클래스
- 구체 클래스에 의존하면 변경에 취약
- 추상 클래스에 의존하면 변경에 유연

### 추상 클래스보다 인터페이스
- 추상 클래스는 구현 상속
- 인터페이스는 인터페이스 상속
- 인터페이스가 더 유연

## 설계 원칙

### SOLID 원칙
- SRP: 단일 책임 원칙
- **OCP: 개방-폐쇄 원칙**
- LSP: 리스코프 치환 원칙
- ISP: 인터페이스 분리 원칙
- **DIP: 의존성 역전 원칙**

## 설계가 필요한 이유

### 변경
- 버그 수정
- 기능 추가
- 요구사항 변경

### 변경을 수용하는 설계
- 변경의 영향을 최소화
- 응집도는 높게, 결합도는 낮게
- 변경이 일어나는 곳을 캡슐화

## 교훈

1. **개방-폐쇄 원칙을 따르라**
2. **생성과 사용을 분리하라**
3. **의존성을 주입하라**
4. **의존성을 역전하라**
5. **추상화에 의존하라**
6. **유연성과 단순성 사이에서 균형을 찾아라**
7. **협력과 책임에 집중하라**
