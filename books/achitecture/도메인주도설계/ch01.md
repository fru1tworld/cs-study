# 1부 동작하는 도메인 모델 만들기

모든 소프트웨어 프로그램은 그 소프트웨어를 사용하는 `사용자의 활동이나 관심사`와 관련돼 있다.

사용자가 프로그램을 사용하는 대상 영역이 `바로 해당 소프트웨어의 도메인`이다.

어떤 도메인은 물리적 요소가 수반되기도 하는데, 이를테면 항공권 예약에는 실제 승객이 있고, 회계 프로그램이 그러하며 화폐와 금융이 도메인에 해당한다. 대개 소프트웨어 도메인은 몇 가지 예외적인 경우, 가령 소프트웨어 개발 자체가 도메인이 되는 소스 코드 관리 시스템과 같은 부류를 제외하면 컴퓨터와 거의 관련이 없다.

사용자의 활동에 도움되는 소프트웨어를 만들기 위해 개발팀은 `사용자의 활동`과 `관련된 지식 체계`에 집중해야 한다.

도메인 모델은 `어떤 특정한 다이어그램이 아니라 다이어그램이 전달하고자 하는 아이디어`다.

도메인 모델은 단지 도메인 전문가의 머릿속에만 존재하는 지식이 아니라 해당 지식을 엄격하게 구성하고 선택적으로 추상화한 것이다.

## 도메인 주도 설계에서의 모델의 유용성

도메인 주도 설계에서는 아래의 세 가지 기본적인 쓰임새에 따라 모델을 선택한다.

1. **모델과 핵심 설계는 서로 영향을 주며 구체화된다.**: 모델을 의미 있게 만들고 모델의 분석이 최종 산출물인 동작하는 프로그램에 적용되게끔 보장하는 것은 다름이 아닌 모델과 구현 간의 긴밀한 연결이다. 이러한 모델과 구현의 연결은 유지보수와 계속되는 기능 개선에도 도움이 되는데, 그 이유는 바로 모델을 이해한 바에 근거해 코드를 해석할 수 있기 때문이다.

2. **모델은 모든 팀 구성원이 사용하는 언어의 중추다**: 모델과 구현이 서로 연결돼 있으므로 개발자는 이 언어를 토대로 프로그램에 관해 의견을 나눌 수 있다. 그러므로 개발자와 도메인 전문가가 의사소통하는 데 별도의 번역 절차가 필요하지 않다.
3. **모델은 지식의 정수만을 뽑아낸 것이다.**: 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식이다. 모델에는 우리가 용어를 선택하고, 개념을 분류하며, 분류한 지식을 서로 연관시킬 때 도메인에 관한 우리의 사고방식이 담겨 있다. 개발자와 도메인 전문가는 공유 언어를 바탕으로 갖가지 정보를 모델로 만들낼 때 효과적으로 협업할 수 있다. 모델과 구현이 연결돼 있다면 초기버전의 소프트웨어를 통해 얻은 경험을 모델링 프로세스에 피드백으로 활용할 수 있다.

이어지는 세 개의 장에서는 모델의 이러한 쓰임에 대해 차례로 각 쓰임의 의미와

## 소프트웨어의 본질

소프트웨어의 본질은 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있다.

그 밖의 매우 중요하다 할 수 있는 기능도 모두 이러한 기본적인 목적을 뒷바딤하는데 불과하다.

도메인이 복잡하면 이 같은 문제 해결은 유능하고 숙련된 사람의 집중적인 노력이 필요한 어려운 일이 된다.

개발자는 업무 지식을 증진하기 위해 도메인 연구에 몰두해야 한다.

# 01 지식 탐구

## 효과적인 모델링의 요소

1. **모델과 구현의 연계**: 초기 프로토타입을 토대로 본질적인 연결 고리를 만든 다음, 이어지는 모든 반복 주기 내내 그 연결 고리를 유지했다.

2. **모델을 기반으로 하는 언어 정제**: 처음에는 엔지니어가 나한테 기초적인 PCB 문제를 설명해야 했고, 나 또한 클래스 다이어그램이 뜻하는 바를 설명해야 했다.

하지만 프로젝트가 진행되면서 누구라도 모델에서 바로 용어를 끄집어내어 모델의 구조와 일관되게 문장을 구성할 수 있게 됐고 별도의 해석 없이도 문장을 명확히 이해할 수 있었다.

3. **풍부한 지식이 담긴 모델 개발**: 객체는 행위를 지니고 규칙을 이행했다.

모델은 단순히 데이터 스키마가 아니라 복잡한 문제를 해결하는 데 필수불가결한 것이다.

그리고 모델에는 다양한 지식이 포함돼 있다.

4. **모델의 정제**: 모델이 점차 완전해지면서 중요한 개념이 더해졌으며, 마찬가지로 쓸모없거나 중요하지 않다고 판명된 개념이 제거됐다는 점 또한 중요하다.

불필요한 개념과 필요한 개념이 한데 묶여 있을 경우 본질과 무관한 개념은 모두 제거할 수 있게 본질적인 개념만을 식별할 수 있는 새로운 모델을 고안해냈다.

5. **브레인스토밍과 실험**: 스케치를 비롯해 브레인스토밍을 하려는 태도와 결합된 언어를 바탕으로 토의를 모델에 대한 실험실로 변모시켜 수백 가지의 실험용 변종을 연습하고, 시도해보며 평가할 수 있다.

팀에서 시나리오를 검토할 때 시나리오를 말로 표현해보기만 해도 제안된 모델의 타당성 여부를 재빨리 판단할 수 있었는데, 이는 우리가 뭔가를 듣기만 해도 그러한 표현이 명확하고 쉬운지, 아니면 어색한지 빠르게 감지할 수 있다.

이런식의 지식 탐구는 팀 내 지식을 가치있는 모델로 만든다.

## 지식 탐구

재무 분석가는 숫자를 면밀히 검토한다.

그들은 숫자의 바탕에 깔린 의미를 알아내려고 숫자를 결합하고 또 결합하며, 그리고 정말로 중요한 것, 말하자면 재무적 판단의 근거가 되는 지식을 드러내간 간결한 표현을 찾으면서 상세한 수치가 적힌 다량의 문서를 면밀히 검토한다.

도메인 모델링을 수행하는 사람들도 지식을 면밀히 탐구한다. 그들은 엄청난 양의 정보 속에서 아주 미미한 관련성을 찾아낸다.

모든 구성원이 함께 모델을 면밀히 만들어 나가면 팀 구성원 간의 상호작용은 그 양상을 달리한다. 도메인 모델의 지속적인 정제를 토대로 개발자는 기능만을 기계쩍으로 만드는 데 머무르지 않고 자신이 보조하고 있는 업무의 중요 원칙들을 배운다.

## 지속적인 학습

소프트웨어를 작성하기 시작할 때 우리는 충분히 알지 못한 상태에서 시작한다.

해당 프로젝트에서 다룰 지식은 단편적이고, 여러 사람들과 문서에 흩어져 있으며, 다른 정보와 섞여 있어 우리는 어떤 지식이 정말로 필요한지조차 알지 못한다.

기술적으로는 그다지 어려워 보이지 않는 도메인이 사람들을 현혹시키는 경우가 있는데, 우리는 스스로 얼마나 알지 못하는가를 깨닫지 못하는 것이다.

생산성이 매우 뛰어난 팀은 지속적인 학습을 바탕으로 의식적으로 지식을 함양한다. 개발자에게는 이것이 일반적인 도메인 모델링 기술과 기술적 지식이 모두 향상된다는 것을 의미한다.

## 풍부한 지식이 담긴 설계

PCB 예제처럼 모델에 포착돼 있는 지식은 단순한 "명사 찾기" 이상이다.

도메인에 관련된 엔티티만큼 업무 활동과 규칙도 도메인에 중요한데, 어떠한 도메인에도 다양한 `범주의 개념`이 존재한다.

이는 여러 업무 규칙 간에 실제로 모순되는 부분이 있을 수도 있기 때문이다. 대개 도메인 전문가는 업무 과정에서 모든 업무 규칙을 차례로 확인하고, 모순되는 사항을 조정하며, 상식적인 선에서 규웨어는 이렇게 할 수가 없다.

### 예제

#### 감춰진 개념 추출하기

Cargo(화물)를 하나의 Voyage(운항)와 연관관계를 맺고, 그것을 기록, 관리하는 것이라고 해보자 지금까지는 아무런 문제가 없다.

애플리케이션의 어딘가에는 아래와 같은 메서드가 있을 것이다.

```java
public int makeBooking(Cargo cargo, Voyage votage){
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

항상 마지막 순간에 취소하는 경우가 있으므로 선박이 운항 중에 나를 수 있는 화물의 최대치보다 예약을 더 받아들이는 것이 해운 산업의 관행이다. 이를 "초과예약"이라 한다.

```java
public int makeBooking(Cargo cargo, Voyage votage){
    double maxBooking = voyage.capacity() * 1.1;
    if((voyage,bookedCargoSize() + cargo.size() > maxBooking))
        return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

이제 중요한 업무 규칙이 애플리케이션 메서드의 보호절(guard clause)로 감춰진다. 이후 4장에서는 LAYERED ARCHITECTURE라는 원칙을 살펴보고, 거기에 따라 초과예약 규칙을 도메인 객체로 옮길 것이다.

하지만 지금은 이 지식이 더 명확하게 하고 프로젝트에 관련된 모든 이가 해당 지식을 접하게 하는 방법에만 집중하자.

이러한 과정에서 비슷한 해법이 나타날 것이다.

1. 코드가 작성된 대로라면 개발자의 도움이 있더라도 업무 전문가가 이 코드를 읽고 규칙을 검증하지 못할 것이다.
2. 해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기가 어려울 것이다.

우리는 설계를 변경해서 이 지식을 더 잘 담을 수 있다. 초과예약 규칙은 일종의 정책이다.

정책이란 잘 알려진 STRATEGY 디자인 패턴의 또 다른 이름이다.

대개 정책은 각종 규칙을 대체할 필요성 때문에 만들어지므로 여기서는 필요하지 않다.

그러나 우리가 담고자 하는 개념은 정책이라는 의미와 잘 맞아 떨어지며, 이러한 정책도 똑같이 도메인 주도 설계의 중요한 동기에 해당한다.

코드는 이제 다음처럼 바뀐다.

```java
public int makeBooking(Cargo cargo, Voyage voyage){
    if(!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

    새 Overbooking Policy(초과예약 정책) 클래스에는 아래 메서드가 포함된다.

```java
publci boolean isAllowd(Cargo cargo, Yoyage voyage){
    return (cargo.size() + yoyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```

이렇게 하면 초과예약이 별개의 정책이라는 사실이 모든 이가 분명히 알게 될 것이며,
