# 3장 가비지 컬렉터와 메모리 할당 전략

가비지 컬렉션에서 해결해야하는 문제는 다음과 같다.

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

가비지 컬렉션을 이해해야 다양한 메모리 오버플로우와 누수 문제를 해결할 수 있다.

힙과 메서드 영역은 북확실한게 많다. 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다.

하나의 메서드에서도 어떤 분기를 실행하냐에 따라 다를 수 있기 때문에 런타임에만 알 수 있다는 특징이 있다.

## 3.2 대상이 죽었는가 ?

### 3.2.1 참조 카운팅 알고리즘

객체를 가리키는 참조 카운터를 추가한다.
카운터 값이 0이 되면 삭제한다.

JVM에서는 실제로 많이 쓰이지 않는다.

예를 들어 참조 카운팅은 순환 문제를 해결하기 어렵다.

### 3.2.2 도달 가능성

GC 루트라고 하는 루트 객체를 시작으로 해서 참조하는 객체를 탐색한다.
이때 만들어진 경로를 참조 체인이라고 하고, 어떤 객체와 GC의 참조 체인이 없다면 도달할 수 없다.
GC 루트로 사용할 수 있는 루트 객체는 정해져있다.

- 가상 머신 스택에서 참조하는 객체에서 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드 스택: JNI가 참조하는 객체
- 자바 가상 머신 내부에서 찾모: 기본 데이터 타입에 해당하는 객체
- 동기화 락으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등
  이상의 정해진 GC 루트들 외에도 가비지 컬렉터 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시로 추가될 수 있다.

이렇게 해서 전체 GC 루트 집합이 만들어진다.

참고로 세대 단위 컬렉션과 부분 컬렉션의 경우 자바 힙의 일부 영역부터 분석을 시작한다.
이 영역들이 서로 격리되거나 닫혀있지 않다는 점에 유의해야 한다.

### 3.2.3 다시 참조 이야기로

예를 들어 메모리가 여유롭다면 그냥 두고 가비지 컬렉션을 하고도 매우 부족하다면 그때 회수하는 객체를 표현하고 싶다면 어떻게 할까 ?

JDK 1.2부터는 참조 개념이 확장됐다.

1. 강한 참조: 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조가 남아 있는 객체는 절대 회수하지 않는다.
2. 부드러운 참조:유용하지만 필수는 아닌 객체다. 부드러운 참조만 남아있는 객체는 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 두 번째 회수 후에도 메모리가 부족하면 그떄 OOM을 던진다.
3. 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 그래서 넉넉하더라도 모두 회수된다.
4. 유령 참조: 가장 약하다 객체 수명에 아무런 영향을 주지 않으며 유일한 목적은 객체가 회수될 때 알림을 받기 위해서다.

(파이널 참조: 참조 강도는 약한 참조와 유령 참조 사이인데, finalize 메서드를 구현한 객체는 모두 파이널 참조 대상이 되고 별도 대기열에 등록된다. 그런 다음 해당 객체에 도달할 수 있는 든든 모참조가 사라지면 finalize() 메서드를 호출한다)

### 3.2.4 살았나 죽었나 ?

도달 가능성 분석 알고리즘이 도달 불가능으로 판단하더라도 반드시 죽어야하는것은 아니다.
그래서 유예 단계가 있는데 확실한 사망 선고를 내리려면 두번의 표시 과정을 거쳐야한다.

첫 번째 표시가 이뤄지면 이후 필터링을 하는데 필터링 조건은 finalize() 메서드를 실행해야 하는 객체인지이다.

finalize()가 필요 없거나 이미 호출한 경우 실행할 필요 없음으로 처리한다.

만약 finalize를 실행해야한다면 F-Queue 대기열에 추가한다. 참고로 실행만 하고 종료를 기다리지는 않는데 왜냐면 무한 루프에 빠지거나 무한 대기가 발생할 수 있기 때문이다.

현재는 사라졌다.

### 3.2.5 메서드 영역 회수하기

다 쓴 상수나 클래스는 회수된다.

클래스는 다소 까다로운데, 세 가지 조건을 만족해야한다.

1. 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
2. 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
3. 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 것도 없다.

### 3.3.1 세대 단위 컬렉션 이론

1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
2. 강한 세대가설 : 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

대부분 위 이론을 기반으로 세대를 나눈다.

이렇게 나누면 가비지 커렉터가 하나 또는 여러개를 선택해서 회수할 수 있는데 이를 마이너 GC, 메이저 GC, 전체 GC라는 식으로 부른다.

생존 특성에 따라 마크 스윕, 마크 카피- 마크 컴팩트 등 알고리즘을 사용한다.

한편 곰곰이 생각해보면 단순히 세대만 나눠서 해결되지는 않는다.
가비지 컬렉션을 하고 싶더라도 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다.
반대도 마찬가지이다.
근데 모두 탐색하는 것은 성능에 부하를 준다.
따라서 세번째 가설을 추가해야한다.

3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
