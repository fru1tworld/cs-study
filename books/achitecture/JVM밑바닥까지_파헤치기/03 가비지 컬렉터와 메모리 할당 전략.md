# 3장 가비지 컬렉터와 메모리 할당 전략

가비지 컬렉션에서 해결해야하는 문제는 다음과 같다.

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

가비지 컬렉션을 이해해야 다양한 메모리 오버플로우와 누수 문제를 해결할 수 있다.

힙과 메서드 영역은 북확실한게 많다. 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다.

하나의 메서드에서도 어떤 분기를 실행하냐에 따라 다를 수 있기 때문에 런타임에만 알 수 있다는 특징이 있다.

## 3.2 대상이 죽었는가 ?

### 3.2.1 참조 카운팅 알고리즘

객체를 가리키는 참조 카운터를 추가한다.
카운터 값이 0이 되면 삭제한다.

JVM에서는 실제로 많이 쓰이지 않는다.

예를 들어 참조 카운팅은 순환 문제를 해결하기 어렵다.

### 3.2.2 도달 가능성

GC 루트라고 하는 루트 객체를 시작으로 해서 참조하는 객체를 탐색한다.
이때 만들어진 경로를 참조 체인이라고 하고, 어떤 객체와 GC의 참조 체인이 없다면 도달할 수 없다.
GC 루트로 사용할 수 있는 루트 객체는 정해져있다.

- 가상 머신 스택에서 참조하는 객체에서 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드 스택: JNI가 참조하는 객체
- 자바 가상 머신 내부에서 찾모: 기본 데이터 타입에 해당하는 객체
- 동기화 락으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등
  이상의 정해진 GC 루트들 외에도 가비지 컬렉터 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시로 추가될 수 있다.

이렇게 해서 전체 GC 루트 집합이 만들어진다.

참고로 세대 단위 컬렉션과 부분 컬렉션의 경우 자바 힙의 일부 영역부터 분석을 시작한다.
이 영역들이 서로 격리되거나 닫혀있지 않다는 점에 유의해야 한다.

### 3.2.3 다시 참조 이야기로

예를 들어 메모리가 여유롭다면 그냥 두고 가비지 컬렉션을 하고도 매우 부족하다면 그때 회수하는 객체를 표현하고 싶다면 어떻게 할까 ?

JDK 1.2부터는 참조 개념이 확장됐다.

1. 강한 참조: 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조가 남아 있는 객체는 절대 회수하지 않는다.
2. 부드러운 참조:유용하지만 필수는 아닌 객체다. 부드러운 참조만 남아있는 객체는 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 두 번째 회수 후에도 메모리가 부족하면 그떄 OOM을 던진다.
3. 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 그래서 넉넉하더라도 모두 회수된다.
4. 유령 참조: 가장 약하다 객체 수명에 아무런 영향을 주지 않으며 유일한 목적은 객체가 회수될 때 알림을 받기 위해서다.

(파이널 참조: 참조 강도는 약한 참조와 유령 참조 사이인데, finalize 메서드를 구현한 객체는 모두 파이널 참조 대상이 되고 별도 대기열에 등록된다. 그런 다음 해당 객체에 도달할 수 있는 든든 모참조가 사라지면 finalize() 메서드를 호출한다)

### 3.2.4 살았나 죽었나 ?

도달 가능성 분석 알고리즘이 도달 불가능으로 판단하더라도 반드시 죽어야하는것은 아니다.
그래서 유예 단계가 있는데 확실한 사망 선고를 내리려면 두번의 표시 과정을 거쳐야한다.

첫 번째 표시가 이뤄지면 이후 필터링을 하는데 필터링 조건은 finalize() 메서드를 실행해야 하는 객체인지이다.

finalize()가 필요 없거나 이미 호출한 경우 실행할 필요 없음으로 처리한다.

만약 finalize를 실행해야한다면 F-Queue 대기열에 추가한다. 참고로 실행만 하고 종료를 기다리지는 않는데 왜냐면 무한 루프에 빠지거나 무한 대기가 발생할 수 있기 때문이다.

현재는 사라졌다.

### 3.2.5 메서드 영역 회수하기

다 쓴 상수나 클래스는 회수된다.

클래스는 다소 까다로운데, 세 가지 조건을 만족해야한다.

1. 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
2. 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
3. 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 것도 없다.

### 3.3.1 세대 단위 컬렉션 이론

1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
2. 강한 세대가설 : 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

대부분 위 이론을 기반으로 세대를 나눈다.

이렇게 나누면 가비지 커렉터가 하나 또는 여러개를 선택해서 회수할 수 있는데 이를 마이너 GC, 메이저 GC, 전체 GC라는 식으로 부른다.

생존 특성에 따라 마크 스윕, 마크 카피- 마크 컴팩트 등 알고리즘을 사용한다.

한편 곰곰이 생각해보면 단순히 세대만 나눠서 해결되지는 않는다.
가비지 컬렉션을 하고 싶더라도 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다.
반대도 마찬가지이다.
근데 모두 탐색하는 것은 성능에 부하를 준다.
따라서 세번째 가설을 추가해야한다.

3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

상호 참조 관계의 두 객체는 삶과 죽음을 함께하는 경향이 있다.
그래서 두 가설을 통해 논리적으로 유추한 가설이다.

따라서 신세대에 기억 집합이라는 전역 데이터 구조를 하나 두고, 그 구조를 통해 구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 관리하면 된다.

그래서 마이너 GC가 수행되면 세대 간 참조를 포함하는 작은 메모리 블록 안의 객체만 GC 루트에 추가된다.
이렇게 되면 참조 관계 변화를 정확히 관리해야해서 연산은 늘지만 구세대 전체를 훑는 것보다는 싸다.

## 3.3.2 마크 스윕 알고리즘

마크 스윕의 단점은 다음과 같다.

1. 실행 효율이 일정하지 않다.
2. 메모리 파편화가 심하다.

## 3.3.3 마크 카피 알고리즘

회수할 객체가 많아질수록 효율이 떨어지는 문제를 극복하기 위해 세미 스페이스 복사라는 알고리즘을 제안했다.
가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 하나만 사용한다.
한쪽이 꽉차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청한한다.
단점은 가용 메모리를 절반으로 줄여 낭비가 심하다는 점이다.

IBM에서 객체들의 생존 기간이 짧다를 정량적으로 나타내보았는데 신세대 객체 중 98%가 삭제된다.
따라서 1:1로 나눌 필요가 없다는 결론이 있다.

아펠 스타일 컬렉션 방식을 구체적으로 보면 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 둔다.
그리고 메모리를 할당할 때 생존자 공간 중 하나와 에덴만 사용한다.

가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들이 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 바로 비운다.

핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1이다.

만약 생존자 공간보다 더 크게 살아남았을 경우 메모리 할당 보증이라는 메커니즘으로 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역을 활용해 메모리 할당(대부분 구 세대로)을 보증하는 것이다. (핸들 승격)

## 3.3.4 마크 컴팩트 알고리즘

위 단점은 객체 생존율이 높을 경우 복사할 게 많아져서 효율이 나빠진다.

그리고 할당 보증 공간을 따로둬서 대다수 객체가 살아남는 극단적 상황을 대처해야한다.
그래서 구 세대에서는 적합하지 않다.

그래서 구 세대를 위한 마크 컴팩트 알고리즘을 제안했다.

마크 컴팩트는 생존한 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.

### 3.5.7 G1 컬렉터 (가비지 우선 컬렉터)

G1은 서버용 애플리케이션이다.

G1의 목표는 정지 시간 예측 모델을 만들어서 목표 시간이 M 밀리초 이상으로 넘지 않도록 통제하기 위함이다.

이 목표를 이루기 위해서는 생각의 전환이 필요했다.

G1의 등장 전까지 CMS를 포함한 모든 컬렉터의 회수 범위는 신세대 전체, 구세대 전체, 힙 전체였는데

G1은 어느 영역에 쓰레기가 가장 많은지를 기준으로 한다.

G1은 신세대가 아니라 어디서든 메모리를 회수할 수 있따고 하는데 이를 Colection set이라한다.

연속된 자바 힙을 여러 독립 리전으로 나누고 각 리전은 다양한 공간이 될 수 있다(에덴, 구세대 등)

G1은 여전히 세대 이론을 기반으로 하지만 리전별 역할을 동적으로 바꿀 수 있고 같은 역할의 리전을 연이어 배치될 필요도 없다.

이것이 가능한 이유는 리전을 최소 회소 단위로 사용하기 때문이다. 그래서 이를 기반으로 자바 힙 전체를 회수하는 상황을 피할 수 있다.

G1이 힙 메모리를 리전 단위로 나눈다는 것은 이해하기 어렵지 않은데 세부 기술이 어렵다.

해결해야하는 문제가 다음과 같기 때문이다.

1. 독립 리전으로 나눈다면 리전 간 참조 문제를 해결해야한다. 근데 기억 집합을 G1에 응용하기가 어렵다.
   기억 집합은 기본적으로 해시 테이블인데 양방향 테이블 구조가 되다보니 기본적인 카드 테이블보다 복잡해서 G1 컬렉션은 보통 클래식보다 메모리를 많이 쓴다. 실험 결과 G1은 자신이 관리하는 자바 힙의 최소 10~20% 정도를 추가로 확인하고 이 크기는 기술의 성숙과 함께 빠르게 줄어들고 있다.
2. 동시 표시 단계 동안 GC 스레드와 사용자 스레드가 서로 간섭하지 않아야한다. 한편
