# Chapter1 깨끗한 코드

- 르블랑의 법칙: 나중은 결코 오지 않는다.

나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.

코드 감각이 있는 프로그래머는 나쁜 모듈을 좋은 모듈로 개발할 방안을 떠올린다.

코드를 짜는 시간보다 읽는 시간이 더 길다. 따라서 끊임없이 코드를 읽는데 가독성이 매우 중요하다는 것을 알 수 있다.

# Chapter2 의미 있는 이름

의도가 분명해야한다.

```java
public List<int []> getThem(){
    List<int []> list1 = new ArrayList<int []>();
    for(int[] x : theList)
        if(x[0] == 4)
            list1.add(X);
    return list1;
}
```

위 코드의 역할은 무엇일까 ?

```java
public List<int []> getFlaggedCells(){
    List<int []> flaggedCells = new ArrayList<int []>();
    for(int[] cell gameBoard)
        if(ceel[STATUS_VALUE] == FALGGED)
            flaggedCells.add(cell);
    return list1;
}
```

이름만으로 역할을 파악할 수 있다.

```java
public List<Cell> getFlaggedCells(){
    List<Cell> flaggedCells = new ArrayList<int []>();
    for(Cell cell gameBoard)
        if(cell.isFlagged())
            flaggedCells.add(cell);
    return list1;
}
```

int 배열 대신 클래스를 정의하고 함수를 사용해서 상수를 감춰도 좋겠다.

### 그릇된 정보를 피하자

hp, aix, sco는 변수 이름으로 적합하지 않은데 유닉스 플랫폼이나 유닉스 변종을 가리키는 이름이고, 실제 List가 아니라면 List는 특수한 의미이므로 그릇된 정보를 제공할 수 있음

유사한 개념은 유사한 표기법을 사용한다.
그릇된 정보의 예 소문자 L과 대문자 O

```java
int a = 1;
if( O == l)
a = 01;
else
l = 01;
```

위에 코드 지어낸게 아니라 실화임

### 의미 있게 구분 하라

```java
public static void copyChars(char a1[], char a2[]){
    for(int i=0; i<a1.length; i++){
        a2[i] = a1[i];
    }
}
```

불용어 사용을 지양하자 불용어 ? noise word: 검색엔진이 검색에서 무시해버리는 단어 또는 검색엔진이 데이터베이스를 구축할때 색인에서 제외해버리는 단어
a1, a2가 아니라 source, destination이라고 하면 쉽겠다

```java

getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```

구분이 되는가 ?

### 발음하기 쉬운 이름을 사용하라

```java
class DtaRcrd102{
    private Data genymhms;
    private DAta modymdhms;
    private final String pszqint = "102"
}
```

```java
class DtaRcrd102{
    private Data generationTimestamp;
    private DAta modificationTimestamp;
    private final String recordId = "102"
}
```

### 검색하기 쉬운 이름 쓰기

```java
for (int j=0; j<34; j++>{
    s += (t[j]*4)/5;
})
```

```java
int realDaysPerIdealDay =4;
const int WORK_DAYS_PER_WEEK = 5;
int sum =0;
for(int j=0; j < NUMBER_OF_TASKS; j++){
    int realTaskDays = taskEstimate[j] * realDaysPerIdealdDay;
    int realTaskWeeks = (realTaskDays /WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
}
```

위 코드에서 sum이 별로 유용하지 않으나 최소한 검색이 가능하다.

### 말장난 금지

add는 덧셈이 될수도 있음

집합에 값 하나를 추가한다도 될 수 있음 이 경우에은 insert, append이 적당한듯

### 맥락을 넣자

finestName, lastName,state를 생각해보면 state는 주소라는 것을 파악할 수 있음

근데 state 단독이면 파악하기 힘듬 근데 addrFirstName, addrLastName 같은 맥락을 쓰면 좀 더 맥락이 분명해진다.

물론 Address라는 클래스를 생성하면 더 좋다.

# Chapter3 함수

### 작게 만들어라

함수를 만드는 첫째 규칙은 **'작게!'**다. 함수를 만드는 둘째 규칙은 **'더 작게!'**다.

블록과 들여쓰기: if 문/else 문/while 문 등에 들어가는 블록은 한 줄이어야 한다.

### 한 가지만 해라

**함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**

함수가 '한 가지'만 하는지 판단하는 방법: 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 당 추상화 수준은 하나로

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

위에서 아래로 코드 읽기: **내려가기 규칙**

### Switch 문

switch 문은 작게 만들기 어렵다. 본질적으로 switch 문은 N가지를 처리한다.

다형성을 이용해 switch 문을 abstract factory에 숨긴다.

### 서술적인 이름을 사용하라

함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.

이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.

### 함수 인수

함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)는 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다.

### 부수 효과를 일으키지 마라

부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까.

### 명령과 조회를 분리하라

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안 된다.

### 오류 코드보다 예외를 사용하라

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

Try/Catch 블록을 별도 함수로 뽑아내는 편이 좋다.

# Chapter4 주석

**나쁜 코드에 주석을 달지 마라. 새로 짜라.**

코드로 의도를 표현하라!

주석은 필요악이다. 프로그래밍 언어를 치밀하게 사용해 의도를 표현할 능력이 있다면, 주석은 거의 필요하지 않다.

### 좋은 주석

- 법적인 주석
- 정보를 제공하는 주석
- 의도를 설명하는 주석
- 의미를 명료하게 밝히는 주석
- 결과를 경고하는 주석
- TODO 주석
- 중요성을 강조하는 주석

### 나쁜 주석

- 주절거리는 주석
- 같은 이야기를 중복하는 주석
- 오해할 여지가 있는 주석
- 의무적으로 다는 주석
- 이력을 기록하는 주석
- 있으나 마나 한 주석
- 무서운 잡음
- 함수나 변수로 표현할 수 있다면 주석을 달지 마라
- 위치를 표시하는 주석
- 닫는 괄호에 다는 주석
- 공로를 돌리거나 저자를 표시하는 주석
- 주석으로 처리한 코드
- HTML 주석
- 전역 정보
- 너무 많은 정보
- 모호한 관계
- 함수 헤더
- 비공개 코드에서 Javadocs

# Chapter5 형식 맞추기

코드 형식은 중요하다! 코드 형식은 의사소통의 일환이다.

### 적절한 행 길이를 유지하라

200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

신문 기사처럼 작성하라: 이름은 간단하면서도 설명이 가능하게 짓는다. 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다.

개념은 빈 행으로 분리하라.

### 수직 거리

서로 밀접한 개념은 세로로 가까이 둬야 한다.

- 변수 선언: 변수는 사용하는 위치에 최대한 가까이 선언한다
- 인스턴스 변수: 클래스 맨 처음에 선언한다
- 종속 함수: 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다

### 가로 형식 맞추기

120자 정도로 행 길이를 제한한다.

# Chapter6 객체와 자료구조

### 자료 추상화

변수를 private으로 선언하더라도 각 값마다 getter 함수와 setter 함수를 제공한다면 구현을 외부로 노출하는 셈이다.

추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

### 자료/객체 비대칭

- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다
- 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다

절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

### 디미터 법칙

디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.

**기차 충돌**: `outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`

# Chapter7 오류 처리

### 오류 코드보다 예외를 사용하라

예외를 사용하면 호출자 코드가 더 깔끔해진다.

### Try-Catch-Finally 문부터 작성하라

try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.

### 미확인(unchecked) 예외를 사용하라

확인된 예외는 OCP(Open Closed Principle)를 위반한다.

### 예외에 의미를 제공하라

오류 메시지에 정보를 담아 예외와 함께 던진다.

### 호출자를 고려해 예외 클래스를 정의하라

오류를 분류하는 방법은 수없이 많다. 하지만 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 **오류를 잡아내는 방법**이 되어야 한다.

### null을 반환하지 마라

null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.

### null을 전달하지 마라

정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.

# Chapter8 경계

### 외부 코드 사용하기

인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다.

Map을 사용할 때마다 캡슐화하라는 말이 아니다. Map을 여기저기 넘기지 말라는 말이다.

### 경계 학습하기

외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다. 두 가지를 동시에 하기는 두 배나 어렵다.

곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익힌다.

**학습 테스트**는 API를 사용하려는 목적에 초점을 맞춘다.

### 아직 존재하지 않는 코드를 사용하기

아는 코드와 모르는 코드를 분리하는 경계에 인터페이스를 정의한다.

# Chapter9 단위 테스트

### TDD 법칙 세 가지

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다

### 깨끗한 테스트 코드 유지하기

테스트 코드는 실제 코드 못지 않게 중요하다.

테스트 코드는 이류 시민이 아니다.

### 깨끗한 테스트 코드

가독성이 실제 코드보다 테스트 코드에 더욱 중요하다.

BUILD-OPERATE-CHECK 패턴

### 테스트 당 개념 하나

테스트 함수마다 한 개념만 테스트하라.

### F.I.R.S.T

- Fast(빠르게): 테스트는 빨라야 한다
- Independent(독립적으로): 각 테스트는 서로 의존하면 안 된다
- Repeatable(반복가능하게): 테스트는 어떤 환경에서도 반복 가능해야 한다
- Self-Validating(자가검증하는): 테스트는 부울(bool) 값으로 결과를 내야 한다
- Timely(적시에): 테스트는 적시에 작성해야 한다

# Chapter10 클래스

### 클래스 체계

표준 자바 관례에 따르면 클래스 내부 순서:

1. static public 상수
2. static private 변수
3. private 인스턴스 변수
4. public 함수
5. private 함수

### 클래스는 작아야 한다

클래스를 만들 때 첫 번째 규칙은 크기다. 클래스는 작아야 한다.

클래스 이름은 해당 클래스 책임을 기술해야 한다. 클래스 이름이 모호하다면 클래스 책임이 너무 많아서다.

클래스 설명은 만일(if), 그리고(and), -(하)며(or), 하지만(but)을 사용하지 않고서 25단어 내외로 가능해야 한다.

### 단일 책임 원칙

클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.

SRP는 객체 지향 설계에서 더욱 중요한 개념이다.

### 응집도

클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.

일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.

### 변경하기 쉬운 클래스

클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다.

# Chapter11 시스템

### 시스템 제작과 시스템 사용을 분리하라

소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.

### Main 분리

생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

### 의존성 주입

의존성 주입(Dependency Injection)은 제어 역전(Inversion of Control) 기법을 의존성 관리에 적용한 메커니즘이다.

# Chapter12 창발성

### 창발적 설계로 깔끔한 코드를 구현하자

켄트 벡이 제시한 단순한 설계 규칙 네 가지:

1. 모든 테스트를 실행한다
2. 중복을 없앤다
3. 프로그래머 의도를 표현한다
4. 클래스와 메서드 수를 최소로 줄인다

위 규칙은 중요도 순이다.

# Chapter13 동시성

### 동시성이 필요한 이유?

동시성은 **결합(coupling)**을 없애는 전략이다. 즉, **무엇(what)**과 **언제(when)**를 분리하는 전략이다.

### 동시성 방어 원칙

- 단일 책임 원칙(SRP): 동시성 관련 코드는 다른 코드와 분리하라
- 자료 범위를 제한하라
- 자료 사본을 사용하라
- 스레드는 가능한 독립적으로 구현하라

# Chapter14 점진적 개선

이 장은 Args 구현 사례 연구다. 점진적으로 개선하는 과정을 보여준다.

# Chapter15 JUnit 들여다보기

이 장은 JUnit 프레임워크의 코드를 리팩터링하는 예제를 보여준다.

# Chapter16 SerialDate 리팩터링

SerialDate는 날짜를 표현하는 자바 클래스다. 코드 리팩터링 예제를 제공한다.

# Chapter17 냄새와 휴리스틱

이 장은 코드 냄새(Code Smells)와 휴리스틱을 정리한 목록이다.

### 주석

- 부적절한 정보
- 쓸모 없는 주석
- 중복된 주석
- 성의 없는 주석
- 주석 처리된 코드

### 환경

- 여러 단계를 거쳐야 하는 빌드
- 여러 단계를 거쳐야 하는 테스트

### 함수

- 너무 많은 인수
- 출력 인수
- 플래그 인수
- 죽은 함수

### 일반

- 한 소스 파일에 여러 언어를 사용
- 당연한 동작을 구현하지 않음
- 경계를 올바로 처리하지 않음
- 안전 절차 무시
- 중복
- 추상화 수준이 올바르지 못함
- 기초 클래스가 파생 클래스에 의존
- 과도한 정보
- 죽은 코드
- 수직 분리
- 일관성 부족
- 잡동사니
- 인위적 결합
- 기능 욕심
- 선택자 인수
- 모호한 의도
- 잘못 지운 책임
- 부적절한 static 함수
- 서술적 변수
- 이름과 기능이 일치하는 함수
- 알고리즘을 이해하라
- 논리적 의존성은 물리적으로 드러내라
- If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
- 표준 표기법을 따르라
- 매직 숫자는 명명된 상수로 교체하라
- 정확하라
- 관례보다 구조를 사용하라
- 조건을 캡슐화하라
- 부정 조건은 피하라
- 함수는 한 가지만 해야 한다
- 숨겨진 시간적인 결합
- 일관성을 유지하라
- 경계 조건을 캡슐화하라
- 함수는 추상화 수준을 한 단계만 내려가야 한다
- 설정 정보는 최상위 단계에 둬라
- 추이적 탐색을 피하라

### 자바

- 긴 import 목록을 피하고 와일드카드를 사용하라
- 상수는 상속하지 않는다
- 상수 대 Enum

### 이름

- 서술적인 이름을 사용하라
- 추상화 수준에 맞는 이름을 선택하라
- 가능하다면 표준 명명법을 사용하라
- 명확한 이름
- 긴 범위는 긴 이름을 사용하라
- 인코딩을 피하라
- 이름으로 부수 효과를 설명하라

### 테스트

- 불충분한 테스트
- 커버리지 도구를 사용하라
- 사소한 테스트를 건너뛰지 마라
- 무시한 테스트는 모호함을 뜻한다
- 경계 조건을 테스트하라
- 버그 주변은 철저히 테스트하라
- 실패 패턴을 살펴라
- 테스트 커버리지 패턴을 살펴라
- 테스트는 빨라야 한다

# 부록 A 동시성 II

동시성에 대한 추가 설명과 고급 기법을 다룬다.

# 부록 B org.jfree.data.SerialDate

SerialDate 클래스의 전체 코드 목록

# 부록 C 휴리스틱의 교차 참조 목록

17장에서 제시한 휴리스틱의 교차 참조 목록
