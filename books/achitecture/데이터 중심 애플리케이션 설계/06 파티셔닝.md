# 6 파티셔닝

파티션은 몽고DB, ES, 솔리클라우드의 샤드에 해당한다. HBase에서 리전, 빅 테이블에서 태블랫, 카산드라와 리악에서는 브이노드, 카우치베이스에서는 브이버켓이라고 부른다.

일반적으로 파티셔닝, 샤드가 많이 쓰이는 용어

파티션을 나눌 때는 보통 각 데이터가 하나의 파티션에 속하게 된다.

여기에는 다양한 방법이 있다.

주로 확장성이 목적

## 6.1 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.

각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다는 의미다.

### 키-값 데이터 파티셔닝

파티셔닝의 목적은 질의 부하를 노드 사이에 고르게 분산시키는 것이다.

모든 노드가 동일한 분량을 담당한다고 가정할 때 10대의 노드를 사용하면 한 대를 사용할 때보다 이론상으로 10배의 데이터를 저장하고 10배의 읽기, 쓰기 요청을 처리할 수 있다.

데이터가 많거나 질의를 많이 받는 파티션이 있다면 **쏠렸다**고 말한다.

불균항하게 부하가 높은 파티션을 **핫스팟**이라 한다.

### 6.1.1 키 범위 기준 파티셔닝

범위를 기준으로 파티셔닝을 한다.

이때는 각 파티션 내에서 키를 정렬된 순서로 저장할 수 있다.

이렇게 하면 범위 스캔이 쉬워지는 장점이 있고, 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는데 사용할 수 있다.

그러나 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발한다는 단점이 있다.

### 6.1.2 키의 해시값 기준 파티셔닝

쏠림과 핫스팟의 위험 때문에 많은 데이터베이스는 해시 함수를 사용한다.

좋은 해시 함수는 쏠린 데이터를 입력받아 균일하게 분산한다.

파티션 경계는 크기가 동일하도록 나눌 수 있고 무작위에 가깝게 선택할 수도 있다.

(이런 기법을 일관성 해싱이라고 부르기도 한다.)

카산드라는 두 가지 파티셔닝 전략 사이에서 타협한다.

테이블을 선언할 때 여러 복합 기본키를 설정할 수 있다. 그래서 첫 부분에만 해싱을 적용해 파티션을 결정하고 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다.

### 6.1.3 쏠린 작업부하와 핫스팟 완화

해싱해서 파티션을 저장하는 핫스팟을 줄이는데 도움이 된다.

그렇지만 핫스팟을 완벽히 제거할 수는 없다.

동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.

예를 들어 SNS에서 수백만 명의 팔로워를 거느린 유명인이 뭔가하면 후폭풍이 발생할 수 있다.

## 6.2 파티셔닝과 보조 색인

지금까지 설명한 파티셔닝 방식은 키-값 데이터 모델에 의존한다.

레코드를 기본키를 통해서만 접근한다면 키로부터 파티션을 결정하고 이를 사용해 해당 키를 담당하는 파티션으로 읽기 쓰기 요청을 전달할 수 있다.

### 6.2.1 문서 기준 보조 색인 파티셔닝

예를 들어 문서 ID라고 부르는 고유 ID가 있고, 문서 기준으로 파티셔닝한다면, 사용자들이 차를 검색할 때 색상과 제조사로 필터링할 수 있게 하려면 관계형 데이터베이스에서는 보조 색인을 만들어야 한다.

이런 색인 방법을 사용하면 각 파티션이 완전히 독립적으로 동작한다.

각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다.

### 6.2.1 용어 기준 보조 색인 파티셔닝

## 6.3 파티션 재균형화

### 6.3.1 재균형화 전략

#### 쓰면 안되는 방법: 해시값에 N 연산을 실행

해시된 값에 모듈러 연산을 쓰면 예를 들어 10을 먹이면 0~9의 값이 되고 16으로 늘렸다고 가정하면 0~9을 다시 0~15로 재분배해야하는 비용이 발생한다.

#### 파티션 개수 고정

상당히 간단한 해결책이 있다 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 방식이다.

이를테면 노드 10대로 구성된 클러스터에서 실행되는 데이터베이스는 처음부터 파티션을 1,000개로 쪼개서 각 노드마다 약 100개의 파티션을 할당할 수 잇다.

클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 몇 개를 뺏어올수 있다.

이런 재균형화 방법은 리악, 엘라스틱 서치, 카우치베이스, 볼드모트에서 사용된다.

#### 동적 파티셔닝

파티션 경계를 잘못 지정하면 한 파티션에 저장되고 나머지 파텨신은 텅 빌 수도 있다.

이러한 이유로 경계를 수동으로 재설정하는 것은 매우 성가시다.

이런 이유로 파티션을 동적으로 만든다. 파티션 크기가 설정된 값을 넘어서면 두 개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다.

반대로 데이터가 많이 삭제되어 파티션 크기가 임곘값 아래로 내려가게 되면 인접한 파티션과 합쳐질 수 있다.

이 과정은 B 트리 최상위 레벨에서 실행되는 작업과 유사하다.

그러나 빈 데이터페이스는 파티션 경계를 어디로 정해야 하는지에 관한 사전 없으므로 시작할 때는 파티션이 하나라는 단점이 있다.

셋이 작을 때는 모든 쓰기 요청이 하나의 노드에서 실행되고 다른 노드들은 유휴 상태에 머물게 된다.

이 문제를 완화하기 위해 HBase와 몽고 DB에서는 초기 파티션 집합을 설정할 수 있게 한다(사전 분할). 키 범위 파티셔닝의 경우 사전 분할을 하려면 키가 어떤 식으로 분할될지 미리 알아야 한다.

참고로 동적 파티셔닝은 키 범위 파티셔닝에만 적합한게 아니고 해시 파티셔닝에도 똑같이 적용할 수 있다.

#### 노드 비례 파티셔닝

동적 파티셔닝에서는 파티션 분할과 병합ㅇ르 통해 개별 파티션 크기가 어떤 고정된 최솟값과 최댓값 사이에 유지되게 하므로 파티션 개수가 데이터셋 크기에 비례한다.

카산드라와 케타마에서 사용되는 세 번째 방법은 파티션 개수가 노드에 비례하는 것이다.

다시 말해 노드당 할당되는 파티션 개수를 고정한다.

이 경우 노드 대수가 변함없는 동안은 갭려 파티션 크기가 데이터셋 크기에 비례해서 증가하지만 노드 대수를 늘리면 파티션 크기는 다시 작아진다.

일반적으로 데이터 용량이 클수록 데이터를 저장할 노드도 많이 필요하므로 이 방법을 쓰면 개별 파티션 크기도 상당히 안정적으로 유지된다.

### 6.3.2 운영: 자동 재균형화와 수동 재균형화

제대로 짚고 넘어가지 않았던 재균형화에 관한 중요한 의문이 하나 있다.

재균형화는 자동으로 실행될까 아니면 수동으로 실행해야 할까 ?

자동 재균형화는 일상적인 유지보수에 손이 덜 가므로 편리할 수 있다. 하지만 예측하기 어렵기도하다.

요청 경로를 재설정해야 하고, 대량의 데이터를 노드 사이에 이동해야 하므로 비용이 큰 연산이다.

## 6.4 요청 라우팅

데이터베이스에 국한된 문제가 아닌 일반적인 문제인 "서비스 찾기"의 일종이다.

이 문제는 몇 가지 접근법이 있다.

1. 클라이언트가 아무 노드에나 접속하게 한다. 마침 노드에 요청을 적용할 파티션이 있다면 거기서 요청을 직접 처리할 수 있다. 그렇지 않으면 요청을 올바른 노드로 전달해서 응답을 받고 클라이언트에 응답을 전달한다.

2.클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다. 라우팅 계층에서는 각 요청을 처리할 노드를 알아내고 그에 따라 해당 노드로 요청을 전달한다. 라우팅 계층 자체에서는 아무 요청도 처리하지 않는다. 파티션 인지로드밸런서로 동작할 뿐이다.

3.클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다. 이 경우 클라이언트는 중개자 없이 올바른 노드로 직접 접속할 수 있따.

MongoDB는 config server 구현에 의존하고 mongos 데몬을 라우팅 계층으로 사용한다.

가십 프로토콜을 사용해서 클러스터 상태 변화를 노드 사이에 퍼뜨린다.

### 6.4.1 병렬 실행

지금까지는 단일 키를 읽거나 쓰는 매우 간단한 질의에 대해서만 설명헀다.

이는 대부분 NoSQL 분산 데이터스토어에서 지원되는 접근 수준이다.

그러나 분석용으로 자주 사용되는 대규모 병렬 처리(MPP) 관계형 데이터베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.

전형적인 웨어하우스 질의는 조인, 필터링, 그룹화, 집계 연산을 몇 개 포함한다.
