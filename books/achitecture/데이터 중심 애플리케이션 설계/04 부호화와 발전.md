# 4 부호화와 발전

애플리케이션은 불가피하게 시간이 지남에 따라 변화한다. 애플리케이션이 변화할 때 데이터도 함께 변한다.

관계형 데이터베이스에서는 스키마 변경이 가능하지만, 이는 보통 전체 데이터베이스를 한 번에 변환해야 한다.

**상위 호환성(forward compatibility)**: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.

**하위 호환성(backward compatibility)**: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 4.1 데이터 부호화 형식

프로그램은 보통 최소한 두 가지 형태로 데이터를 다룬다:

1. 메모리에서는 객체, 구조체, 리스트, 배열, 해시 테이블, 트리 등으로 데이터를 유지한다
2. 데이터를 파일에 쓰거나 네트워크로 전송하려면 일련의 바이트열로 **부호화(encode)**해야 한다

메모리 내부 표현에서 바이트열로 변환하는 것을 **부호화(encoding)**, **직렬화(serialization)**, **마샬링(marshalling)**이라고 한다.

역변환을 **복호화(decoding)**, **역직렬화(deserialization)**, **언마샬링(unmarshalling)**이라고 한다.

### 4.1.1 언어별 형식

많은 프로그래밍 언어는 메모리 내 객체를 바이트열로 부호화하는 기능이 내장되어 있다.

자바는 java.io.Serializable을 제공하고, 루비는 Marshal을, 파이썬은 pickle을 제공한다.

이런 언어별 부호화 라이브러리의 문제점:

- **언어 종속적**: 다른 프로그래밍 언어로 작성된 시스템과 통합하기 어렵다
- **보안 문제**: 임의 클래스를 인스턴스화하는 기능은 종종 보안 문제의 원인이 된다
- **버저닝 문제**: 데이터 버저닝을 처리하기 어렵다
- **효율성**: 자바의 내장 직렬화는 성능과 부호화된 크기 면에서 비효율적이다

### 4.1.2 JSON과 XML, 이진 변형

표준화된 부호화 방식으로 JSON과 XML을 사용한다.

JSON, XML, CSV의 문제점:

- **숫자 부호화의 애매함**: XML과 CSV는 숫자와 숫자로 구성된 문자열을 구별할 수 없다. JSON은 숫자와 문자열을 구별하지만 정수와 부동소수점 수를 구별하지 않으며, 정밀도를 지정하지 않는다
- **이진 문자열 지원 부족**: JSON과 XML은 이진 문자열을 지원하지 않는다. 대신 Base64를 사용해서 이진 데이터를 텍스트로 부호화하는데, 이는 데이터 크기를 33% 증가시킨다
- **스키마 지원**: XML과 JSON은 스키마를 지원하지만 강제하지 않는다
- **CSV 문제**: CSV는 스키마가 없으므로 각 행과 열의 의미를 애플리케이션에서 정의해야 한다

#### 이진 변형

JSON과 XML은 텍스트 형식이기 때문에 사람이 읽을 수 있다는 장점이 있지만, 공간을 많이 차지한다.

이진 부호화 형식들:

- MessagePack
- BSON
- BJSON
- UBJSON
- BISON
- Smile

### 4.1.3 스리프트와 프로토콜 버퍼

**스리프트(Thrift)**와 **프로토콜 버퍼(Protocol Buffers, protobuf)**는 같은 원리를 기반으로 하는 이진 부호화 라이브러리다.

스리프트는 페이스북에서 개발했고, 프로토콜 버퍼는 구글에서 개발했다.

둘 다 스키마를 사용해 부호화할 데이터를 정의한다.

#### 프로토콜 버퍼 예시

```protobuf
message Person {
    required string user_name = 1;
    optional int64 favorite_number = 2;
    repeated string interests = 3;
}
```

스리프트와 프로토콜 버퍼는 각 필드에 **태그(tag) 번호**를 부여한다. 이는 필드명 대신 사용된다.

태그 번호 덕분에:

- 필드명을 변경해도 호환성이 유지된다
- 부호화된 데이터에 필드명이 포함되지 않아 크기가 작다

#### 스키마 발전과 호환성

상위 호환성을 유지하려면:

- **필드 추가**: 새로운 코드는 새로운 필드를 알고 있지만, 예전 코드는 무시한다
- **필드 제거**: 새로운 태그 번호를 재사용해서는 안 된다

하위 호환성을 유지하려면:

- **필드 추가**: 새로운 필드를 추가할 때 옵셔널이거나 기본값이 있어야 한다
- **필드 제거**: required 필드는 제거할 수 없다

### 4.1.4 아브로

**아브로(Avro)**는 하둡의 하위 프로젝트로 시작됐다.

아브로는 스리프트나 프로토콜 버퍼와 다르게 필드에 태그 번호가 없다.

```avro
record Person {
    string userName;
    union { null, long } favoriteNumber = null;
    array<string> interests;
}
```

#### 스키마 레지스트리

대규모 데이터셋을 다루는 환경(하둡 등)에서는 수백만 개의 레코드가 모두 같은 스키마로 부호화된다.

따라서 파일의 시작 부분에 스키마를 한 번만 포함하면 된다.

아브로는 데이터베이스 스키마와 아브로 스키마를 쉽게 연동할 수 있다.

### 4.1.5 스키마의 장점

이진 부호화와 스키마를 사용하는 장점:

- **공간 효율성**: 텍스트 형식보다 훨씬 간결하다
- **스키마는 유용한 문서화 형식**: 스키마는 복호화 시에 확인되므로 최신 상태로 유지된다
- **스키마 데이터베이스**: 스키마의 버전을 관리할 수 있다
- **상위 및 하위 호환성**: 스키마는 호환성을 검증하는 도구를 제공한다
- **정적 타입 언어 지원**: 스키마로부터 코드를 생성할 수 있다

## 4.2 데이터플로 모드

프로세스 간에 데이터를 전달하는 방법:

- 데이터베이스를 통해
- 서비스 호출을 통해 (REST와 RPC)
- 비동기 메시지 전달을 통해

### 4.2.1 데이터베이스를 통한 데이터플로

데이터베이스에 기록하는 프로세스는 데이터를 부호화하고, 데이터베이스에서 읽는 프로세스는 복호화한다.

**데이터는 코드보다 오래 산다**. 데이터베이스는 일반적으로 수명이 긴 데이터를 저장한다.

#### 다양한 시점에 기록된 다양한 값

한 필드의 값이 애플리케이션의 한 버전에서 기록되고, 데이터베이스의 값은 계속 유지된다.

새로운 버전의 코드가 예전 데이터를 읽을 때 이 데이터가 복호화될 수 있어야 한다.

#### 보관 저장소

데이터 웨어하우스와 같이 데이터의 최신 스냅샷을 대량으로 디스크에 기록하는 경우를 생각해보자.

**파켓(Parquet)**같은 칼럼 지향 형식은 분석에 좋은 부호화 형식이다.

### 4.2.2 서비스를 통한 데이터플로: REST와 RPC

클라이언트와 서버 간 통신에서 클라이언트가 요청을 만들어 네트워크를 통해 서버로 보낸다.

서버는 요청을 처리하고 응답을 네트워크를 통해 클라이언트로 되돌려준다.

#### 웹 서비스

**웹 서비스**는 HTTP를 근간 프로토콜로 사용하는 서비스다.

웹 서비스는 웹 브라우저로만 쓰이는 것이 아니라 다른 조직이 제공하는 서비스에 요청을 보낼 때도 사용된다.

두 가지 대중적인 웹 서비스 접근법:

- **REST**: HTTP의 원칙을 기반으로 설계 철학
- **SOAP**: 네트워크 API 요청을 위한 XML 기반 프로토콜

#### REST의 특징

**REST(Representational State Transfer)**는 프로토콜이 아니라 HTTP의 원칙을 기반으로 한 설계 철학이다.

간단한 데이터 형식을 강조하며 URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 타입 협상에 HTTP 기능을 사용한다.

#### SOAP의 특징

**SOAP**는 XML 기반 프로토콜이다.

SOAP 웹 서비스의 API는 WSDL이라는 XML 기반 언어를 사용해 기술한다.

SOAP는 HTTP와 독립적으로 설계됐으며, 대부분의 HTTP 기능을 사용하지 않는다.

#### RPC의 문제점

**RPC(Remote Procedure Call)** 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 보이도록 시도한다.

하지만 네트워크 요청은 로컬 함수 호출과 매우 다르다:

- **예측 불가능성**: 네트워크 문제로 요청이 유실될 수 있다
- **재시도**: 요청이나 응답이 유실되면 재시도가 필요하다. 하지만 중복 처리 문제가 발생할 수 있다
- **지연시간**: 네트워크 요청은 로컬 함수 호출보다 훨씬 느리다
- **인자 전달**: 로컬 함수는 포인터나 참조를 전달할 수 있지만, 네트워크로는 부호화해야 한다
- **데이터 타입 변환**: 언어가 다르면 데이터 타입 변환 문제가 발생한다

#### 현재 RPC의 방향

최근 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 명시적으로 드러낸다.

- **gRPC**: 프로토콜 버퍼를 사용
- **Finagle**: 스리프트를 사용
- **Rest.li**: JSON over HTTP를 사용

#### 데이터 부호화와 RPC의 발전

서비스 호환성을 가정하면:

- 서버를 먼저 업데이트하고 클라이언트를 나중에 업데이트한다 (**하위 호환성**)
- 요청과 응답에 하위 호환성과 상위 호환성이 필요하다

REST와 RPC API는 버전 번호를 URL이나 HTTP Accept 헤더에 명시하는 것이 일반적이다.

### 4.2.3 메시지 전달 데이터플로

**비동기 메시지 전달 시스템**은 RPC와 데이터베이스의 중간 형태다.

#### 메시지 브로커

**메시지 브로커(message broker)** 또는 **메시지 큐(message queue)**는 메시지를 임시로 저장하는 서버다.

메시지 브로커 사용의 장점:

- **버퍼 역할**: 수신자가 사용 불가능하거나 과부하 상태면 버퍼 역할을 해서 시스템 안정성을 향상시킨다
- **재전송**: 메시지를 유실하지 않도록 자동으로 재전송한다
- **송신자 분리**: 송신자는 수신자의 IP 주소나 포트 번호를 알 필요가 없다
- **다중 수신자**: 하나의 메시지를 여러 수신자에게 전송할 수 있다
- **논리적 분리**: 송신자와 수신자를 논리적으로 분리한다

대표적인 메시지 브로커:

- RabbitMQ
- ActiveMQ
- Apache Kafka
- Amazon SQS

#### 분산 액터 프레임워크

**액터 모델(actor model)**은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다.

각 액터는 보통 하나의 클라이언트나 엔티티를 나타낸다.

**분산 액터 프레임워크**는 여러 노드에 걸쳐 확장할 수 있다.

대표적인 분산 액터 프레임워크:

- **Akka**: 액터가 로컬이든 원격이든 메시지 전달 방식이 동일하다
- **Orleans**: 기본적으로 메시지 부호화에 커스텀 데이터 직렬화 형식을 사용한다
- **Erlang OTP**: 하위 호환성이 매우 어려워 롤링 업그레이드를 신중하게 계획해야 한다

## 4.3 정리

이번 장에서는 데이터를 부호화하는 다양한 방법과 그 발전 가능성을 살펴봤다.

- 프로그래밍 언어별 부호화는 단일 프로그래밍 언어로 제한되고 상위/하위 호환성 문제를 겪는다
- JSON, XML, CSV 같은 텍스트 형식은 널리 사용되지만, 스키마에 대한 지원이 선택 사항이고 데이터 타입을 구별하는 데 한계가 있다
- 스리프트, 프로토콜 버퍼, 아브로 같은 이진 스키마 기반 형식은 간결하고 명확히 정의된 상위/하위 호환성을 지원한다
- 이러한 형식의 스키마는 코드 생성과 정적 타입 검사에 유용하다
- 데이터플로의 일반적인 방식:
  - **데이터베이스**: 기록하는 프로세스가 부호화하고 읽는 프로세스가 복호화한다
  - **RPC와 REST API**: 클라이언트가 요청을 부호화하고, 서버가 요청을 복호화하고 응답을 부호화하며, 클라이언트가 응답을 복호화한다
  - **비동기 메시지 전달**: 송신자가 메시지를 부호화하고, 수신자가 복호화한다

호환성은 애플리케이션을 변경하거나 업그레이드할 때 상당히 중요하다. 상위 호환성과 하위 호환성을 유지하면 시스템을 쉽게 변경할 수 있다.
