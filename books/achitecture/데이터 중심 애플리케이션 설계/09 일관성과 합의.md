# 9 일관성과 합의

## 9.1 일관성 보장

## 9.2 선형성

선형성이란 최신성 보장이다.

### 9.2.1 시스템에 선형성을 부여하는 것은 무엇인가?

선형성을 뒷받침하는 아이디어는 간단하다. 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것이다.

그러나 그게 정확히 무슨 뜻인지 확실하게 하려면 실제로는 주의가 좀 필요하다.

선형성 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트를 보여준다.

분산 시스템 분야에서 x는 레지스터라고 불린다. 예를 들면 현실에서는 키-값 저장소의 키

하나, 관계형 데이터베이스의 로우 하나, 또는 문서 데이터베이스의 문서 하나가 될 수 있다.

읽기와 쓰기가 동시에 일어나는 시점에 새로운 값이나 오래된 값을 반환할 수 있는 것을 정규 레지스터라고 한다.

따라서 read, write 이외에 새로운 연산인 cas를 추가한다.

cas는 Compare and set을 요청한다는 뜻이다. (원자적 요청)

레지스터 x의 현재 값이 Vold와 같으면 원자적으로 V new로 설정되어야 한다.

### 9.2.2 선형성에 기대기

어떤 환경에서 선형성이 유용할까? 스포츠 시합의 최종 점수 조회는 시시한 예다.

이 상황에서 결과가 몇 초 뒤쳐진다고 해도 실질적인 손해를 유발할 가능성은 거의 없다.

그러나 시스템이 올바르게 동작호도록 만들기 위해 선형성이 중요한 요구사항이 되는 영역이 몇 가지 있다.

#### 잠금과 리더 선출

- 단일 리더 복제를 사용하는 시스템은 스플릿 브레인이 되지 않게 리더가 하나만 되도록 보장해야 한다.
- 이를 위해 아파치 주키퍼와 같은 코디네이션 서비스가 종종 사용된다.
- 이런 코디네이션 작업에는 선형성 저장소 서비스가 기초적인 기반이 된다.

#### 제약 조건과 유일성 보장

- 유일성 제약 조건은 데이터베이스에서 흔하다
- 이를테면 사용자명이나 이메일 주소는 유일한 식별자로 되어야한다.
- 이러한 조건을 강제하고 싶다면 선형성이 필요하다.

#### 채널 간 타이밍 의존성

선형적이지 않다면 경쟁 조건의 위험이 있다.

선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순하다.

#### 잠금과 리더 선출

### 9.2.3 선형성 시스템 구현하기

다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전하다.

### 9.2.4 선형성의 비용

#### CAP 정리

이 문제는 단지 단일 리더 복제와 다중 리더 복제의 결과만은 아니다.

어떤 선형성 데이터베이스라도 구현이 어떻게 됐는지 상관없이 이 문제가 존재한다.

- 애플리케이션이 선형성을 요구하고 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없다. 네트워크 문제가 고쳐질 때까지 기다리거나 오류를 반환해야 한다. (어떤 방법을 쓰든 가용성이 없다.)
- 애플리케이션이 선형성을 요구하지 않는다면 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하느 방식으로 쓰기를 처리할 수 있다. 이경우 가용한 상태를 유지하지만 그 동작은 선형적이지 않다.

따라서 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인하다.

이런 통찰력은 CAP 정리로 널리 알려져 있다.

#### 도움이 안되는 CAP 정리

- CAP는 때때로 세 개 중 2개만 고르라는 것으로 표현된다. 불행하게도 이런 식으로 생각하면 오해의 소지가 있다. 네트워크 분단은 일종의 결함이므로 선택할 수 있는 뭔가가 아니다 좋든 싫든 발생한다.
- 네트워크 올바르게 동작할 때는 시스템이 일관성과 가용성을 모두 제공할 수 있다. 따라서 CAP에서 P는 무조건 발생하므로 A 혹은 C를 선택하는 것이다.
- CAP에 대한 논의에서 가용성이라는 단어의 몇 가지 모순된 정의가 있고 공식적인 정리는 보통의 의미와 부합하지 않는다. 많은 이른바 고가용성 시스템들은 실제로 CAP에서의 가용성에 기이한 정의를 만족시키지 않는다. 그래서 CAP는 피하는게 최선이다.

### 9.3.3 전체 순서 브로드캐스트

프로그램이 단일 CPU 코어에서만 실행된다면 연산의 전체 순서를 정하기 쉽다.

단일 리더 복제는 한 노드를 리더로 선택하고 리더의 단일 CPU 코어에서 모든 연산을 차례대로 배열함으로써 연산의 전체 순서를 정한다.

어려운 문제는 처리량이 단일 리더가 처리할 수 있는 수준을 넘어설 때 시스템을 어떻게 확장할 것인가와 리더에 장애가 발생했을 때 어떻게 장애를 복구처리할 것인가다.

분산 시스템에서 이 문제를 전체 순서 브로드캐스트나 원자적 브로드캐스트로 알려져있다.

전체 순서 브로드캐스트는 노드 사이 메시지를 교환하는 프로토콜로 기술된다.

비공식적으로는 두 가지 안전성 속성을 항상 만족해야 한다.

- 신뢰성 있는 전달: 어떤 메시지도 손실되지 않는다. 메시지가 한 노드에 전달되면 모든 노드에도 전달된다.
- 전체 순서가 정해진 전달: 메시지는 모든 노드에 같은 순서로 전달된다.

#### 전체 순서 브로드캐스트 사용하기

주키퍼나 etcd같은 합의서비스는 전체 순서 브로드캐스트를 실제로 구현한다.

이 사실은 전체 순서 브로드캐스트와 합의 사이에는 강한 연관이 있다는 암시이다.

전체 순서 브로드캐스트는 데이터베이스 복제에 딱 필요한 것이다.

모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은

서로 일관성 있는 상태를 유지한다.

이 원리를 상태 기계 복제라고 한다.

마찬가지로 전체 순서 브로드캐스트는 직렬성 트랜잭션을 구현하는데도 쓸 수 있다.

## 9.4 분산 트랜잭션과 합의

##### 합의 불가능성

- FLP 결과란 어떤 노드가 죽을 위험이 있다면 항상 합의에 이를 수 있는 알고리즘은 없다는 것을 증명한 것이다.
- 분산 시스템에서 노드가 죽을 수 있다고 가정해야 하고, 따라서 신뢰성 있는 합의는 불가능하다 그럼에도 합의를 얻는 알고리즘을 살펴보는 이유는 무엇일까?
- 그 이유는 FLP 결과는 어떤 시계나 타임아웃도 사용할 수 없는 결정적 알고리즘을 가정하는 매우 제한된 모델인 비동기 시스템 모델에서 증명된다는 것이다.
- 알고리즘이 타임아웃을 쓰는게 허용되거나 죽은 것으로 의심되는 노드를 식별하는 다른 방법이 있다면 합의는 해결 가능해진다.
- 알고리즘이 단지 임의의 숫자를 사용하는 것을 허용하기만 해도 불가능성 결과를 회피하는 데 충분하다.
- 그러므로 합의 불가능성에 대한 FLP 결과는 이론적으로 매우 중요하지만 분산 시스템은 보통 현실에서 합의를 달성할 수 있다.

### 9.4.1 원자적 커밋과 2단계 커밋

### 9.4.2 현실의 분산 트랜잭션

### 9.4.3 내결함성을 지닌 합의

- 뷰시스템 , Raft 알고리즘

### 9.4.4 멤버십과 코디네이션 서비스
