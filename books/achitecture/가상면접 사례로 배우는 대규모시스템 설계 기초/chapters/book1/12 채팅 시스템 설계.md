# 12장 채팅 시스템 설계

채팅 애플리케이션은 거의 모든 사람이 사용해 보았을 것이다. 페이스북 메신저, 위챗, 왓츠앱 등이 대표적이다.

## 1단계: 문제 이해 및 설계 범위 확정

### 요구사항

- 일대일 채팅, 그룹 채팅을 지원해야 한다
- 모바일 앱과 웹 애플리케이션을 지원해야 한다
- 규모: 하루 5천만 명이 이용하는 시스템
- 그룹 채팅 인원 제한은 최대 100명이다
- 일대일 채팅, 그룹 채팅, 사용자 접속상태 표시 등을 지원한다
- 텍스트만 전송 가능하다
- 메시지 크기는 100,000자를 넘지 않는다
- 종단 간 암호화는 고려하지 않는다
- 채팅 이력은 영원히 보관한다

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 클라이언트

채팅 시스템의 클라이언트는 모바일 앱일 수도 있고 웹 애플리케이션일 수도 있다. 클라이언트는 서로 직접 통신하지 않는다. 대신, 각 클라이언트는 채팅 서비스와 연결되며, 채팅 서비스는 모든 클라이언트를 지원한다.

### 네트워크 프로토콜

#### HTTP 프로토콜

대부분의 클라이언트/서버 애플리케이션은 HTTP 프로토콜을 사용한다. HTTP는 클라이언트가 요청을 보내면 서버가 응답을 반환하는 방식이다. 이 프로토콜은 통신을 시작하는 쪽이 클라이언트인 경우 잘 동작한다.

하지만 서버에서 클라이언트로 메시지를 보내는 것은 쉽지 않다. 이 문제를 해결하는 기법들:

- 폴링(polling): 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어본다. 응답하는 메시지가 없을 때도 서버 자원이 불필요하게 낭비된다
- 롱 폴링(long polling): 클라이언트가 새 메시지가 반환되거나 타임아웃될 때까지 연결을 유지하는 기법
- 웹소켓(WebSocket): 클라이언트가 연결을 만들고, 연결이 유지되는 동안 양방향 통신을 할 수 있다

#### 웹소켓

웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다. 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다.

웹소켓 연결은 항구적이며 양방향이다.

### 개략적 설계안

채팅 시스템을 다음 세 가지로 나눌 수 있다:

- 무상태 서비스(stateless service)
- 상태 유지 서비스(stateful service)
- 제3자 서비스 연동(third-party integration)

#### 무상태 서비스

로그인, 회원가입, 사용자 프로파일 표시 등의 기능을 제공하는 전통적인 요청/응답 서비스다. 이런 서비스는 무상태 서비스로, 로드밸런서 뒤에 위치한다.

#### 상태 유지 서비스

채팅 서비스가 이에 해당한다. 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하므로 상태를 유지해야 한다.

서비스 탐색(service discovery) 기능이 추천 서버를 클라이언트에게 알려준다. 어떤 서버를 추천할지는 서버 용량, 클라이언트의 지역 위치 등을 기준으로 한다.

#### 제3자 서비스 연동

푸시 알림은 가장 중요한 제3자 서비스다. 새 메시지를 받았다면 설사 앱이 실행 중이 아니라도 알림을 받아야 한다.

### 규모 확장성

소규모 환경이라면 모든 기능을 한 서버에 몰아넣어도 된다. 대규모 환경에서는 다음과 같이 분리한다:

- 채팅 서버: 실시간 메시지 송수신을 처리한다
- 접속상태 서버: 사용자의 접속 여부를 관리한다
- API 서버: 로그인, 회원가입, 프로파일 변경 등의 기능을 제공한다
- 알림 서버: 푸시 알림을 보낸다
- 키-값 저장소: 채팅 이력을 보관한다

### 저장소

- 일반 데이터: 사용자 프로파일, 설정, 친구 목록 등의 데이터는 견고하고 안정적인 관계형 데이터베이스에 보관한다
- 채팅 이력 데이터: 채팅 시스템이 다루는 데이터 가운데 가장 중요하다. 읽기/쓰기 연산의 양이 많고, 무작위적이며, 최근 채팅 메시지만 자주 사용된다. 키-값 저장소를 추천한다

#### 왜 키-값 저장소를 추천하는가?

- 수평적 규모 확장이 쉽다
- 데이터 접근 지연시간이 낮다
- 관계형 데이터베이스는 데이터 가운데 롱테일에 해당하는 부분을 잘 처리하지 못한다
- 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고 있다. 페이스북 메신저는 HBase를, 디스코드는 카산드라를 사용한다

### 데이터 모델

#### 1:1 채팅을 위한 메시지 테이블

메시지 테이블의 기본키는 message_id이다. message_id가 메시지 순서를 결정한다.

#### 그룹 채팅을 위한 메시지 테이블

그룹 채팅 메시지 테이블의 기본키는 (channel_id, message_id)의 복합키다. channel_id는 파티션 키로 사용한다.

## 3단계: 상세 설계

### 서비스 탐색

서비스 탐색의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이다. 사용되는 기준은 다음과 같다:

- 클라이언트의 위치
- 서버의 용량

아파치 주키퍼(Apache Zookeeper)가 이런 일을 하는 유명한 오픈소스 솔루션이다.

### 메시지 흐름

#### 1:1 채팅 메시지 처리 흐름

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 메시지의 ID를 결정
3. 채팅 서버 1은 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. 사용자 B가 접속 중인 경우:
   - 메시지는 사용자 B가 접속 중인 채팅 서버 2로 전송
   - 채팅 서버 2는 메시지를 사용자 B에게 전송
6. 사용자 B가 접속 중이 아닌 경우 푸시 알림 서버로 푸시 알림이 전송됨

#### 여러 단말 사이의 메시지 동기화

각 단말은 cur_max_message_id라는 변수를 유지한다. 이 변수는 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적한다.

새로운 메시지가 있는지 확인하려면 KV 저장소에 보관된 메시지 가운데 cur_max_message_id보다 큰 ID를 가진 메시지를 가져온다.

#### 소규모 그룹 채팅에서의 메시지 흐름

새 메시지가 있는지 확인하는 작업은 각 사용자가 독립적으로 수행한다. 그룹 채팅에 속한 사용자가 메시지를 보내면 그룹 내 나머지 모든 사용자에게 복사본이 전달된다.

### 접속상태 표시

#### 사용자 로그인

웹소켓 연결이 맺어지면 접속상태 서버는 해당 사용자의 상태와 last_active_at 타임스탬프 값을 KV 저장소에 보관한다. 사용자는 온라인 상태가 된다.

#### 로그아웃

사용자가 로그아웃하면 KV 저장소에 보관된 사용자 상태가 offline으로 바뀐다.

#### 접속 장애

사용자의 인터넷 연결이 끊어지면, 클라이언트와 서버 사이에 맺어진 웹소켓 연결이 끊어진다. 간단한 해결책은 사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 바꾸는 것이다.

#### 상태 정보의 전송

접속상태 서버는 pub-sub 모델을 사용한다. 친구 관계마다 채널을 하나씩 두고, 친구 사이의 상태 변화는 해당 채널을 통해 전파한다.

그룹 크기가 작다면 이 방법이 효과적이지만, 그룹 크기가 크면 비용 및 시간이 많이 소모될 것이다. 그런 경우에는 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶을 때 수동으로 하도록 해야 한다.

## 4단계: 마무리

추가로 논의할 만한 주제들:

### 미디어 파일 지원

미디어 파일은 텍스트보다 크기가 훨씬 크다. 압축, 클라우드 저장소, 섬네일 생성 등이 필요하다.

### 종단 간 암호화

메시지가 발신인과 수신인을 제외하고는 누구도 볼 수 없게 하는 것이다. 왓츠앱이 이 방식을 지원한다.

### 캐시

클라이언트는 이미 읽은 메시지를 로컬에 캐시할 수 있다. 서버 레벨에서는 최신 메시지만 캐시에 두고 과거 메시지는 데이터베이스에서 가져오도록 한다.

### 로딩 속도 개선

슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산된 네트워크를 통해 배포한다.

### 오류 처리

- 채팅 서버 오류: 서비스 탐색 기능이 클라이언트에게 새로운 서버를 배정한다
- 메시지 재전송: 재시도나 큐는 일반적으로 사용되는 기법이다
