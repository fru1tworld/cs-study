# 15장 구글 드라이브 설계

구글 드라이브는 파일 저장 및 동기화 서비스다. 파일을 클라우드에 보관하고 어느 단말로든 접근할 수 있으며, 타인과 공유할 수도 있다. 드롭박스, 마이크로소프트 원드라이브, 애플 아이클라우드도 비슷한 서비스를 제공한다.

## 1단계: 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 파일 추가: 파일을 추가하는 가장 쉬운 방법은 드래그 앤 드롭이다
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편집되거나, 삭제되거나, 새롭게 공유되었을 때 알림 표시

### 비기능 요구사항

- 안정성: 데이터 손실이 발생하면 안 된다
- 빠른 동기화 속도: 파일이 처리되기를 오래 기다려야 한다면 사용자는 불만을 느낄 것이다
- 네트워크 대역폭: 작은 대역폭을 사용해야 한다
- 규모 확장성: 대량의 트래픽을 감당할 수 있어야 한다
- 높은 가용성: 일부 서버에 장애가 발생하거나, 네트워크 일부가 끊기거나, 데이터센터 전체 정전이 발생해도 시스템은 계속 이용 가능해야 한다

### 개략적 추정

- 가입 사용자 5천만 명, DAU 천만 명
- 사용자는 평균적으로 10GB의 여유 저장공간을 가진다
- 사용자는 매일 평균 2개의 파일을 업로드한다. 평균 파일 크기는 500KB
- 읽기:쓰기 비율은 1:1
- 필요한 총 저장공간: 5천만 명 X 10GB = 500PB
- 업로드 API QPS: 천만 명 X 2 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = QPS X 2 = 480

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 한 대 서버로 시작

파일 업로드와 다운로드, 데이터베이스, 저장소 등을 한 대 서버에 구현한다면 다음과 같은 구조를 갖게 될 것이다:

- 웹 서버: 파일 업로드와 다운로드 처리
- 데이터베이스: 사용자, 로그인, 파일 정보 등의 메타데이터 관리
- 파일 저장소: 파일 시스템에 파일 저장

### API 서비스

#### 파일 업로드 API

- 단순 업로드: 파일 크기가 작을 때 사용
- 이어 올리기(resumable upload): 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높을 때 사용

#### 파일 다운로드 API

파일을 특정 경로로 다운로드한다.

#### 파일 갱신 이력 취득 API

특정 파일의 갱신 이력을 취득한다.

### 한 대 서버의 제약 극복

한 대 서버로 모든 것을 하려고 하면 다음과 같은 문제가 발생한다:

- 파일 업로드와 다운로드에 하나의 서버만 이용하므로 SPOF 문제가 있다
- 여러 지역의 수백만 사용자를 지원하기 어렵다

확장성을 제공하기 위해 사용할 수 있는 몇 가지 전략:

- 샤딩: 데이터베이스를 더 작은 부분으로 쪼개어 성능 및 확장성 개선
- 로드밸런서: 네트워크 트래픽을 분산시켜 준다
- 웹 서버를 추가: 로드밸런서가 트래픽을 분산시키므로, 웹 서버를 쉽게 추가/삭제할 수 있다
- 메타데이터 데이터베이스와 파일 저장소를 분리: 이 둘은 서로 다른 데이터 접근 패턴을 보이므로, 독립적으로 확장할 수 있도록 분리한다
- 파일을 여러 저장소에 다중화하여 가용성과 안정성을 보장
- 아마존 S3는 같은 지역 안에서 파일을 여러 지역에 다중화하여 99.999999999%의 내구성을 보장한다

### 동기화 충돌

두 사용자가 같은 파일을 동시에 업데이트하려고 할 때 충돌이 발생한다. 먼저 처리되는 변경은 성공하지만, 나중 변경은 충돌이 발생한다.

해결 전략: 사용자에게 충돌이 발생했음을 알려주고, 두 버전을 모두 보여준 다음 어느 버전을 보관할 것인지 선택하게 한다.

### 개략적 설계안

- 사용자 단말
- 블록 저장소 서버: 파일 블록을 클라우드 저장소에 업로드하는 서버다. 블록 저장소는 파일을 여러 블록으로 나눈 다음, 각 블록에 고유한 해시값을 할당하고 저장한다
- 클라우드 저장소: 파일은 블록 단위로 나뉘어 클라우드 저장소에 보관된다
- 아카이빙 저장소(cold storage): 오래되어 사용하지 않는 비활성 데이터를 저장하기 위한 컴퓨터 시스템
- 로드밸런서: 요청을 모든 API 서버에 고르게 분산하는 역할
- API 서버: 파일 업로드 외에 거의 모든 것을 담당하는 서버
- 메타데이터 데이터베이스: 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리
- 메타데이터 캐시: 성능 향상을 위해 데이터베이스에서 자주 사용되는 메타데이터 캐시
- 알림 서비스: 특정 이벤트가 발생하면 클라이언트에게 알려주는 발행-구독(publish-subscribe) 기반 서비스
- 오프라인 사용자 백업 큐: 클라이언트가 오프라인이라면 변경 내용을 이 큐에 두어 나중에 동기화

## 3단계: 상세 설계

### 블록 저장소 서버

파일 업로드 성능을 최적화하기 위해 두 가지 최적화 기법을 사용한다:

- 델타 동기화(delta sync): 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화한다
- 압축: 블록 단위로 압축하여 전송 데이터 크기를 줄인다

### 높은 일관성 요구사항

메타데이터 캐시와 데이터베이스 계층은 강한 일관성(strong consistency) 모델을 지원해야 한다.

메모리 캐시는 결과적 일관성 모델을 지원하므로, 데이터의 최신 버전을 보기 위해서는 다음 전략 중 하나를 적용해야 한다:

- 캐시에 보관된 사본이 최신인지 확인하기 위해 데이터베이스에 질의
- 두 가지 유형의 일관성 모델이 모두 지원되도록 수정

RDBMS를 사용하면 ACID(Atomicity, Consistency, Isolation, Durability) 속성을 제공하기 쉽다.

NoSQL 데이터베이스는 기본적으로 ACID를 지원하지 않지만, 프로그래밍을 통해 ACID 속성을 갖도록 만들 수 있다.

### 메타데이터 데이터베이스

#### 사용자 테이블

사용자의 기본 정보: 사용자명, 이메일, 프로파일 사진 등을 저장한다.

#### 파일 테이블

파일에 대한 최신 정보를 유지한다.

#### 블록 테이블

파일 블록에 대한 정보를 보관한다.

#### 작업공간 테이블

여러 사용자가 같은 작업공간에서 협력할 수 있도록 한다.

### 업로드 절차

두 가지 유형의 요청을 API 서버로 보낸다:

- 파일 메타데이터 추가: 새 파일의 메타데이터를 추가한다
- 파일을 클라우드 저장소에 업로드: 블록 저장소 서버로 파일을 업로드한다

파일 업로드 상세 절차:

1. 클라이언트는 파일 메타데이터 추가 요청을 보낸다
2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기중(pending)으로 변경한다
3. 클라이언트에게 파일 업로드를 시작하라는 응답을 보낸다
4. 파일을 블록 저장소 서버에 전송한다
5. 블록 저장소 서버는 파일을 블록 단위로 나눠 압축하고 암호화한 다음 클라우드 저장소로 전송한다
6. 파일 업로드가 끝나면 클라우드 저장소는 완료 콜백을 호출한다
7. 메타데이터 데이터베이스에 파일 상태를 업로드됨(uploaded)으로 변경한다
8. 알림 서비스에 파일 업로드 완료를 알린다
9. 알림 서비스는 관련된 클라이언트에게 파일이 업로드되었음을 알린다

### 다운로드 절차

파일 다운로드는 다음과 같이 진행된다:

1. 다운로드 요청을 API 서버로 전송
2. API 서버는 메타데이터 데이터베이스로부터 파일 메타데이터를 가져온다
3. API 서버는 클라우드 저장소에서 파일을 다운로드할 URL을 반환한다
4. URL 정보가 클라이언트에게 반환된다
5. 클라이언트는 URL을 사용해 클라우드 저장소에서 파일을 다운로드한다

### 알림 서비스

알림 서비스를 통해 한 클라이언트에서 발생한 변경이 다른 클라이언트에게 알려져 충돌을 줄이고 일관성을 유지할 수 있다.

알림 서비스는 이벤트 데이터를 클라이언트로 보내는 방법으로 롱 폴링과 웹소켓 두 가지가 있다.

양방향 통신이 필요하지 않으므로 롱 폴링을 사용한다.

### 저장소 공간 절약

중복 제거는 불필요한 데이터 사본을 제거하여 저장소 공간을 절약하는 기술이다.

- 계정 수준 중복 제거: 같은 사용자가 같은 파일을 두 번 업로드하지 못하게 한다
- 최상위 계층(top-level) 중복 제거: 이미 다른 사용자가 해당 파일을 업로드했다면 저장소에 업로드하지 않는다
- 블록 수준 중복 제거: 해시 비교를 통해 같은 블록은 한 번만 저장한다

### 장애 처리

#### 로드밸런서 장애

로드밸런서에 장애가 발생하면 부 로드밸런서가 활성화되어 트래픽을 이어받는다.

#### 블록 저장소 서버 장애

다른 서버가 미완료 또는 대기 중인 작업을 이어받는다.

#### 클라우드 저장소 장애

S3 버킷은 여러 지역에 다중화되어 있다. 한 지역에서 장애가 발생하면 다른 지역에서 파일을 가져온다.

#### API 서버 장애

API 서버는 무상태 서버다. 로드밸런서가 장애가 발생한 서버로 트래픽을 보내지 않으면 된다.

#### 메타데이터 캐시 장애

메타데이터 캐시 서버도 다중화한다. 한 노드에 장애가 발생하면 다른 노드에 접속하여 데이터를 가져온다.

#### 메타데이터 데이터베이스 장애

- 주 서버 장애: 부 서버 가운데 하나를 주 서버로 승격한다
- 부 서버 장애: 다른 부 서버가 읽기 연산을 처리하고, 새로운 부 서버로 대체한다

#### 알림 서비스 장애

알림 서버가 많고 하나가 죽어도 서비스는 계속된다.

#### 오프라인 사용자 백업 큐 장애

큐의 크기는 제한되어 있다. 클라이언트가 오랜 시간 오프라인 상태이면 캐시 손실이 발생할 수 있다. 클라이언트 동기화 프로세스로 데이터를 다시 가져와야 한다.

## 4단계: 마무리

추가로 논의할 만한 주제:

- 저장소 용량 초과로부터 시스템을 보호하기 위해 업로드 용량 제한
- 파일의 여러 버전을 추적하고 이전 버전으로 되돌리기
- 여러 버전에 걸친 파일을 모두 보관하는 것은 저장소 용량을 크게 소진하므로, 몇 가지만 보관하도록 제한
- 확장성: 사용자 수가 증가해도 견딜 수 있도록 샤딩 등을 적용
