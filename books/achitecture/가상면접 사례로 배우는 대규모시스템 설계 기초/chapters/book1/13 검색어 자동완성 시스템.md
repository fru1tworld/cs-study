# 13장 검색어 자동완성 시스템

구글 검색창에 무언가를 타이핑하면 검색어를 완성할 만한 질의들이 자동으로 나타난다. 이 기능을 자동완성(autocomplete), 자동완성 검색(typeahead search), 검색어 추천(search-as-you-type) 등으로 부른다.

## 1단계: 문제 이해 및 설계 범위 확정

### 요구사항

- 빠른 응답 속도: 사용자가 검색어를 입력함에 따라 자동완성 검색어가 충분히 빨리 표시되어야 한다. 페이스북 논문에 따르면 100ms 이내여야 한다
- 연관성: 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야 한다
- 정렬: 시스템의 계산 결과는 인기도 등의 순위 모델에 의해 정렬되어야 한다
- 규모 확장성: 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다
- 고가용성: 시스템의 일부에 장애가 발생하거나, 느려지거나, 예상치 못한 네트워크 문제가 생겨도 시스템은 계속 사용 가능해야 한다

### 개략적 규모 추정

- DAU(Daily Active User)는 천만 명이다
- 평균적으로 한 사용자는 매일 10건의 검색을 수행한다
- 질의할 때마다 평균적으로 20바이트의 데이터를 입력한다고 가정
- 문자 인코딩 방법으로는 ASCII를 사용한다고 가정. 1문자 = 1바이트
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다고 가정. 평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다
- 최대 5개의 자동완성 검색어를 제안한다

QPS 추정:

- QPS = 10,000,000 사용자 X 10 질의 / 일 X 20 자 / 24시간 / 3600초 = 약 24,000
- 최대 QPS = QPS X 2 = 약 48,000

## 2단계: 개략적 설계안 제시 및 동의 구하기

시스템을 두 부분으로 나눈다:

- 데이터 수집 서비스: 사용자가 입력한 질의를 실시간으로 수집하는 시스템
- 질의 서비스: 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스

### 데이터 수집 서비스

사용자가 검색창에 뭔가 타이핑할 때마다 입력된 질의와 사용 빈도를 저장한다.

#### 데이터베이스 테이블

질의문과 빈도를 저장하는 관계형 데이터베이스 테이블을 생각해보자. query와 frequency라는 두 개 필드가 있다.

### 질의 서비스

검색어 자동완성을 위한 인기 검색어 다섯 개를 골라내기 위해서는 다음과 같이 하면 된다:

```sql
SELECT * FROM frequency_table
WHERE query LIKE `{사용자 입력 검색어}%`
ORDER BY frequency DESC
LIMIT 5
```

이 방법은 작은 데이터 집합에는 괜찮지만, 데이터가 많을 때는 데이터베이스가 병목이 된다.

### 최적화 방안

#### 트라이(trie) 자료구조

관계형 데이터베이스는 이런 용도로는 적합하지 않다. 트라이 자료구조를 이용하면 효율적으로 처리할 수 있다.

트라이는 문자열들을 간략하게 저장할 수 있는 자료구조다. 이름은 retrieval의 중간 부분에서 따왔지만, 보통 "try"로 발음한다.

트라이 자료구조의 핵심 아이디어는 다음과 같다:

- 트라이는 트리 형태의 자료구조다
- 이 트리의 루트 노드는 빈 문자열을 나타낸다
- 각 노드는 글자 하나를 저장하며, 26개(영문자)의 자식 노드를 가질 수 있다
- 각 트리 노드는 하나의 단어 또는 접두어 문자열을 나타낸다

트라이 자료구조를 사용하면 접두어 문자열로 시작하는 검색어들을 효율적으로 찾아낼 수 있다.

#### 노드에 인기 검색어 캐시

각 노드에 인기 검색어를 k개 캐시해 두면, 최고 인기 검색어 k개를 골라내는 일은 시간 복잡도 O(1)에 끝낼 수 있다.

각 노드마다 검색어 빈도수 정보를 저장해야 하므로, 공간을 많이 차지한다는 단점이 있다.

#### 데이터 수집 서비스

실시간으로 매번 트라이를 갱신하는 것은 실용적이지 않다. 이유는 다음과 같다:

- 매일 수천만 건의 질의가 입력될 것이다
- 트라이가 너무 자주 갱신되면, 자동완성을 제공하는 질의 서비스가 느려진다

따라서 트라이는 주기적으로(예: 매주) 갱신되도록 한다.

## 3단계: 상세 설계

### 트라이 연산

#### 트라이 생성

트라이는 데이터 분석 서비스 또는 로깅 서비스로부터 집계된 데이터를 이용해 만든다.

#### 트라이 갱신

트라이를 매주 한 번 갱신한다고 가정하면:

- 매주 새로 만들고 기존 트라이는 교체한다
- 트라이의 각 노드를 개별적으로 갱신한다

### 질의 서비스

#### AJAX 요청

웹 애플리케이션의 경우, 브라우저는 보통 AJAX 요청을 보낸다. AJAX 요청의 주된 장점은 웹 페이지를 새로고침하지 않고도 서버에 데이터를 전송하고 받아올 수 있다는 것이다.

#### 브라우저 캐싱

대부분의 애플리케이션에서 자동완성 검색 결과는 짧은 시간 안에 자주 바뀌지 않는다. 따라서 자동완성 제안 결과를 브라우저 캐시에 넣어두면 후속 질의의 결과는 해당 캐시에서 바로 가져갈 수 있다.

#### 데이터 샘플링

모든 질의 결과를 로깅하도록 해놓으면 CPU 자원과 저장공간을 엄청나게 소진하게 된다. 데이터 샘플링은 이런 문제를 완화하는데 유용하다. N개 요청 가운데 1개만 로깅하도록 하는 것이다.

### 트라이 연산

#### 트라이 생성

작업 서버가 분석 서비스의 로그나 데이터베이스로부터 집계된 데이터를 이용해 주기적으로 트라이를 만든다.

#### 트라이 갱신

트라이를 갱신하는 방법은 두 가지다:

- 매주 한 번 새로 만들어 기존 트라이를 교체한다
- 각 노드를 개별적으로 갱신한다

### 검색어 삭제

혐오성이 짙거나, 폭력적이거나, 성적으로 노골적이거나, 위험한 자동완성 제안 검색어는 자동완성 결과에서 제거되어야 한다.

이런 제안 검색어를 제거하기 위한 방법:

- 필터 계층을 두고, 부적절한 질의어가 반환되기 전에 걸러낸다
- 트라이 캐시 앞에 필터 계층을 두고, 부적절한 검색어가 클라이언트로 전송되지 않도록 한다

### 저장소 규모 확장

영어만 지원한다고 가정하면 트라이에 최대 26개의 자식 노드가 있다. 대략적으로 1TB의 저장소가 필요할 것이다.

이 트라이를 한 대 서버에 넣기는 불가능하므로, 샤딩을 통해 규모 확장성을 달성해야 한다.

첫 글자를 기준으로 샤딩하면, 최대 26대의 서버가 필요할 것이다. 하지만 서버마다 보관하는 데이터 양이 균등하지 않을 것이므로, 과거 질의 데이터 패턴을 분석하여 샤딩을 하는 것이 바람직하다.

## 4단계: 마무리

추가로 논의할 만한 주제들:

### 다국어 지원

유니코드 데이터를 저장해야 한다.

### 국가별 인기 검색어

국가별로 다른 트라이를 사용하여 지원할 수 있다. CDN을 사용하면 응답시간을 더 줄일 수 있다.

### 실시간 검색어

실시간 검색어를 지원하려면 샤딩, 로깅, 집계 및 순위 결정 알고리즘 등을 변경해야 한다.

실시간 검색어에 대한 아이디어:

- 순위 모델 변경: 최근 검색어에 더 높은 가중치 부여
- 스트림 처리 사용: 실시간으로 데이터를 처리
- 샤딩 최적화
