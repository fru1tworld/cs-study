# DHCP(Dynamic Host Configuration Protocol)

- DHCP는 네트워크에 연결된 장치(클라이언트)가 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소와 같은 네트워크 설정을 자동으로 할당받을 수 있도록 지원하는 네트워크 관리 프로토콜입니다.
- 이 프로토콜은 네트워크 관리자에게 수동으로 IP 주소를 설정할 필요 없이, 장치들이 네트워크에 쉽게 연결되도록 도와줍니다.

## DHCP의 주요 기능

### 자동 IP 주소 할당

- 네트워크에 연결된 장치(예: 컴퓨터, 스마트폰, 프린터)는 DHCP를 통해 사용 가능한 IP 주소를 자동으로 할당받습니다.
- 이 과정은 사용자가 직접 설정하지 않아도 이루어집니다.

### 중복 IP 주소 방지

- DHCP 서버는 네트워크에서 중복된 IP 주소가 할당되지 않도록 관리합니다.
- 이는 네트워크 충돌을 방지하고 안정성을 유지합니다.
  ### 네트워크 설정 정보 제공
- DHCP는 IP 주소 외에도 다음과 같은 정보를 제공할 수 있습니다:

- 서브넷 마스크: 네트워크와 호스트를 구분하는 데 사용.
- 기본 게이트웨이: 네트워크를 넘어 외부로 데이터를 전송하기 위한 라우터 주소.
- DNS 서버: 도메인 이름을 IP 주소로 변환하기 위한 서버 주소.

### 유지보수 단순화

- 장치가 많거나 자주 변경되는 네트워크 환경에서도 DHCP를 사용하면 IP 주소 관리가 간소화됩니다.

## DHCP 동작 과정

1. DHCP Discover (탐색)
   클라이언트(장치)가 네트워크에 연결되면 브로드캐스트 메시지로 "IP 주소를 주세요!"라는 요청을 DHCP 서버에게 보냅니다.
   메시지 형식: DHCP Discover.
2. DHCP Offer (제안)
   네트워크에 있는 DHCP 서버는 사용 가능한 IP 주소를 확인한 뒤, 클라이언트에게 IP 주소 제안 메시지를 보냅니다.
   메시지 형식: DHCP Offer.
   이 메시지에는 제안된 IP 주소와 함께 서브넷 마스크, 게이트웨이 주소 등의 정보가 포함됩니다.
3. DHCP Request (요청)
   클라이언트는 받은 제안을 확인하고, 자신에게 할당된 IP 주소를 수락하기 위해 DHCP Request 메시지를 보냅니다.
   이 과정에서 다른 DHCP 서버의 제안을 거절합니다.
4. DHCP Acknowledgement (확인)
   DHCP 서버는 클라이언트의 요청을 확인하고, IP 주소를 최종적으로 할당하며 네트워크 설정 정보를 전달합니다.
   메시지 형식: DHCP ACK(Acknowledgement).
   이 과정을 통해 클라이언트는 네트워크 연결에 필요한 정보를 얻고, 정상적으로 통신을 시작할 수 있습니다.

## DHCP의 구성 요소

### DHCP 서버

- 네트워크에 연결된 장치들에게 IP 주소와 기타 네트워크 정보를 제공하는 장치 또는 소프트웨어.
- 예: 라우터나 독립적인 DHCP 서버.

### DHCP 클라이언트

- 네트워크에 연결되어 DHCP 서버로부터 설정 정보를 요청하는 장치.
- 예: 컴퓨터, 스마트폰, IoT 장치.

### DHCP 리스(Lease)

- DHCP 서버가 IP 주소를 클라이언트에게 일정 기간 동안만 임시로 할당하는 방식.
- 리스 시간이 만료되면 클라이언트는 주소를 갱신하거나 새로운 주소를 요청합니다.

## HTTP Response Status Code

### 1xx: 정보 응답

- 100 Continue: 클라이언트가 요청을 계속 진행해도 됨을 나타냅니다.

### 2xx: 성공

- 200 OK: 요청이 성공적으로 처리되었음을 나타냅니다.
- 201 Created: 요청이 성공적으로 처리되었고 리소스가 생성되었음을 나타냅니다.
- 204 No Content: 요청은 성공했지만 반환할 데이터가 없음을 나타냅니다.

### 3xx: 리다이렉션

- 301 Moved Permanently: 요청된 리소스의 URI가 변경되었음을 나타냅니다. 클라이언트는 새 URI로 리소스를 요청해야 합니다.
- 302 Found: 요청된 리소스가 일시적으로 다른 URI에 있음을 나타냅니다.
- 304 Not Modified: 클라이언트가 캐시된 리소스를 사용할 수 있음을 나타냅니다.

### 4xx: 클라이언트 오류

- 400 Bad Request: 잘못된 요청입니다. 서버가 요청을 이해할 수 없습니다.
- 401 Unauthorized: 인증이 필요합니다.
- 403 Forbidden: 서버가 요청을 거부했습니다.
- 404 Not Found: 요청한 리소스를 찾을 수 없습니다.
- 429 Too Many Requests: 클라이언트가 너무 많은 요청을 보냈음을 나타냅니다.

### 5xx: 서버 오류

- 500 Internal Server Error: 서버에서 요청을 처리하는 동안 오류가 발생했습니다.
- 502 Bad Gateway: 게이트웨이 또는 프록시 서버가 잘못된 응답을 받았음을 나타냅니다.
- 503 Service Unavailable: 서버가 일시적으로 사용 불가능함을 나타냅니다.
- 504 Gateway Timeout: 게이트웨이 또는 프록시 서버가 응답을 기다리다 시간 초과됨을 나타냅니다.

#

## 3-way Handshake에서 교환되는 추가 정보와 정책

1. SYN 패킷 (클라이언트 → 서버)
   클라이언트는 연결 요청과 함께 초기 설정 및 옵션 정보를 전달합니다:

### MSS (Maximum Segment Size):

- 클라이언트가 한 번에 전송할 수 있는 TCP 세그먼트의 최대 크기를 제안합니다.
- 이는 IP 패킷 크기(기본적으로 MTU)에서 TCP/IP 헤더 크기를 뺀 값입니다.
- 예: Ethernet의 MTU가 1500바이트라면 MSS는 일반적으로 1460바이트.

### Window Size:

- 클라이언트가 수신 가능한 데이터의 크기를 나타냅니다.
- 이를 통해 흐름 제어(flow control)를 지원합니다.

### Selective Acknowledgment (SACK) Permitted:

- 선택적 ACK 옵션 지원 여부를 표시합니다.
- 이 옵션이 활성화되면, 패킷 손실 시 효율적으로 재전송할 수 있습니다.

### Timestamps (옵션):

- RTT(Round Trip Time) 측정 및 PAWS(Protect Against Wrapped Sequence)와 같은 기능 지원. 2. SYN-ACK 패킷 (서버 → 클라이언트)
- 서버는 클라이언트 요청을 수락하며 자신만의 설정과 옵션 정보를 추가로 전달합니다:
- MSS: 서버도 자신의 MSS 값을 제안합니다.
- Window Size: 서버가 수신 가능한 데이터 크기를 설정합니다.
- SACK Permitted: 서버 측에서도 SACK 옵션을 사용할 수 있음을 알립니다.
- Timestamps: 서버가 지원하는 경우, 해당 값을 추가로 포함합니다. 3. ACK 패킷 (클라이언트 → 서버)

- ACK 패킷은 연결을 최종적으로 확정하며, 클라이언트와 서버 간 정책 및 옵션 설정이 완료됩니다.
- 이 단계에서는 추가적인 설정은 포함되지 않고, 주로 ACK 정보만 전달됩니다.

## 교환되는 주요 정책 요약

### 옵션/정책 설명

- MSS 한 번에 전송 가능한 최대 세그먼트 크기
- Window Size 흐름 제어를 위한 수신 창 크기
- SACK Permitted 선택적 ACK를 통한 효율적인 재전송 지원 여부
- Timestamps RTT 측정 및 PAWS를 위한 시간 정보
- Nagle Algorithm 소량의 데이터를 합쳐 전송할지 여부 (일반적으로 handshake 단계에서 협상되지 않지만 중요한 TCP 정책 중 하나)

## 정리

- TCP 3-way handshake 과정은 단순히 연결을 설정하는 것뿐만 아니라, 전송 효율성과 신뢰성을 높이기 위한 옵션 및 정책을 교환하는 단계입니다. 이를 통해 클라이언트와 서버는 최적의 통신 환경을 협상하게 됩니다.

# TLS 인증서

- TLS는 서버와 클라이언트 간의 신뢰를 보장하기 위해 디지털 인증서를 사용합니다.
- 디지털 인증서는 인증 기관(CA, Certificate Authority)이 발행하며, 클라이언트는 이를 통해 서버가 신뢰할 수 있는 엔터티인지 확인합니다.

1. 인증서 구성 요소
   **공개 키 (Public Key)**: 서버의 공개 키를 포함하며, 클라이언트가 데이터를 암호화하거나 신원을 확인하는 데 사용합니다.
   **인증서 서명(Signature)**: 상위 인증 기관의 개인 키로 서명하여 인증서의 무결성을 보장합니다.
   **도메인 정보**: 해당 인증서가 유효한 도메인을 포함합니다.
   유효 기간: 인증서의 만료일이 명시됩니다.
2. 인증서 알고리즘
   디지털 인증서에서 사용되는 주요 알고리즘에는 다음이 포함됩니다:

### RSA (Rivest-Shamir-Adleman):

- 가장 널리 사용되는 공개 키 암호화 알고리즘 중 하나입니다.
- 주로 서버 인증서와 클라이언트 암호화에 사용됩니다.
- TLS 1.3에서는 RSA 키 교환이 사용되지 않지만, 인증서 서명에는 여전히 사용될 수 있습니다.

### ECDSA (Elliptic Curve Digital Signature Algorithm):

- RSA보다 더 짧은 키 길이로 높은 보안을 제공합니다.
- 효율적인 키 교환과 디지털 서명에 적합하며, TLS 1.3에서 선호되는 알고리즘 중 하나입니다.

### EdDSA (Edwards-Curve Digital Signature Algorithm):

- 최신 알고리즘으로, TLS 1.3에서 도입되었습니다.
- 높은 보안성과 속도를 제공하며, Ed25519와 같은 곡선이 자주 사용됩니다. 3. 하위 인증 기관과 루트 인증서
- 루트 인증서: 신뢰 체계의 최상위 인증 기관에서 발급하는 인증서로, 클라이언트가 기본적으로 신뢰합니다.
- 중간 인증서: 루트 인증 기관이 직접 인증서를 발급하지 않고, 중간 인증 기관을 통해 서명하여 계층적인 신뢰 체계를 만듭니다.

### 요약

- TLS는 인터넷 보안을 책임지는 핵심 프로토콜로, 암호화, 인증, 무결성을 제공합니다.
- TLS 1.3은 보안 강화와 성능 개선을 위해 설계되었으며, 구식 알고리즘을 제거하고 핸드셰이크 과정을 간소화했습니다.

### 디지털 인증서는 공개 키 기반 알고리즘(RSA, ECDSA 등)을 사용하여 신뢰성을 보장합니다. TLS 1.3에서는 더욱 안전하고 효율적인 알고리즘이 사용됩니다.

- 체크섬(checksum)은 데이터 통신에서 데이터 무결성을 검증하기 위해 사용되는 기법입니다.
- 네트워크에서 데이터를 전송하는 과정에서 오류가 발생할 수 있는데, 체크섬은 이러한 오류를 감지하는 데 유용합니다.
- 아래에 체크섬의 개념, 작동 방식, 활용 사례 등을 자세히 설명하겠습니다.

1. 체크섬의 정의
   체크섬은 송신 측에서 데이터를 기반으로 특정 알고리즘을 사용해 생성된 값입니다. 이 값은 데이터를 전송할 때 함께 보내지며, 수신 측에서 동일한 알고리즘으로 데이터를 검증하여 오류를 확인합니다.

2. 체크섬의 생성과 검증 과정
   (1) 체크섬 생성 (송신 측)
   전송할 데이터를 특정 크기의 블록으로 나눕니다.
   각 블록의 값을 합산하거나 특정 연산(예: XOR, CRC 등)을 수행하여 하나의 값(체크섬)을 생성합니다.
   이 체크섬 값을 원래 데이터와 함께 전송합니다.
   (2) 체크섬 검증 (수신 측)
   수신된 데이터와 함께 전달된 체크섬 값을 분리합니다.
   수신된 데이터에 대해 동일한 알고리즘을 적용해 체크섬 값을 계산합니다.
   계산한 체크섬 값과 수신된 체크섬 값을 비교합니다.
   일치: 데이터가 손상되지 않음.
   불일치: 데이터가 전송 중 손상되었음.
3. 체크섬의 활용 사례
   (1) 네트워크 프로토콜
   IP 헤더 체크섬 (IPv4)
   IP 패킷 헤더의 무결성을 검증하기 위해 사용됩니다. 각 필드의 값을 합산한 뒤, 1의 보수 값을 계산해 체크섬으로 사용합니다. IPv6에서는 보다 강력한 오류 검출을 위해 체크섬이 사용되지 않습니다.

### TCP/UDP 체크섬

- TCP와 UDP는 데이터 페이로드와 헤더를 포함하여 체크섬을 계산합니다.
  이를 통해 애플리케이션 계층까지 전달되는 데이터의 무결성을 보장합니다.

### (2) 파일 전송

- 파일 전송 프로토콜에서 데이터가 손상 없이 전달되었는지 확인하기 위해 체크섬이 사용됩니다. 예: FTP, HTTP(S).

### (3) 저장 및 복구

- 데이터가 저장되는 동안 발생할 수 있는 손상을 감지하기 위해 체크섬이 사용됩니다. 예: RAID, 디스크 저장 시스템.

### (4) 무선 통신

- 데이터 패킷이 전송되는 도중 간섭이나 잡음으로 인해 오류가 발생했는지 검증합니다. 4. 체크섬의 종류

### (1) 단순 합산 방식

- 데이터를 일정 크기 블록으로 나누어 모든 값을 단순히 합산하여 계산. 계산 속도가 빠르지만 오류 검출 능력이 떨어질 수 있음.

### (2) XOR 방식

- 각 블록을 XOR 연산하여 결과를 생성. 단순 오류 감지에 적합.

### (3) CRC (Cyclic Redundancy Check)

- 이진 다항식으로 데이터를 나누는 방식. 오류 검출 능력이 매우 뛰어나며, 네트워크 및 저장 시스템에서 널리 사용됨.

### (4) MD5, SHA-1 등

- 암호학적 해시 함수로, 데이터를 고정 크기의 해시 값으로 변환. 데이터 변경이 민감하게 반영되지만, 체크섬보다는 보안 목적에 더 적합. 5. 체크섬의 한계
- 오류 수정 불가능

- 체크섬은 오류를 감지할 수 있지만, 데이터를 복구하거나 수정하지는 못합니다.
- 데이터 복구에는 별도의 방식(예: ECC, 리드 솔로몬 코드 등)이 필요합니다.

### 한계적인 검출 능력

- 체크섬은 데이터의 손상이 특정 방식으로 발생할 경우 감지하지 못할 수 있습니다.
- 예: 값의 교환, 특정 패턴의 오류.

### 충돌 가능성

- 서로 다른 데이터가 동일한 체크섬 값을 가질 가능성이 있으며, 이는 충돌(collision)이라고 합니다. 6. 체크섬의 장점
- 간단한 구현: 알고리즘이 간단하여 구현 및 계산 속도가 빠릅니다.
- 낮은 오버헤드: 전송 데이터에 추가되는 체크섬 값이 작아 네트워크 대역폭에 큰 영향을 미치지 않습니다.
- 오류 감지 효율성: 단순한 오류를 효과적으로 감지할 수 있습니다.

# 서브넷(Subnet)

- 서브넷은 하나의 네트워크를 더 작은 네트워크로 나누는 방식입니다.
- 서브넷을 통해 네트워크 자원을 효율적으로 관리하고, 네트워크 트래픽을 줄이며 보안을 강화할 수 있습니다.

## 서브넷의 핵심 개념

### 네트워크와 호스트 분리

- IP 주소는 네트워크 부분과 호스트 부분으로 나뉩니다.
- 서브넷 마스크는 이를 구분하는 데 사용됩니다.
- 예: 서브넷 마스크 255.255.255.0은 처음 24비트가 네트워크 부분이고, 나머지 8비트가 호스트 부분임을 나타냅니다.

### 서브넷 마스크(Subnet Mask)

- 네트워크와 호스트를 구분하는 데 사용되는 32비트 값.
- 이진수에서 1은 네트워크 부분, 0은 호스트 부분을 나타냅니다.
- 예:
- 255.255.255.0 = 11111111.11111111.11111111.00000000

### 서브넷 계산 예제

- IP 주소: 192.168.1.0
- 서브넷 마스크: 255.255.255.0
- => 네트워크에는 256개의 주소(2^8)가 포함됩니다.
- 호스트 주소: 254개 (256 - 2):
- 한 주소는 네트워크 식별, 다른 하나는 브로드캐스트 용도로 사용되므로 실제 사용 가능한 호스트는 254개입니다.
- 클래스 기반 IP 주소(Classful Addressing)
- 초기에는 IP 주소를 관리하기 위해 클래스(Classful Addressing)가 사용되었습니다. 클래스는 네트워크 크기에 따라 IP 주소를 분류합니다.

### 클래스의 구분

#### 클래스 A

- 범위: 1.0.0.0 ~ 126.255.255.255
- 서브넷 마스크: 255.0.0.0 (네트워크 부분 8비트, 호스트 부분 24비트)
- 사용 예: 대규모 네트워크 (수십만 개의 호스트 가능).

#### 클래스 B

- 범위: 128.0.0.0 ~ 191.255.255.255
- 서브넷 마스크: 255.255.0.0 (네트워크 부분 16비트, 호스트 부분 16비트)
- 사용 예: 중규모 네트워크.

#### 클래스 C

- 범위: 192.0.0.0 ~ 223.255.255.255
- 서브넷 마스크: 255.255.255.0 (네트워크 부분 24비트, 호스트 부분 8비트)
- 사용 예: 소규모 네트워크.

#### 클래스 D

- 범위: 224.0.0.0 ~ 239.255.255.255
- 사용 목적: 멀티캐스트.

#### 클래스 E

- 범위: 240.0.0.0 ~ 255.255.255.255
- 사용 목적: 연구/실험용.

### 클래스 기반의 한계

- 네트워크 크기 조정이 비효율적입니다.
- 예: 클래스 A는 너무 큰 네트워크를 할당하고, 클래스 C는 너무 작은 네트워크를 할당합니다.
- 이로 인해 IP 주소 낭비가 발생합니다.

## CIDR(Classless Inter-Domain Routing)

- CIDR는 클래스 기반의 한계를 극복하기 위해 도입된 방식으로, 네트워크 주소를 유연하게 나누고 IP 주소를 효율적으로 관리할 수 있도록 합니다.

## CIDR의 특징

### 슬래시 표기법 (Slash Notation)

- CIDR은 IP 주소 뒤에 **슬래시(/)**와 함께 네트워크 비트 수를 표시합니다.
- 예:
- 192.168.1.0/24: 네트워크 부분이 24비트이고, 호스트 부분이 8비트입니다.
- 10.0.0.0/8: 네트워크 부분이 8비트이고, 호스트 부분이 24비트입니다.

### 유연한 네트워크 크기

- 네트워크를 클래스에 의존하지 않고 필요한 크기만큼 나눌 수 있습니다.
- 예:
  25는 128개의 IP 주소를 가짐.
  26은 64개의 IP 주소를 가짐.

### IP 주소 블록 할당

- ISP는 CIDR을 사용해 고객에게 필요한 크기의 IP 주소 블록을 할당합니다.
- 예: 192.168.1.0/27은 32개의 IP 주소를 포함.

### CIDR과 서브넷팅의 차이

서브넷팅: 기존 네트워크를 더 작은 네트워크로 나눕니다.
CIDR: 새로운 방식으로 네트워크 크기를 자유롭게 정의합니다.

### 서브넷과 CIDR의 사용 사례

#### 서브넷팅

- 대규모 네트워크를 소규모 네트워크로 나누어 트래픽과 보안을 관리.
- 예: 회사 내 부서별로 독립적인 네트워크 구성.

#### CIDR

- 인터넷 서비스 제공자(ISP)가 고객에게 필요한 크기의 IP 블록을 할당.
- 예: 소규모 기업에 /29(8개 IP 주소) 제공.

# TCP 오류제어, 흐름제어, 혼잡제어

### 1. 오류 제어 (Error Control)

- 오류 제어는 데이터를 전송하는 동안 발생할 수 있는 오류를 감지하고, 이를 수정하거나 재전송하여 신뢰성을 보장하는 기능입니다.

주요 기법:

- 검사합(Checksum):

- TCP 헤더와 데이터에 대해 16비트 체크섬을 생성하여 데이터의 무결성을 확인합니다.
- 수신자가 체크섬을 다시 계산하여 송신자의 체크섬과 비교하여 오류를 검출합니다.

### 긍정적 확인 및 재전송 (ACK and Retransmission):

- 송신자는 데이터가 올바르게 수신되었는지 확인하기 위해 **ACK(acknowledgment)**를 기다립니다.
- ACK를 받지 못하면 해당 데이터를 재전송합니다.

### 타이머 기반 재전송 (Timeout):

- 송신자는 데이터를 전송한 후 ACK를 받을 때까지 타이머를 설정합니다.
- 타이머가 만료되면 해당 데이터를 재전송합니다.

### 순서 제어 (Sequence Control):

- 데이터를 청크 단위로 분할하여 시퀀스 번호를 부여합니다.
- 수신자는 시퀀스 번호를 기반으로 데이터를 올바른 순서로 재조립하고, 누락된 패킷을 감지합니다.

### 2. 흐름 제어 (Flow Control)

- 흐름 제어는 송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 전송 속도를 조절하는 기능입니다. TCP는 슬라이딩 윈도우(Sliding Window) 프로토콜을 사용합니다.

## 주요 개념:

### 윈도우 크기(Window Size):

- 수신자는 자신이 처리할 수 있는 최대 데이터 크기(버퍼 크기)를 윈도우 크기로 송신자에게 알려줍니다.
- 송신자는 이 크기를 초과하지 않도록 데이터를 전송합니다.
  동적 윈도우 크기 조정:

- 수신자가 처리 능력에 따라 윈도우 크기를 동적으로 변경합니다.
- 윈도우 크기가 0이 되면 송신자는 수신자로부터 새로운 윈도우 크기를 받을 때까지 전송을 멈춥니다.
  예:
- 송신자는 수신자가 처리할 준비가 될 때까지 데이터를 기다림으로써 수신자의 버퍼 오버플로를 방지합니다.

### 3. 혼잡 제어 (Congestion Control)

- 혼잡 제어는 네트워크 내 혼잡 상황(패킷 손실, 지연 증가)을 방지하거나 해결하기 위한 기법입니다. 네트워크의 전체 성능을 고려하여 송신 속도를 조절합니다.

## 주요 알고리즘:

### 슬로우 스타트 (Slow Start):

- 송신자는 처음에 낮은 전송 속도로 시작합니다.
- 네트워크 상태를 확인하면서 전송 속도를 지수적으로 증가시킵니다.
- 혼잡 윈도우(Congestion Window, CWND)라는 값을 사용하여 전송할 수 있는 데이터 양을 결정합니다.

### 혼잡 회피 (Congestion Avoidance):

- 혼잡 윈도우(CWND)가 특정 임계값(임계 윈도우, SSTHRESH)에 도달하면 속도를 선형적으로 증가시킵니다.
- 혼잡 가능성을 줄이기 위해 신중하게 전송 속도를 조정합니다.

### 빠른 재전송 (Fast Retransmit):

- 송신자는 세 개 이상의 중복 ACK를 수신하면 데이터가 손실되었다고 판단하고 즉시 재전송합니다.
- 타이머 만료를 기다리지 않고 혼잡을 빠르게 해결합니다.

### 빠른 복구 (Fast Recovery):

- 손실이 감지된 후, 혼잡 윈도우를 절반으로 줄이고 선형적으로 증가시킵니다.
- 슬로우 스타트로 돌아가지 않고 혼잡 회피 단계에서 복구를 시작합니다.

### 종합적인 동작

- TCP는 오류 제어, 흐름 제어, 혼잡 제어를 통합적으로 사용하여 다음을 달성합니다:

## 정리

- 데이터의 무결성 보장(오류 제어)
- 송신자와 수신자의 균형 유지(흐름 제어)
- 네트워크 안정성과 효율성 유지(혼잡 제어)

# SDN(Software-Defined Networking)

- SDN(Software-Defined Networking)은 네트워크를 소프트웨어적으로 정의하고 관리하는 기술 및 아키텍처입니다.
- 기존의 하드웨어 중심 네트워크와 달리, SDN은 네트워크를 유연하고 동적으로 구성할 수 있게 해줍니다.
- 이를 통해 네트워크의 복잡성을 줄이고, 효율성을 높이며, 다양한 요구 사항에 더 쉽게 대응할 수 있습니다.

## SDN의 주요 개념

데이터 플레인과 컨트롤 플레인의 분리:

- 전통적인 네트워크 장비(스위치, 라우터 등)에서는 데이터 전송(데이터 플레인)과 제어(컨트롤 플레인)가 같은 장비에서 처리됩니다.
- SDN은 이 두 가지를 분리하여, 데이터 플레인은 패킷을 전달하는 역할만 수행하고, 컨트롤 플레인은 중앙 집중식 컨트롤러가 담당합니다.

### 중앙 집중식 제어:

- SDN 컨트롤러는 네트워크의 모든 장치를 중앙에서 관리합니다. 이를 통해 네트워크 전체를 단일 시스템처럼 제어할 수 있습니다.
- 컨트롤러는 네트워크 상태를 실시간으로 파악하고, 정책이나 라우팅을 동적으로 설정합니다.

### 프로그래머블 네트워크:

- SDN은 네트워크 동작을 소프트웨어로 프로그래밍할 수 있도록 API를 제공합니다.
- 이를 통해 자동화된 네트워크 관리와 애플리케이션과의 통합이 가능해집니다.

## SDN의 구조

SDN은 세 가지 주요 계층으로 구성됩니다:

### 애플리케이션 계층 (Application Layer):

- 네트워크를 사용하는 애플리케이션들이 위치합니다.
- 예: 트래픽 관리 애플리케이션, 로드 밸런싱, 방화벽 등.
- 이 계층은 컨트롤 계층과 상호작용하여 네트워크 요구 사항을 전달합니다.

### 컨트롤 계층 (Control Layer):

- 중앙 집중식 컨트롤러가 위치합니다.
- 컨트롤러는 네트워크 장치로부터 정보를 수집하고, 정책이나 라우팅 규칙을 설정합니다.
- OpenFlow 같은 프로토콜을 사용하여 데이터 계층과 통신합니다.

### 데이터 계층 (Data Layer):

- 실제 네트워크 장치(스위치, 라우터 등)가 위치합니다.
- 컨트롤 계층의 지시에 따라 데이터 패킷을 전달합니다.

## SDN의 장점

### 유연성:

- 네트워크를 소프트웨어적으로 프로그래밍하여 빠르게 변경할 수 있습니다.
- 새로운 서비스나 기술을 쉽게 도입할 수 있습니다.

### 중앙 집중화:

네트워크 전반에 대한 가시성과 제어가 향상됩니다.
트래픽 흐름을 최적화하고, 문제를 신속히 해결할 수 있습니다.

### 자동화 및 효율성:

수작업으로 네트워크를 구성할 필요 없이, 자동화된 도구를 통해 관리할 수 있습니다.
운영 비용을 절감하고 오류를 줄입니다.

### 확장성:

새로운 장치를 네트워크에 추가하거나 기존 장치를 변경하는 작업이 간단해집니다.

### SDN의 단점 및 과제

### 보안 문제:

중앙 집중식 컨트롤러가 공격받으면 전체 네트워크가 영향을 받을 수 있습니다.
컨트롤러와 장치 간의 통신이 안전해야 합니다.

### 복잡한 초기 설정:

기존 네트워크를 SDN으로 전환하는 데 시간이 많이 걸릴 수 있습니다.
관련 기술과 프로토콜에 대한 깊은 이해가 필요합니다.

### 표준화 부족:

다양한 SDN 솔루션과 프로토콜(OpenFlow, NETCONF 등)이 존재하여 상호운용성이 제한될 수 있습니다.
SDN의 주요 프로토콜

### OpenFlow:

가장 널리 사용되는 SDN 프로토콜 중 하나입니다.
컨트롤러와 네트워크 장치 간의 통신을 정의합니다.

### NETCONF:

네트워크 장치의 설정을 관리하는 데 사용되는 프로토콜입니다.
XML 기반으로 데이터 전송이 이루어집니다.

### gRPC/TLS:

SDN 컨트롤러와 장치 간의 고성능 통신을 위한 프로토콜로 사용됩니다
