# 운영체제 정리: 데드락, 물리 메모리, 가상 메모리

---

## 데드락 (Deadlock)

### 1. 데드락이란?

- **정의**: 두 개 이상의 프로세스가 서로의 작업 완료를 기다리며 영원히 실행되지 못하는 상태.
- **발생 조건** (Coffman 조건):
  1. **상호 배제**: 자원은 한 번에 하나의 프로세스만 사용할 수 있음.
  2. **점유와 대기**: 자원을 점유한 프로세스가 추가 자원을 기다림.
  3. **비선점**: 이미 할당된 자원은 강제로 빼앗을 수 없음.
  4. **환형 대기**: 대기 중인 프로세스들 사이에 원형 대기 상태가 발생.

### 2. 데드락 해결 방법

- **예방**: 데드락 발생 조건 중 하나 이상을 제거.
  - 상호 배제 조건 제거: 공유 자원 사용을 최소화.
  - 점유와 대기 조건 제거: 자원을 요청할 때, 필요한 모든 자원을 한 번에 할당.
  - 비선점 조건 제거: 자원을 강제로 회수 가능하게 설계.
  - 환형 대기 조건 제거: 자원에 순서를 부여하고 순서대로만 요청.
- **회피**: 데드락 가능성을 실시간으로 감지하고 피함 (예: 은행가 알고리즘).
- **탐지 및 복구**: 데드락 발생을 허용한 후 탐지하고 해결.
  - 탐지: 자원 할당 그래프 분석.
  - 복구: 프로세스 종료 또는 자원 회수.

---

## 물리 메모리 (Physical Memory)

### 1. 물리 메모리란?

- **정의**: 실제 컴퓨터에 설치된 메모리(RAM).
- **특징**:
  - 고속 데이터 접근 가능.
  - 제한된 용량 (메모리 크기에 따라 성능 제한 발생 가능).

### 2. 메모리 관리 전략

- **연속 메모리 할당**:
  - 단일 연속 공간에 프로세스를 배치.
  - 단점: 외부 단편화 발생.
- **단편화 문제**:
  - **외부 단편화**: 사용 가능한 메모리 공간이 조각나 있어 할당이 어려운 상태.
  - **내부 단편화**: 할당된 메모리 내 사용되지 않는 공간.

---

## 가상 메모리 (Virtual Memory)

### 1. 가상 메모리란?

- **정의**: 물리 메모리의 크기를 초과하는 메모리 공간을 제공하기 위해 저장장치를 활용하는 기술.
- **목적**:
  - 큰 프로그램 실행 지원.
  - 메모리 사용 효율성 증대.
  - 프로세스 간 메모리 보호.

### 2. 가상 메모리 구현 방식

- **페이징 (Paging)**:

  - 메모리를 고정 크기 블록(페이지)으로 나눔.
  - 페이지는 **페이지 테이블**을 통해 물리 메모리의 프레임과 매핑.
  - 장점: 외부 단편화 해결, 효율적 메모리 관리.
  - 단점: 페이지 테이블 관리 오버헤드.

- **세그먼테이션 (Segmentation)**:
  - 메모리를 가변 크기 블록(세그먼트)으로 나눔.
  - 각 세그먼트는 논리적 단위 (코드, 데이터 등)로 관리.
  - 장점: 프로그램 논리와 일치.
  - 단점: 외부 단편화 발생 가능.

### 3. 페이지 교체 알고리즘

- 물리 메모리가 부족할 때 사용하지 않는 페이지를 교체.
  - **FIFO (First-In, First-Out)**: 가장 먼저 들어온 페이지 교체.
  - **LRU (Least Recently Used)**: 가장 오래 사용되지 않은 페이지 교체.
  - **Optimal**: 앞으로 가장 오랫동안 사용되지 않을 페이지 교체 (이론적 최적).

### 4. 스왑(Swap) 영역

- 사용하지 않는 페이지를 디스크의 스왑 영역으로 이동하여 물리 메모리를 확보.
- 단점: 디스크 접근 속도는 RAM보다 느리므로 성능 저하 발생 가능.

---

# 은행가 알고리즘 (Banker's Algorithm)

## 1. 개념

- 데드락 회피 알고리즘 중 하나.
- 시스템이 프로세스의 자원 요청을 처리할 때, 시스템이 **안전 상태(Safe State)**에 있는지 확인하고 요청을 수락하거나 거부함.
- 프로세스가 필요로 하는 최대 자원량, 현재 할당된 자원량, 사용 가능한 자원량을 고려하여 동작.

## 2. 주요 변수

- **Available**: 현재 사용 가능한 자원의 수.
- **Maximum**: 각 프로세스가 작업 완료를 위해 필요로 하는 최대 자원의 수.
- **Allocation**: 각 프로세스에 현재 할당된 자원의 수.
- **Need**: 작업 완료를 위해 추가적으로 필요한 자원의 수.  
  \[
  \text{Need[i]} = \text{Maximum[i]} - \text{Allocation[i]}
  \]

## 3. 동작 단계

1. **요청 검증**:

   - 프로세스의 요청량이 `Need`를 초과하면 잘못된 요청.
   - 프로세스의 요청량이 `Available`보다 많으면 대기 상태로 둠.

2. **가상 할당 후 안전성 검사**:

   - 요청된 자원을 할당한 가상 상태를 가정.
   - 가상 상태에서 안전 상태 여부를 검사.
     - **Work 배열**: 사용 가능한 자원의 상태를 나타냄.
     - **Finish 배열**: 각 프로세스가 작업 완료 가능한지를 나타냄.

3. **안전 상태 판단**:
   - 안전 상태(Safe State)라면 요청을 수락.
   - 불안전 상태(Unsafe State)라면 요청을 거부하고 가상 할당을 취소.

---

# 뮤텍스와 세마포어 (Mutex and Semaphore)

## 1. 뮤텍스 (Mutex)

- **정의**: 상호 배제를 보장하기 위한 동기화 기법.
- 하나의 스레드/프로세스만 특정 자원을 사용할 수 있도록 접근을 제어.
- **Binary Lock**(0 또는 1)로 표현.
  - **Lock**: 자원을 점유 중.
  - **Unlock**: 자원을 해제.

### 특징

1. **자원 소유**: 뮤텍스를 잠근(lock) 프로세스만 잠금을 해제(unlock)할 수 있음.
2. **사용 예**: 공유 데이터 보호, 임계 구역 문제 해결.

---

## 2. 세마포어 (Semaphore)

- **정의**: 자원 접근을 관리하는 변수로, 자원의 상태를 나타냄.
- 두 가지 유형:
  1. **카운팅 세마포어**: 자원의 개수가 여러 개인 경우 사용.
  2. **바이너리 세마포어**: 뮤텍스와 동일하게 동작.

### 주요 연산

1. **Wait(P 연산)**:
   - 자원 사용 가능 여부를 확인.
   - 자원이 사용 가능하면 감소; 사용 불가능하면 대기.
2. **Signal(V 연산)**:
   - 자원 사용이 끝났음을 알림.
   - 대기 중인 프로세스가 있으면 깨움.

### 특징

1. **프로세스 간 협력**: 여러 프로세스가 자원을 공유할 때 사용.
2. **사용 예**: 생산자-소비자 문제, 독자-작가 문제 등.

---

# 차이점 비교: 뮤텍스 vs 세마포어

| 특징        | 뮤텍스 (Mutex)            | 세마포어 (Semaphore)      |
| ----------- | ------------------------- | ------------------------- |
| 자원 개수   | 하나                      | 여러 개 (카운팅 세마포어) |
| 소유권      | 잠근 프로세스만 해제 가능 | 소유권 없음               |
| 동작 방식   | 이진 락 (0 또는 1)        | 카운터 기반               |
| 사용 예     | 임계 구역 보호            | 다수의 자원 접근 관리     |
| 구현 복잡성 | 비교적 단순               | 상대적으로 복잡           |

# 운영체제 스레드 동기화 기법

## 1. 락 (Locks)

### 1.1 정의

- 특정 자원에 대한 접근 권한을 제어하는 동기화 메커니즘.
- 자원을 사용하려는 스레드가 자원에 "Lock"을 걸고, 작업이 끝난 후 "Unlock"하여 다른 스레드가 자원을 사용할 수 있도록 함.

### 1.2 종류

1. **스핀 락 (Spin Lock)**:

   - 스레드가 락을 얻기 위해 반복적으로 상태를 확인 (바쁜 대기).
   - **장점**: 컨텍스트 스위칭 오버헤드 없음.
   - **단점**: CPU 자원 낭비.

2. **재진입 락 (Reentrant Lock)**:
   - 동일 스레드가 동일 락을 여러 번 획득할 수 있음.
   - 자바의 `ReentrantLock`이 대표적 구현.

---

## 2. 세마포어 (Semaphore)

- 이미 설명되었으므로 생략.

---

## 3. 모니터 (Monitor)

### 3.1 정의

- 고수준의 동기화 기법으로, 공유 자원에 대한 접근을 자동으로 제어.
- 내부적으로 락을 사용하며, 자원의 접근을 안전하게 관리.

### 3.2 특징

1. **임계 구역 보호**: 특정 코드 블록이 한 번에 하나의 스레드만 실행.
2. **조건 변수 사용**: `wait`와 `signal` 연산을 통해 스레드 간 협력 가능.

---

## 4. 조건 변수 (Condition Variables)

### 4.1 정의

- 특정 조건이 만족될 때까지 스레드를 대기 상태로 두고, 조건이 충족되면 대기 스레드를 깨우는 메커니즘.

### 4.2 주요 연산

- **Wait**: 조건이 충족될 때까지 스레드 대기.
- **Signal**: 대기 중인 스레드 중 하나를 깨움.
- **Broadcast**: 대기 중인 모든 스레드를 깨움.

---

## 5. 이벤트 플래그 (Event Flags)

### 5.1 정의

- 특정 이벤트가 발생했음을 알리기 위해 사용하는 플래그 기반의 동기화 기법.
- 사용 사례: 비동기 이벤트 처리.

---

## 6. 리더-라이터 락 (Reader-Writer Lock)

### 6.1 정의

- 다중 읽기 및 단일 쓰기를 동시에 지원하는 동기화 기법.
- 읽기 연산은 여러 스레드가 동시에 수행 가능하지만, 쓰기 연산은 단일 스레드만 수행 가능.

### 6.2 주요 특징

- **읽기 우선 정책**: 읽기 작업이 쓰기보다 우선순위.
- **쓰기 우선 정책**: 쓰기가 대기 상태에 있으면 우선 처리.

---

## 7. 메시지 패싱 (Message Passing)

### 7.1 정의

- 스레드 간 데이터를 주고받기 위해 메시지를 사용.
- 자원을 직접 공유하지 않고, 메시지를 통해 통신하여 동기화.

---

## 8. 데드락 회피 및 예방 기법

### 8.1 데드락 예방

- 데드락 발생 조건 중 하나 이상을 제거.
  - **상호 배제 조건 제거**: 공유 자원 사용 최소화.
  - **점유와 대기 조건 제거**: 자원을 한 번에 모두 요청.
  - **비선점 조건 제거**: 자원 강제 회수 가능하게 설계.
  - **환형 대기 조건 제거**: 자원에 순서를 부여하여 요청.

### 8.2 데드락 회피

- 은행가 알고리즘과 같은 회피 기법 사용.

---

## 9. 비교표: 주요 동기화 기법

| 기법           | 특징                               | 사용 사례              |
| -------------- | ---------------------------------- | ---------------------- |
| 락 (Locks)     | 자원 접근을 제어하는 기본 메커니즘 | 임계 구역 보호         |
| 세마포어       | 다수의 자원 접근 제어              | 생산자-소비자 문제     |
| 모니터         | 고수준 동기화 기법                 | 객체 단위 동기화       |
| 조건 변수      | 특정 조건 만족 대기 및 알림        | 멀티스레드 작업 조율   |
| 리더-라이터 락 | 읽기-쓰기 동시 처리                | 데이터베이스 접근 제어 |
| 메시지 패싱    | 자원 공유 없이 통신                | 분산 시스템            |
