# Git에 대한 상세 설명

Git은 분산 버전 관리 시스템(DVCS)으로, 코드 변경 사항을 추적하고 협업을 효율적으로 관리할 수 있도록 설계되었습니다. 이 문서에서는 Git의 개념, 주요 명령어, 내부 구현(Core), 그리고 원리를 중심으로 상세히 설명합니다.

---

## 1. **Git의 기본 개념**

### **1.1. 주요 특징**

- **분산형**: 중앙 서버 없이도 로컬에서 모든 파일의 전체 히스토리를 관리 가능.
- **스냅샷 기반**: 변경 사항을 델타 방식으로 저장하지 않고, 파일의 상태를 스냅샷으로 저장.
- **브랜치와 병합**: 가벼운 브랜치를 통해 여러 작업 흐름을 효율적으로 관리.
- **데이터 무결성**: SHA-1 해시를 사용하여 데이터를 보호.

---

## 2. **Git의 주요 명령어**

### **2.1. 작업 영역**

- **Working Directory**: 로컬 파일이 있는 디렉토리.
- **Staging Area**: 커밋 준비를 위해 변경 사항을 저장하는 중간 영역.
- **Repository**: 버전 관리 데이터가 저장된 디렉토리.

### **2.2. 명령어**

1. **저장소 초기화 및 복제**

   - `git init`: 새로운 Git 저장소 초기화.
   - `git clone <URL>`: 원격 저장소 복제.

2. **변경 사항 추적**

   - `git add <file>`: 변경 사항을 Staging Area에 추가.
   - `git commit -m "<message>"`: Staging Area의 변경 사항을 커밋.

3. **브랜치 관리**

   - `git branch`: 현재 브랜치 확인.
   - `git branch <branch-name>`: 새로운 브랜치 생성.
   - `git checkout <branch-name>`: 브랜치 전환.
   - `git merge <branch-name>`: 브랜치 병합.

4. **기록 확인**

   - `git log`: 커밋 히스토리 확인.
   - `git status`: 현재 작업 디렉토리 상태 확인.
   - `git diff`: 변경 사항 비교.

5. **원격 작업**
   - `git remote add <name> <URL>`: 원격 저장소 추가.
   - `git push <remote> <branch>`: 로컬 브랜치를 원격 저장소에 업로드.
   - `git pull`: 원격 저장소의 변경 사항 가져오기.

---

## 3. **Git의 내부 구조와 Core 구현**

Git의 내부는 다음과 같은 핵심 구성 요소로 이루어져 있습니다.

### **3.1. 데이터 구조**

Git은 데이터를 **스냅샷** 형태로 저장하며, 다음의 핵심 객체를 사용합니다.

1. **Blob (Binary Large Object)**

   - 파일의 내용을 저장.
   - 파일 이름이나 메타데이터는 저장하지 않고 순수한 데이터만 저장.
   - 고유한 SHA-1 해시를 통해 식별.

2. **Tree**

   - 디렉토리 구조를 표현.
   - 트리는 파일(Blob)과 다른 디렉토리(Tree)에 대한 포인터를 포함.

3. **Commit**
   - 특정 시점의 스냅샷을 저장.
   - 부모 커밋에 대한 포인터, Tree 객체에 대한 포인터, 커밋 메시지, 작성자 정보 등을 포함.

### **3.2. Git 객체 저장소**

Git은 `.git/objects` 디렉토리에 객체를 저장합니다.

- 모든 객체는 **SHA-1 해시**를 사용해 식별되고 압축되어 저장.
- 동일한 내용의 파일은 중복 저장되지 않음.

### **3.3. 브랜치와 레퍼런스**

- **HEAD**: 현재 작업 중인 브랜치를 가리키는 포인터.
- **Refs**: 브랜치, 태그 등 Git 레퍼런스를 저장.
  - `.git/refs/heads/<branch-name>`: 브랜치의 커밋을 가리킴.

---

### **3.4. Git의 동작 원리**

1. **파일 변경 및 스테이징**

   - 파일을 수정하고 `git add`를 실행하면, Git은 파일을 Blob 객체로 변환 후 저장소에 저장.
   - Tree 객체가 업데이트되며, 변경된 디렉토리 구조를 반영.

2. **커밋**

   - `git commit` 실행 시, Git은 Staging Area의 모든 변경 사항을 Commit 객체로 생성.
   - Commit 객체는 부모 커밋, Tree 객체, 커밋 메시지 등 메타데이터를 포함.

3. **브랜치**

   - 브랜치는 특정 커밋을 가리키는 레퍼런스(포인터).
   - 새로운 커밋이 생성되면 브랜치는 자동으로 해당 커밋을 가리키도록 이동.

4. **병합**

   - 두 브랜치의 변경 사항을 합치기 위해 Git은 기본적으로 **3-way merge**를 사용.
   - 공통 조상(ancestor), 브랜치 A, 브랜치 B를 비교하여 충돌을 해결.

5. **충돌 처리**
   - 충돌 발생 시 Git은 충돌 파일을 표시하고 사용자가 수동으로 해결하도록 유도.

---

### **3.5. Git의 무결성**

- Git은 모든 데이터가 연결된 구조를 가지며, 각 객체는 SHA-1 해시로 참조됩니다.
- 하나의 객체가 변조되면 전체 히스토리가 손상됨을 감지 가능.

---

## 4. **Git의 특성 요약**

- **효율성**: 스냅샷 기반 저장과 중복 데이터 제거로 저장소 크기를 최소화.
- **유연성**: 다양한 워크플로우(중앙집중형, 분산형 등) 지원.
- **안전성**: 데이터 무결성과 변경 내역을 안전하게 보존.

---

## 5. **Git과 협업**

### **5.1. 원격 저장소**

- GitHub, GitLab, Bitbucket 등 다양한 원격 플랫폼을 통해 협업 가능.
- Pull Request와 Review를 통해 코드 품질을 향상.

### **5.2. 워크플로우 예시**

1. **Feature 브랜치 기반**

   - 새로운 기능은 별도의 브랜치에서 개발.
   - 개발 완료 후 `main` 브랜치로 병합.

2. **Git Flow**
   - 브랜치 종류: `main`, `develop`, `feature`, `release`, `hotfix`.
   - 단계별로 브랜치를 나눠 체계적인 개발 관리.

---

## 6. **Git의 한계**

- 대용량 바이너리 파일 관리에 비효율적 (이를 보완하기 위해 Git LFS 사용 가능).
- 초기 학습 곡선이 높아 초보자에게 다소 어려울 수 있음.

---
