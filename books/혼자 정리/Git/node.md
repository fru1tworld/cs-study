# Git에 대한 상세 설명

Git은 분산 버전 관리 시스템(DVCS)으로, 코드 변경 사항을 추적하고 협업을 효율적으로 관리할 수 있도록 설계되었습니다. 이 문서에서는 Git의 개념, 주요 명령어, 내부 구현(Core), 그리고 원리를 중심으로 상세히 설명합니다.

---

## 1. **Git의 기본 개념**

### **1.1. 주요 특징**

- **분산형**: 중앙 서버 없이도 로컬에서 모든 파일의 전체 히스토리를 관리 가능.
- **스냅샷 기반**: 변경 사항을 델타 방식으로 저장하지 않고, 파일의 상태를 스냅샷으로 저장.
- **브랜치와 병합**: 가벼운 브랜치를 통해 여러 작업 흐름을 효율적으로 관리.
- **데이터 무결성**: SHA-1 해시를 사용하여 데이터를 보호.

---

## 2. **Git의 주요 명령어**

### **2.1. 작업 영역**

- **Working Directory**: 로컬 파일이 있는 디렉토리.
- **Staging Area**: 커밋 준비를 위해 변경 사항을 저장하는 중간 영역.
- **Repository**: 버전 관리 데이터가 저장된 디렉토리.

### **2.2. 명령어**

1. **저장소 초기화 및 복제**

   - `git init`: 새로운 Git 저장소 초기화.
   - `git clone <URL>`: 원격 저장소 복제.

2. **변경 사항 추적**

   - `git add <file>`: 변경 사항을 Staging Area에 추가.
   - `git commit -m "<message>"`: Staging Area의 변경 사항을 커밋.

3. **브랜치 관리**

   - `git branch`: 현재 브랜치 확인.
   - `git branch <branch-name>`: 새로운 브랜치 생성.
   - `git checkout <branch-name>`: 브랜치 전환.
   - `git merge <branch-name>`: 브랜치 병합.

4. **기록 확인**

   - `git log`: 커밋 히스토리 확인.
   - `git status`: 현재 작업 디렉토리 상태 확인.
   - `git diff`: 변경 사항 비교.

5. **원격 작업**
   - `git remote add <name> <URL>`: 원격 저장소 추가.
   - `git push <remote> <branch>`: 로컬 브랜치를 원격 저장소에 업로드.
   - `git pull`: 원격 저장소의 변경 사항 가져오기.

---

## 3. **Git의 내부 구조와 Core 구현**

Git의 내부는 다음과 같은 핵심 구성 요소로 이루어져 있습니다.

### **3.1. 데이터 구조**

Git은 데이터를 **스냅샷** 형태로 저장하며, 다음의 핵심 객체를 사용합니다.

1. **Blob (Binary Large Object)**

   - 파일의 내용을 저장.
   - 파일 이름이나 메타데이터는 저장하지 않고 순수한 데이터만 저장.
   - 고유한 SHA-1 해시를 통해 식별.

2. **Tree**

   - 디렉토리 구조를 표현.
   - 트리는 파일(Blob)과 다른 디렉토리(Tree)에 대한 포인터를 포함.

3. **Commit**
   - 특정 시점의 스냅샷을 저장.
   - 부모 커밋에 대한 포인터, Tree 객체에 대한 포인터, 커밋 메시지, 작성자 정보 등을 포함.

### **3.2. Git 객체 저장소**

Git은 `.git/objects` 디렉토리에 객체를 저장합니다.

- 모든 객체는 **SHA-1 해시**를 사용해 식별되고 압축되어 저장.
- 동일한 내용의 파일은 중복 저장되지 않음.

### **3.3. 브랜치와 레퍼런스**

- **HEAD**: 현재 작업 중인 브랜치를 가리키는 포인터.
- **Refs**: 브랜치, 태그 등 Git 레퍼런스를 저장.
  - `.git/refs/heads/<branch-name>`: 브랜치의 커밋을 가리킴.

---

### **3.4. Git의 동작 원리**

1. **파일 변경 및 스테이징**

   - 파일을 수정하고 `git add`를 실행하면, Git은 파일을 Blob 객체로 변환 후 저장소에 저장.
   - Tree 객체가 업데이트되며, 변경된 디렉토리 구조를 반영.

2. **커밋**

   - `git commit` 실행 시, Git은 Staging Area의 모든 변경 사항을 Commit 객체로 생성.
   - Commit 객체는 부모 커밋, Tree 객체, 커밋 메시지 등 메타데이터를 포함.

3. **브랜치**

   - 브랜치는 특정 커밋을 가리키는 레퍼런스(포인터).
   - 새로운 커밋이 생성되면 브랜치는 자동으로 해당 커밋을 가리키도록 이동.

4. **병합**

   - 두 브랜치의 변경 사항을 합치기 위해 Git은 기본적으로 **3-way merge**를 사용.
   - 공통 조상(ancestor), 브랜치 A, 브랜치 B를 비교하여 충돌을 해결.

5. **충돌 처리**
   - 충돌 발생 시 Git은 충돌 파일을 표시하고 사용자가 수동으로 해결하도록 유도.

---

### **3.5. Git의 무결성**

- Git은 모든 데이터가 연결된 구조를 가지며, 각 객체는 SHA-1 해시로 참조됩니다.
- 하나의 객체가 변조되면 전체 히스토리가 손상됨을 감지 가능.

---

## 4. **Git의 특성 요약**

- **효율성**: 스냅샷 기반 저장과 중복 데이터 제거로 저장소 크기를 최소화.
- **유연성**: 다양한 워크플로우(중앙집중형, 분산형 등) 지원.
- **안전성**: 데이터 무결성과 변경 내역을 안전하게 보존.

---

## 5. **Git과 협업**

### **5.1. 원격 저장소**

- GitHub, GitLab, Bitbucket 등 다양한 원격 플랫폼을 통해 협업 가능.
- Pull Request와 Review를 통해 코드 품질을 향상.

### **5.2. 워크플로우 예시**

1. **Feature 브랜치 기반**

   - 새로운 기능은 별도의 브랜치에서 개발.
   - 개발 완료 후 `main` 브랜치로 병합.

2. **Git Flow**
   - 브랜치 종류: `main`, `develop`, `feature`, `release`, `hotfix`.
   - 단계별로 브랜치를 나눠 체계적인 개발 관리.

---

## 6. **Git의 한계**

- 대용량 바이너리 파일 관리에 비효율적 (이를 보완하기 위해 Git LFS 사용 가능).
- 초기 학습 곡선이 높아 초보자에게 다소 어려울 수 있음.

---

# Git 면접 질문과 답변

## **기본 개념 및 원리**

### 1. Git과 다른 버전 관리 시스템(SVN 등)의 차이점은 무엇인가요?

- Git은 분산 버전 관리 시스템(DVCS)으로, 모든 사용자가 로컬에 전체 저장소를 복사할 수 있습니다.
- SVN은 중앙집중식 버전 관리 시스템(CVCS)으로, 중앙 서버에서만 저장소를 관리합니다.
- Git은 오프라인 작업이 가능하며, SVN은 항상 네트워크 연결이 필요합니다.
- Git은 브랜치 생성과 병합이 가볍고 빠르며, SVN은 브랜치 관리가 무겁고 느립니다.

### 2. Git의 워크플로우(Working Directory, Staging Area, Repository)에 대해 설명해주세요.

- Working Directory: 현재 작업 중인 디렉토리.
- Staging Area: `git add` 명령어로 준비된 변경 사항을 보관하는 중간 영역.
- Repository: `git commit`으로 저장된 변경 사항을 보관하는 데이터베이스.

### 3. Git의 분산 버전 관리 시스템이란 무엇이며, 장점은 무엇인가요?

- 각 사용자가 저장소의 전체 복사본을 로컬에 보유.
- 장점:
  - 네트워크가 없어도 작업 가능.
  - 중앙 서버가 손상되어도 복구 가능.
  - 브랜치 생성, 병합 등 작업이 빠름.

---

## **일반 명령어 및 사용법**

### 4. Git에서 `clone`, `pull`, `fetch`의 차이를 설명해주세요.

- `clone`: 원격 저장소를 로컬로 복사.
- `pull`: 원격 저장소의 변경 사항을 가져오고, 로컬 브랜치에 병합.
- `fetch`: 원격 저장소의 변경 사항을 가져오지만, 병합은 하지 않음.

### 5. Git에서 `merge`와 `rebase`의 차이점은 무엇인가요?

- `merge`: 두 브랜치를 병합하며, 병합 커밋이 생성됨.
- `rebase`: 브랜치의 커밋을 기반으로 다른 브랜치 위에 재정렬하며, 병합 커밋이 생성되지 않음.

### 6. `git stash`는 언제 사용하며, 사용 방법은 무엇인가요?

- 작업 중인 변경 사항을 임시로 저장하고, 다른 작업을 수행해야 할 때 사용.

### 7. `git reset`, `git revert`, `git checkout`의 차이를 설명해주세요.

- `reset`: 커밋을 되돌리며 기록을 삭제.
- `revert`: 커밋을 되돌리되, 되돌린 기록을 새 커밋으로 저장.
- `checkout`: 브랜치 변경 또는 특정 커밋/파일로 이동.

### 8. Git에서 태그(tag)를 사용하는 이유와 방법을 설명해주세요.

- 특정 커밋(예: 버전 릴리스)을 쉽게 식별하고 참조하기 위해 사용.

---

## **협업 및 브랜치 관리**

### 9. 브랜치 전략(예: Git Flow, GitHub Flow 등)에 대해 설명해주세요.

- Git Flow: Feature, Develop, Release, Master 브랜치를 사용하며, 대규모 프로젝트에 적합.
- GitHub Flow: 간단한 브랜치 전략으로 Feature 브랜치에서 작업 후 바로 병합.

### 10. `git cherry-pick`은 언제 사용하며, 어떤 상황에서 유용한가요?

- 특정 커밋만 다른 브랜치로 가져와야 할 때 유용.

### 11. Conflict(충돌)가 발생했을 때 어떻게 해결하나요?

- 충돌 파일을 수정하고 스테이징 후 커밋.

### 12. Pull Request(PR)와 Code Review에서의 Git 역할을 설명해주세요.

- Pull Request: 코드 병합 요청.
- Code Review: 코드 품질 향상 및 협업 강화.
- Git은 변경 사항 추적, 비교, 병합 지원.

---

## **문제 해결 능력**

### 13. `detached HEAD` 상태는 무엇이며, 어떻게 복구하나요?

- 특정 커밋으로 이동했지만 브랜치에 연결되지 않은 상태.
- 브랜치로 전환하거나 새 브랜치를 생성하여 복구.

### 14. 로컬에서 커밋을 잘못 작성했거나 수정하고 싶을 때 어떻게 하나요?

- 최근 커밋을 수정하거나, 새로운 커밋을 추가하여 변경 내용을 반영.

### 15. 원격 브랜치를 삭제하려면 어떻게 해야 하나요?

- 원격 저장소에 명령을 전달하여 브랜치를 삭제.

### 16. 실수로 브랜치를 삭제했을 때 복구 방법은 무엇인가요?

- `reflog`를 이용하여 삭제된 브랜치의 HEAD를 찾아 복구.

### 17. Git의 `reflog`는 무엇이며, 언제 유용한가요?

- Git의 모든 HEAD 변경 기록을 추적하며, 실수로 삭제된 커밋이나 브랜치를 복구할 때 유용.

---

## **고급 사용법**

### 18. `git bisect`의 동작 원리와 사용 사례를 설명해주세요.

- 특정 버그를 찾기 위해 바이너리 검색 방식을 사용.

### 19. 서브모듈(submodule)이란 무엇이며, 어떻게 관리하나요?

- 저장소 내 다른 Git 저장소를 포함하는 기능으로, 종속 프로젝트 관리에 유용.

### 20. Git Hooks는 무엇이고, 어떻게 설정하나요?

- 특정 Git 이벤트가 발생할 때 실행되는 스크립트로, 자동화 작업을 수행.

### 21. Git의 `squash` 기능은 무엇이며, 왜 사용하나요?

- 여러 커밋을 하나로 합쳐 깔끔한 히스토리를 유지하기 위해 사용.

### 22. CI/CD 파이프라인에서 Git이 어떻게 활용되나요?

- Git은 코드 변경 사항을 트리거로 CI/CD 파이프라인을 시작하며, 빌드, 테스트, 배포를 자동화.

---

## **성능 및 최적화**

### 23. Git 저장소가 커질 경우 최적화 방법은 무엇인가요?

- 불필요한 파일 제거, 커밋 정리, 저장소 압축을 수행.

### 24. 대용량 파일이나 바이너리 파일을 다룰 때 Git LFS를 사용하는 이유는 무엇인가요?

- 대용량 파일의 이력을 효율적으로 관리하고 저장소 크기를 줄이기 위해 사용.

### 25. Git 저장소에서 특정 파일을 영구히 삭제하려면 어떻게 해야 하나요?

- 파일 이력을 포함한 모든 흔적을 제거하기 위해 Git 필터링 도구를 사용.

---

## **상황형 질문**

### 26. 만약 팀원이 실수로 민감한 정보를 Git에 커밋했다면 어떻게 처리하겠습니까?

- 기록에서 해당 정보를 제거하고, 새 커밋을 작성하여 푸시.

### 27. 다른 팀원이 동일한 파일을 수정한 후 충돌이 발생했을 때, 어떻게 해결하겠습니까?

- 충돌 파일을 수정하고 테스트 후 병합.

### 28. 원격 저장소에 올린 커밋을 수정하거나 삭제해야 할 때, 어떤 과정을 거치나요?

- 커밋을 수정하거나 제거한 후 강제 푸시를 사용.

### 29. 원격 저장소와 로컬 저장소가 동기화되지 않는 상황을 해결하는 방법은 무엇인가요?

- 원격 변경 사항을 확인하고, 병합하거나 재정렬하여 동기화.
