# NestJS

## 1. **NestJS란?**

- **NestJS**는 **Node.js** 기반의 **TypeScript** 프레임워크로, 효율적이고 확장 가능한 서버사이드 애플리케이션을 구축하기 위해 설계됨.
- **Angular**에서 영감을 받아 모듈화, 데코레이터 기반 문법, 의존성 주입(Dependency Injection)을 중심으로 개발됨.
- HTTP 서버뿐만 아니라 **GraphQL**, **WebSocket**, **Microservices**를 지원하는 다재다능한 프레임워크.

---

## 2. **NestJS의 주요 특징**

### 2.1. **TypeScript 지원**

- TypeScript로 작성되어 정적 타입 검사와 더불어 강력한 코드 품질을 보장.
- JavaScript로도 동작 가능 (하지만 기본적으로 TypeScript를 권장).

### 2.2. **모듈화된 구조**

- NestJS는 모든 애플리케이션을 **모듈 단위**로 관리.
- 기능을 독립적으로 개발하고 재사용 가능하게 유지.

### 2.3. **데코레이터 기반 프로그래밍**

- @Module, @Controller, @Get, @Post 등과 같은 **데코레이터**를 사용하여 직관적이고 선언적으로 작성.

### 2.4. **의존성 주입 (Dependency Injection)**

- 서비스 간 의존성을 효율적으로 관리하며, 단위 테스트와 유지보수를 용이하게 만듦.

### 2.5. **다양한 플랫폼 지원**

- **Express** 또는 **Fastify** 기반으로 HTTP 서버를 실행.
- **WebSocket**, **GraphQL**, **Microservices**, **CLI 도구**를 통한 다목적 지원.

---

## 3. **NestJS의 핵심 개념**

### 3.1. **모듈 (Modules)**

- 애플리케이션의 주요 빌딩 블록.
- 관련 있는 컨트롤러와 서비스, 제공자(Providers)를 묶어 하나

# Nest.js Dependency Injection (DI) Container

## 1. Dependency Injection(DI)이란?

의존성 주입(Dependency Injection)은 객체 간의 의존성을 객체 내부에서 생성하지 않고 외부에서 주입하는 디자인 패턴입니다.  
Nest.js는 DI를 중심으로 설계되어 있으며, 애플리케이션 구성 요소 간의 의존성을 효율적으로 관리할 수 있도록 돕습니다.

---

## 2. DI Container란?

Nest.js의 DI Container는 애플리케이션에서 사용되는 모든 의존성을 관리하는 핵심 구성 요소입니다.  
DI Container는 객체를 생성, 관리, 주입하며, 객체 간의 관계를 자동으로 처리합니다.

### 주요 역할

1. 의존성 관리: 필요한 의존성을 찾아서 적절히 주입.
2. 인스턴스 관리: 객체를 생성하고 재사용 가능한 싱글톤으로 관리.
3. 모듈 분리: 애플리케이션의 구조를 모듈화하여 유지보수 용이.

---

## 3. Nest.js DI Container의 동작 원리

### Provider

Provider는 의존성을 정의하는 기본 단위로, 클래스, 값, 또는 팩토리 함수가 될 수 있습니다.  
Nest.js는 Provider를 DI Container에 등록하고, 이를 통해 의존성을 주입합니다.

### Module

Provider는 모듈 내부에 정의됩니다.
DI Container는 각 모듈의 Provider를 분석하고 의존성을 관리합니다.  
모듈은 애플리케이션의 구성 요소를 그룹화하는 역할을 합니다.

### Injection

Nest.js는 생성자에서 필요한 의존성을 확인하고 DI Container를 통해 자동으로 주입합니다.  
의존성 주입은 생성자 기반으로 이루어지며, 타입 정보를 사용하여 적절한 Provider를 찾습니다.

---

## 4. DI Container의 주요 개념

### Provider Scope

Provider는 기본적으로 싱글톤으로 관리됩니다.
그러나 요청 단위 또는 객체 단위로 새 인스턴스를 생성하도록 스코프를 변경할 수도 있습니다.

- Singleton: 애플리케이션 전체에서 하나의 인스턴스를 공유.
- Request: HTTP 요청마다 새로운 인스턴스를 생성.
- Transient: 주입 시마다 새로운 인스턴스를 생성.

### Custom Provider

Nest.js는 클래스 외에도 사용자 정의 값, 객체, 또는 팩토리 함수로 Provider를 등록할 수 있습니다.  
이때 제공되는 토큰을 기반으로 의존성을 식별합니다.

### Token 기반 의존성

DI Container는 의존성을 식별하기 위해 토큰(Token)을 사용합니다. 토큰은 문자열, 클래스, 또는 심볼로 정의될 수 있습니다.  
이를 통해 같은 유형의 의존성을 여러 개 정의하고 사용할 수 있습니다.

---

## 5. DI Container의 작동 과정

1. **모듈 초기화**: 애플리케이션 부트스트랩 시 각 모듈의 메타데이터를 분석합니다.
2. **Provider 등록**: 각 모듈에서 정의된 Provider를 DI Container에 등록합니다.
3. **의존성 분석**: 생성자의 매개변수를 분석하여 필요한 Provider를 확인합니다.
4. **의존성 주입**: DI Container는 필요한 Provider를 찾아 생성하거나 기존 인스턴스를 주입합니다.

---

## 6. DI Container의 장점

1. **결합도 감소**: 클래스 간의 의존성을 명확히 정의하여 코드 간의 결합도를 줄입니다.
2. **테스트 용이성**: Mock Provider로 의존성을 쉽게 대체할 수 있어 테스트가 용이합니다.
3. **유지보수성 향상**: 모듈화된 구조로 인해 코드 관리가 쉽고 재사용성이 높습니다.
4. **확장성 제공**: 의존성을 동적으로 추가하거나 스코프를 변경하는 등 유연하게 확장할 수 있습니다.

# Nest.js Dependency Injection (DI) Container

## 1. Dependency Injection(DI)이란?

의존성 주입(Dependency Injection)은 객체 간의 의존성을 객체 내부에서 생성하지 않고 외부에서 주입하는 디자인 패턴입니다.  
Nest.js는 DI를 중심으로 설계되어 있으며, 애플리케이션 구성 요소 간의 의존성을 효율적으로 관리할 수 있도록 돕습니다.

---

## 2. DI Container란?

Nest.js의 DI Container는 애플리케이션에서 사용되는 모든 의존성을 관리하는 핵심 구성 요소입니다.  
DI Container는 객체를 생성, 관리, 주입하며, 객체 간의 관계를 자동으로 처리합니다.

### 주요 역할

1. 의존성 관리: 필요한 의존성을 찾아서 적절히 주입.
2. 인스턴스 관리: 객체를 생성하고 재사용 가능한 싱글톤으로 관리.
3. 모듈 분리: 애플리케이션의 구조를 모듈화하여 유지보수 용이.

---

## 3. Nest.js DI Container의 동작 원리

### Provider

Provider는 의존성을 정의하는 기본 단위로, 클래스, 값, 또는 팩토리 함수가 될 수 있습니다.  
Nest.js는 Provider를 DI Container에 등록하고, 이를 통해 의존성을 주입합니다.

### Module

Provider는 모듈 내부에 정의됩니다. DI Container는 각 모듈의 Provider를 분석하고 의존성을 관리합니다.  
모듈은 애플리케이션의 구성 요소를 그룹화하는 역할을 합니다.

### Injection

Nest.js는 생성자에서 필요한 의존성을 확인하고 DI Container를 통해 자동으로 주입합니다.  
의존성 주입은 생성자 기반으로 이루어지며, 타입 정보를 사용하여 적절한 Provider를 찾습니다.

---

## 4. DI Container의 주요 개념

### Provider Scope

Provider는 기본적으로 싱글톤으로 관리됩니다. 그러나 요청 단위 또는 객체 단위로 새 인스턴스를 생성하도록 스코프를 변경할 수도 있습니다.

- Singleton: 애플리케이션 전체에서 하나의 인스턴스를 공유.
- Request: HTTP 요청마다 새로운 인스턴스를 생성.
- Transient: 주입 시마다 새로운 인스턴스를 생성.

### Custom Provider

Nest.js는 클래스 외에도 사용자 정의 값, 객체, 또는 팩토리 함수로 Provider를 등록할 수 있습니다.  
이때 제공되는 토큰을 기반으로 의존성을 식별합니다.

### Token 기반 의존성

DI Container는 의존성을 식별하기 위해 토큰(Token)을 사용합니다. 토큰은 문자열, 클래스, 또는 심볼로 정의될 수 있습니다.  
이를 통해 같은 유형의 의존성을 여러 개 정의하고 사용할 수 있습니다.

---

## 5. DI Container의 작동 과정

1. **모듈 초기화**: 애플리케이션 부트스트랩 시 각 모듈의 메타데이터를 분석합니다.
2. **Provider 등록**: 각 모듈에서 정의된 Provider를 DI Container에 등록합니다.
3. **의존성 분석**: 생성자의 매개변수를 분석하여 필요한 Provider를 확인합니다.
4. **의존성 주입**: DI Container는 필요한 Provider를 찾아 생성하거나 기존 인스턴스를 주입합니다.

---

## 6. DI Container의 장점

1. **결합도 감소**: 클래스 간의 의존성을 명확히 정의하여 코드 간의 결합도를 줄입니다.
2. **테스트 용이성**: Mock Provider로 의존성을 쉽게 대체할 수 있어 테스트가 용이합니다.
3. **유지보수성 향상**: 모듈화된 구조로 인해 코드 관리가 쉽고 재사용성이 높습니다.
4. **확장성 제공**: 의존성을 동적으로 추가하거나 스코프를 변경하는 등 유연하게 확장할 수 있습니다.

# NestJS에서의 프로바이더(Provider)와 모듈(Module)

## 1. 모듈(Module)

### 1.1 모듈이란?

모듈은 NestJS 애플리케이션의 기본 구성 단위입니다.  
NestJS는 애플리케이션을 기능별로 모듈화하여 개발자들이 구조적이고 확장 가능한 애플리케이션을 설계할 수 있도록 돕습니다.  
모든 애플리케이션은 최소한 하나의 루트 모듈(`AppModule`)을 포함하며, 애플리케이션이 이 모듈을 통해 부트스트랩됩니다.

### 1.2 모듈의 역할

1. **기능 단위로 구성**  
   관련된 컨트롤러(Controller), 서비스(Service), 프로바이더(Provider) 등을 그룹화하여 특정 기능을 독립적으로 관리할 수 있게 합니다.
2. **의존성 관리**  
   모듈 간 의존성을 정의하고, 다른 모듈에서 사용할 기능을 명확히 내보내는(Export) 방식을 통해 의존성 관계를 체계적으로 관리합니다.

3. **재사용 가능성**  
   모듈은 다른 모듈에 가져오거나 공유할 수 있으므로 재사용성을 높일 수 있습니다.

4. **구조화된 설계 지원**  
   애플리케이션을 작은 단위로 분리하여 코드 유지보수를 용이하게 하고, 확장성을 높입니다.

---

### 1.3 모듈의 구성 요소

모듈은 여러 구성 요소로 이루어지며, 아래의 주요 속성을 포함합니다.

- **imports**:  
  다른 모듈에서 제공하는 기능(Provider, Service 등)을 가져와 사용할 수 있습니다. 이때 가져온 모듈에서 `exports`된 것만 사용할 수 있습니다.

- **controllers**:  
  현재 모듈에 포함된 컨트롤러를 정의합니다. 컨트롤러는 주로 클라이언트 요청을 처리하고 응답을 반환하는 역할을 합니다.

- **providers**:  
  현재 모듈에 포함된 서비스, 리포지토리, 팩토리 등 의존성을 정의합니다. 프로바이더는 DI(Dependency Injection) 컨테이너에 등록되며, 다른 구성 요소에서 주입받아 사용할 수 있습니다.

- **exports**:  
  현재 모듈에서 다른 모듈에서 사용할 수 있도록 내보낼 구성 요소를 정의합니다. 이 속성에 명시적으로 추가하지 않으면 외부에서 접근이 불가능합니다.

---

### 1.4 모듈 간의 관계

NestJS에서는 모듈이 독립적이면서도 서로 협력할 수 있도록 설계되었습니다.  
이를 위해 한 모듈의 기능(Provider 등)을 다른 모듈로 가져와 사용하는 방식으로 의존성을 관리합니다.  
이를 통해 코드를 명확히 분리하면서도 유기적으로 작동하는 시스템을 구축할 수 있습니다.

---

## 2. 프로바이더(Provider)

### 2.1 프로바이더란?

프로바이더는 NestJS에서 의존성을 생성, 관리, 제공하는 핵심 단위입니다.  
일반적으로 서비스를 비롯한 객체들이 프로바이더로 정의됩니다.  
NestJS는 **DI(Dependency Injection) 컨테이너**를 통해 프로바이더를 관리하고, 다른 클래스에서 필요할 때 이를 주입합니다.

### 2.2 프로바이더의 역할

1. **의존성 제공**  
   애플리케이션의 구성 요소 간에 필요한 객체를 자동으로 생성하고, 이를 주입하여 사용할 수 있게 합니다.

2. **객체 생성 관리**  
   프로바이더는 클래스의 인스턴스를 한 번 생성하고, 이를 DI 컨테이너에 등록하여 재사용합니다.  
   기본적으로 싱글톤으로 관리되며, 필요에 따라 요청별로 새로운 인스턴스를 생성할 수도 있습니다.

3. **모듈화된 설계 지원**  
   프로바이더는 모듈 단위로 등록되며, 모듈 내에서만 사용할지 또는 다른 모듈에서 사용할 수 있도록 내보낼지를 선택할 수 있습니다.

---

### 2.3 프로바이더의 주요 특징

- **싱글톤 관리**:  
  기본적으로 프로바이더는 싱글톤으로 관리되며, 한 번 생성된 인스턴스는 애플리케이션 전역에서 재사용됩니다.

- **스코프 제어**:  
  특정 요구사항에 따라 프로바이더의 생애주기를 변경할 수 있습니다. 예를 들어, 요청(Request) 단위로 생성되거나, 매번 새로 생성될 수도 있습니다.

- **의존성 주입**:  
  다른 프로바이더 또는 외부 모듈에서 제공하는 의존성을 생성자에서 선언하여 자동으로 주입받을 수 있습니다.

---

### 2.4 프로바이더와 DI 컨테이너의 관계

NestJS는 DI 컨테이너를 통해 프로바이더를 관리합니다. DI 컨테이너는 애플리케이션에서 선언된 모든 프로바이더를 탐색하고, 이를 필요로 하는 클래스의 생성자에 자동으로 주입합니다.  
이를 통해 클래스 간의 결합도를 낮추고, 코드의 테스트 및 유지보수를 쉽게 만듭니다.

---

### 2.5 모듈과 프로바이더의 관계

1. 프로바이더는 항상 모듈에 의해 관리됩니다.  
   모듈에 등록된 프로바이더는 해당 모듈 내에서 사용 가능하며, `exports` 속성을 통해 외부 모듈에서도 사용할 수 있습니다.

2. 모듈은 프로바이더를 그룹화하여 관리하므로, 애플리케이션의 의존성을 체계적으로 구조화할 수 있습니다.

---

## 3. 모듈과 프로바이더의 협력

NestJS 애플리케이션은 모듈과 프로바이더의 유기적인 협력으로 구성됩니다.  
모듈은 기능별로 프로바이더를 포함하고, 프로바이더는 애플리케이션 로직을 처리하며, DI 컨테이너는 필요한 의존성을 제공하여 이 모든 것이 원활히 작동하도록 합니다.

- **모듈은 프로바이더를 포함하여 특정 기능을 제공합니다.**
- **프로바이더는 모듈의 구성 요소로서 동작하며, 애플리케이션 전반에서 의존성을 주입받아 처리합니다.**
- **DI 컨테이너는 의존성 관리를 자동화하여 개발자가 객체 생성 및 관리에 신경 쓰지 않도록 합니다.**

# NestJS에서의 게이트웨이(Gateway)

## 1. 게이트웨이(Gateway)란?

NestJS에서 게이트웨이(Gateway)는 **실시간 양방향 통신**을 처리하기 위한 핵심 요소입니다.  
주로 **웹소켓(WebSocket)** 프로토콜을 기반으로 구현되며, 클라이언트와 서버 간의 데이터 송수신을 실시간으로 처리하는 데 사용됩니다.

게이트웨이는 HTTP 요청/응답 모델과는 달리, 연결이 유지된 상태에서 클라이언트와 서버 간의 지속적인 통신을 지원합니다.  
이를 통해 채팅, 알림 시스템, 실시간 데이터 업데이트와 같은 기능을 구현할 수 있습니다.

---

## 2. 게이트웨이의 주요 역할

1. **실시간 연결 관리**

   - 클라이언트가 서버와 연결할 수 있도록 WebSocket 핸들러를 제공합니다.
   - 연결이 시작되거나 종료될 때 이를 감지하여 처리할 수 있습니다.

2. **양방향 데이터 통신**

   - 클라이언트가 서버로 메시지를 보내거나, 서버가 클라이언트로 메시지를 보낼 수 있습니다.
   - 특정 클라이언트 또는 모든 클라이언트로 메시지를 전송할 수 있습니다.

3. **실시간 이벤트 처리**

   - 클라이언트에서 발생한 이벤트를 서버에서 처리하고, 결과를 클라이언트로 반환합니다.

4. **커스텀 로직 처리**
   - 연결된 클라이언트의 인증, 데이터 검증, 특정 이벤트 처리 등 커스텀 로직을 구현할 수 있습니다.

---

## 3. 게이트웨이의 작동 원리

### 3.1 WebSocket 기반

- 게이트웨이는 기본적으로 WebSocket 프로토콜을 사용합니다.
- 클라이언트와 서버 간의 **핸드셰이크(Handshake)**가 이루어진 후 연결이 유지되며, 이를 통해 지속적인 데이터 송수신이 가능합니다.

### 3.2 이벤트 기반 구조

- WebSocket은 이벤트 기반 구조를 가지며, NestJS에서 각 이벤트는 메서드로 매핑됩니다.
- 클라이언트가 특정 이벤트를 트리거하면 서버는 해당 이벤트 핸들러를 호출하여 요청을 처리합니다.
- 서버에서도 이벤트를 정의하여 클라이언트로 데이터를 푸시(push)할 수 있습니다.

---

## 4. 게이트웨이의 주요 구성 요소

### 4.1 연결 관리 이벤트

- 게이트웨이는 클라이언트와의 연결 상태를 추적하며, 특정 상황에서 이벤트를 처리합니다:
  - **연결 시작**: 클라이언트가 서버와 WebSocket 연결을 성공적으로 설정한 경우.
  - **연결 종료**: 클라이언트가 연결을 끊거나 네트워크 문제로 인해 연결이 종료된 경우.

### 4.2 이벤트 핸들러

- 게이트웨이는 특정 이벤트에 대한 핸들러를 정의하여 클라이언트로부터 데이터를 처리하거나 응답을 보냅니다.
- 각 이벤트는 고유한 이름을 가지며, 클라이언트와 서버 간의 특정 기능을 구현하는 데 사용됩니다.

### 4.3 메시지 송수신

- 게이트웨이를 통해 서버는 특정 클라이언트, 그룹, 또는 모든 연결된 클라이언트로 메시지를 보낼 수 있습니다.
- 클라이언트가 서버로 데이터를 전송할 때, 서버는 이를 처리한 후 응답을 보낼 수도 있습니다.

---

## 5. 게이트웨이의 작동 방식

### 5.1 핸드셰이크

1. 클라이언트는 서버에 WebSocket 연결 요청을 보냅니다.
2. 서버는 요청을 수락하고 핸드셰이크를 완료합니다.
3. 연결이 성공적으로 이루어지면 클라이언트와 서버 간의 지속적인 통신이 가능해집니다.

### 5.2 이벤트 기반 메시지 처리

1. 클라이언트는 특정 이벤트와 데이터를 서버로 보냅니다.
2. 서버는 해당 이벤트를 처리하는 핸들러를 호출합니다.
3. 처리 결과를 클라이언트로 반환하거나, 추가 작업을 수행합니다.

### 5.3 연결 관리

- 클라이언트가 연결을 종료하거나 네트워크 문제로 인해 연결이 끊어질 경우, 게이트웨이는 이를 감지하여 필요한 처리를 수행합니다.  
  예: 연결 종료 시 리소스 해제, 사용자 세션 관리 등.

---

## 6. 게이트웨이의 장점

1. **실시간 통신**  
   클라이언트와 서버 간의 빠른 데이터 전송 및 실시간 통신이 가능합니다.

2. **이벤트 기반 처리**  
   각 이벤트를 명확히 구분하여 클라이언트-서버 간의 다양한 작업을 효율적으로 처리할 수 있습니다.

3. **확장성**  
   여러 클라이언트를 처리할 수 있도록 설계되어 확장성이 높습니다.

4. **다양한 응용 가능성**  
   채팅 애플리케이션, 실시간 알림, 게임, IoT 애플리케이션 등에 활용할 수 있습니다.

---

## 7. 게이트웨이의 주요 사용 사례

1. **채팅 애플리케이션**

   - 클라이언트 간 실시간 메시지 전송.
   - 특정 사용자 또는 그룹을 대상으로 메시지를 전송.

2. **실시간 알림 시스템**

   - 이벤트 발생 시 연결된 클라이언트로 즉시 알림 전송.

3. **게임 애플리케이션**

   - 멀티플레이어 게임에서 플레이어 간 상태 동기화 및 업데이트.

4. **IoT 디바이스 관리**
   - 연결된 IoT 디바이스와의 실시간 상태 확인 및 명령 전송.

---

## 8. 게이트웨이 사용 시 고려 사항

1. **확장성 문제 해결**  
   다수의 클라이언트 연결을 처리할 수 있도록 WebSocket 서버를 수평 확장하는 방법을 고려해야 합니다.

2. **보안**  
   WebSocket 연결의 인증 및 데이터 암호화와 같은 보안 메커니즘을 구현해야 합니다.

3. **리소스 관리**  
   연결 해제, 오류 발생 시 리소스를 적절히 해제하여 메모리 누수를 방지해야 합니다.

4. **네트워크 안정성**  
   연결 끊김 상황에서 재연결 메커니즘을 구현하여 네트워크 문제에 대응해야 합니다.
