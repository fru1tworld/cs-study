# 자바스크립트 핵심 개념 정리

## 1. 렉시컬 환경 (Lexical Environment)

### 1.1 정의

- **렉시컬 환경**은 코드가 작성된 물리적인 위치를 기반으로 변수와 함수의 유효 범위(Scope)를 결정하는 구조.
- 자바스크립트는 **정적 스코핑(Static Scoping)** 또는 **렉시컬 스코핑(Lexical Scoping)**을 사용.

### 1.2 구성 요소

- **환경 레코드(Environment Record)**: 현재 실행 중인 코드 블록의 변수, 함수 선언 등을 저장.
- **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)**: 현재 렉시컬 환경의 외부 환경을 참조.

### 1.3 동작 원리

- 변수와 함수는 선언된 위치를 기준으로 상위 스코프를 참조.
- 중첩된 함수는 선언된 환경의 스코프 체인을 따라 변수와 함수에 접근.

---

## 2. 실행 컨텍스트 (Execution Context)

### 2.1 정의

- 자바스크립트 코드가 실행될 때 생성되는 실행 환경으로, 변수, 함수, `this` 바인딩 등의 정보를 포함.

### 2.2 실행 컨텍스트 구성

1. **Variable Environment**:
   - 변수 선언 및 초기화 정보를 저장.
2. **Lexical Environment**:
   - 변수와 함수 선언을 포함하며 스코프 체인을 관리.
3. **`this` 바인딩**:
   - 실행 컨텍스트에서 `this`가 참조하는 객체.

### 2.3 실행 컨텍스트의 생성 과정

1. **Global Execution Context**:
   - 스크립트 실행 시 가장 먼저 생성.
   - 전역 객체(Global Object)와 전역 변수 및 함수를 포함.
2. **Function Execution Context**:
   - 함수 호출 시 생성.
   - 호출된 함수의 변수 및 `this`를 포함.
3. **Eval Execution Context**:
   - `eval()` 함수 호출 시 생성 (사용 권장하지 않음).

### 2.4 실행 컨텍스트 스택

- 실행 중인 컨텍스트를 스택 형태로 관리.
- 가장 위에 있는 컨텍스트가 현재 실행 중인 컨텍스트.

---

## 3. 비동기 프로그래밍 (Asynchronous Programming)

### 3.1 정의

- 코드 실행이 블로킹되지 않고, 작업이 완료될 때까지 기다리지 않고 다음 작업을 수행하는 프로그래밍 방식.

### 3.2 주요 동작 원리

1. **이벤트 루프(Event Loop)**:
   - 비동기 작업을 처리하기 위해 자바스크립트 엔진과 함께 동작.
   - 호출 스택(Call Stack)과 작업 큐(Task Queue)를 관리.
2. **콜백 큐(Callback Queue)**:
   - 비동기 작업이 완료되면 콜백 함수가 큐에 저장되었다가 호출 스택이 비워지면 실행.

### 3.3 비동기 프로그래밍의 주요 도구

1. **콜백 함수(Callback Function)**:
   - 특정 작업이 완료된 후 실행될 함수.
   - 단점: 콜백 헬(Callback Hell) 발생 가능.
2. **Promise**:
   - 비동기 작업의 성공 또는 실패 결과를 나타내는 객체.
   - 상태: Pending → Fulfilled / Rejected.
3. **`async/await`**:
   - Promise 기반의 비동기 작업을 동기식 코드처럼 작성 가능.

---

## 4. 모듈 (Modules)

### 4.1 정의

- 코드의 재사용성과 유지보수성을 향상시키기 위해 코드를 독립적인 단위로 분리한 구조.

### 4.2 모듈의 특징

- **캡슐화**: 모듈 내부의 코드를 외부에서 접근할 수 없도록 보호.
- **재사용성**: 모듈을 여러 곳에서 재사용 가능.
- **의존성 관리**: 필요한 모듈만 가져와 사용.

### 4.3 자바스크립트의 모듈 시스템

1. **CommonJS**:

   - Node.js에서 사용되는 모듈 시스템.
   - `require()`로 모듈 로드, `module.exports`로 모듈 내보내기.

2. **ES 모듈 (ES Modules)**:

   - 표준 모듈 시스템.
   - `import`와 `export` 키워드를 사용.
   - 브라우저와 Node.js에서 모두 지원.

3. **AMD (Asynchronous Module Definition)**:
   - 비동기 로딩을 지원하는 모듈 시스템.
   - RequireJS에서 주로 사용.

### 4.4 모듈의 이점

- 코드 구조화 및 분리.
- 중복 코드 제거.
- 유지보수 용이성 향상.
- 네임스페이스 충돌 방지.

# 자바스크립트의 가비지 컬렉션(Garbage Collection, GC)

자바스크립트의 가비지 컬렉션(GC)은 더 이상 사용되지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지하는 메커니즘입니다. 여기에서는 가비지 컬렉션의 원리와 알고리즘을 상세히 설명합니다.

---

## 1. 가비지 컬렉션의 핵심 원리

### 1.1 도달 가능성(Reachability)

- 자바스크립트는 객체가 "도달 가능(Reachable)" 상태인지 여부를 기준으로 메모리 해제를 결정합니다.
- **도달 가능성**이란, 루트(root)에서 해당 객체까지 참조가 존재하는 상태를 말합니다.
  - **루트 객체**:
    - 글로벌 객체(`window` 또는 `global`).
    - 스택의 현재 실행 컨텍스트(함수 호출 스택).
    - 클로저에서 참조되는 변수.
- 객체가 루트에서 도달 가능하지 않을 경우, 해당 객체는 "가비지"로 간주됩니다.

---

## 2. 주요 알고리즘

### 2.1 참조 카운팅(Reference Counting)

- **원리**: 객체가 참조되는 횟수를 추적하여, 참조 카운트가 0이 되면 해당 객체를 해제합니다.
- **장점**: 단순하고 빠른 구현.
- **단점**:
  - **순환 참조(Circular Reference)** 문제 발생 가능.
    - 두 객체가 서로를 참조하면, 참조 카운트가 0이 되지 않아 메모리가 해제되지 않습니다.
  - 이 문제로 인해 현대의 자바스크립트 엔진은 참조 카운팅 방식을 단독으로 사용하지 않습니다.

---

### 2.2 마크 앤 스윕(Mark-and-Sweep)

- 현대 자바스크립트 엔진이 사용하는 기본 알고리즘.
- **원리**:
  1. **마킹 단계(Marking)**: 루트에서부터 시작하여 도달 가능한 모든 객체를 탐색하고 마킹합니다.
  2. **스윕 단계(Sweeping)**: 마킹되지 않은 객체를 "가비지"로 간주하고 메모리에서 해제합니다.
- **과정**:
  1. GC가 실행되면 루트에서 시작해 객체 그래프를 탐색합니다.
  2. 도달 가능한 객체에 마킹을 추가합니다.
  3. 탐색이 끝난 후, 도달 불가능한 객체를 해제합니다.
- **장점**: 순환 참조 문제를 해결합니다.

---

### 2.3 세대별 가비지 컬렉션(Generational Garbage Collection)

- 객체의 생명 주기가 짧다는 점을 활용한 최적화 방식.
- **원리**:
  - 객체를 **Young Generation**(짧은 생명 주기)과 **Old Generation**(긴 생명 주기)으로 나눕니다.
  - Young Generation에서 주기적으로 가비지 컬렉션을 실행하며, 생존하는 객체는 Old Generation으로 승격됩니다.
- **단계**:
  1. **Young Generation**:
     - 대부분의 객체가 생성되는 공간.
     - 단기적인 객체를 빠르게 수집.
  2. **Old Generation**:
     - Young Generation에서 승격된 객체가 저장되는 공간.
     - 수집 빈도가 낮지만, 더 많은 메모리를 사용합니다.

---

### 2.4 인크리멘털 및 동시 GC(Incremental and Concurrent GC)

- **인크리멘털 GC**:
  - 가비지 컬렉션 작업을 여러 단계로 나눠 실행.
  - 긴 GC 중단 시간을 줄이기 위해 도입.
- **동시 GC**:
  - 애플리케이션이 실행되는 동안 백그라운드에서 가비지 컬렉션을 병렬로 수행.
  - GC로 인한 성능 저하를 최소화.

---

## 3. 가비지 컬렉션의 한계와 최적화

### 3.1 한계

- **GC 실행 시점**:
  - GC는 자바스크립트 엔진의 판단에 따라 실행되므로, 객체가 즉시 해제되지 않을 수 있습니다.
- **메모리 누수(Memory Leak)**:
  - 불필요한 참조로 인해 메모리가 해제되지 않는 경우가 발생합니다.
  - 클로저, 전역 변수, 이벤트 리스너 등이 주요 원인입니다.

### 3.2 최적화

- **스코프 관리**:
  - 필요하지 않은 변수는 `null`로 설정하거나, 적절한 스코프에서 해제합니다.
- **전역 변수 최소화**:
  - 전역 변수는 참조가 지속될 가능성이 높아 메모리 해제에 영향을 줄 수 있습니다.
- **이벤트 리스너 해제**:
  - DOM 요소가 삭제될 때 이벤트 리스너를 명시적으로 제거합니다.

---

## 4. 참고 사항

- 최신 자바스크립트 엔진(V8, SpiderMonkey 등)은 복잡한 가비지 컬렉션 최적화 기법을 적용하여 메모리 사용 효율을 극대화하고 있습니다.
- 가비지 컬렉션은 자동화된 기능이지만, 개발자는 메모리 관리를 염두에 두고 코드를 작성해야 메모리 누수를 방지할 수 있습니다.
