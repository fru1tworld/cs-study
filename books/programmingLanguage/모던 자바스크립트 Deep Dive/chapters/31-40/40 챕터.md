# chapter40 - 이벤트

## 40.1 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다. 예를 들어, 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.

```javascript
const $button = document.querySelector("button");

// 사용자가 버튼을 클릭하면 함수를 호출하도록 이벤트 핸들러를 등록
$button.onclick = () => {
  alert("button click");
};
```

이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러(event handler)**라 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다.

이벤트와 그에 대응하는 함수(이벤트 핸들러)를 통해 사용자와 애플리케이션은 상호작용할 수 있다. 이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 **이벤트 드리븐 프로그래밍(event-driven programming)**이라 한다.

## 40.2 이벤트 타입

이벤트 타입은 이벤트의 종류를 나타내는 문자열이다. 예를 들어, 이벤트 타입 'click'은 사용자가 마우스 버튼을 클릭했을 때 발생하는 이벤트를 나타낸다.

### 마우스 이벤트

| 이벤트 타입 | 설명                                                  |
| ----------- | ----------------------------------------------------- |
| click       | 마우스 버튼을 클릭했을 때                             |
| dblclick    | 마우스 버튼을 더블 클릭했을 때                        |
| mousedown   | 마우스 버튼을 눌렀을 때                               |
| mouseup     | 누르고 있던 마우스 버튼을 놓았을 때                   |
| mousemove   | 마우스 커서를 움직였을 때                             |
| mouseenter  | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 X) |
| mouseover   | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 O) |
| mouseleave  | 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 X) |
| mouseout    | 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 O) |

### 키보드 이벤트

| 이벤트 타입 | 설명                                  |
| ----------- | ------------------------------------- |
| keydown     | 모든 키를 눌렀을 때 발생              |
| keypress    | 문자 키를 눌렀을 때 발생 (deprecated) |
| keyup       | 누르고 있던 키를 놓았을 때 발생       |

### 포커스 이벤트

| 이벤트 타입 | 설명                                      |
| ----------- | ----------------------------------------- |
| focus       | HTML 요소가 포커스를 받았을 때 (버블링 X) |
| blur        | HTML 요소가 포커스를 잃었을 때 (버블링 X) |
| focusin     | HTML 요소가 포커스를 받았을 때 (버블링 O) |
| focusout    | HTML 요소가 포커스를 잃었을 때 (버블링 O) |

### 폼 이벤트

| 이벤트 타입 | 설명                                                              |
| ----------- | ----------------------------------------------------------------- |
| submit      | form을 submit할 때 (button 또는 input 요소 클릭 또는 엔터키 입력) |
| reset       | form을 reset할 때                                                 |

### 값 변경 이벤트

| 이벤트 타입      | 설명                                                                       |
| ---------------- | -------------------------------------------------------------------------- |
| input            | input/textarea 요소의 값이 입력되었을 때                                   |
| change           | input/select/textarea 요소의 값이 변경되었을 때                            |
| readystatechange | HTML 문서의 로드와 파싱 상태를 나타내는 readyState 프로퍼티 값이 변경될 때 |

### DOM 뮤테이션 이벤트

| 이벤트 타입      | 설명                                                        |
| ---------------- | ----------------------------------------------------------- |
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때 |

### 뷰 이벤트

| 이벤트 타입 | 설명                                   |
| ----------- | -------------------------------------- |
| resize      | 브라우저 윈도우의 크기를 리사이즈할 때 |
| scroll      | 웹페이지 또는 HTML 요소를 스크롤할 때  |

### 리소스 이벤트

| 이벤트 타입 | 설명                                                                      |
| ----------- | ------------------------------------------------------------------------- |
| load        | DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스의 로딩이 완료되었을 때 |
| unload      | 리소스가 언로드될 때 (주로 새로운 웹페이지를 요청한 경우)                 |
| abort       | 리소스 로딩이 중단되었을 때                                               |
| error       | 리소스 로딩이 실패했을 때                                                 |

## 40.3 이벤트 핸들러 등록

### 이벤트 핸들러 어트리뷰트 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button onclick="sayHi('Lee')">Click me!</button>
    <script>
      function sayHi(name) {
        console.log(`Hi! ${name}.`);
      }
    </script>
  </body>
</html>
```

### 이벤트 핸들러 프로퍼티 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.onclick = function () {
        console.log("button click");
      };
    </script>
  </body>
</html>
```

### addEventListener 메서드 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 등록
      $button.addEventListener("click", function () {
        console.log("button click");
      });
    </script>
  </body>
</html>
```

addEventListener 메서드 방식은 이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향을 주지 않는다. 따라서 하나 이상의 이벤트 핸들러를 등록할 수 있다.

```javascript
const $button = document.querySelector("button");

// 이벤트 핸들러 프로퍼티 방식
$button.onclick = function () {
  console.log("[이벤트 핸들러 프로퍼티 방식]button click");
};

// addEventListener 메서드 방식
$button.addEventListener("click", function () {
  console.log("[addEventListener 메서드 방식]button click");
});
```

## 40.4 이벤트 핸들러 제거

addEventListener 메서드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventListener 메서드를 사용한다.

```javascript
const $button = document.querySelector("button");

const handleClick = () => console.log("button click");

$button.addEventListener("click", handleClick);

// 이벤트 핸들러 제거
$button.removeEventListener("click", handleClick);
```

## 40.5 이벤트 객체

이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. **생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.**

```javascript
const $msg = document.querySelector(".message");

function showCoords(e) {
  $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`;
}

document.onclick = showCoords;
```

### 이벤트 객체의 공통 프로퍼티

| 공통 프로퍼티    | 설명                                                                        | 타입          |
| ---------------- | --------------------------------------------------------------------------- | ------------- |
| type             | 이벤트 타입                                                                 | string        |
| target           | 이벤트를 발생시킨 DOM 요소                                                  | DOM 요소 노드 |
| currentTarget    | 이벤트 핸들러가 바인딩된 DOM 요소                                           | DOM 요소 노드 |
| eventPhase       | 이벤트 전파 단계                                                            | number        |
| bubbles          | 이벤트를 버블링으로 전파하는지 여부                                         | boolean       |
| cancelable       | preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부 | boolean       |
| defaultPrevented | preventDefault 메서드를 호출하여 이벤트를 취소했는지 여부                   | boolean       |
| isTrusted        | 사용자의 행위에 의해 발생한 이벤트인지 여부                                 | boolean       |
| timeStamp        | 이벤트가 발생한 시각                                                        | number        |

## 40.6 이벤트 전파

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 **이벤트 전파(event propagation)**라고 한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </body>
</html>
```

ul 요소의 두 번째 자식 요소인 li 요소를 클릭하면 클릭 이벤트가 발생한다. 이때 생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다.

1. **캡처링 단계(capturing phase)**: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
2. **타깃 단계(target phase)**: 이벤트가 이벤트 타깃에 도달
3. **버블링 단계(bubbling phase)**: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

## 40.7 이벤트 위임

이벤트 위임은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.

```javascript
const $fruits = document.getElementById("fruits");

$fruits.onclick = (e) => {
  if (!e.target.matches("#fruits > li")) return;

  e.target.style.color = "red";
};
```

## 40.8 DOM 요소의 기본 동작 조작

### preventDefault

```javascript
document.querySelector("a").onclick = (e) => {
  // a 요소의 기본 동작을 중단한다.
  e.preventDefault();
};
```

### stopPropagation

```javascript
document.querySelector(".container").onclick = () => {
  console.log("Container clicked");
};

document.querySelector(".btn").onclick = (e) => {
  // 이벤트 전파를 중지시킨다.
  e.stopPropagation();
  console.log("Button clicked");
};
```

## 40.9 이벤트 핸들러 내부의 this

### 이벤트 핸들러 어트리뷰트 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button onclick="handleClick()">Click me</button>
    <script>
      function handleClick() {
        console.log(this); // window
      }
    </script>
  </body>
</html>
```

### 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

```javascript
const $button1 = document.querySelector(".btn1");
const $button2 = document.querySelector(".btn2");

// 이벤트 핸들러 프로퍼티 방식
$button1.onclick = function (e) {
  console.log(this); // $button1
  console.log(e.currentTarget); // $button1
  console.log(this === e.currentTarget); // true
};

// addEventListener 메서드 방식
$button2.addEventListener("click", function (e) {
  console.log(this); // $button2
  console.log(e.currentTarget); // $button2
  console.log(this === e.currentTarget); // true
});
```

화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다.

```javascript
const $button = document.querySelector(".btn");

$button.addEventListener("click", (e) => {
  console.log(this); // window
  console.log(e.currentTarget); // $button
  console.log(this === e.currentTarget); // false
});
```

## 40.10 이벤트 핸들러에 인수 전달

이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식의 경우 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 자체를 등록해야 하므로 인수를 전달할 수 없다. 그러나 인수를 전달할 방법이 전혀 없는 것은 아니다.

```javascript
const MIN_USER_NAME_LENGTH = 5;
const $input = document.querySelector("input[type=text]");
const $msg = document.querySelector(".message");

const checkUserNameLength = (min) => {
  $msg.textContent =
    $input.value.length < min ? `이름은 ${min}자 이상 입력해 주세요` : "";
};

// 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
$input.onblur = () => {
  checkUserNameLength(MIN_USER_NAME_LENGTH);
};
```

## 40.11 커스텀 이벤트

### 커스텀 이벤트 생성

```javascript
// CustomEvent 생성자 함수로 foo 이벤트 타입의 커스텀 이벤트 객체를 생성
const customEvent = new CustomEvent("foo");
console.log(customEvent.type); // foo
```

### 커스텀 이벤트 디스패치

```javascript
const $button = document.querySelector(".btn");

// 커스텀 이벤트 핸들러 등록
$button.addEventListener("foo", (e) => {
  alert(e.detail.message);
});

// 커스텀 이벤트 생성
const customEvent = new CustomEvent("foo", {
  detail: { message: "Hello" },
});

// 커스텀 이벤트 디스패치
$button.dispatchEvent(customEvent);
```
