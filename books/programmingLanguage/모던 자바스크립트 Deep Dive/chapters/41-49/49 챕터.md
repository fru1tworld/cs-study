# chapter49 - Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축

ES6+와 ES.NEXT의 최신 ECMAScript 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를 경우에 따라 IE를 포함한 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축하는 것이 필요하다. 또한 대부분의 프로젝트가 모듈을 사용하므로 모듈 로더도 필요하다.

트랜스파일러인 Babel과 모듈 번들러인 Webpack을 이용하여 ES6+/ES.NEXT 개발 환경을 구축하여 보자.

## 49.1 Babel

다음 예제에서는 ES6의 화살표 함수와 ES7의 지수 연산자를 사용하고 있다.

```javascript
// ES6 화살표 함수와 ES7 지수 연산자
[1, 2, 3].map((n) => n ** n);
```

IE와 다른 구형 브라우저에서는 ES6의 화살표 함수와 ES7의 지수 연산자를 지원하지 않을 수 있다. Babel을 사용하면 위 코드를 다음과 같이 ES5 사양으로 변환할 수 있다.

```javascript
// ES5
"use strict";

[1, 2, 3].map(function (n) {
  return Math.pow(n, n);
});
```

이처럼 Babel은 ES6+/ES.NEXT로 구현된 최신 사양의 소스코드를 IE 같은 구형 브라우저에서도 동작하는 ES5 사양의 소스코드로 변환(트랜스파일링)할 수 있다.

### Babel 설치

```bash
# 프로젝트 폴더 생성
$ mkdir esnext-project && cd esnext-project
# package.json 생성
$ npm init -y
# babel-core, babel-cli 설치
$ npm install --save-dev @babel/core @babel/cli
```

### Babel 프리셋 설치와 babel.config.json 설정 파일 작성

Babel을 사용하려면 @babel/preset-env를 설치해야 한다. @babel/preset-env는 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋이라고 부른다.

```bash
# @babel/preset-env 설치
$ npm install --save-dev @babel/preset-env
```

프로젝트 루트 폴더에 babel.config.json 설정 파일을 생성하고 다음과 같이 작성한다.

```json
{
  "presets": ["@babel/preset-env"]
}
```

### 트랜스파일링

package.json 파일에 scripts를 추가한다.

```json
{
  "name": "esnext-project",
  "version": "1.0.0",
  "scripts": {
    "build": "babel src/js -w -d dist/js"
  },
  "devDependencies": {
    "@babel/cli": "^7.10.3",
    "@babel/core": "^7.10.3",
    "@babel/preset-env": "^7.10.3"
  }
}
```

위 npm scripts의 build는 src/js 폴더(타깃 폴더)에 있는 모든 자바스크립트 파일들을 트랜스파일링한 후, 그 결과물을 dist/js 폴더에 저장한다.

- -w: 타깃 폴더에 있는 모든 자바스크립트 파일들의 변경을 감지하여 자동으로 트랜스파일한다. (--watch 옵션의 축약형)
- -d: 트랜스파일링된 결과물이 저장될 폴더를 지정한다. (--out-dir 옵션의 축약형)

트랜스파일링을 테스트하기 위해 ES6+/ES.NEXT 사양의 자바스크립트 파일을 작성해 보자. 프로젝트 루트 폴더에 src/js 폴더를 생성한 후 lib.js와 main.js를 추가한다.

```javascript
// src/js/lib.js
export const pi = Math.PI;

export function power(x, y) {
  // ES7: 지수 연산자
  return x ** y;
}

// ES6: 클래스
export class Foo {
  // stage 3: 클래스 필드 정의 제안
  #private = 10;

  foo() {
    // stage 4: 옵셔널 체이닝 연산자
    const { a, b, c } = { a: 1, b: 2, c: 3 };
    console.log(a, b, c);
  }

  bar() {
    return this.#private;
  }
}
```

```javascript
// src/js/main.js
import { pi, power, Foo } from "./lib";

console.log(pi);
console.log(power(pi, pi));

const f = new Foo();
f.foo();
console.log(f.bar());
```

트랜스파일링을 실행한다.

```bash
$ npm run build
```

## 49.2 Webpack

Webpack은 의존 관계에 있는 자바스크립트, CSS, 이미지 등의 리소스들을 하나(또는 여러 개)의 파일로 번들링하는 모듈 번들러다. Webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요 없다. 그리고 여러 개의 자바스크립트 파일을 하나로 번들링하므로 HTML 파일에서 script 태그로 여러 개의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.

### Webpack 설치

```bash
$ npm install --save-dev webpack webpack-cli
```

### babel-loader 설치

Webpack이 모듈을 번들링할 때 Babel을 사용하여 ES6+/ES.NEXT 사양의 소스코드를 ES5 사양의 소스코드로 트랜스파일링하도록 babel-loader를 설치한다.

```bash
$ npm install --save-dev babel-loader
```

npm scripts를 변경하여 Babel 대신 Webpack을 실행하도록 수정한다.

```json
{
  "name": "esnext-project",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack -w"
  },
  "devDependencies": {
    "@babel/cli": "^7.10.3",
    "@babel/core": "^7.10.3",
    "@babel/preset-env": "^7.10.3",
    "babel-loader": "^8.1.0",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.12"
  }
}
```

### webpack.config.js 설정 파일 작성

프로젝트 루트 폴더에 webpack.config.js 설정 파일을 생성하고 다음과 같이 작성한다.

```javascript
const path = require("path");

module.exports = {
  // entry file
  entry: "./src/js/main.js",
  // 번들링된 js 파일의 이름(filename)과 저장될 경로(path)를 지정
  output: {
    path: path.resolve(__dirname, "dist/js"),
    filename: "bundle.js",
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: [path.resolve(__dirname, "src/js")],
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
          },
        },
      },
    ],
  },
  devtool: "source-map",
  mode: "development",
};
```

Webpack을 실행하여 트랜스파일링 및 번들링을 실행한다.

```bash
$ npm run build
```

### babel-polyfill 설치

Babel을 사용하여 ES6+/ES.NEXT 사양의 소스코드를 ES5 사양의 소스코드로 트랜스파일링해도 브라우저가 지원하지 않는 코드가 남아 있을 수 있다. 예를 들어, ES6에서 추가된 Promise, Object.assign, Array.from 등은 ES5 사양으로 트랜스파일링해도 ES5 사양에 대체할 기능이 없기 때문에 트랜스파일링되지 못하고 그대로 남는다.

따라서 구형 브라우저에서도 ES6+/ES.NEXT 사양의 소스코드를 실행하기 위해서는 @babel/polyfill을 설치해야 한다.

```bash
$ npm install @babel/polyfill
```

@babel/polyfill은 개발 환경에서만 사용하는 것이 아니라 실제 운영 환경에서도 사용해야 한다. 따라서 개발 설치(--save-dev)하지 않도록 주의한다.

ES6의 import를 사용하는 경우에는 진입점의 선두에서 먼저 폴리필을 로드하도록 한다.

```javascript
// src/js/main.js
import "@babel/polyfill";
import { pi, power, Foo } from "./lib";

console.log(pi);
console.log(power(pi, pi));

const f = new Foo();
f.foo();
console.log(f.bar());
```

Webpack을 사용하는 경우에는 위 방법 대신 webpack.config.js 파일의 entry 배열에 폴리필을 추가한다.

```javascript
const path = require("path");

module.exports = {
  entry: ["@babel/polyfill", "./src/js/main.js"],
  // ...
};
```

## 결론

이상으로 ES6+/ES.NEXT 개발 환경을 구축해 보았다. 개발 환경 구축은 Babel과 Webpack의 버전이 빈번하게 업그레이드되므로 자신이 설치한 버전과 다른 경우가 많아 에러가 자주 발생한다. 이런 경우에는 공식 문서를 참고하여 버전에 맞게 수정해야 한다. 또한 개발 환경 구축에 관한 부분은 create-react-app, Next.js, Vite 같은 도구를 통해 자동화할 수 있다.
