# chapter26 - ES6 함수의 추가 기능

## 26.1 함수의 구분

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 즉, ES6 이전의 모든 함수는 callable이면서 constructor다.

ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

| ES6 함수의 구분 | constructor | prototype | super | arguments |
| --------------- | ----------- | --------- | ----- | --------- |
| 일반 함수       | O           | O         | X     | O         |
| 메서드          | X           | X         | O     | O         |
| 화살표 함수     | X           | X         | X     | X         |

## 26.2 메서드

ES6에서 메서드는 **메서드 축약 표현으로 정의된 함수**만을 의미한다.

```javascript
const obj = {
  x: 1,
  // foo는 메서드다.
  foo() {
    return this.x;
  },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수다.
  bar: function () {
    return this.x;
  },
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```

ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor다.

```javascript
new obj.foo(); // TypeError: obj.foo is not a constructor
new obj.bar(); // bar {}
```

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다. super 참조는 내부 슬롯 [[HomeObject]]를 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 [[HomeObject]]를 갖는 ES6 메서드는 super 키워드를 사용할 수 있다.

```javascript
const base = {
  name: "Lee",
  sayHi() {
    return `Hi! ${this.name}`;
  },
};

const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.
  sayHi() {
    return `${super.sayHi()}. how are you doing?`;
  },
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

## 26.3 화살표 함수

### 화살표 함수 정의

```javascript
const multiply = (x, y) => x * y;
multiply(2, 3); // 6
```

### 매개변수 선언

```javascript
const arrow = (x, y) => { ... };

// 매개변수가 한 개인 경우 소괄호 생략 가능
const arrow = x => { ... };

// 매개변수가 없는 경우 소괄호 생략 불가
const arrow = () => { ... };
```

### 함수 몸체 정의

```javascript
// concise body
const power = (x) => x ** 2;
power(2); // 4

// 위 표현은 다음과 동일하다.
const power = (x) => {
  return x ** 2;
};

// 객체 리터럴을 반환하는 경우 소괄호로 감싸야 한다.
const create = (id, content) => ({ id, content });
create(1, "JavaScript"); // {id: 1, content: "JavaScript"}

// 위 표현은 다음과 동일하다.
const create = (id, content) => {
  return { id, content };
};
```

### 화살표 함수와 일반 함수의 차이

#### 1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.

```javascript
const Foo = () => {};
new Foo(); // TypeError: Foo is not a constructor
```

#### 2. 중복된 매개변수 이름을 선언할 수 없다.

```javascript
const arrow = (a, a) => a + a;
// SyntaxError: Duplicate parameter name not allowed in this context
```

#### 3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

### this

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 **lexical this**라 한다.

```javascript
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    // 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
    return arr.map((item) => this.prefix + item);
  }
}

const prefixer = new Prefixer("-webkit-");
console.log(prefixer.add(["transition", "user-select"]));
// ['-webkit-transition', '-webkit-user-select']
```

### super

화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.

### arguments

화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 arguments를 참조한다.

## 26.4 Rest 파라미터

### 기본 문법

```javascript
function foo(...rest) {
  console.log(rest); // [1, 2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5);
```

Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

```javascript
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest); // [2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5);
```

### Rest 파라미터와 arguments 객체

```javascript
function sum() {
  // arguments 객체를 배열로 변환
  var array = Array.prototype.slice.call(arguments);

  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Rest 파라미터 사용
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

## 26.5 매개변수 기본값

```javascript
function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1)); // 1
console.log(sum()); // 0
```
