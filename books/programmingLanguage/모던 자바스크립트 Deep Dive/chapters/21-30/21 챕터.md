# chapter21 - 빌트인 객체

## 21.1 자바스크립트 객체의 분류

- **표준 빌트인 객체**: ECMAScript 사양에 정의된 객체
- **호스트 객체**: 자바스크립트 실행 환경에서 추가로 제공하는 객체
- **사용자 정의 객체**: 사용자가 직접 정의한 객체

## 21.2 표준 빌트인 객체

Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개의 표준 빌트인 객체를 제공한다.

```javascript
const strObj = new String("Lee");
console.log(typeof strObj); // object
console.log(strObj); // String {"Lee"}

const numObj = new Number(123);
console.log(typeof numObj); // object

const boolObj = new Boolean(true);
console.log(typeof boolObj); // object

const func = new Function("x", "return x * x");
console.log(typeof func); // function

const arr = new Array(1, 2, 3);
console.log(typeof arr); // object

const regExp = new RegExp(/ab+c/i);
console.log(typeof regExp); // object

const date = new Date();
console.log(typeof date); // object
```

## 21.3 원시값과 래퍼 객체

```javascript
const str = "hello";

// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```

자바스크립트 엔진은 원시값을 객체처럼 사용하면 암묵적으로 연관된 객체를 생성하여 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다. 이를 **래퍼 객체**라 한다.

```javascript
const str = "hi";

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```

## 21.4 전역 객체

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다.

- 브라우저: window (또는 self, this, frames)
- Node.js: global
- ES11: globalThis

```javascript
// 브라우저 환경
globalThis === window; // true

// Node.js 환경
globalThis === global; // true
```

### 빌트인 전역 프로퍼티

```javascript
Infinity; // 무한대
NaN; // Not-a-Number
undefined; // undefined
```

### 빌트인 전역 함수

#### eval

```javascript
// 문자열을 코드로 평가
eval("1 + 2"); // 3
eval("var x = 5;"); // undefined
console.log(x); // 5

// eval 함수는 보안에 매우 취약하므로 사용을 금지해야 한다.
```

#### isFinite

```javascript
isFinite(0); // true
isFinite(2e64); // true
isFinite("10"); // true: '10' → 10
isFinite(null); // true: null → 0

isFinite(Infinity); // false
isFinite(-Infinity); // false
isFinite(NaN); // false
isFinite("Hello"); // false
```

#### isNaN

```javascript
isNaN(NaN); // true
isNaN(10); // false

isNaN("blabla"); // true: 'blabla' → NaN
isNaN("10"); // false: '10' → 10
isNaN("10.12"); // false: '10.12' → 10.12
isNaN(""); // false: '' → 0
isNaN(" "); // false: ' ' → 0
```

#### parseFloat

```javascript
parseFloat("3.14"); // 3.14
parseFloat("10.00"); // 10

parseFloat("34 45 66"); // 34
parseFloat("40 years"); // 40
parseFloat("He was 40"); // NaN
```

#### parseInt

```javascript
parseInt("10"); // 10
parseInt("10.123"); // 10

parseInt(10); // 10
parseInt(10.123); // 10

// 2진수 해석
parseInt("10", 2); // 2

// 8진수 해석
parseInt("10", 8); // 8

// 16진수 해석
parseInt("10", 16); // 16
```

#### encodeURI / decodeURI

```javascript
const uri = "http://example.com?name=이웅모&job=programmer&teacher";

const enc = encodeURI(uri);
console.log(enc);
// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher

const dec = decodeURI(enc);
console.log(dec);
// http://example.com?name=이웅모&job=programmer&teacher
```

#### encodeURIComponent / decodeURIComponent

```javascript
const uriComp = "name=이웅모&job=programmer&teacher";

let enc = encodeURIComponent(uriComp);
console.log(enc);
// name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacher

let dec = decodeURIComponent(enc);
console.log(dec);
// 이웅모&job=programmer&teacher
```

### 암묵적 전역

```javascript
var x = 10; // 전역 변수

function foo() {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y); // 30

console.log(window.y); // 20

delete y; // 프로퍼티는 삭제된다.
console.log(window.y); // undefined

delete x; // 전역 변수는 삭제되지 않는다.
console.log(window.x); // 10
```
