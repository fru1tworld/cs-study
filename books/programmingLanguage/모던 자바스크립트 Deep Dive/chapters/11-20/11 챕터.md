# chapter11 - 원시 값과 객체의 비교

## 11.1 원시 값

### 변경 불가능한 값

원시 타입의 값은 **변경 불가능한 값(immutable value)**이다.

- 변수는 재할당을 통해 값을 변경할 수 있지만, 값 자체는 변경 불가능
- 원시 값을 재할당하면 새로운 메모리 공간에 저장

```javascript
let score = 80;
score = 90; // 새로운 원시 값 90을 생성하고 score 변수에 재할당
```

### 불변성의 이점

- 데이터의 신뢰성 보장
- 상태 변경 추적 용이
- 함수형 프로그래밍의 기반

### 문자열과 불변성

```javascript
let str = "Hello";
str[0] = "S"; // 문자열은 변경 불가능
console.log(str); // 'Hello' (변경되지 않음)

// 새로운 문자열 생성
str = "World";
```

### 값에 의한 전달

```javascript
let score = 80;
let copy = score; // 값에 의한 전달

score = 100;

console.log(score); // 100
console.log(copy); // 80 (독립적인 값)
```

## 11.2 객체

### 변경 가능한 값

객체 타입의 값은 **변경 가능한 값(mutable value)**이다.

- 객체는 프로퍼티를 동적으로 추가, 삭제, 갱신 가능
- 재할당 없이 직접 변경 가능

```javascript
const person = {
  name: "Lee",
};

// 재할당 없이 객체 직접 변경
person.name = "Kim";
person.address = "Seoul";

console.log(person); // {name: "Kim", address: "Seoul"}
```

### 얕은 복사와 깊은 복사

```javascript
// 얕은 복사
const original = { x: { y: 1 } };
const shallow = { ...original };
shallow.x.y = 2;
console.log(original.x.y); // 2 (원본도 변경됨)

// 깊은 복사
const deep = JSON.parse(JSON.stringify(original));
deep.x.y = 3;
console.log(original.x.y); // 2 (원본은 변경되지 않음)
```

### 참조에 의한 전달

```javascript
let person = {
  name: "Lee",
};

let copy = person; // 참조에 의한 전달

copy.name = "Kim";

console.log(person.name); // 'Kim' (원본도 변경됨)
console.log(copy.name); // 'Kim'
console.log(person === copy); // true (같은 참조)
```

## 11.3 원시 값과 객체의 비교 정리

| 구분      | 원시 타입         | 객체 타입     |
| --------- | ----------------- | ------------- |
| 값의 변경 | 불가능(immutable) | 가능(mutable) |
| 변수 할당 | 실제 값 저장      | 참조 값 저장  |
| 복사      | 값 복사           | 참조 복사     |
| 비교      | 값 비교           | 참조 비교     |

### 실전 활용

```javascript
// 원시 값: 안전한 비교
let a = 1;
let b = 1;
console.log(a === b); // true

// 객체: 참조 비교
let obj1 = { value: 1 };
let obj2 = { value: 1 };
console.log(obj1 === obj2); // false (다른 참조)

// 깊은 비교가 필요한 경우
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true
```
