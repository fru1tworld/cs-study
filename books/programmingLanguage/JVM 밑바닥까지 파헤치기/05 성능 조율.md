# 05 성능 조율

## 성능 조율의 목표

성능 조율은 다음을 최적화하는 것:

- 처리량 (Throughput)
- 응답 시간 (Response Time)
- 메모리 사용량
- 안정성

## GC 조율

### GC 조율 목표

- GC 일시 정지 시간 최소화
- GC 빈도 감소
- 처리량 최대화

### 주요 GC 매개변수

#### 힙 크기

- `-Xms`: 초기 힙 크기
- `-Xmx`: 최대 힙 크기
- `-Xmn`: 신세대 크기
- `-XX:SurvivorRatio`: Eden과 Survivor 비율

#### GC 선택

- `-XX:+UseSerialGC`: Serial GC
- `-XX:+UseParallelGC`: Parallel GC
- `-XX:+UseConcMarkSweepGC`: CMS GC
- `-XX:+UseG1GC`: G1 GC

#### GC 동작

- `-XX:MaxGCPauseMillis`: 목표 정지 시간
- `-XX:GCTimeRatio`: 처리량 목표
- `-XX:ParallelGCThreads`: 병렬 GC 스레드 수

### GC 로그 분석

#### GC 로그 활성화

```
-Xloggc:gc.log
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
```

#### 주요 지표

- GC 빈도
- 일시 정지 시간
- 힙 사용률
- 승격률 (Promotion Rate)

## 메모리 조율

### 메모리 누수 탐지

1. 힙 덤프 생성
2. MAT/VisualVM으로 분석
3. Dominator Tree 확인
4. GC Root 추적

### 메모리 최적화

- 불필요한 객체 생성 방지
- 적절한 자료구조 선택
- 캐시 크기 조정
- 약한 참조 활용

## 컴파일 조율

### JIT 컴파일러

- C1 (Client): 빠른 시작
- C2 (Server): 높은 처리량
- Tiered Compilation: 계층적 컴파일

### 인라인 최적화

- 작은 메서드 인라인
- 핫스팟 식별
- 가상 호출 최적화

### 탈최적화 (Deoptimization)

- 잘못된 가정 발견 시
- 코드 재컴파일
- 성능 영향 최소화

## 스레드 조율

### 스레드 풀 크기

- CPU 집약적: CPU 코어 수 + 1
- I/O 집약적: 대기 시간 고려
- 동적 조정

### 동기화 최적화

- 잠금 범위 최소화
- 읽기-쓰기 잠금
- 락 프리 알고리즘
- 원자적 변수

## 클래스 로딩 조율

### 클래스 로딩 최적화

- 클래스 공유
- AppCDS (Application Class-Data Sharing)
- AOT (Ahead-Of-Time) 컴파일

## 성능 모니터링

### 지속적 모니터링

- APM (Application Performance Monitoring)
- 메트릭 수집
- 알림 설정
- 대시보드

### 주요 메트릭

- 응답 시간
- 처리량
- 에러율
- 메모리/CPU 사용률

## 성능 테스트

### 부하 테스트

- 예상 부하 시뮬레이션
- 병목 지점 식별
- 용량 계획

### 스트레스 테스트

- 한계 테스트
- 장애 복구
- 안정성 검증

## 최적화 우선순위

1. **측정 먼저**: 추측하지 말고 측정하라
2. **큰 것부터**: 가장 큰 영향을 주는 것부터
3. **단순함 유지**: 과도한 최적화 지양
4. **트레이드오프**: 모든 것을 최적화할 수 없다

## 일반적인 최적화 실수

### 조기 최적화

- 측정 없이 최적화
- 불필요한 복잡도
- 유지보수성 저하

### 과도한 최적화

- 가독성 희생
- 미묘한 버그
- 플랫폼 의존성

## 교훈

1. **측정하라, 추측하지 마라**
2. **병목 지점을 찾아라**
3. **트레이드오프를 이해하라**
4. **단순함을 유지하라**
5. **지속적으로 모니터링하라**
6. **문서화하라**
7. **조기 최적화를 피하라**
