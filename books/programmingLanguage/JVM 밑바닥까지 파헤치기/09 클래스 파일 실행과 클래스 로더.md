# 09 클래스 파일 실행과 클래스 로더

## 클래스 로더 시스템

### 클래스 로더 계층 구조

#### 1. Bootstrap ClassLoader (부트스트랩 클래스 로더)

- 최상위 클래스 로더
- JVM 자체의 일부 (네이티브 코드)
- JDK 핵심 라이브러리 로드
- `java.lang.*`, `java.util.*` 등
- `$JAVA_HOME/jre/lib` 경로

#### 2. Extension ClassLoader (확장 클래스 로더)

- 확장 라이브러리 로드
- `$JAVA_HOME/jre/lib/ext` 경로
- Java로 구현됨
- 부트스트랩 클래스 로더의 자식

#### 3. Application ClassLoader (애플리케이션 클래스 로더)

- 사용자 애플리케이션 클래스 로드
- CLASSPATH 환경 변수
- `-cp` 옵션으로 지정된 경로
- 가장 많이 사용됨

#### 4. Custom ClassLoader (사용자 정의 클래스 로더)

- 개발자가 직접 구현
- 동적 클래스 로딩
- 네트워크에서 클래스 로드
- 암호화된 클래스 로드

## 클래스 로딩 메커니즘

### 1. 로딩 (Loading)

- 클래스 파일 찾기
- 바이너리 데이터 읽기
- Method Area에 저장
- Class 객체 생성

### 2. 링킹 (Linking)

#### 검증 (Verification)

- 클래스 파일 형식 검증
- 메타데이터 검증
- 바이트코드 검증
- 심볼 참조 검증

#### 준비 (Preparation)

- 정적 변수 메모리 할당
- 기본값으로 초기화
- final 상수는 실제 값으로

#### 해석 (Resolution)

- 심볼 참조를 직접 참조로 변환
- 다른 클래스/메서드/필드 참조 해결

### 3. 초기화 (Initialization)

- 정적 초기화 블록 실행
- 정적 변수 초기화
- 클래스 생성자 `<clinit>` 실행

## 부모 위임 모델 (Parent Delegation Model)

### 동작 방식

1. 클래스 로드 요청 받음
2. 부모 클래스 로더에게 위임
3. 부모가 로드 못 하면 자신이 로드
4. 재귀적으로 최상위까지 전달

### 장점

- 클래스 중복 로딩 방지
- 보안 향상
- 핵심 클래스 보호

### 단점

- 유연성 부족
- 플러그인 아키텍처 어려움
- OSGi 등 대안 필요

## 클래스 로더의 특성

### 1. 가시성 (Visibility)

- 자식은 부모가 로드한 클래스 볼 수 있음
- 부모는 자식이 로드한 클래스 못 봄

### 2. 유일성 (Uniqueness)

- 부모가 로드한 클래스는 자식이 다시 안 로드
- 같은 클래스는 한 번만 로드

### 3. 격리성 (Isolation)

- 서로 다른 클래스 로더가 로드한 클래스는 다름
- 같은 클래스 파일이라도 다른 클래스로 취급

## 클래스 언로딩

### 언로딩 조건

1. 클래스의 모든 인스턴스가 GC됨
2. 클래스 로더가 GC됨
3. Class 객체에 대한 참조 없음

### GC와의 관계

- 클래스는 Method Area에 저장
- Method Area도 GC 대상
- Perm Gen/Metaspace 관리

## 사용자 정의 클래스 로더

### 구현 방법

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) {
        byte[] classData = loadClassData(name);
        return defineClass(name, classData, 0, classData.length);
    }
}
```

### 활용 사례

- 동적 코드 생성
- 핫 디플로이
- 코드 암호화/복호화
- 네트워크에서 클래스 로드

## OSGi와 모듈 시스템

### OSGi (Open Service Gateway Initiative)

- 동적 모듈 시스템
- 번들 (Bundle) 단위
- 각 번들은 자체 클래스 로더
- 의존성 관리

### Java 9 모듈 시스템 (JPMS)

- 모듈 개념 도입
- 명시적 의존성
- 강한 캡슐화
- 플랫폼 모듈화

## 클래스 로딩 문제 해결

### ClassNotFoundException

- 클래스 파일이 없음
- CLASSPATH 확인
- 패키지 이름 확인

### NoClassDefFoundError

- 컴파일 시에는 있었으나 런타임에 없음
- 정적 초기화 실패
- 클래스 로더 문제

### ClassCastException

- 같은 클래스가 다른 클래스 로더로 로드됨
- 클래스 로더 격리 문제
- 공유 클래스 사용

## 성능 고려사항

### 클래스 로딩 최적화

- 지연 로딩 (Lazy Loading)
- 클래스 공유 (Class Sharing)
- AOT 컴파일

### 클래스 데이터 공유 (CDS)

- 클래스 메타데이터 공유
- 시작 시간 단축
- 메모리 사용량 감소

## 교훈

1. **부모 위임 모델을 이해하라**
2. **클래스 로더 계층을 파악하라**
3. **클래스 가시성과 격리성을 이해하라**
4. **사용자 정의 클래스 로더는 신중히 사용하라**
5. **클래스 언로딩 조건을 이해하라**
6. **CLASSPATH 설정을 정확히 하라**
7. **모듈 시스템을 활용하라**
