# 12 자바 메모리 모델과 스레드

## 12.1 들어가며

자바는 서버 애플리케이션을 가장 잘하고 실제로 가장 큰 비중을 차지한다.

자바에서 동시성은 어려운 문제이다.

## 12.2 하드웨어에서의 효율과 일관성

프로세와와 메인 메모리 사이 속도를 완화하기 위해 캐시를 활용한다.
그런데 이러한 캐시를 활용하면 데이터의 과관성 고문제가 있어서 케시 프로토콜을 별도로 사용해야한다.
캐시 프로토콜은 MSI, MESI, MOSI 드래곤, 시냅스 등있다 .

## 12.3 자바 메모리 모델

### 12.3.1 메인 메모리와 작업 메모리

자의의 바메모리 모델의 주된 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정하는 것인데, 여기서변수는 메서드 매개 변수와 같은 경합성과 상관없는 변수는 포함되지 않는다.

\*지역 변수가 참조형이면 객체는 자바 힙에 위치하여 다른 스레드와 공유되지만 참조자체는 자바 스택의 지역 변수 테이블에 위치하여 공유되지 않는다.

### 12.3.2 메모리 간 상호 작용

메인 메모와와 리작업 메모리 사이의 프로토콜, 즉 메인 메모리에서 작업 메모리로 변수를 복사하고 작업 메모리의 내용을 메인 메모리로 다시 동기화하는 구체적인 방법을 자바 메모리를 여덟가지로 정의했다.

- 잠금(lock): 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다.
- 잠금 해제(unlock): 잠겨 있는 변수를 잠금 해제한다. 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있다
- 읽기(read): 뒤이어 수행되는 적재 연산을 위해 메모리의 변숫값을 특정 스레드의 작업 메모리로 전송
- 적재(load): 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 복사해 넣는다.
- 사용(use): 작업 메모리의 변숫값을 실행 엔진으로 전달한다. 가상 머신이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행된다.
- 할당(aggin): 실행 엔진에서 받은 값을 작업 메모리로 할당한다.
- 저장(store): 뒤이어 수행되는 쓰기 연산을 위해 작업 메모의의 변숫값을 메인 메모리로 전송한다.
- 쓰기(writ): 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록한다.

이 연산에 규칙이 있는데

- read,load 와 store,write는 단독으로수행될 수 없다 변수를 메인 메모리에서 읽고 작업 메모리로 적재를 하거나 작업 메모리의 변수값을 저장한다음 메인 메모리에 쓰지 않아도 안된다.
- 스레드는 최근 할당 연산을 버릴 수 없다. 즉 작업 메모리에서 변숫값이 변경되면 메인 메모리로 동기화해야한다
- 스레드는 작업 메모리의 디에터를 아무 이유 없이(할당 없이) 메인 메모리로 동기화할 수 없다.
- 변수는 한번에 한 스레드만 잠글 수 있고 같은 스레드라면 여러번 잠글 수 있다.
- 변수를 잠그면 작업 메모리의 변숫값을 지워진다.
- 잠겨 있지 않은 변수나 다른 스레드가 잠근 변수에 대해서는 잠금 해제 연산을 수행할 수 없다.
- 잠금 해제하려면 변수를 메인 메모리로 동기화해야한다.

### 12.3.3 volatile 변수용 특별 규칙

volatile 키워드는 자바 가상 머신이 제공하는 가장 가벼운 동기화 메커니즘인데 완벽하게 이해하기 쉽지 않아서 스레드들이 데이터를 놓고 경합할 때 synchronized를 주로 활용하는 개발자가 많다.

자바의 산술 연산자는 원자적이 아니라서 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하지 못하다.
심지어 바이트코드 명령어 한 개가 반드시 원자적으로 수행된다는 보장은 없다.

바이트코드 하나도 결국 기계어 명령어 여러 개로 변환되어 실행될 수 있다.
따라서 다음과같은 조건이라면 synchronized 키워드나 java.util.concurrent를 사용해 원자적 클래스의 락을 사용해야한다.

1. 연산의 결과가 변수의 현재 값과는 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장한다.
2. 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않는다.

그리고 volatitle로 선언한 변수의 두 번째 특성은 명령어 재정렬 최적화를 막아준다는 것이다.
일반 변수는 메서드 실행 중 할당 결과를 이용해야 하는 모든 위치에 올바른 결과를 얻는다는 점만 보장될 뿐, 그 외 변수 할당 작업의 실행 순서가 프로그램 코드 순서와 같다는 보장은 없다.
이러한 명령어 재정렬은 같은 스레드에서 메서드를 실행하는 동안에는 탐지할 수 없다.

그래서 자바 메모리모델에서는 스레드 안에서는 순차적인 시맨틱이라 한다.

명령어 재정렬은 동시성 프로그래밍에서 가장 혼란스러운 영역에 속한다.

### 12.3.4 long과 double 변수용 특별 규칙

자바 메모리 모델에서 제공하는 8가지 연산이 모두 원자적이어야하지만 long과 double은 예외이다.

volatitle로 지정되지 않았으면 연산 2개로 나눠 처리할 수 있다.
이를 long과 double의 비원자적 처리라고 한다.

volatitle에서 long또는 double 변수를 여러 스레드가 공유하고 동시에 읽고 수정한다면 반만 수정될 수 있다.
하지만 주류 64비트 가상머신에서는 거의 일어나지 않는다.

### 12.3.5 원자성, 가시성, 실행 순서

실행 순서
스레드에서는 일관성을 유지하지만 멀티스레드에서 순서가 다를 수 있다.

### 12.3.6 선 발생 원칙

어떤 작업 A가 B보다 먼저 발생했으면 A 작업은 B에 의존한다 이를 선 발생 원칙이라고 한다.
