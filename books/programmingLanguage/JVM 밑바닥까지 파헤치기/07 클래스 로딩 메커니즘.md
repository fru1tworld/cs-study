## 7.1 들어가며

이전 장에서 클래스 파일 저장 형식을 알봐봤고 , 클래스 파일에 서술된 정보를 가상 머신이 이용하려면 먼저 로드를 해야한다.
가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신 안에서 활용하는 방법이 이번 장의 주제다.

JVM은 클래스를 설명하는 파일로부터 메모리를 읽고 그것을 검증, 변환, 초기화 및 최종적으로 VM이 곧바로 활용할 수 있는 자바 타입을 생성하는데.

이것이 클래스 로딩 메커니즘이다.

컴파일 시 링크까지 해야하는 언와와 어다르게 자바 언어에서는 클래스 로딩, 링킹, 초기화가 모두 프로그램 실행 중에 이뤄진다.

그래서 자바 언어는 AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 떨어지지만 이로 인해 높은 확장성과 유연성을 가능케하는 이점으로 작용한다.

즉 동적 로딩과 동적 링킹이 가능하다.

예를 들어 애플리케이션을 인터페이스 중심으로 작성하면 실제 구현 클래스를 결정하는 일은 실행 시까지 미룰 수 있다.

또한 클래스로더를 활용하면 실행 중인 프로그램의 코드 일부를 네트워크를 통해 바이너리 스트림으로으로읽어올 수 있다.

참고로 클래스 파일은 메모리, 네트워크 DB 등 어디든 존재할 수 있다.

## 7.2 클래스 로딩 시점

클래스는 로딩에서 언로딩까지의 과정이 있는데

로딩 -> 검증 -> 준비 -> 해석 -> 초기화 -> 사용 -> 언로딩의 과정이 있고
검증,준비, 해석을 묶어서 링킹이라고 한다.

로딩,검증,준비,초기화,언로딩은 반드시 순서대로 해야한다.

반면 해석은은 그렇지않아서 따라서는 초기화 후에 시작할 수 있다.

이는 자바 언어의 `런타임 바인딩`을 지원하기 위해서이다.

**참고로 여기서 단계별 순서의 기준은 진행, 완료 시점이 아니라 시작 시점이다. 따라서 병렬 상태로 진행되기도 한다.**

로딩을 어디서 시작해야하는지 명시하지 않았는데, 초기화는 즉시 시작되어야 하는 상황 여섯가지를 규정하였다.

1. 바이트코드 명령어인 new, getstatic, putstatic, invokestatic을 만났을 때 해당 타입이 초기화되지 않았다면 초기화를 촉발한다.

- new 키워드로 객체 생성
- 타입의 정적 필드를 읽거나설정(단 final로 지정된 정적 필드는 컴파일타임에 상수 풀에 채워지므로 제외)
- 타입의 정적 메서드 호출

2. Class 클래스나, java.lang.reflect 패키지 등 리플렉션 메서드를 사용할 때 해당 타입이 초기화되어 있지 않다면 초기화를 촉발한다.

3. 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않다면 상위 클래스 초기화를 촉발한다.

4. 가상 머신은 구동 직후 사용자가 지정한 main 타입을 찾아 실행하고. 이때 main 타입을 먼저 초기화한다.
5. REF_getStatic, pustatic, invokeStatic과 같은 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당 클래스가 초기화되어 있지 않다면 초기화를 한다.
6. 인터페이스에 디폴트 메서드를 정의했다면 해당 인터페이스를 직 간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화한다.

## 7.3 클래스 로딩 처리 과정

### 7.3.1 로딩

로딩은 클래스 로딩의 전체 과정 중 한 단계를 말한다.

1. 완전한 이름(클래스 파일 구조에서 상수풀에 있는)을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환한다.
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로가 된다.

참고로 위 방법의 실제 구현은 다양하게 구현될 수 있다.

- ZIP 압축파일로부터 로딩, 이후 JAR, EAR, WAR 형식의 기초가 됨
- 네트워크 로딩, 런타임에 동적으로 생성, 다른 파일로부터 생성, 데이터베이스로부터 로딩, 암호화된 파일로부터 로딩

### 7.3.2 검증

검증은 링킹의 첫 단계이다.

1. 클래스 파일의 바이트 스트림에 담긴 정보가 JVM에서 규정한 모든 제약을 만족하는지 확인한다.
2. 이 정보를 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.

그래서 순수한 자바 언어는 배열 경계를 넘거나 범위를 넘어서는 접근 혹은 상속하지 않은 타입으로 변환 및 존재하지 않는 코드 라인으로 점프하는 동작을 불가능하게 한다.

1. 파일 형식 검증
2. 메타데이터 검증
3. 바이트코드 검증
4. 심벌 참조 검증

이 4단계를 거쳐 완료된다.

### 7.3.3 준비

준비는 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계다.
개념적으로는 이 변수들이 사용하는 메모리를 메서드영역에 할당해야 하지만. 메서드 영역 자체가 논리적이라는 사실을 감안해야한다.
인스턴스

일반적으로
public statc int value = 123; 은 제로값으로 들어가고 이후 값이 할당되지만

pulib static final int vlaue = 123;은 처음부터 값이 할당된 상태로 초기화한다.

즉 ConstantVAlue 속성을 생성한다.

### 7.3.4 해석

해석은 자바 가상 머신이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다.
심벌 참조는 CONSTANT_Class_info와 같은 것이다.
직접 참조와 심벌 참조는 어떤 관계일까 ?

1. 심벌 참조: 몇 가지 심벌로 참조 대상을 설명한다. 여기서 심벌은 대상을 명확하게 지칭하는데 이용될 수 있는 모든 리터럴이 될 수 있다. 참조 대상이 반드시 가상 머신의 메모리에 로드되어 있을 필요도 없다. 메모리 레이아웃은 가상 머신 구현에 따라 달라질 수 있지만 심벌 참조는 달라지지 않는다 그래서 리터럴 형태는 클래스 파일 구조에 명확하게 정의되어있기 때문이다.

2. 직접 참조: 포인터, 상대적 위치 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 직접 참조는 가상 머신에 구현이 달라진다.
   직접 참조는 참조 대상이 가상 머신의 메모리에 이미 존재해야 한다.

JVM 명세서는 해석 단계를 수행하는 시간을 특정하지 않고, 그 대신 심벌 참조를 다루는 바이트 코드 명령어들에 대해 실행하도록 규정했다.

### 7.3.5 초기화

초기화는 클래스 로딩의 마지막인데 대부분 JVM이 통제한다.

모든 클래스 변수 할당과 정적 문장 블록의 내용을 취합하여 컴파일러가 자동으로 생성한다. 컴파일러가 수집하는 순서는 문장이 소스 파일에 등장하는 순서에 영향을 받는다.

## 7.4 클래스 로더

클래스 로딩을 애플리케이션이 정할 수 있기를 원하는 것이 자바 언어의 혁신이다.

### 7.4.1 클래스와 클래스 로더

클래스 로더는 클래스를 로딩하는 일을 하지만 그 외의 일도 한다.
예를 들어 어떤 클래스가 동치인지 여부는 모두 같은 클래스 로더로 로드했을 때만 의미가 있다.
따라서 똑같은 클래스 파일로 로딩을 했더라도 서로 다른 클래스 로더로 읽어 들였다면 서로 다른 클래스이다.

여기서 말하는 동치인가는 해당 클래스의 equals(), isAssignableFrom(), isInstance()

### 7.4.2 부모 위임 모델

### 7.4.3 부모 위임 모델에 대한 도전

## 7.5 자바 모듈 시스템

### 7.5.1 모듈 호환성

### 7.5.2 모듈화 시대의 클래스 로더

## 7.6 마치며
