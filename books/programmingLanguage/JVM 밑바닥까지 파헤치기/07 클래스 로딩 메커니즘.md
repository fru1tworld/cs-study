# 7장. 가상 머신 클래스 로딩 메커니즘

## 7.1 들어가며

이전 장에서 클래스 파일 저장 형식을 알아봤고, 클래스 파일에 서술된 정보를 가상 머신이 이용하려면 먼저 로드를 해야한다.
가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신 안에서 활용하는 방법이 이번 장의 주제다.

JVM은 클래스를 설명하는 파일로부터 메모리를 읽고 그것을 검증, 변환, 초기화 및 최종적으로 VM이 곧바로 활용할 수 있는 자바 타입을 생성하는데, 이것이 클래스 로딩 메커니즘이다.

컴파일 시 링크까지 해야하는 언어와 다르게 자바 언어에서는 클래스 로딩, 링킹, 초기화가 모두 프로그램 실행 중에 이뤄진다. 그래서 자바 언어는 AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 떨어지지만 이로 인해 높은 확장성과 유연성을 가능케하는 이점으로 작용한다. 즉 동적 로딩과 동적 링킹이 가능하다.

예를 들어 애플리케이션을 인터페이스 중심으로 작성하면 실제 구현 클래스를 결정하는 일은 실행 시까지 미룰 수 있다. 또한 클래스로더를 활용하면 실행 중인 프로그램의 코드 일부를 네트워크를 통해 바이너리 스트림으로 읽어올 수 있다.

참고로 클래스 파일은 메모리, 네트워크, DB 등 어디든 존재할 수 있다.

## 7.2 클래스 로딩 시점

클래스는 로딩에서 언로딩까지의 과정이 있는데
로딩 → 검증 → 준비 → 해석 → 초기화 → 사용 → 언로딩의 과정이 있고
검증, 준비, 해석을 묶어서 링킹이라고 한다.

로딩, 검증, 준비, 초기화, 언로딩은 반드시 순서대로 해야한다. 반면 해석은 그렇지 않아서 따라서는 초기화 후에 시작할 수 있다. 이는 자바 언어의 `런타임 바인딩`을 지원하기 위해서이다.

**참고로 여기서 단계별 순서의 기준은 진행, 완료 시점이 아니라 시작 시점이다. 따라서 병렬 상태로 진행되기도 한다.**

로딩을 어디서 시작해야하는지 명시하지 않았는데, 초기화는 즉시 시작되어야 하는 상황 여섯 가지를 규정하였다.

1. 바이트코드 명령어인 new, getstatic, putstatic, invokestatic을 만났을 때 해당 타입이 초기화되지 않았다면 초기화를 촉발한다.

   - new 키워드로 객체 생성
   - 타입의 정적 필드를 읽거나 설정(단 final로 지정된 정적 필드는 컴파일타임에 상수 풀에 채워지므로 제외)
   - 타입의 정적 메서드 호출

2. Class 클래스나 java.lang.reflect 패키지 등 리플렉션 메서드를 사용할 때 해당 타입이 초기화되어 있지 않다면 초기화를 촉발한다.

3. 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않다면 상위 클래스 초기화를 촉발한다.

4. 가상 머신은 구동 직후 사용자가 지정한 main 타입을 찾아 실행하고, 이때 main 타입을 먼저 초기화한다.

5. REF_getStatic, pustatic, invokeStatic과 같은 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당 클래스가 초기화되어 있지 않다면 초기화를 한다.

6. 인터페이스에 디폴트 메서드를 정의했다면 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화한다.

## 7.3 클래스 로딩 처리 과정

### 7.3.1 로딩

로딩은 클래스 로딩의 전체 과정 중 한 단계를 말한다.

1. 완전한 이름(클래스 파일 구조에서 상수풀에 있는)을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환한다.
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로가 된다.

참고로 위 방법의 실제 구현은 다양하게 구현될 수 있다.

- ZIP 압축파일로부터 로딩, 이후 JAR, EAR, WAR 형식의 기초가 됨
- 네트워크 로딩, 런타임에 동적으로 생성, 다른 파일로부터 생성, 데이터베이스로부터 로딩, 암호화된 파일로부터 로딩

### 7.3.2 검증

검증은 링킹의 첫 단계이다.

1. 클래스 파일의 바이트 스트림에 담긴 정보가 JVM에서 규정한 모든 제약을 만족하는지 확인한다.
2. 이 정보를 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.

그래서 순수한 자바 언어는 배열 경계를 넘거나 범위를 넘어서는 접근 혹은 상속하지 않은 타입으로 변환 및 존재하지 않는 코드 라인으로 점프하는 동작을 불가능하게 한다.

검증 단계는 다음 4단계를 거쳐 완료된다:

1. **파일 형식 검증**: 클래스 파일이 올바른 형식인지 검증

   - 매직 넘버 0xCAFEBABE로 시작하는지 확인
   - 주 버전과 부 버전이 JVM에서 처리할 수 있는 범위인지 확인
   - 상수 풀의 상수들이 올바른 타입인지 확인

2. **메타데이터 검증**: 바이트코드가 자바 언어 명세를 준수하는지 검증

   - 클래스에 부모 클래스가 있는지 확인 (Object 제외)
   - 클래스가 final로 표시된 클래스를 상속하지 않는지 확인
   - 추상 클래스가 아닌데 추상 메서드를 구현하지 않은 경우는 없는지 확인

3. **바이트코드 검증**: 메서드 본문을 분석해 실행 시 JVM에 해를 끼치지 않는지 검증

   - 타입 변환이 안전한지 확인
   - 객체 필드에 할당하는 값이 적절한 타입인지 확인
   - 메서드 호출의 매개변수 개수와 타입이 올바른지 확인

4. **심벌 참조 검증**: 해석 단계에서 심벌 참조를 직접 참조로 변환할 때 참조되는 클래스, 필드, 메서드가 존재하는지 확인
   - 클래스가 존재하는지 확인
   - 필드나 메서드에 대한 접근 권한이 있는지 확인

### 7.3.3 준비

준비는 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계다. 개념적으로는 이 변수들이 사용하는 메모리를 메서드 영역에 할당해야 하지만, 메서드 영역 자체가 논리적이라는 사실을 감안해야한다.

인스턴스 변수는 이 단계에서 할당되지 않으며, 객체 생성 시 힙에 함께 할당된다.

일반적으로:

- `public static int value = 123;`은 준비 단계에서 0으로 초기화되고, 초기화 단계에서 123이 할당된다.
- `public static final int value = 123;`은 컴파일 시점에 ConstantValue 속성을 생성하므로 준비 단계에서 바로 123으로 초기화된다.

### 7.3.4 해석

해석은 자바 가상 머신이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다. 심벌 참조는 CONSTANT_Class_info와 같은 것이다.

직접 참조와 심벌 참조는 어떤 관계일까?

1. **심벌 참조**: 몇 가지 심벌로 참조 대상을 설명한다. 여기서 심벌은 대상을 명확하게 지칭하는데 이용될 수 있는 모든 리터럴이 될 수 있다. 참조 대상이 반드시 가상 머신의 메모리에 로드되어 있을 필요도 없다. 메모리 레이아웃은 가상 머신 구현에 따라 달라질 수 있지만 심벌 참조는 달라지지 않는다. 그래서 리터럴 형태는 클래스 파일 구조에 명확하게 정의되어있기 때문이다.

2. **직접 참조**: 포인터, 상대적 위치 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 직접 참조는 가상 머신 구현에 따라 달라진다. 직접 참조는 참조 대상이 가상 머신의 메모리에 이미 존재해야 한다.

JVM 명세서는 해석 단계를 수행하는 시간을 특정하지 않고, 그 대신 심벌 참조를 다루는 바이트코드 명령어들에 대해 실행하기 직전에 해석하도록 규정했다. 이를 지연 해석(Lazy Resolution)이라고 한다.

### 7.3.5 초기화

초기화는 클래스 로딩의 마지막 단계인데 대부분 JVM이 통제한다. 컴파일러는 모든 클래스 변수 할당과 정적 문장 블록의 내용을 취합하여 `<clinit>()` 메서드를 자동으로 생성한다. 컴파일러가 수집하는 순서는 문장이 소스 파일에 등장하는 순서에 영향을 받는다.

`<clinit>()` 메서드의 특징:

- 정적 변수 할당문과 static 블록만 포함된다
- 부모 클래스의 `<clinit>()` 메서드가 먼저 실행된다
- JVM은 멀티스레드 환경에서 `<clinit>()` 메서드의 동시 실행을 제어한다
- 인터페이스의 경우 부모 인터페이스를 먼저 초기화할 필요는 없다

## 7.4 클래스 로더

클래스 로딩을 애플리케이션이 정할 수 있기를 원하는 것이 자바 언어의 혁신이다.

### 7.4.1 클래스와 클래스 로더

클래스 로더는 클래스를 로딩하는 일을 하지만 그 외의 일도 한다. 예를 들어 어떤 클래스가 동치인지 여부는 모두 같은 클래스 로더로 로드했을 때만 의미가 있다.

따라서 똑같은 클래스 파일로 로딩을 했더라도 서로 다른 클래스 로더로 읽어 들였다면 서로 다른 클래스이다. 여기서 말하는 동치성 판단은 해당 클래스의 equals(), isAssignableFrom(), isInstance() 메서드와 instanceof 키워드 등을 포함한다.

이는 클래스의 유일성이 클래스 파일 자체와 해당 클래스를 로드한 클래스 로더에 의해 결정되기 때문이다.

### 7.4.2 부모 위임 모델

JVM에서 사용하는 클래스 로더는 계층 구조를 이루고 있다:

1. **부트스트랩 클래스 로더(Bootstrap Class Loader)**:

   - JVM의 일부로 C/C++로 구현
   - `<JAVA_HOME>/lib` 디렉토리의 핵심 라이브러리 로드
   - java.lang.Object 등 기본 클래스들을 로드

2. **확장 클래스 로더(Extension Class Loader)**:

   - `<JAVA_HOME>/lib/ext` 디렉토리의 확장 라이브러리 로드
   - 또는 java.ext.dirs 시스템 프로퍼티에 지정된 디렉토리

3. **애플리케이션 클래스 로더(Application Class Loader)**:
   - 클래스패스에 지정된 사용자 클래스들을 로드
   - 대부분의 사용자 클래스가 이 로더에 의해 로드됨

**위임 모델의 작동 방식**:

1. 클래스 로드 요청이 오면 먼저 부모 클래스 로더에게 위임
2. 부모가 로드할 수 없으면 자신이 로드를 시도
3. 자신도 로드할 수 없으면 ClassNotFoundException 발생

이 모델의 장점:

- 핵심 클래스들의 무결성 보장
- 중복 로딩 방지
- 보안 강화

### 7.4.3 부모 위임 모델에 대한 도전

부모 위임 모델은 완벽하지 않으며, 다음과 같은 한계가 있다:

1. **SPI(Service Provider Interface) 문제**:

   - JDBC 드라이버처럼 핵심 API는 부트스트랩 클래스 로더가 로드하지만
   - 실제 구현체는 애플리케이션 클래스 로더가 로드해야 하는 경우

2. **해결책들**:

   - **스레드 컨텍스트 클래스 로더**: 스레드별로 클래스 로더를 설정
   - **OSGi**: 복잡한 클래스 로더 구조로 모듈 시스템 구현
   - **커스텀 클래스 로더**: 특별한 요구사항을 위한 사용자 정의 로더

3. **Java 9의 모듈 시스템**:
   - 기존 클래스패스 시스템의 한계를 극복
   - 모듈 간 의존성을 명시적으로 관리

## 7.5 자바 모듈 시스템

Java 9에서 도입된 Project Jigsaw는 자바 플랫폼의 모듈화를 목표로 한다.

### 7.5.1 모듈 호환성

모듈 시스템은 다음과 같은 호환성을 제공한다:

1. **자동 모듈(Automatic Module)**:

   - 클래스패스의 JAR 파일을 자동으로 모듈로 변환
   - 모든 패키지를 내보내고 모든 모듈을 읽을 수 있음

2. **이름 없는 모듈(Unnamed Module)**:

   - 클래스패스의 클래스들이 속하는 기본 모듈
   - 자동 모듈과 이름 없는 모듈은 서로 읽을 수 있음

3. **명시적 모듈(Named Module)**:
   - module-info.java로 명시적으로 정의된 모듈
   - requires, exports, opens 등으로 의존성과 가시성 제어

### 7.5.2 모듈화 시대의 클래스 로더

모듈 시스템에서는 클래스 로더 구조가 변경되었다:

1. **부트스트랩 클래스 로더**:

   - java.base 모듈만 로드
   - 가장 핵심적인 클래스들만 담당

2. **플랫폼 클래스 로더(Platform Class Loader)**:

   - 기존 확장 클래스 로더를 대체
   - 모든 플랫폼 클래스들을 로드

3. **시스템 클래스 로더(System Class Loader)**:
   - 기존 애플리케이션 클래스 로더와 동일
   - 애플리케이션 클래스들을 로드

모듈 시스템의 장점:

- 강한 캡슐화로 내부 API 은닉
- 명시적 의존성으로 안정성 향상
- 런타임 성능 개선
- 보안 강화

## 7.6 마치며

클래스 로딩 메커니즘은 자바의 핵심 특징 중 하나로, 동적 언어로서의 유연성을 제공한다. 로딩, 링킹, 초기화의 각 단계는 자바 애플리케이션의 실행에 필수적이며, 클래스 로더의 계층 구조는 보안과 모듈성을 보장한다.

Java 9의 모듈 시스템은 기존 클래스 로딩 메커니즘을 보완하여 더 나은 캡슐화와 모듈성을 제공한다. 개발자는 이러한 메커니즘을 이해함으로써 더 효율적이고 안전한 자바 애플리케이션을 개발할 수 있다.

클래스 로딩은 단순해 보이지만 그 내부에는 복잡한 메커니즘이 숨어있으며, 이를 제대로 이해하는 것은 고급 자바 개발자가 되는 데 필수적이다.
