# 8 바이트코드 실행 엔진

## 8.1 들어가며

## 8.2 런타임 스택 프레임 구조

자바 가상 머신은 메서드를 가장 기본적인 실행 단위로 사용하며, 메서드 호출과 실행을 뒷받침하는 내부 데이터 구조로 스택 프레임을 이용한다.

스택 프레임은 가상 머신 런타임 데이터 영역에 있는 가상 머신 스택의 요소이기도 하다.

스택 프레임에는 메서드의 지역 변수 테이블, 피연산자 스택, 동적 링크, 반환 주소와 같은 정보가 담긴다.

### 8.2.1 지역 변수 테이블

지역 변수 테이블은 메서드 매개 변수와 메서드 안에서 정의된 지역 변수를 저장하는 공간이다.

자바 프로그램을 클래스 파일로 컴파일할 때 메서드에 할당해야 하는 지역 변수 테이블의 최대 용량은 메서드의 Code 속성 중 max_locals 항목에 기록된다.

지역 변수 테이블의 용량 기준은 가장 작은 단위인 변수 슬롯이다.
데이터 타입은 모두 32비트 이하 물리 메모리만 차지한다.

64비트 가상 머신에서는 변수 슬롯을 64비트로 구현하기도 한다.

참고로 지역 변수 테이블에서 참조 타입은 객체 인스턴스를 가리키는 참조를 뜻한다.

참조의 길이나 구조를 명시하지 않았따.

하지만 일반적으로 자바 가상 머신은 다음 두 가지 정보를 처리한다.

첫째, 참조가 가리키는 객의의 체자바 힙내에서의 시작 주소 또는 인덱스를 직간접적으로 알 수 있다.

둘째, 참조가 가리키는 객체의 타입 정보를 직간접적으로 알 수 있다.

이 두 조건을 충족하지 못하면 자바 언어 명세에 정의된 구문 규칙을 구현할 수 없다.

returnAddress 타입은 좀 특별한데, 바이트코드 명령어 jsr, jsr_w, ret에 다른 바이트 코드명령어ㅢ 주소를 알려 주는 용도로 쓰인다.
예전 가상머시은 예외 처리할때도 썼는데 지금은 모두 예외 테이블을 사용하도록 바뀌었다.

64비트 데이터 타입의 경우 자바 가상 머신은 연속된 두 개의 변수 슬롯을 고차 정렬 방식으로 연결해 핼당한다.

자바 언어에서 이용하는 64비트 데이터 타입은 long과 double 뿐이다.

long과 double 타입의 읽기와 쓰기는 32비트씩 나눠수행되어 원자적이지 않다라는 이야기가 있는데 사실 지금 주제인 지역변수 테이블은 스레드 스택별로 되므로 해당되지 않는다.

한편 자바 가상 머신은 지역 변수 테이블을 인덱스 방식으로 이용한다.

인덱스 값의 범위는 0부터 지역 변수 테이블이 담을 수 있는 변수 슬롯의 최대 개수까지다.

32비트 변수에 접근할 경우 N은 N번쨰 변수 슬롯을 뜻한다.
64비트 변수라면 N번쨰와 N+1번째 변수슬롯을 사용한다.

### 8.2.2 피연산자 스택

피연산자 스택은 후입선출 스택이다.

최적화에 따라 스레드 끼리 공유하는 변수가 있을 수 있다.

### 8.2.4 반환 주소

시작된 메서를를 드종료하는 방법은 두 가지뿐이다.
첫째, 실행 엔진이 화환 반바이트코드 명령어를 만나면 메서드를 종료한다.
이때 호출자에 반환값이 전달될 수 있는데, 반환값 유무와 반환값의 타입은 메서드 반환 명령어에 의해 결정된다.
이 방식은 메서드 종료를 정상적인 메서드 호출 완료라고 한다.

둘 쨰 메서드 실행 도중 예외가 발생하고 메서드 본문에서 예외 처리가 제대로 이루어지지 않으면 종료된다.

자바 가상 머신 내부에서 발생한 예인인지 이또는 코드에서 athrow 바이트 코드 명령어로 발생시킨 예외인지와 상관없이, 메서드의 예외 테이블에 적절한 예외 핸들러가 없다면 메서드가 종료된다.

이 방식의 메서드 종료를 갑작스러운 메서드 호출 완료라고 한다.

둘중 어떤 방식으로든 종료되었으면 메서드를 호출한 위치로 돌아가야한다.

메서드가 에러로 인해서 비정상 종료되면 예외 핸들러 테이블에 의해 반환 주소가 결정된다.

1. 호출자의 지역 변수 테이블과 피연산자 스택을 복원한다.
2. 반환값이 있는 경우 반환값을 호출자 스택 프레임의 피연산자 스택에 푸시한다.
3. 프로그램 카운터 값을 조정하여 메서드 호출 명령어의 바로 다음 명령어를 가리키게 한다.

### 8.2.5 기타 정보

JVM 명세는 그 외 추가로 포함시킬 길을 열어뒀다
.주로 디버깅이나 프로파일링 관련 정보를 담는데 활용된다.

개념 모델을 얘기할 떄 주로 동적 링크, 반환 주소, 추가 정보를 모두 스택 프레임 정보라는 하나의 범주로 묶는다.

## 8.3 메서드 호출

메서드 호출은 메서드 본문 코드를 실행하는 일과 다르다.

메서드 호출 단계에서 수행하는 유일한 일은 호출할 메서드의 버전을 선택한 것이다.

즉 메서드 본문은 아직 관심밖이다.

링킹 과정의 분리로 인해 자바는 메서드 호출 과정이 상대적으로 복잡하다.

때에 따라 클래스 로딩 시점에 또는 심지어 런타임에 대상 메서드의 직접 참조를 알아내야 한다.

### 8.3.1 해석

메서드 호출 대상은 모두 클래스 파일의 상수 풀에 심벌 참조로 기록되어 있다.

클래스 로딩의 해석 단계에서 그중 일부는 직접 참조로 변환하는데, 이때 직접 참조를 찾아낼 수 있는 전제는 다음과 같다.

어떤 메서드는 호출할 버전을 프로그램이 실행되기 전에 알아낼 수 있으모 런타임에는 다른 것으로 변경될 수 없다. 이런 경우를 정적해석이라고 한다.

이에 부합하는 메서드는 주로 정적 메서드와 private 메서드다.

정적 메서드는 특정 클래스에 고정되어있고, private 메서드는 인스턴스 바깥에서는 접근할 수 없다.

따라서 두 유형의 메서드 모두 상속 등을 통해 다른 버전을 만들 수 없으므로 클래스 로딩 단계에서 해석하기에 적합하다.

한편 메서드 호출 유형에 따라 사용되는 바이트코드 명령어가 다르다.

자바 가상 머신은 다음과 같이 총 다섯 가지 메서드 호출 바이트코드 명령어를 제공한다.

- invokestatic: 정적 메서드를 호출한다.
- invokespecial: 인스턴스 생성자인 <init>() 메서드private메서드, 부모 클래스의 메서드를 호출한다.
- invokevirtual: 가상 메서드를 호출한ㄷ .
- invokeinterface: 인터페이스 메서드를 호출한다. 인터페이스를 구현한 대상 객체는 런타임에 결정된다.
- invokedynamic: 호출 사이트 한정자가 참조하는 메서드는 메서드 실행 전 런타임에 동적으로 해석된다.

static과 special로 호출할 수 있는 메서드는 해석 단계에서 고유한 호출 버전을 특정할 수 있다.

한편 메서드 호출의 또 다른 형태로는 디스패치가 있는데 디스패치는 4가지가 있다.

- 정적 단일 디스패치
- 정적 다중 디스패치
- 동적 단일 디스패치
- 동적 다중 디스패치

### 8.3.2 디스패치

자바는 객체지향의 세 가지 기본 특징인 상속, 캡슐화, 다형성을 지원하는 객체 지향 프로그래밍이다.

호출 디스패치 과정은 자바 가상 머신에서 오버로등과 오버라이딩이 구현되는 방식처럼 다형성이라는 특성의 가장 기본에 해당하는 내용이다.

## 8.4 동적 타입 언어 지원

### 8.4.1 동적 타입 언어

### 8.4.2 자바와 동적 타이핑

### 8.4.3 java.lang.invoke 패키지

### 8.4.4 invokedynamic 명령어

### 8.4.5 실전: 제어 메서드 할당 규칙

## 8.5 스택 기반 바이트코드 해석 및 실행 엔진

### 8.5.1 해석 실행

### 8.5.2 스택 기반 명령어 집합과 레지스터 기반 명령어 집합

### 8.5.3 스택 기반의 해석 실행 과정

## 8.6 마치며
