# 3장 가비지 컬렉터와 메모리 할당 전략

가비지 컬렉션에서 해결해야하는 문제는 다음과 같다.

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

가비지 컬렉션을 이해해야 다양한 메모리 오버플로우와 누수 문제를 해결할 수 있다.

힙과 메서드 영역은 북확실한게 많다. 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다.

하나의 메서드에서도 어떤 분기를 실행하냐에 따라 다를 수 있기 때문에 런타임에만 알 수 있다는 특징이 있다.

## 3.2 대상이 죽었는가 ?

### 3.2.1 참조 카운팅 알고리즘

객체를 가리키는 참조 카운터를 추가한다.
카운터 값이 0이 되면 삭제한다.

JVM에서는 실제로 많이 쓰이지 않는다.

예를 들어 참조 카운팅은 순환 문제를 해결하기 어렵다.

### 3.2.2 도달 가능성

GC 루트라고 하는 루트 객체를 시작으로 해서 참조하는 객체를 탐색한다.
이때 만들어진 경로를 참조 체인이라고 하고, 어떤 객체와 GC의 참조 체인이 없다면 도달할 수 없다.
GC 루트로 사용할 수 있는 루트 객체는 정해져있다.

- 가상 머신 스택에서 참조하는 객체에서 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드 스택: JNI가 참조하는 객체
- 자바 가상 머신 내부에서 찾모: 기본 데이터 타입에 해당하는 객체
- 동기화 락으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등
  이상의 정해진 GC 루트들 외에도 가비지 컬렉터 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시로 추가될 수 있다.

이렇게 해서 전체 GC 루트 집합이 만들어진다.

참고로 세대 단위 컬렉션과 부분 컬렉션의 경우 자바 힙의 일부 영역부터 분석을 시작한다.
이 영역들이 서로 격리되거나 닫혀있지 않다는 점에 유의해야 한다.

### 3.2.3 다시 참조 이야기로

예를 들어 메모리가 여유롭다면 그냥 두고 가비지 컬렉션을 하고도 매우 부족하다면 그때 회수하는 객체를 표현하고 싶다면 어떻게 할까 ?

JDK 1.2부터는 참조 개념이 확장됐다.

1. 강한 참조: 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조가 남아 있는 객체는 절대 회수하지 않는다.
2. 부드러운 참조:유용하지만 필수는 아닌 객체다. 부드러운 참조만 남아있는 객체는 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 두 번째 회수 후에도 메모리가 부족하면 그떄 OOM을 던진다.
3. 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 그래서 넉넉하더라도 모두 회수된다.
4. 유령 참조: 가장 약하다 객체 수명에 아무런 영향을 주지 않으며 유일한 목적은 객체가 회수될 때 알림을 받기 위해서다.

(파이널 참조: 참조 강도는 약한 참조와 유령 참조 사이인데, finalize 메서드를 구현한 객체는 모두 파이널 참조 대상이 되고 별도 대기열에 등록된다. 그런 다음 해당 객체에 도달할 수 있는 든든 모참조가 사라지면 finalize() 메서드를 호출한다)

### 3.2.4 살았나 죽었나 ?

도달 가능성 분석 알고리즘이 도달 불가능으로 판단하더라도 반드시 죽어야하는것은 아니다.
그래서 유예 단계가 있는데 확실한 사망 선고를 내리려면 두번의 표시 과정을 거쳐야한다.

첫 번째 표시가 이뤄지면 이후 필터링을 하는데 필터링 조건은 finalize() 메서드를 실행해야 하는 객체인지이다.

finalize()가 필요 없거나 이미 호출한 경우 실행할 필요 없음으로 처리한다.

만약 finalize를 실행해야한다면 F-Queue 대기열에 추가한다. 참고로 실행만 하고 종료를 기다리지는 않는데 왜냐면 무한 루프에 빠지거나 무한 대기가 발생할 수 있기 때문이다.

현재는 사라졌다.

### 3.2.5 메서드 영역 회수하기

다 쓴 상수나 클래스는 회수된다.

클래스는 다소 까다로운데, 세 가지 조건을 만족해야한다.

1. 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
2. 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
3. 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 것도 없다.

### 3.3.1 세대 단위 컬렉션 이론

1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
2. 강한 세대가설 : 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

대부분 위 이론을 기반으로 세대를 나눈다.

이렇게 나누면 가비지 커렉터가 하나 또는 여러개를 선택해서 회수할 수 있는데 이를 마이너 GC, 메이저 GC, 전체 GC라는 식으로 부른다.

생존 특성에 따라 마크 스윕, 마크 카피- 마크 컴팩트 등 알고리즘을 사용한다.

한편 곰곰이 생각해보면 단순히 세대만 나눠서 해결되지는 않는다.
가비지 컬렉션을 하고 싶더라도 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다.
반대도 마찬가지이다.
근데 모두 탐색하는 것은 성능에 부하를 준다.
따라서 세번째 가설을 추가해야한다.

3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

상호 참조 관계의 두 객체는 삶과 죽음을 함께하는 경향이 있다.
그래서 두 가설을 통해 논리적으로 유추한 가설이다.

따라서 신세대에 기억 집합이라는 전역 데이터 구조를 하나 두고, 그 구조를 통해 구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 관리하면 된다.

그래서 마이너 GC가 수행되면 세대 간 참조를 포함하는 작은 메모리 블록 안의 객체만 GC 루트에 추가된다.
이렇게 되면 참조 관계 변화를 정확히 관리해야해서 연산은 늘지만 구세대 전체를 훑는 것보다는 싸다.

## 3.3.2 마크 스윕 알고리즘

마크 스윕의 단점은 다음과 같다.

1. 실행 효율이 일정하지 않다.
2. 메모리 파편화가 심하다.

## 3.3.3 마크 카피 알고리즘

회수할 객체가 많아질수록 효율이 떨어지는 문제를 극복하기 위해 세미 스페이스 복사라는 알고리즘을 제안했다.
가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 하나만 사용한다.
한쪽이 꽉차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청한한다.
단점은 가용 메모리를 절반으로 줄여 낭비가 심하다는 점이다.

IBM에서 객체들의 생존 기간이 짧다를 정량적으로 나타내보았는데 신세대 객체 중 98%가 삭제된다.
따라서 1:1로 나눌 필요가 없다는 결론이 있다.

아펠 스타일 컬렉션 방식을 구체적으로 보면 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 둔다.
그리고 메모리를 할당할 때 생존자 공간 중 하나와 에덴만 사용한다.

가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들이 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 바로 비운다.

핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1이다.

만약 생존자 공간보다 더 크게 살아남았을 경우 메모리 할당 보증이라는 메커니즘으로 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역을 활용해 메모리 할당(대부분 구 세대로)을 보증하는 것이다. (핸들 승격)

## 3.3.4 마크 컴팩트 알고리즘

위 단점은 객체 생존율이 높을 경우 복사할 게 많아져서 효율이 나빠진다.

그리고 할당 보증 공간을 따로둬서 대다수 객체가 살아남는 극단적 상황을 대처해야한다.
그래서 구 세대에서는 적합하지 않다.

그래서 구 세대를 위한 마크 컴팩트 알고리즘을 제안했다.

마크 컴팩트는 생존한 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.

### 3.5.7 G1 컬렉터 (가비지 우선 컬렉터)

G1은 서버용 애플리케이션이다.

G1의 목표는 정지 시간 예측 모델을 만들어서 목표 시간이 M 밀리초 이상으로 넘지 않도록 통제하기 위함이다.

이 목표를 이루기 위해서는 생각의 전환이 필요했다.

G1의 등장 전까지 CMS를 포함한 모든 컬렉터의 회수 범위는 신세대 전체, 구세대 전체, 힙 전체였는데

G1은 어느 영역에 쓰레기가 가장 많은지를 기준으로 한다.

G1은 신세대가 아니라 어디서든 메모리를 회수할 수 있따고 하는데 이를 Colection set이라한다.

연속된 자바 힙을 여러 독립 리전으로 나누고 각 리전은 다양한 공간이 될 수 있다(에덴, 구세대 등)

G1은 여전히 세대 이론을 기반으로 하지만 리전별 역할을 동적으로 바꿀 수 있고 같은 역할의 리전을 연이어 배치될 필요도 없다.

이것이 가능한 이유는 리전을 최소 회소 단위로 사용하기 때문이다. 그래서 이를 기반으로 자바 힙 전체를 회수하는 상황을 피할 수 있다.

G1이 힙 메모리를 리전 단위로 나눈다는 것은 이해하기 어렵지 않은데 세부 기술이 어렵다.

해결해야하는 문제가 다음과 같기 때문이다.

1. 독립 리전으로 나눈다면 리전 간 참조 문제를 해결해야한다. 근데 기억 집합을 G1에 응용하기가 어렵다.
   기억 집합은 기본적으로 해시 테이블인데 양방향 테이블 구조가 되다보니 기본적인 카드 테이블보다 복잡해서 G1 컬렉션은 보통 클래식보다 메모리를 많이 쓴다. 실험 결과 G1은 자신이 관리하는 자바 힙의 최소 10~20% 정도를 추가로 확인하고 이 크기는 기술의 성숙과 함께 빠르게 줄어들고 있다.
2. 동시 표시 단계 동안 GC 스레드와 사용자 스레드가 서로 간섭하지 않아야한다. 예를 들어 사용자 스레드가 객체 참조 관계를 바꿔도 파괴되지 않아야한다. G1은 스냅숏 알고리즘을 사용했다. 회수 대상에서 제외될 수 있는데 그로 인해서 전체 GC가 유발될 수 있다.그래서 메모리 회수속도가 할당 속도를 따라가지 못하면 긴 STW를 겪어야한다.
3. 신뢰할 수 있는 정지 시간 예측 모델을 구현해야 한다.

G1의 정지 시간 예측 모델의 핵심은 감소 평균이다.

G1는 리전별 회수 시간, 리전별 기억 집합에서 더럽혀짖ㄴ 카드 개수 등 측정할 수 있는 각 단계에 소요 시간을 측정하고, 평균, 표준 편차, 신뢰도 같은 통계를 분석한다. 그래서 감소 평균은 일반 평균과 비교해 새로운 데이터에 더 민감하다.

감소 평균은 최근의 평균적인 상태를 더 정확하게 알려준다.

따라서 리전의 통계적 상태가 더 최근일수록 회수해서 얻는 가치를 더 높게 쳐준다.

1. 최초 표시: GC 루트가 직접 참조하는 객체들을 표시하고 TAMS 포인터의 값을 수정한다. 즉 시작 단계 스냅숏을 생성한다. 이 단계에서 일시 정지하지만 매우 짧아서 G1이 추가로 일으키는 정지는 없다.

2. 동시 표시: GC루트로부터 시작하여 객체들의 도달 가능성을 분석하고 전체 힙의 객체 그래프를 재귀적으로 스캔한다. 이 단계는 사용자 스레드와 동시 수행된다. 이후 시작 스냅숏과 비교해서 동시 실행 도중 참조가 변경된 객체들을 다시 재스캔해야한다.

3. 재표시: 또 한 번 사용자 스레드를 멈춰야한다. 시작 단계 스냅숏 이후 변경된 소수의 객체만 처리하면 되므로 매우 빠르게 끝난다.
4. 복사 및 청소: 통계 데이터를 기반으로 리전들을 회수 가치와 비용에 따라 줄 세운 다음, 목표한일시 정지 시간에 부합하도록 계획을 세운다. 회수할 리전들을 적절히 선별하고 빈 리전에 이주시킨다. 이 단계는 생존한 객체를 이동시켜야하므로 사용자 스레드가 잠시 멈춰야한다.

이 단계는 생존한 객체를 이동해야하므로 사용자 스레드가 잠시 멈춘다.

G1은 동시 표시 단계를 제외하고 사용자 스레드를 멈춘다.
G1은 지연 시간을 제어하는 동시에 처리량을 최대한 높이는 것이다.

그래서 정지 시간의 기댓값을 알 수 있따는 것이 G1의 큰 장점이다.

### 3.6.2.ZGC - 저지연 가비지 컬렉터

ZGC는 세대 구분 없이 리전 기반 메모리 레이아웃을 사용하여, 낮은 지연 시간을 최우선 목표로 하며, 동시 마크-컴팩트 알고리즘을 구현하기 위해, 읽기 장벽, 컬러 포인터, 메모리 다중 매핑 기술을 활용하는 가비지 컬렉터이다.

ZGC의 핵심 목표:

- 힙 크기(8MB~16TB)에 관계없이 10ms 이하의 일시 정지 시간 보장
- G1보다 훨씬 낮고 예측 가능한 지연 시간 제공
- 애플리케이션 처리량 저하를 15% 이내로 제한

주요 기술적 특징:

컬러 포인터(Colored Pointer) 기술

- 64비트 플랫폼에서 객체 참조 포인터의 상위 비트들을 메타데이터 저장에 활용
- 마킹된(Marked), 재배치된(Relocated), 재배치 준비(Relocation Set) 등의 상태 정보를 포인터에 직접 저장
- 별도의 메타데이터 구조 없이도 객체 상태를 빠르게 확인 가능

로드 배리어(Load Barrier)

- 객체 참조를 읽을 때마다 실행되는 코드
- 컬러 포인터의 메타데이터를 확인하여 객체가 재배치되었는지 검사
- 필요시 자동으로 참조를 새 주소로 업데이트("자가 치유")

메모리 다중 매핑(Memory Multi-Mapping)

- 동일한 물리 메모리 영역을 여러 가상 주소에 매핑
- Marked/Relocated/Relocation Set 각각의 뷰를 제공
- 메모리 복사 없이도 다른 상태의 메모리 영역처럼 접근 가능

리전 기반 메모리 관리

- 힙을 동적 크기의 리전으로 분할 (2MB, 32MB, N×32MB)
- 소형/중형/대형 객체에 따라 적절한 크기의 리전 할당
- 세대 구분 없이 모든 객체를 동일하게 처리

ZGC의 동작 과정:
동시 표시(Concurrent Marking)

- 사용자 스레드와 동시에 실행
- 컬러 포인터를 이용해 살아있는 객체들을 표시
- STW 없이 전체 힙 스캔

동시 재배치 준비(Concurrent Relocation Set Selection)

- 재배치할 리전들을 선별
- 빈 공간이 많은 리전을 우선적으로 선택

동시 재배치(Concurrent Relocation)

- 선택된 리전의 객체들을 새 위치로 이동
- 로드 배리어가 참조 업데이트를 담당
- 사용자 스레드 실행 중에도 진행

동시 재매핑(Concurrent Remapping)

- 이전 GC 사이클에서 재배치된 객체들의 참조를 정리
- 다음 표시 단계와 병행하여 실행

ZGC의 장점:

- 예측 가능한 낮은 지연시간: 힙 크기와 무관하게 10ms 이하 보장
- 높은 동시성: 거의 모든 작업이 애플리케이션과 동시 실행
- 대용량 힙 지원: 최대 16TB까지 확장 가능
- 메모리 효율성: 압축을 통한 메모리 파편화 해결

ZGC의 한계:

- CPU 오버헤드: 로드 배리어로 인한 처리량 15% 내외 감소
- 메모리 오버헤드: 컬러 포인터와 다중 매핑으로 인한 추가 메모리 사용
- 플랫폼 제한: 64비트 플랫폼에서만 동작 (컬러 포인터 때문)
- 세대별 수집 미지원: 모든 객체를 동일하게 처리 (JDK 21부터 Generational ZGC 도입)
