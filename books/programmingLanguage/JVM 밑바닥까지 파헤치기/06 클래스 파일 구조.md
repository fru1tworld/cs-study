# 6 클래스 파일 구조

## 6.2 플랫폼 독립을 향한 초석

자바, 코틀린, 스칼라 그 외 프로그램 언어는 모두 해당 언어로 컴파일이 되고 그 컴파일된건 바이트코드의 형태가 된다.

바이트코드는 JVM 위에서 동작한다.

## 6.3 클래스 파일의 구조

클래스 파일은 본질적으로 테이블이다.

같은 타입의 데이터 여러 개를 표현할 때 그 개수가 정해져 있지 않다면 개수를 알려 주는 타입이 바로 등장한다.

클래스 파일의 바이트 순서는 빅 엔디언이다.

### 6.3.1 매직 넘버와 클래스 파일의 버전

모든 클래스 파일의 첫 4바이트는 매직 넘버로 시작한다.
매직 넘버는 가상 머신이 허용하는 클래스 파일인지 빠르게 확인하는 용도이다.
그 외에도 다양한 파일을 식별하기 위해 매직 넘버를 확인한다.

즐겨 찾는 카페의 인기 바리스타가 눈에 띄어 `0xCAFEBABE`라는 이름으로 선정했다.

매직 넘버 다음 4바이트는 클래스 파일의 버전이고다 자바 버전 번호는 45부터 시작한다.
이후 JDK 릴리스의 메이저 버전은 1씩 증가하며, 상위 버전은 하위 버전을 인식할 수 있다.
반대는 불가능하다.

### 6.3.2 상수 풀

상수 풀은 클래스 파일의 자원 창고이다.

클래스 파일 구조에서 다른 클래스와 가장 많이 연관된 부분이다.

한편 상수풀에서 0번째는 비워뒀는데, 상수 풀 항목을 참조하지 않음을 표현하기 위해서이다.

상수풀만 이렇고 그 외 인터페이스 컬렉션, 필드 테이블 컬렉션, 메서드 테이블 컬렉션은 0부터 센다.

상수 풀에 담기는 상수 유형은 리터럴과 심벌참조 두 가지다.

리터럴은 상수는 final로 선언된 문자열과 리터럴이고 심벌 참조는 다음과 같다.

- 모듈에서 익스포트하거나 임포트하는 패키지
- 클래스와 인터페이스의 완전한 이름
- 필드 이름과 서술자
- 메서드 이름과 서술자
- 메서드 핸들과 메서드 타입
- 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수

C/C++와 달리 자바 컴파일은 링크 단계가 없다.

자바 링크는 클래스 파일을 로드할 때 동적으로 이뤄진다.

참고로 자바 프로그램에서 메서드와 필드 이름이 65535를 넘으면 컴파일 되지 않는다.

### 6.3.3 접근 플래그

public, final, super, interface, abstract, synthetic, annotation, enum, module과 같이 의미가 있다.
2바이트이므로 비트는 최대 16개 사용할 수 있다.

### 6.3.4 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

클래스 인덱스(this_class), 부모 클래스 인덱스(super_class), 인터페이스 인덱스 컬렉션이 나온다.

인터페이스 인덱스 컬렉션은 현재 구현한 인터페이의의 수를 나타내고 아무것도 구현하지 않았으면 0이다.

### 6.3.5 필드 테이블

필드 테이블은 인터페이스나 클래스 안에 선언된 변수들을 설명하는데 쓰인다.

자바 언어에서 필드란 클래스 변수와 인스턴스 변수를 뜻한다.

메서드 안에 선언된 지역 변수는 필드가 아니다.

범위 제한, 불변 여부, 인스턴스 변수와 클래스 변수의 구분(static), 휘발성(volatitle, CPU가 아닌 메모리를 직접 읽거나 쓰게함), 직렬화 시 포함 여부, 데이터 타입, 필드 이름 등이 있다.

### 6.3.6 메서드 테이블

메서드 테이블은 access_flags, name_index, desciptor_index, attributes_count, attributes[attributes_count]로 되어있고
필드테이블과 완전히 같다.
메시지 본문은 자바 컴파일러에 의해 바이트코드 명령어로 변환된 후, 메서드 속성 테이블 컬렉션의 Code 속성에 따로 저장된다.

속성 테블블은 브클래스 파일 형식에서 확장성이 가장 큰 데이터 항목이다.

### 6.3.7 속성 테이블

속성 테이블은 상당히 유연하며 현대에는 30개의 속성이 존재한다.

#### Code 속성

필수적으로 포함해야되는 속성은 다음과 같다.
Code 속성: 자바 프로그램의 메서드 본문 코드는 자바 컴파일러에 의해 최종적으로 바이트 코드 명령어로 변환된 후 Code 속성에 저장된다.
Code 속성은 메서드 테이블의 속성 컬렉션에 자리하지만, 모든 메서드 테이블에 포함되는 것은 아니다.
예를 들어 인터페이스나 추상 클래스의 추상 메서드에는 Code 속성이 없다.

예외 처리를 하는 방법

1. try에서 Exception 또는 하위 예외가 발생하면 catch 블록으로 이동해 처리한다.
2. try블록에서 Exception이 아니고 하위 예외도 아니면 finally 블록으로 이동해 처리한다.
3. catch 블록에서 예외가 발생하면 finally 블록으로 이동해 처리한다.

#### Exceptions 속성

Code 속성에 있는 예외 테이블과 다르다. Exceptions 속성은 메서드에서 throw될 수 있는 검사 예외, 즉 메서드 설명에서 throws 키워드 뒤에 나오는 예외들을 나열하는 기능을 한다.

#### LineNumberTable

자바 소스 코드의 줄 번호와 바이트코드의 줄번호 사이의 대응 관계를 설명한다 꼭 필요한 속성은 아니지만 클래스 파일에 기본적으로 생성된다.

생성하지 않으면 오류를 일으킨 코드의 줄 번호가 스택 추적 정보에 나타나지 않는다.

## 6.4 바이트코드 명령어 소개

자바 가상 머신의 명령어는 특정 작업을 뜻하는 바이트 길이의 숫자인 연산 코드와 해당 작업에 필요한 0개 이상의 피연산자로 이루어진다.
대부분이 피연산자 없이 연산 코드 하나로 구성되며 피연산자 스택에 저장된다.

그런데 바이트코드 명령 집합은 고유학 특징과 장단점이 있는데, 연산 코드가 256개밖에 없다.
또한 피연산자의 길이 정렬을 허용하지 않아 1바이트가 넘는 데이터를 처리하면 특정 구조로 재구성해야한다. 예를 들어 부호 없는 16비트 정수는 부호 없는 바이트 2개를 이용하여 다음과 같은 형태로 저장한다
(byte1<<1) | byte2
이러한 작업 때문에 바이트코드를 해석하고 실행하는 속도가 느려진다.

장점 역시 명확한데, 피연산자 길이 정렬을 포기하면 수 많은 패딩과 공백을 없앨 수 있다.
그리고 바이트 하나로 표현되기 때문에 컴파일된 결과물이 짧고 간결하다.

```
do{
  PC 레지스터의 값을 자동으로 계사한다.
  바이트코드 스트림에서 PC 레지스터가 가리키는 위치의 연산 코드를 가져온다.
  (피연산자가 필요한 바이트코드라면) 바이트코드 스트림에서 피연산자를 가져온다.
  연산 코드가 정의하는 동직을 수행한다.
} while(바이트코드 스트림 길이 > 0);
```

### 6.4.1 바이트코드와 데이터 타입들

### 6.4.2 로드와 스토어 명령어

### 6.4.3 산술 명령어

### 6.4.4 형변환 명령어

### 6.4.5 객체 생성과 접근 명령어

### 6.4.6 피연산자 스택 관리 명령어

### 6.4.7 제어 전이 명령어

### 6.4.8 메서드 호출과 반환 명령어

### 6.4.9 예외 처리 명령어

### 6.4.10 동기화 명령어

## 6.5 설계는 공개, 구현은 비공개

## 6.6 클래스 파일 구조의 진화

## 6.7 마치며
