# 10 프런트엔드 컴파일과 최적화

## 10.1 들어가며

자바 기술에서 컴파일 타임은 컴파일러의 프론트엔드가 .java 파일과 .class 변환하는 과정도 컴파일이고, 자바 가상 머신에서 JIT 컴파일러가 바이트코드를 기계어로 변환하는 과정도 컴파일이다.

프런트 컴파일은 JDK의 javac, 이클립스의 증분 컴파일러(ECJ)에 해당하고
JIT 컴파일러: 핫스팟 가상머신의 C1,C2 그랄 컴파일러 등에 해당한다.
AOT 컴파일러: 그랄 컴파일러, jaotc, GNU 컴파일러 등

개발자가 일반적으로 컴파일러라고 하면 프론트엔트 컴파일을 말한다.

일반적으로 프론트엔드 컴파일은 최적화를 거의하지 않는다.

javac로 생성하지 않는 클래스파일도 최적화 효과를 공평하게 누리도록 하기 위해서다

런타임에 실행효율을 높이는 최적화를 JIT 컴파일러가 하고 개발자의 코딩 효율을 높이는 최적화를 프런트엔드 컴파일러가 수행한다고 보면 된다.

## 10.2 javac 컴파일러

핫스팟 가상 머신과 달리 javac 컴파일러는 순수하게 자바로 작성됐다.

### 10.2.1 javac 소스 코드와 디버깅

0: 플러그인 애너테이션 처리기들 초기화
1: 구문 분석 및 심벌 테이블 채우기

- 1.1: 어휘 및 구문 분석: 소스 코드를 토큰화하여 추상 구문 트리 구성
- 1.2: 심벌 테이블 채우기: 심벌 주소와 심벌 정보 생성

2. 플러그인 에너테이션 처리기들로 애너테이션 처리
3. 의미 분석 및 바이트코드 생성. 예를 들면 다음과 같다

- 3.1: 특성 검사: 문법의 정적 정보 확이
- 3.2: 데이터 흐름 및 제어 흐름 분석: 프로그램의 동적 실행 과정 확인
- 3.3: 편의 문법 제거: 코드를 단순화하는 편의 문법을 원래 형식으로 복원
- 3.4: 바이트드드 코드생성: 지금까지 생성된 정보를 바이트코드로 변환

### 10.2.2 구문 분석과 심벌 테이블 채우기

#### 1 어휘 및 구문 분석

컴파일은 어휘 분석과 구문 분석을 수행한다.
토큰을 분류해서 AST를 만든다.

#### 2 심벌 테이블 채우기

어휘와 구문 분석 다음은 심벌 테이블 채우기로, 그림 10-5의 enterTrees() 메서드가 담당한다.
심벌 테이블은 심벌 주소와 심벌 정보의 집합으로 구성된 데이터 구조다. 키-값 쌍을 담은 해시 테이블을 떠올리면 쉽게 이해도리 것이다.

### 10.2.3 에너테이션 처리

자바 언어는 애너테이션을 지원하기 시작했다.

애너테이션 처리를 위해 플러그인이 추상 구문 트리를 수정한다.

그리고 이 과정을 플러그인의 애너테이션 처리기가 구문 트리를 더는 수정하지 않을 떄까지 반복하고 한 번의 반복을 round라 한다.

### 10.2.4 의미 분석과 바이트코드 생성

#### 1. 특성 검사

일반적으로 묵시적 형변환은 C에서 허용될 수 있는데 자바에서는 불가능하다.
특성검사에서는 변수와 할당될 데이터의 타입이 일치하는지 등을 확인한다.

특성 검사 과정에서 상수 접기라는 최적화도 수행한다.
예를 들어 1+2는 3으로 최적화된다.

#### 2. 데이터 흐름 분석과 제어 흐름 분석

데이터와 제어 흐름 분석은 프로그램이 맥락상 논리적으로 올바른지 확인하는 추가 검사다.
예를 들어 지역변수가 사용되기전 값을 할당받았는지 실행 경로에서 값을 반환하는지를 확인한다.

#### 3. 편의 문법 제거

편의 문법은 컴파일 결과와 언어 기능에 실질적인 영향은 없지만 개발자가 언어를 더 쉽게 사용할 수 있게끔 프로그래밍 언어에 추가된 구문을 뜻한다.
이 프로그래밍 용어는 영국의 컴퓨터 과학자 피터 랜딘이 쓰기 시작했다.
자바의 대표적 편의 문법은 제네릭, 가변 길이 매개변수, 오토 박싱/언박싱 등이다.
이러한 구문은 JVM의 런타임에 직접 지원하지 않는다. 그래서 컴파일 과정 중 편의 문법을 가상 머신의 런타임에서 직접 지원하지 않는다.

#### 4. 바이트코드 생성

바이트코드 생성은 javac 컴파일의 마지막 단계이다.
javac.jvm.Gen 클래스에서 담당한다.
예를 들어 인스턴스 생성자 <init>()와 클래스 생성자<client>()가 이 단계에서 구문 트리에 추가된다.

## 10.3 자바 편의 문법의 재미난 점

### 10.3.1 제네릭

제네릭의 본질은 매개 변수화된 타입 또는 매개 변수화된 다형성이라 할 수 있다.
자바가 선택한 제네릭 구현 방식은 타입 소거 제네릭이라고 하며, C#의 방식을 구체화된 제네릭이라고 한다.
컴파일 과정에서 자바는 타입 정보가 사라지진다.
자바는 제네릭 정보가 소스 코드에만 남아있다.

컴파일된 바이트코드에서는 타입 정보가 원래의 타입으로 대체되고 적절한 형 변환 코드가 해당 위치에 삽입된다.
이러한 차이로부터 타입 소거라는 이름을 알 수 있다.

타입 소거는 여러 문제가 있어서 발할라 프로젝트가 출범했다.
현재 JDK21까지도 진행 중이다.

### 10.3.2 오토박싱, 오토언박싱, 개선된 for 문

순전히 기술적인 관점에서 말하면 오토박싱/언박싱, 개선된 for문은 모두 편의 문법에 해당한다.

### 10.3.3 조건부 컴파일

if문으로 도달하지 못하면 컴파일되지 않는다.
