# 18 함수형 관점으로 생각하기

## 함수형 프로그래밍이란?

함수형 프로그래밍은 **함수를 일급 시민으로 취급**하고, **부작용이 없는** 프로그래밍 패러다임이다.

## 함수형 프로그래밍의 핵심 개념

### 1. 부작용 없음 (No Side Effects)

함수가 다음 조건을 만족할 때 부작용이 없다고 한다:

- 함수 외부의 어떤 것도 변경하지 않는다
- 예외를 발생시키지 않는다
- I/O를 수행하지 않는다

```java
// 부작용이 있는 함수
public class SideEffectExample {
    private int count = 0;  // 가변 상태

    public int increment() {
        return ++count;  // 외부 상태 변경
    }
}

// 부작용이 없는 함수
public class PureFunction {
    public int add(int a, int b) {
        return a + b;  // 오직 입력만 사용, 상태 변경 없음
    }
}
```

### 2. 참조 투명성 (Referential Transparency)

동일한 입력에 대해 항상 동일한 출력을 반환하는 함수의 속성

```java
// 참조 투명한 함수
public int multiply(int a, int b) {
    return a * b;
}

// multiply(2, 3)은 항상 6을 반환
// 표현식을 그 결과값으로 대체해도 프로그램 의미가 변하지 않음

// 참조 투명하지 않은 함수
public int random() {
    return new Random().nextInt();  // 호출마다 다른 값
}
```

### 3. 불변성 (Immutability)

데이터 구조가 생성된 이후 변경되지 않는 속성

```java
// 가변 객체
List<String> mutableList = new ArrayList<>();
mutableList.add("A");  // 리스트 변경

// 불변 객체
List<String> immutableList = List.of("A", "B", "C");
// immutableList.add("D");  // UnsupportedOperationException
```

## 함수형 자바의 실천

### 1. 지역 변수는 final이거나 사실상 final이어야 함

```java
// 함수형 스타일
public static List<String> filterNames(List<String> names) {
    return names.stream()
        .filter(name -> name.startsWith("A"))  // name은 사실상 final
        .collect(Collectors.toList());
}

// 안티 패턴
int count = 0;  // 가변 지역 변수
names.forEach(name -> {
    // count++;  // 컴파일 오류! effectively final이 아님
});
```

### 2. 모든 필드는 final이어야 함

```java
// 함수형 스타일의 불변 클래스
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Point moveRight(int distance) {
        return new Point(x + distance, y);  // 새 객체 반환
    }
}
```

### 3. 모든 예외는 확인된 예외여야 함

함수형 스타일에서는 예외를 사용하지 않고 Optional을 활용

```java
// 명령형 스타일 - 예외 사용
public int divide(int a, int b) {
    if (b == 0) throw new ArithmeticException("Division by zero");
    return a / b;
}

// 함수형 스타일 - Optional 사용
public Optional<Integer> safeDivide(int a, int b) {
    return b == 0 ? Optional.empty() : Optional.of(a / b);
}
```

## 재귀와 반복

### 반복 방식 (명령형)

```java
public static int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

### 재귀 방식 (함수형)

```java
public static long factorial(long n) {
    return n == 1 ? 1 : n * factorial(n - 1);
}
```

### 꼬리 재귀 최적화

Java는 꼬리 재귀 최적화를 지원하지 않지만, 개념적으로는 이해해야 함

```java
// 일반 재귀 (스택 오버플로 위험)
public static long factorial(long n) {
    return n == 1 ? 1 : n * factorial(n - 1);
}

// 꼬리 재귀 형태 (Java는 최적화 안 됨)
public static long factorialTail(long n, long acc) {
    return n == 1 ? acc : factorialTail(n - 1, n * acc);
}

// Stream을 이용한 대안
public static long factorialStream(long n) {
    return LongStream.rangeClosed(1, n)
        .reduce(1, (a, b) -> a * b);
}
```

## 영속 자료구조 (Persistent Data Structures)

### 파괴적 갱신 vs 함수형 갱신

```java
// 파괴적 갱신 (명령형)
class TrainJourney {
    int price;
    TrainJourney onward;

    // 리스트 연결 - 원본 수정
    static TrainJourney link(TrainJourney a, TrainJourney b) {
        if (a == null) return b;
        TrainJourney t = a;
        while (t.onward != null) {
            t = t.onward;
        }
        t.onward = b;
        return a;  // 원본 a가 변경됨
    }
}

// 함수형 갱신 (불변)
static TrainJourney append(TrainJourney a, TrainJourney b) {
    return a == null ? b
        : new TrainJourney(a.price, append(a.onward, b));
}
```

### 트리 구조의 함수형 갱신

```java
class Tree {
    private String key;
    private int val;
    private Tree left, right;

    // 함수형 업데이트 - 경로상의 노드만 새로 생성
    public static Tree update(String k, int newVal, Tree t) {
        if (t == null)
            return new Tree(k, newVal, null, null);
        else if (k.equals(t.key))
            return new Tree(k, newVal, t.left, t.right);
        else if (k.compareTo(t.key) < 0)
            return new Tree(t.key, t.val, update(k, newVal, t.left), t.right);
        else
            return new Tree(t.key, t.val, t.left, update(k, newVal, t.right));
    }
}
```

## 함수형 프로그래밍의 장점

### 1. 테스트하기 쉬움

```java
// 순수 함수는 테스트가 간단
@Test
public void testAdd() {
    assertEquals(5, add(2, 3));
    assertEquals(5, add(2, 3));  // 항상 같은 결과
}
```

### 2. 병렬 처리가 쉬움

```java
// 부작용이 없으므로 안전한 병렬 처리
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.parallelStream()
    .mapToInt(i -> i * i)
    .sum();
```

### 3. 모듈화가 좋음

```java
// 작은 함수들을 조합
List<String> result = names.stream()
    .filter(this::isValid)        // 유효성 검사
    .map(this::normalize)          // 정규화
    .map(String::toUpperCase)      // 대문자 변환
    .collect(Collectors.toList());
```

## 함수형 기법의 실전 활용

### 1. Stream을 활용한 데이터 처리

```java
// 명령형
List<String> result = new ArrayList<>();
for (Transaction t : transactions) {
    if (t.getType() == Transaction.Type.GROCERY) {
        result.add(t.getId());
    }
}
Collections.sort(result);

// 함수형
List<String> result = transactions.stream()
    .filter(t -> t.getType() == Transaction.Type.GROCERY)
    .map(Transaction::getId)
    .sorted()
    .collect(Collectors.toList());
```

### 2. Optional을 활용한 null 처리

```java
// 명령형
public String getCarInsuranceName(Person person) {
    if (person != null) {
        Car car = person.getCar();
        if (car != null) {
            Insurance insurance = car.getInsurance();
            if (insurance != null) {
                return insurance.getName();
            }
        }
    }
    return "Unknown";
}

// 함수형
public String getCarInsuranceName(Optional<Person> person) {
    return person.flatMap(Person::getCar)
                 .flatMap(Car::getInsurance)
                 .map(Insurance::getName)
                 .orElse("Unknown");
}
```

### 3. 고차 함수 활용

```java
// 함수를 반환하는 함수
public Function<Integer, Integer> multiplyBy(int factor) {
    return x -> x * factor;
}

Function<Integer, Integer> triple = multiplyBy(3);
Function<Integer, Integer> double = multiplyBy(2);

int result = triple.apply(10);  // 30
```

## 함수형 vs 명령형 비교

### 반복 처리

```java
// 명령형
List<Integer> doubled = new ArrayList<>();
for (Integer i : numbers) {
    doubled.add(i * 2);
}

// 함수형
List<Integer> doubled = numbers.stream()
    .map(i -> i * 2)
    .collect(Collectors.toList());
```

### 조건부 처리

```java
// 명령형
Integer result = null;
for (Integer i : numbers) {
    if (i > 10) {
        result = i;
        break;
    }
}

// 함수형
Optional<Integer> result = numbers.stream()
    .filter(i -> i > 10)
    .findFirst();
```

## 함수형 프로그래밍의 한계

### Java에서의 제약

1. **꼬리 재귀 최적화 미지원**: 깊은 재귀는 스택 오버플로 위험
2. **완전한 불변성 보장 어려움**: 언어 차원의 강제 없음
3. **성능 오버헤드**: 객체 생성 비용
4. **학습 곡선**: 명령형에 익숙한 개발자에게는 어려움

### 실용적인 접근

```java
// 완전한 함수형이 아니라 "함수형 스타일"을 추구
public class FunctionalStyleExample {
    // 불변 필드
    private final List<String> names;

    public FunctionalStyleExample(List<String> names) {
        // 방어적 복사
        this.names = new ArrayList<>(names);
    }

    // 순수 함수 스타일의 메서드
    public List<String> getFilteredNames(Predicate<String> predicate) {
        return names.stream()
            .filter(predicate)
            .collect(Collectors.toList());
    }
}
```

## 결론

함수형 프로그래밍은 **부작용 없음**, **참조 투명성**, **불변성**을 핵심으로 한다. Java 8 이후의 Stream API와 람다를 활용하면 함수형 스타일의 코드를 작성할 수 있지만, Java는 완전한 함수형 언어가 아니므로 실용적인 균형을 찾는 것이 중요하다.
