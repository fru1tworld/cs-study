# 17 리액티브 프로그래밍

## 리액티브 매니페스토

### 리액티브 시스템의 네 가지 특성

1. **반응성(Responsive)**: 일정하고 예상 가능한 반응 시간 제공
2. **회복성(Resilient)**: 장애가 발생해도 시스템은 반응해야 함
3. **탄력성(Elastic)**: 다양한 작업 부하에 자동으로 대응
4. **메시지 주도(Message Driven)**: 비동기 메시지를 통한 컴포넌트 간 통신

### 리액티브 프로그래밍이란?

- 데이터 흐름과 변경의 전파에 중점을 둔 프로그래밍 패러다임
- 비동기 데이터 스트림을 다루는 프로그래밍
- 선언적 방식으로 이벤트에 반응

## 리액티브 스트림과 플로우 API

### 리액티브 스트림 표준 (Reactive Streams Specification)

- **Publisher**: 데이터 생산자
- **Subscriber**: 데이터 소비자
- **Subscription**: Publisher와 Subscriber 사이의 제어 흐름
- **Processor**: Publisher이면서 Subscriber

### Flow API (Java 9)

```java
public final class Flow {
    @FunctionalInterface
    public static interface Publisher<T> {
        void subscribe(Subscriber<? super T> subscriber);
    }

    public static interface Subscriber<T> {
        void onSubscribe(Subscription subscription);
        void onNext(T item);
        void onError(Throwable throwable);
        void onComplete();
    }

    public static interface Subscription {
        void request(long n);
        void cancel();
    }

    public static interface Processor<T,R> extends Subscriber<T>, Publisher<R> {
    }
}
```

## Publisher 구현

### 간단한 Publisher 구현

```java
import java.util.concurrent.Flow.*;

public class SimplePublisher<T> implements Publisher<T> {
    private final List<T> items;

    public SimplePublisher(List<T> items) {
        this.items = new ArrayList<>(items);
    }

    @Override
    public void subscribe(Subscriber<? super T> subscriber) {
        subscriber.onSubscribe(new SimpleSubscription<>(subscriber, items));
    }

    private static class SimpleSubscription<T> implements Subscription {
        private final Subscriber<? super T> subscriber;
        private final List<T> items;
        private int currentIndex = 0;
        private boolean canceled = false;

        SimpleSubscription(Subscriber<? super T> subscriber, List<T> items) {
            this.subscriber = subscriber;
            this.items = items;
        }

        @Override
        public void request(long n) {
            if (canceled) return;

            for (long i = 0; i < n && currentIndex < items.size(); i++, currentIndex++) {
                subscriber.onNext(items.get(currentIndex));
            }

            if (currentIndex >= items.size()) {
                subscriber.onComplete();
            }
        }

        @Override
        public void cancel() {
            canceled = true;
        }
    }
}
```

## Subscriber 구현

### 간단한 Subscriber 구현

```java
import java.util.concurrent.Flow.*;

public class SimpleSubscriber<T> implements Subscriber<T> {
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);  // 첫 번째 아이템 요청
    }

    @Override
    public void onNext(T item) {
        System.out.println("Received: " + item);
        subscription.request(1);  // 다음 아이템 요청
    }

    @Override
    public void onError(Throwable throwable) {
        System.err.println("Error: " + throwable.getMessage());
    }

    @Override
    public void onComplete() {
        System.out.println("Completed!");
    }
}

// 사용
Publisher<Integer> publisher = new SimplePublisher<>(Arrays.asList(1, 2, 3, 4, 5));
Subscriber<Integer> subscriber = new SimpleSubscriber<>();
publisher.subscribe(subscriber);
```

## 백프레셔 (Backpressure)

### 백프레셔란?

- 데이터 생산 속도와 소비 속도의 불균형 문제 해결
- Subscriber가 처리할 수 있는 만큼만 요청

### 백프레셔 구현

```java
public class BackpressureSubscriber<T> implements Subscriber<T> {
    private Subscription subscription;
    private final int batchSize;
    private int count = 0;

    public BackpressureSubscriber(int batchSize) {
        this.batchSize = batchSize;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(batchSize);  // 배치 크기만큼 요청
    }

    @Override
    public void onNext(T item) {
        System.out.println("Processing: " + item);
        count++;

        if (count % batchSize == 0) {
            subscription.request(batchSize);  // 다음 배치 요청
        }
    }

    @Override
    public void onError(Throwable throwable) {
        System.err.println("Error: " + throwable.getMessage());
    }

    @Override
    public void onComplete() {
        System.out.println("Completed!");
    }
}
```

## Processor 구현

### 데이터 변환 Processor

```java
import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;
import java.util.function.Function;

public class TransformProcessor<T, R> extends SubmissionPublisher<R> implements Processor<T, R> {
    private final Function<T, R> function;
    private Subscription subscription;

    public TransformProcessor(Function<T, R> function) {
        this.function = function;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);
    }

    @Override
    public void onNext(T item) {
        submit(function.apply(item));
        subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable) {
        closeExceptionally(throwable);
    }

    @Override
    public void onComplete() {
        close();
    }
}

// 사용 예제
SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();
TransformProcessor<Integer, String> processor = new TransformProcessor<>(i -> "Number: " + i);
SimpleSubscriber<String> subscriber = new SimpleSubscriber<>();

publisher.subscribe(processor);
processor.subscribe(subscriber);

publisher.submit(1);
publisher.submit(2);
publisher.submit(3);
publisher.close();
```

## SubmissionPublisher

### SubmissionPublisher 사용

```java
import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;

public class SubmissionPublisherExample {
    public static void main(String[] args) throws InterruptedException {
        // Publisher 생성
        SubmissionPublisher<String> publisher = new SubmissionPublisher<>();

        // Subscriber 등록
        publisher.subscribe(new Flow.Subscriber<String>() {
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1);
            }

            @Override
            public void onNext(String item) {
                System.out.println("Received: " + item);
                subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable) {
                System.err.println("Error: " + throwable.getMessage());
            }

            @Override
            public void onComplete() {
                System.out.println("Done!");
            }
        });

        // 데이터 발행
        publisher.submit("Hello");
        publisher.submit("Reactive");
        publisher.submit("World");

        // Publisher 종료
        publisher.close();

        Thread.sleep(1000);  // 완료 대기
    }
}
```

## 리액티브 라이브러리

### RxJava

```java
Observable<String> observable = Observable.just("Hello", "Reactive", "World");

observable
    .map(String::toUpperCase)
    .filter(s -> s.length() > 5)
    .subscribe(
        item -> System.out.println("Received: " + item),
        error -> System.err.println("Error: " + error),
        () -> System.out.println("Complete!")
    );
```

### Project Reactor

```java
Flux<String> flux = Flux.just("Hello", "Reactive", "World");

flux
    .map(String::toUpperCase)
    .filter(s -> s.length() > 5)
    .subscribe(
        item -> System.out.println("Received: " + item),
        error -> System.err.println("Error: " + error),
        () -> System.out.println("Complete!")
    );
```

### Akka Streams

```java
Source<Integer, NotUsed> source = Source.range(1, 100);

source
    .map(x -> x * 2)
    .filter(x -> x > 50)
    .runWith(Sink.foreach(System.out::println), materializer);
```

## 리액티브 연산자

### map: 데이터 변환

```java
Flux.just(1, 2, 3, 4, 5)
    .map(i -> i * 2)
    .subscribe(System.out::println);  // 2, 4, 6, 8, 10
```

### flatMap: 비동기 변환

```java
Flux.just("user1", "user2", "user3")
    .flatMap(userId -> getUserData(userId))  // 비동기 호출
    .subscribe(System.out::println);
```

### filter: 필터링

```java
Flux.just(1, 2, 3, 4, 5)
    .filter(i -> i % 2 == 0)
    .subscribe(System.out::println);  // 2, 4
```

### buffer: 배치 처리

```java
Flux.range(1, 10)
    .buffer(3)
    .subscribe(System.out::println);  // [1,2,3], [4,5,6], [7,8,9], [10]
```

### zip: 결합

```java
Flux<Integer> flux1 = Flux.just(1, 2, 3);
Flux<String> flux2 = Flux.just("A", "B", "C");

Flux.zip(flux1, flux2, (num, letter) -> num + letter)
    .subscribe(System.out::println);  // 1A, 2B, 3C
```

## 에러 처리

### onErrorReturn: 기본값 반환

```java
Flux.just(1, 2, 0, 4)
    .map(i -> 10 / i)
    .onErrorReturn(-1)
    .subscribe(System.out::println);
```

### onErrorResume: 대체 스트림

```java
Flux.just(1, 2, 0, 4)
    .map(i -> 10 / i)
    .onErrorResume(e -> Flux.just(-1, -2, -3))
    .subscribe(System.out::println);
```

### retry: 재시도

```java
Flux.just(1, 2, 0, 4)
    .map(i -> 10 / i)
    .retry(3)
    .subscribe(
        System.out::println,
        e -> System.err.println("Failed after retries")
    );
```

## Hot vs Cold Publishers

### Cold Publisher

- 구독할 때마다 처음부터 데이터 발행
- 예: HTTP 요청, 파일 읽기

```java
Flux<String> coldFlux = Flux.just("A", "B", "C");

coldFlux.subscribe(s -> System.out.println("Subscriber 1: " + s));
coldFlux.subscribe(s -> System.out.println("Subscriber 2: " + s));
// 각 구독자가 A, B, C를 모두 받음
```

### Hot Publisher

- 구독 시점과 관계없이 데이터 발행
- 예: 마우스 이벤트, 주식 시세

```java
Flux<String> hotFlux = Flux.just("A", "B", "C")
    .share();  // Cold를 Hot으로 변환

hotFlux.subscribe(s -> System.out.println("Subscriber 1: " + s));
Thread.sleep(100);
hotFlux.subscribe(s -> System.out.println("Subscriber 2: " + s));
// Subscriber 2는 구독 이후 데이터만 받음
```

## 스케줄러 (Scheduler)

### 스케줄러 종류

- **immediate()**: 현재 스레드에서 즉시 실행
- **single()**: 단일 재사용 스레드
- **parallel()**: CPU 코어 수만큼의 스레드 풀
- **elastic()**: 필요에 따라 증가하는 스레드 풀

### subscribeOn과 publishOn

```java
Flux.range(1, 5)
    .map(i -> {
        System.out.println("Map 1: " + Thread.currentThread().getName());
        return i * 2;
    })
    .subscribeOn(Schedulers.elastic())  // 전체 체인의 시작점 스케줄러
    .map(i -> {
        System.out.println("Map 2: " + Thread.currentThread().getName());
        return i + 1;
    })
    .publishOn(Schedulers.parallel())  // 이후 연산의 스케줄러
    .subscribe(i -> System.out.println("Subscribe: " + Thread.currentThread().getName()));
```

## 리액티브 웹 애플리케이션

### Spring WebFlux 예제

```java
@RestController
public class UserController {

    @GetMapping("/users")
    public Flux<User> getUsers() {
        return userRepository.findAll();
    }

    @GetMapping("/users/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userRepository.findById(id);
    }

    @PostMapping("/users")
    public Mono<User> createUser(@RequestBody User user) {
        return userRepository.save(user);
    }
}
```

## 정리

1. **리액티브 프로그래밍은 비동기 데이터 스트림을 다룬다**
2. **Flow API는 Java 9+의 리액티브 스트림 표준 구현이다**
3. **백프레셔로 데이터 흐름을 제어한다**
4. **Publisher, Subscriber, Subscription, Processor가 핵심 인터페이스다**
5. **RxJava와 Project Reactor가 대표적인 라이브러리다**
6. **Hot과 Cold Publisher의 차이를 이해해야 한다**
7. **스케줄러로 실행 스레드를 제어할 수 있다**
8. **리액티브 시스템은 반응성, 회복성, 탄력성, 메시지 주도가 핵심이다**
