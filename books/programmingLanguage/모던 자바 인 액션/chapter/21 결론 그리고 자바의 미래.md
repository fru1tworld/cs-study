# 21 결론 그리고 자바의 미래

## 자바 8의 혁신

### 함수형 프로그래밍의 도입

- **람다 표현식**: 익명 함수를 간결하게 표현
- **스트림 API**: 선언적 데이터 처리
- **메서드 참조**: 기존 메서드를 람다처럼 활용
- **디폴트 메서드**: 인터페이스의 진화 가능성
- **Optional**: null 안전성 향상

### 패러다임의 변화

```java
// 명령형 (Before Java 8)
List<String> names = new ArrayList<>();
for (Apple apple : apples) {
    if (apple.getWeight() > 150) {
        names.add(apple.getName());
    }
}

// 선언형 (Java 8+)
List<String> names = apples.stream()
    .filter(apple -> apple.getWeight() > 150)
    .map(Apple::getName)
    .collect(toList());
```

## 자바 9의 개선사항

### 모듈 시스템 (Project Jigsaw)

- **모듈화된 JDK**: 필요한 모듈만 포함 가능
- **명확한 의존성**: module-info.java로 의존성 선언
- **강한 캡슐화**: 내부 API 접근 제한

```java
module com.example.myapp {
    requires java.sql;
    requires java.logging;
    exports com.example.myapp.api;
}
```

### 컬렉션 팩토리 메서드

```java
List<String> names = List.of("Alice", "Bob", "Charlie");
Set<Integer> numbers = Set.of(1, 2, 3);
Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
```

### 리액티브 스트림 지원

```java
Flow.Publisher<String> publisher = ...
Flow.Subscriber<String> subscriber = ...
publisher.subscribe(subscriber);
```

## 자바 10, 11의 추가 기능

### var 키워드 (Java 10)

```java
var numbers = List.of(1, 2, 3);  // List<Integer>로 추론
var name = "Alice";               // String으로 추론
```

### 로컬 변수 타입 추론

- 가독성 향상
- 보일러플레이트 코드 감소
- 타입이 명확할 때만 사용 권장

### HTTP 클라이언트 (Java 11)

```java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .build();

HttpResponse<String> response = client.send(request,
    HttpResponse.BodyHandlers.ofString());
```

## 함수형 프로그래밍의 영향

### 사이드 이펙트 최소화

```java
// 사이드 이펙트 있음 (나쁜 예)
List<Integer> results = new ArrayList<>();
stream.forEach(x -> results.add(x * 2));

// 사이드 이펙트 없음 (좋은 예)
List<Integer> results = stream
    .map(x -> x * 2)
    .collect(toList());
```

### 불변성 선호

```java
// 가변 객체
class MutablePerson {
    private String name;
    public void setName(String name) { this.name = name; }
}

// 불변 객체
class ImmutablePerson {
    private final String name;
    public ImmutablePerson(String name) { this.name = name; }
    public String getName() { return name; }
}
```

### 선언적 프로그래밍

- **무엇(What)**을 할 것인지에 집중
- **어떻게(How)**는 라이브러리에 위임
- 가독성과 유지보수성 향상

## 동시성의 진화

### CompletableFuture

```java
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> transform(data))
    .thenAccept(result -> save(result))
    .exceptionally(ex -> {
        log.error("Error: " + ex);
        return null;
    });
```

### 리액티브 프로그래밍

- **비동기 데이터 스트림** 처리
- **백프레셔(Backpressure)** 지원
- **논블로킹** 방식

## 자바의 미래 방향

### Project Loom (가상 스레드)

- 경량 스레드로 동시성 처리 개선
- 수백만 개의 스레드 생성 가능
- 기존 스레드 모델의 한계 극복

```java
// 미래의 코드 (예상)
Thread.startVirtualThread(() -> {
    // 가벼운 스레드에서 실행
    handleRequest();
});
```

### Project Valhalla (값 타입)

- 원시 타입과 객체의 장점을 결합
- 성능 향상
- 메모리 효율성 개선

### Project Panama (외부 함수 인터페이스)

- C/C++ 라이브러리와의 통합 개선
- JNI의 복잡성 감소
- 성능 향상

### Project Amber (언어 개선)

- **패턴 매칭**
- **레코드 타입**
- **봉인 클래스(Sealed Classes)**

```java
// 패턴 매칭 (미래)
if (obj instanceof String s) {
    System.out.println(s.toLowerCase());
}

// 레코드 타입 (Java 14+)
record Point(int x, int y) {}

// 봉인 클래스 (Java 17+)
sealed interface Shape permits Circle, Rectangle {}
```

## 함수형과 객체지향의 조화

### 최선의 방식 선택

- 상황에 맞는 패러다임 사용
- 함수형: 데이터 변환, 병렬 처리
- 객체지향: 도메인 모델링, 상태 관리

### 하이브리드 접근

```java
class OrderService {
    // 객체지향: 상태와 행동
    private final OrderRepository repository;

    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }

    // 함수형: 데이터 처리
    public List<Order> getExpensiveOrders() {
        return repository.findAll().stream()
            .filter(order -> order.getTotal() > 1000)
            .sorted(comparing(Order::getTotal))
            .collect(toList());
    }
}
```

## 모던 자바의 핵심 원칙

### 1. 동작 파라미터화

- 코드 블록을 파라미터로 전달
- 유연하고 재사용 가능한 코드

### 2. 스트림을 통한 데이터 처리

- 선언적 프로그래밍
- 병렬 처리의 간소화
- 내부 반복

### 3. 효과적인 null 처리

- Optional 활용
- NullPointerException 방지
- 명시적인 부재 표현

### 4. 비동기 프로그래밍

- CompletableFuture 활용
- 리액티브 프로그래밍
- 논블로킹 I/O

### 5. 디폴트 메서드

- 인터페이스의 진화
- 다중 상속 문제 해결
- API 호환성 유지

## 개발자에게 주는 조언

### 계속 배우기

- 새로운 자바 버전의 기능 학습
- 함수형 프로그래밍 개념 이해
- 리액티브 프로그래밍 패턴 습득

### 레거시 코드 개선

- 점진적인 리팩터링
- 람다와 스트림 도입
- Optional로 null 안전성 향상

### 성능과 가독성의 균형

- 과도한 최적화 지양
- 명확한 코드 작성
- 필요시 벤치마크

### 커뮤니티 참여

- 오픈소스 프로젝트 기여
- JEP(JDK Enhancement Proposal) 팔로우
- 컨퍼런스 및 사용자 그룹 참여

## 결론

자바는 20년 이상의 역사를 가진 언어지만, 계속해서 진화하고 있습니다.

### 자바 8의 의의

- **함수형 프로그래밍의 도입으로 패러다임 확장**
- **람다와 스트림으로 간결한 코드 작성**
- **병렬 처리의 간소화**

### 앞으로의 자바

- **더 간결한 문법** (레코드, 패턴 매칭)
- **더 나은 성능** (가상 스레드, 값 타입)
- **더 안전한 코드** (봉인 클래스, 타입 시스템 강화)

### 마지막 조언

1. **함수형과 객체지향을 조화롭게 사용하라**
2. **불변성을 선호하되, 필요시 가변성 사용**
3. **선언적 코드를 작성하라**
4. **병렬 처리를 고려하라**
5. **계속 학습하고 발전하라**

자바는 여전히 진화하는 언어이며, 모던 자바의 기법들을 익히면 더 나은 소프트웨어를 개발할 수 있습니다.
