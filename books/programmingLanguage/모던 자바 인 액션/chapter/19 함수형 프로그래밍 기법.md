# 19 함수형 프로그래밍 기법

## 고급 함수형 프로그래밍 기법

이 장에서는 함수형 프로그래밍의 고급 기법인 커링, 부분 적용, 영속 자료구조, 지연 평가, 패턴 매칭을 다룬다.

## 1. 일급 시민 (First-Class Citizen)

### 일급 함수

Java 8에서 메서드 참조와 람다로 일급 함수 지원

```java
// 함수를 값으로 다루기
Function<Integer, Integer> square = x -> x * x;
Function<Integer, Integer> cube = x -> x * x * x;

// 함수를 인수로 전달
public <T> void process(List<T> list, Function<T, T> func) {
    list.replaceAll(func::apply);
}

// 함수를 반환
public Function<Integer, Integer> createMultiplier(int factor) {
    return x -> x * factor;
}
```

## 2. 고차원 함수 (Higher-Order Functions)

### 정의

- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환

```java
// Comparator.comparing은 고차원 함수
inventory.sort(Comparator.comparing(Apple::getWeight));

// 함수 합성
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 2;
Function<Integer, Integer> h = f.andThen(g);  // (x + 1) * 2

int result = h.apply(1);  // (1 + 1) * 2 = 4
```

### 실용적인 예제

```java
// 필터 조합
public Predicate<Apple> createComplexFilter() {
    Predicate<Apple> redApple = a -> "red".equals(a.getColor());
    Predicate<Apple> heavyApple = a -> a.getWeight() > 150;

    return redApple.and(heavyApple);  // 빨간색이면서 무거운 사과
}

// 함수 파이프라인
public Function<String, String> processingPipeline() {
    return ((Function<String, String>) String::trim)
        .andThen(String::toLowerCase)
        .andThen(s -> s.replaceAll("\\s+", " "));
}
```

## 3. 커링 (Currying)

### 개념

함수의 인수를 여러 개 받는 대신, 인수의 일부를 받아 나머지 인수를 받는 함수를 반환

```java
// 일반 함수
static double converter(double x, double f, double b) {
    return x * f + b;
}

// 커링된 함수
static DoubleUnaryOperator curriedConverter(double f, double b) {
    return x -> x * f + b;
}

// 사용
DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32);
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0);
DoubleUnaryOperator convertKmtoMi = curriedConverter(0.6214, 0);

double fahrenheit = convertCtoF.applyAsDouble(24);  // 섭씨를 화씨로
```

### 다단계 커링

```java
// 3개 인수를 받는 함수의 커링
static Function<Double, Function<Double, Function<Double, Double>>>
    curriedConverter() {
    return f -> b -> x -> x * f + b;
}

// 사용
Function<Double, Double> convertCtoF =
    curriedConverter().apply(9.0/5).apply(32);
```

## 4. 부분 적용 (Partial Application)

```java
// 부분 적용 헬퍼 메서드
public static <A, B, C> Function<B, C> partial(
        BiFunction<A, B, C> func, A a) {
    return b -> func.apply(a, b);
}

// 사용 예
BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
Function<Integer, Integer> multiplyBy2 = partial(multiply, 2);

int result = multiplyBy2.apply(5);  // 10
```

## 5. 영속 자료구조 (Persistent Data Structures)

### 함수형 리스트

```java
interface MyList<T> {
    T head();
    MyList<T> tail();
    default boolean isEmpty() {
        return true;
    }
    MyList<T> filter(Predicate<T> p);
}

class MyLinkedList<T> implements MyList<T> {
    private final T head;
    private final MyList<T> tail;

    public MyLinkedList(T head, MyList<T> tail) {
        this.head = head;
        this.tail = tail;
    }

    public T head() {
        return head;
    }

    public MyList<T> tail() {
        return tail;
    }

    public boolean isEmpty() {
        return false;
    }

    // 구조 공유를 통한 효율적인 추가
    public MyList<T> prepend(T element) {
        return new MyLinkedList<>(element, this);
    }

    public MyList<T> filter(Predicate<T> p) {
        return isEmpty() ? this :
            p.test(head()) ?
                new MyLinkedList<>(head(), tail().filter(p)) :
                tail().filter(p);
    }
}

class Empty<T> implements MyList<T> {
    public T head() {
        throw new UnsupportedOperationException();
    }

    public MyList<T> tail() {
        throw new UnsupportedOperationException();
    }

    public MyList<T> filter(Predicate<T> p) {
        return this;
    }
}
```

### 트리 구조의 갱신

```java
class Tree {
    private String key;
    private int val;
    private Tree left, right;

    public Tree(String k, int v, Tree l, Tree r) {
        key = k; val = v; left = l; right = r;
    }

    // 함수형 갱신 - 경로만 복사
    public static Tree fupdate(String k, int newval, Tree t) {
        return (t == null) ?
            new Tree(k, newval, null, null) :
            k.equals(t.key) ?
                new Tree(k, newval, t.left, t.right) :
            k.compareTo(t.key) < 0 ?
                new Tree(t.key, t.val, fupdate(k,newval, t.left), t.right) :
                new Tree(t.key, t.val, t.left, fupdate(k,newval, t.right));
    }
}
```

## 6. 지연 평가 (Lazy Evaluation)

### 지연 리스트

```java
interface MyList<T> {
    T head();
    MyList<T> tail();
    default boolean isEmpty() {
        return true;
    }
}

class LazyList<T> implements MyList<T> {
    final T head;
    final Supplier<MyList<T>> tail;  // Supplier로 지연 평가

    public LazyList(T head, Supplier<MyList<T>> tail) {
        this.head = head;
        this.tail = tail;
    }

    public T head() {
        return head;
    }

    public MyList<T> tail() {
        return tail.get();  // 필요할 때만 계산
    }

    public boolean isEmpty() {
        return false;
    }

    // 무한 리스트 생성 가능
    public static LazyList<Integer> from(int n) {
        return new LazyList<>(n, () -> from(n + 1));
    }
}

// 사용 예: 무한 소수 리스트
public static MyList<Integer> primes(MyList<Integer> numbers) {
    return new LazyList<>(
        numbers.head(),
        () -> primes(
            numbers.tail()
                   .filter(n -> n % numbers.head() != 0)
        )
    );
}

MyList<Integer> numbers = LazyList.from(2);
int two = primes(numbers).head();
int three = primes(numbers).tail().head();
int five = primes(numbers).tail().tail().head();
```

### 지연 평가 활용

```java
// 무한 스트림
public static Stream<Integer> primes(int n) {
    return Stream.iterate(n, i -> i + 1)
        .filter(PrimeExample::isPrime);
}

// 필요한 만큼만 계산
List<Integer> first10Primes = primes(2)
    .limit(10)
    .collect(Collectors.toList());
```

## 7. 패턴 매칭 (Pattern Matching)

Java는 완전한 패턴 매칭을 지원하지 않지만, 유사하게 구현 가능

### Visitor 패턴으로 구현

```java
class Expr { }
class Number extends Expr {
    int val;
    Number(int val) { this.val = val; }
}
class BinOp extends Expr {
    String opname;
    Expr left, right;
    BinOp(String opname, Expr left, Expr right) {
        this.opname = opname;
        this.left = left;
        this.right = right;
    }
}

// 패턴 매칭 스타일 (Scala/Haskell과 유사하게)
public static int eval(Expr e) {
    if (e instanceof Number) {
        return ((Number) e).val;
    }
    if (e instanceof BinOp) {
        BinOp b = (BinOp) e;
        String op = b.opname;
        if ("+".equals(op)) {
            return eval(b.left) + eval(b.right);
        }
        if ("*".equals(op)) {
            return eval(b.left) * eval(b.right);
        }
    }
    throw new RuntimeException("Unknown expression");
}
```

### Java 14+의 instanceof 패턴 매칭

```java
public static int eval(Expr e) {
    if (e instanceof Number n) {
        return n.val;
    } else if (e instanceof BinOp b) {
        return switch (b.opname) {
            case "+" -> eval(b.left) + eval(b.right);
            case "*" -> eval(b.left) * eval(b.right);
            default -> throw new RuntimeException("Unknown operator");
        };
    }
    throw new RuntimeException("Unknown expression");
}
```

## 8. 함수 조합 (Function Composition)

```java
// andThen: f.andThen(g) = g(f(x))
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 2;
Function<Integer, Integer> h = f.andThen(g);  // (x + 1) * 2

// compose: f.compose(g) = f(g(x))
Function<Integer, Integer> i = f.compose(g);  // (x * 2) + 1

// 실용 예제
Function<String, String> pipeline =
    ((Function<String, String>) String::trim)
        .andThen(String::toLowerCase)
        .andThen(s -> s.replaceAll("\\s+", " "))
        .andThen(s -> s.substring(0, Math.min(s.length(), 100)));
```

## 9. 메모이제이션 (Memoization)

### 계산 결과 캐싱

```java
public class Memoizer<T, U> {
    private final Map<T, U> cache = new HashMap<>();

    public Function<T, U> memoize(Function<T, U> function) {
        return input -> cache.computeIfAbsent(input, function);
    }
}

// 사용 예: 피보나치
Function<Integer, Long> fibonacci = n -> {
    if (n <= 1) return (long) n;
    // 비효율적인 재귀...
    return fibonacci.apply(n - 1) + fibonacci.apply(n - 2);
};

Memoizer<Integer, Long> m = new Memoizer<>();
Function<Integer, Long> fastFib = m.memoize(fibonacci);
```

## 10. 함수형 디버깅

### peek을 활용한 스트림 디버깅

```java
List<Integer> numbers = Arrays.asList(2, 3, 4, 5);

List<Integer> result = numbers.stream()
    .peek(x -> System.out.println("from stream: " + x))
    .map(x -> x + 17)
    .peek(x -> System.out.println("after map: " + x))
    .filter(x -> x % 2 == 0)
    .peek(x -> System.out.println("after filter: " + x))
    .limit(3)
    .peek(x -> System.out.println("after limit: " + x))
    .collect(Collectors.toList());
```

## 실전 활용 예제

### 1. DSL 구축

```java
// 주문 DSL
public class Order {
    private List<Trade> trades = new ArrayList<>();

    public void addTrade(Trade trade) {
        trades.add(trade);
    }

    public static Order order(Consumer<Order> init) {
        Order order = new Order();
        init.accept(order);
        return order;
    }
}

// 사용
Order order = order(o -> {
    o.addTrade(buy(80, stock("IBM"), on(exchange("NYSE"))));
    o.addTrade(sell(50, stock("GOOGLE"), on(exchange("NASDAQ"))));
});
```

### 2. 옵저버 패턴의 함수형 구현

```java
interface Observer<T> {
    void notify(T event);
}

// 함수형 스타일
List<Consumer<String>> observers = new ArrayList<>();
observers.add(s -> System.out.println("First: " + s));
observers.add(s -> System.out.println("Second: " + s));

// 이벤트 발생
String event = "Hello";
observers.forEach(o -> o.accept(event));
```

## 결론

함수형 프로그래밍 기법(커링, 지연 평가, 패턴 매칭 등)을 Java에서 활용하면 더 간결하고 표현력 있는 코드를 작성할 수 있다. 완벽한 함수형 언어는 아니지만, Java 8 이후의 기능들로 충분히 함수형 스타일의 프로그래밍이 가능하다.
