# 11장 동시성

## 개요

스레드는 여러 활동을 동시에 수행할 수 있게 해주지만, 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다. 제대로 하는 방법을 배워보자.

## 아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라

### 동기화의 두 가지 역할

#### 1. 배타적 실행 (Mutual Exclusion)

- 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막음

#### 2. 스레드 사이의 안정적인 통신

- 한 스레드가 만든 변화를 다른 스레드에서 확인 가능하게 함

### 동기화 실패 예

```java
// 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까?
public class StopThread {
    private static boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested)  // 끝나지 않을 수 있다!
                i++;
        });
        backgroundThread.start();

        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;  // 읽혀지지 않을 수 있다!
    }
}
```

### 해결 방법

#### 1. synchronized 사용

```java
public class StopThread {
    private static boolean stopRequested;

    private static synchronized void requestStop() {
        stopRequested = true;
    }

    private static synchronized boolean stopRequested() {
        return stopRequested;
    }

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested())
                i++;
        });
        backgroundThread.start();

        TimeUnit.SECONDS.sleep(1);
        requestStop();
    }
}
```

#### 2. volatile 사용

```java
public class StopThread {
    private static volatile boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested)
                i++;
        });
        backgroundThread.start();

        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

### volatile의 주의사항

```java
// 잘못된 코드 - 동기화가 필요하다!
private static volatile int nextSerialNumber = 0;

public static int generateSerialNumber() {
    return nextSerialNumber++;  // 원자적이지 않음!
}

// 올바른 코드 - synchronized 사용
private static int nextSerialNumber = 0;

public static synchronized int generateSerialNumber() {
    return nextSerialNumber++;
}

// 더 나은 방법 - AtomicLong 사용
private static final AtomicLong nextSerialNum = new AtomicLong();

public static long generateSerialNumber() {
    return nextSerialNum.getAndIncrement();
}
```

### 원칙

- **여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다**
- **가변 데이터는 단일 스레드에서만 사용하라** (가장 좋은 방법)

## 아이템 79: 과도한 동기화는 피하라

### 과도한 동기화의 문제

- 성능 저하
- 교착상태 (deadlock)
- 예측할 수 없는 동작

### 동기화된 영역 안에서 외계인 메서드 호출 금지

```java
// 잘못된 예 - 동기화 블록 안에서 외계인 메서드 호출!
public class ObservableSet<E> extends ForwardingSet<E> {
    private final List<SetObserver<E>> observers = new ArrayList<>();

    public void addObserver(SetObserver<E> observer) {
        synchronized(observers) {
            observers.add(observer);
        }
    }

    public boolean removeObserver(SetObserver<E> observer) {
        synchronized(observers) {
            return observers.remove(observer);
        }
    }

    private void notifyElementAdded(E element) {
        synchronized(observers) {
            for (SetObserver<E> observer : observers)
                observer.added(this, element);  // 외계인 메서드!
        }
    }

    @Override public boolean add(E element) {
        boolean added = super.add(element);
        if (added)
            notifyElementAdded(element);
        return added;
    }
}
```

### 해결 방법 1: 외계인 메서드를 동기화 블록 바깥으로 이동

```java
// 외계인 메서드를 동기화 블록 바깥으로 옮김
private void notifyElementAdded(E element) {
    List<SetObserver<E>> snapshot = null;
    synchronized(observers) {
        snapshot = new ArrayList<>(observers);
    }
    for (SetObserver<E> observer : snapshot)
        observer.added(this, element);
}
```

### 해결 방법 2: CopyOnWriteArrayList 사용

```java
// CopyOnWriteArrayList를 사용해 구현한 스레드 안전하고 관찰 가능한 집합
private final List<SetObserver<E>> observers =
    new CopyOnWriteArrayList<>();

public void addObserver(SetObserver<E> observer) {
    observers.add(observer);
}

public boolean removeObserver(SetObserver<E> observer) {
    return observers.remove(observer);
}

private void notifyElementAdded(E element) {
    for (SetObserver<E> observer : observers)
        observer.added(this, element);
}
```

### 원칙

- **동기화 영역에서는 가능한 한 일을 적게 하라**
- **가변 클래스를 작성할 때는:**
  1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화
  2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들기 (단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 개선할 수 있을 때만)

## 아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라

### java.util.concurrent 프레임워크

```java
// 작업 큐 생성
ExecutorService exec = Executors.newSingleThreadExecutor();

// 실행할 태스크 제출
exec.execute(runnable);

// 실행자 종료
exec.shutdown();
```

### 실행자 서비스의 주요 기능

```java
// 특정 태스크가 완료되기를 기다림
exec.submit(callable).get();

// 태스크 모음 중 아무것 하나 완료되기를 기다림
exec.invokeAny(tasks);

// 모든 태스크가 완료되기를 기다림
exec.invokeAll(tasks);

// 실행자 서비스가 종료하기를 기다림
exec.awaitTermination(10, TimeUnit.SECONDS);

// 완료된 태스크의 결과를 차례로 받음
ExecutorCompletionService<Result> ecs = new ExecutorCompletionService<>(exec);
for (Callable<Result> task : tasks)
    ecs.submit(task);
for (int i = 0; i < tasks.size(); i++) {
    Result r = ecs.take().get();
    // 결과 처리
}
```

### 스레드 풀 선택

```java
// 평범한 서버 프로그램: 고정 크기 스레드 풀
ExecutorService exec = Executors.newFixedThreadPool(n);

// 가벼운 서버: Executor.newCachedThreadPool (부하가 심하면 문제 발생 가능)
ExecutorService exec = Executors.newCachedThreadPool();

// 무거운 서버: ThreadPoolExecutor 직접 사용
ThreadPoolExecutor exec = new ThreadPoolExecutor(
    corePoolSize, maximumPoolSize, keepAliveTime,
    TimeUnit.SECONDS, new LinkedBlockingQueue<>());
```

### ForkJoinPool (Java 7+)

```java
// 병렬 처리에 적합
ForkJoinPool pool = new ForkJoinPool();
pool.invoke(new MyRecursiveTask());
```

### 원칙

- **작업 큐를 직접 만들거나 스레드를 직접 다루는 것은 일반적으로 삼가야 한다**
- **스레드를 직접 다루지 말고 실행자 프레임워크를 사용하라**

## 아이템 81: wait와 notify보다는 동시성 유틸리티를 애용하라

### java.util.concurrent의 고수준 유틸리티 세 가지 범주

#### 1. 실행자 프레임워크 (Executor Framework)

- 아이템 80에서 다룸

#### 2. 동시성 컬렉션 (Concurrent Collection)

```java
// ConcurrentMap으로 구현한 동시성 정규화 맵
private static final ConcurrentMap<String, String> map =
    new ConcurrentHashMap<>();

public static String intern(String s) {
    String previousValue = map.putIfAbsent(s, s);
    return previousValue == null ? s : previousValue;
}

// Java 8 이후 - computeIfAbsent 사용
public static String intern(String s) {
    return map.computeIfAbsent(s, key -> key);
}

// ConcurrentHashMap은 get 같은 검색 연산에 최적화
public static String intern(String s) {
    String result = map.get(s);
    if (result == null) {
        result = map.putIfAbsent(s, s);
        if (result == null)
            result = s;
    }
    return result;
}
```

**동시성 컬렉션의 특징:**

- `Collections.synchronizedMap`보다 월등히 빠름
- 동시성을 무력화하지 못하며 외부에서 락을 걸면 오히려 느려짐

#### 3. 동기화 장치 (Synchronizer)

```java
// CountDownLatch를 사용한 동시 실행 시간 측정
public static long time(Executor executor, int concurrency,
                        Runnable action) throws InterruptedException {
    CountDownLatch ready = new CountDownLatch(concurrency);
    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch done = new CountDownLatch(concurrency);

    for (int i = 0; i < concurrency; i++) {
        executor.execute(() -> {
            ready.countDown();  // 타이머에게 준비를 마쳤음을 알림
            try {
                start.await();  // 모든 작업자 스레드가 준비될 때까지 대기
                action.run();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                done.countDown();  // 타이머에게 작업을 마쳤음을 알림
            }
        });
    }

    ready.await();     // 모든 작업자가 준비될 때까지 대기
    long startNanos = System.nanoTime();
    start.countDown(); // 작업자들을 깨운다
    done.await();      // 모든 작업자가 일을 끝마치기를 대기
    return System.nanoTime() - startNanos;
}
```

**시간 측정에는 System.currentTimeMillis가 아닌 System.nanoTime 사용**

### wait와 notify를 사용해야 한다면 (레거시 코드)

```java
// wait 메서드를 사용하는 표준 방식
synchronized (obj) {
    while (<조건이 충족되지 않았다>)
        obj.wait();  // 락을 놓고, 깨어나면 다시 잡는다

    ... // 조건이 충족됐을 때의 동작을 수행
}
```

**원칙:**

- wait는 반드시 반복문 안에서 호출하라
- notify보다는 notifyAll을 사용하라 (안전하고 합리적)

## 아이템 82: 스레드 안전성 수준을 문서화하라

### 스레드 안전성 수준

#### 1. 불변 (Immutable)

- 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화가 필요 없다
- 예: `String`, `Long`, `BigInteger`

#### 2. 무조건적 스레드 안전 (Unconditionally Thread-Safe)

- 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다
- 예: `AtomicLong`, `ConcurrentHashMap`

#### 3. 조건부 스레드 안전 (Conditionally Thread-Safe)

- 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다
- 예: `Collections.synchronized` 래퍼 메서드가 반환한 컬렉션들

```java
/**
 * Collections.synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면
 * 반드시 맵을 락으로 사용해 수동으로 동기화하라.
 *
 * Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
 * Set<K> s = m.keySet();  // 동기화 블록 밖에 있어도 된다
 * ...
 * synchronized(m) {  // s가 아닌 m을 사용해 동기화해야 한다!
 *     for (K key : s)
 *         key.f();
 * }
 *
 * 이대로 따르지 않으면 동작을 예측할 수 없다.
 */
```

#### 4. 스레드 안전하지 않음 (Not Thread-Safe)

- 이 클래스의 인스턴스는 수정될 수 있다. 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다
- 예: `ArrayList`, `HashMap` 같은 기본 컬렉션

#### 5. 스레드 적대적 (Thread-Hostile)

- 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다
- 일반적으로 정적 데이터를 아무 동기화 없이 수정한다
- 문제를 고쳐 재배포하거나 사용 자제(deprecated) API로 지정

### 문서화 예시

```java
/**
 * 이 리스트는 스레드 안전하지 않습니다.
 * 여러 스레드가 동시에 접근한다면 외부 동기화가 필요합니다.
 */
public class MyList<E> {
    ...
}

/**
 * 조건부 스레드 안전 클래스
 *
 * 컬렉션 뷰를 순회할 때는 반드시 외부 동기화가 필요합니다:
 *
 * <pre>{@code
 * synchronized(myObject) {
 *     for (Element e : myObject.elements())
 *         e.process();
 * }
 * }</pre>
 */
public class MyThreadSafeClass {
    ...
}
```

## 아이템 83: 지연 초기화는 신중히 사용하라

### 지연 초기화(Lazy Initialization)

- 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법

### 대부분의 경우: 일반적인 초기화

```java
// 인스턴스 필드의 일반적인 초기화
private final FieldType field = computeFieldValue();
```

### 지연 초기화가 필요한 경우

#### 1. 인스턴스 필드의 스레드 안전한 지연 초기화 - synchronized 사용

```java
// 인스턴스 필드의 지연 초기화 - synchronized 접근자 방식
private FieldType field;

private synchronized FieldType getField() {
    if (field == null)
        field = computeFieldValue();
    return field;
}
```

#### 2. 정적 필드용 지연 초기화 홀더 클래스 관용구

```java
// 정적 필드용 지연 초기화 홀더 클래스 관용구
private static class FieldHolder {
    static final FieldType field = computeFieldValue();
}

private static FieldType getField() { return FieldHolder.field; }
```

#### 3. 인스턴스 필드의 이중검사(Double-Check) 관용구

```java
// 인스턴스 필드의 지연 초기화 - 이중검사 관용구
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result == null) {  // 첫 번째 검사 (락 사용 안 함)
        synchronized(this) {
            if (field == null)  // 두 번째 검사 (락 사용)
                field = result = computeFieldValue();
        }
    }
    return result;
}
```

#### 4. 단일검사(Single-Check) 관용구 (반복 초기화 허용)

```java
// 단일검사 관용구 - 초기화가 중복해서 일어날 수 있다
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result == null)
        field = result = computeFieldValue();
    return result;
}
```

## 아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라

### 견고하고 이식성 좋은 프로그램

- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것
- 그래야 스레드 스케줄러가 고민할 거리가 줄어든다

### 원칙

- **실행 가능한 스레드의 수를 적게 유지하라**
- **스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안 된다**
- **바쁜 대기(busy waiting) 상태로 만들지 말라**

```java
// 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전!
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0)
            throw new IllegalArgumentException(count + " < 0");
        this.count = count;
    }

    public void await() {
        while (true) {
            synchronized(this) {
                if (count == 0)
                    return;
            }
        }
    }

    public synchronized void countDown() {
        if (count != 0)
            count--;
    }
}
```

### 주의사항

- Thread.yield에 의존하지 말라
- 스레드 우선순위를 조절하는 것으로 문제를 해결하려 시도하지 말라
- 스레드 우선순위는 이식성이 가장 나쁜 특성

## 핵심 정리

1. 공유 중인 가변 데이터는 동기화해 사용하라
2. 과도한 동기화는 피하라
3. 스레드보다는 실행자, 태스크, 스트림을 애용하라
4. wait와 notify보다는 동시성 유틸리티를 애용하라
5. 스레드 안전성 수준을 문서화하라
6. 지연 초기화는 신중히 사용하라
7. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
