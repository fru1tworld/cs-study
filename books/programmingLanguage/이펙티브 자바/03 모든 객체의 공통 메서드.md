# 03 모든 객체의 공통 메서드

Object는 객체를 만들 수 있는 구체 클래스지만 기본적으로는 상속해서 사용하도록 설계되었다. Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의(overriding)을 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있다.

## 아이템 10: equals는 일반 규약을 지켜 재정의하라

### equals를 재정의하지 않아도 되는 경우

- 각 인스턴스가 본질적으로 고유하다 (Thread 등)
- 인스턴스의 '논리적 동치성'을 검사할 일이 없다
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 적합하다
- 클래스가 private이거나 package-private이고 equals를 호출할 일이 없다

### equals 재정의 시 지켜야 할 규약

**반사성(reflexivity)**: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.

**대칭성(symmetry)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.

**추이성(transitivity)**: null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.

**일관성(consistency)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.

**null-아님**: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.

### 양질의 equals 메서드 구현 방법

```java
@Override
public boolean equals(Object o) {
    // 1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인
    if (this == o) return true;

    // 2. instanceof 연산자로 입력이 올바른 타입인지 확인
    if (!(o instanceof PhoneNumber)) return false;

    // 3. 입력을 올바른 타입으로 형변환
    PhoneNumber pn = (PhoneNumber) o;

    // 4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 확인
    return pn.lineNum == lineNum
        && pn.prefix == prefix
        && pn.areaCode == areaCode;
}
```

### 주의사항

- float와 double을 제외한 기본 타입 필드는 == 연산자로 비교
- 참조 타입 필드는 각각의 equals 메서드로 비교
- float와 double 필드는 Float.compare, Double.compare로 비교
- 배열 필드는 Arrays.equals 사용
- null 정상값 취급 방지를 위해 Objects.equals(Object, Object) 사용 고려

## 아이템 11: equals를 재정의하려거든 hashCode도 재정의하라

### hashCode 규약

- equals 비교에 사용되는 정보가 변경되지 않았다면, hashCode도 변하지 않아야 한다
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다
- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다 (하지만 다른 값을 반환해야 해시테이블의 성능이 좋아진다)

### 좋은 hashCode 작성 요령

```java
@Override
public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

또는 Objects.hash 사용:

```java
@Override
public int hashCode() {
    return Objects.hash(areaCode, prefix, lineNum);
}
```

### 주의사항

- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자 (개선 여지를 남겨둠)

## 아이템 12: toString을 항상 재정의하라

### toString의 일반 규약

"간결하면서 사람이 읽기 쉬운 형태의 유익한 정보"를 반환해야 한다.

### 좋은 toString 예시

```java
@Override
public String toString() {
    return String.format("%03d-%03d-%04d", areaCode, prefix, lineNum);
}
```

### toString 구현 시 고려사항

- 객체가 가진 주요 정보를 모두 반환하는 게 좋다
- 큰 객체나 문자열로 표현하기 적합하지 않은 객체는 요약 정보를 담아야 한다
- 포맷을 명시하든 아니든 의도를 명확히 밝혀야 한다
- toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자

## 아이템 13: clone 재정의는 주의해서 진행하라

### Cloneable 인터페이스의 문제점

- clone 메서드가 선언된 곳이 Cloneable이 아닌 Object
- protected 접근 제한자로 선언되어 있음
- 메서드 하나 없는 인터페이스지만, 이를 구현한 클래스는 Object의 clone 동작 방식을 결정

### clone 메서드 재정의 시 규약

- x.clone() != x는 true
- x.clone().getClass() == x.getClass()는 true
- x.clone().equals(x)는 true이지만 필수는 아님

### 가변 객체를 참조하는 클래스의 clone

```java
@Override
public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        result.elements = elements.clone();  // 깊은 복사
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

### 복사 생성자와 복사 팩터리

clone보다 나은 대안:

```java
// 복사 생성자
public Yum(Yum yum) { ... }

// 복사 팩터리
public static Yum newInstance(Yum yum) { ... }
```

## 아이템 14: Comparable을 구현할지 고려하라

### compareTo 메서드의 일반 규약

- sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
- 추이성: (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0
- x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))
- 권고: (x.compareTo(y) == 0) == (x.equals(y))

### compareTo 메서드 작성 요령

```java
public int compareTo(PhoneNumber pn) {
    int result = Short.compare(areaCode, pn.areaCode);
    if (result == 0) {
        result = Short.compare(prefix, pn.prefix);
        if (result == 0)
            result = Short.compare(lineNum, pn.lineNum);
    }
    return result;
}
```

또는 Comparator 생성 메서드 사용:

```java
private static final Comparator<PhoneNumber> COMPARATOR =
    comparingInt((PhoneNumber pn) -> pn.areaCode)
        .thenComparingInt(pn -> pn.prefix)
        .thenComparingInt(pn -> pn.lineNum);

public int compareTo(PhoneNumber pn) {
    return COMPARATOR.compare(this, pn);
}
```

### 주의사항

- 관계 연산자 < 와 >는 사용하지 말고, 박싱된 기본 타입 클래스의 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자
- 값의 차를 기준으로 compareTo나 compare를 구현하지 말자 (정수 오버플로우나 부동소수점 계산 오류 발생 가능)

## 핵심 정리

- equals는 일반 규약을 지켜 재정의하라. 재정의할 때는 hashCode도 반드시 재정의하라
- toString은 명확하고 유용한 정보를 반환하도록 재정의하라
- clone은 되도록 사용하지 말고, 복사 생성자와 복사 팩터리를 사용하라
- Comparable 구현은 정렬이나 극값 계산 등에 유용하다
