# 10장 예외

## 개요

예외를 효과적으로 활용하면 프로그램의 가독성, 신뢰성, 유지보수성이 높아진다. 잘못 사용하면 반대의 효과가 나타난다.

## 아이템 69: 예외는 진짜 예외 상황에만 사용하라

### 예외를 잘못 사용한 사례

```java
// 예외를 완전히 잘못 사용한 예 - 따라 하지 말 것!
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}

// 표준적인 관용구 - 간결하고 명확
for (Mountain m : range)
    m.climb();
```

**문제점:**

- 예외는 예외 상황에 쓸 용도로 설계되어 JVM 구현자 입장에서 명확한 검사만큼 빠르게 만들어야 할 동기가 약함
- try-catch 블록 안의 코드는 JVM이 적용할 수 있는 최적화가 제한됨
- 배열 순회의 표준 관용구는 JVM이 알아서 최적화해줌

### 원칙

- **예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다**
- **잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다**

### 상태 검사 메서드와 Optional

```java
// 상태 검사 메서드
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
}

// 옵셔널 사용
Optional<Foo> foo = ... ;
if (foo.isPresent()) {
    Foo f = foo.get();
    ...
}

// 상태 검사 메서드 대신 빈 옵셔널 반환
Optional<Foo> foo = ... ;
foo.ifPresent(f -> ... );
```

## 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

### Java의 세 가지 throwable

#### 1. 검사 예외 (Checked Exception)

- 호출하는 쪽에서 복구하리라 믿는 상황
- 호출자가 catch 블록으로 잡아 처리하거나 더 바깥으로 전파하도록 강제
- 예: `IOException`, `SQLException`

```java
// 복구 가능한 상황 - 검사 예외
try {
    obj = readObject(file);
} catch (IOException e) {
    // 다른 파일로 재시도하거나, 사용자에게 안내
}
```

#### 2. 런타임 예외 (Unchecked Exception / Runtime Exception)

- 프로그래밍 오류를 나타낼 때 사용
- 전제조건을 만족하지 못했을 때 발생
- 예: `NullPointerException`, `ArrayIndexOutOfBoundsException`

```java
// 프로그래밍 오류 - 런타임 예외
public void setRange(int min, int max) {
    if (min > max)
        throw new IllegalArgumentException("최솟값이 최댓값보다 큽니다.");
    // ...
}
```

#### 3. 에러 (Error)

- JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용
- Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하라
- 예: `OutOfMemoryError`, `StackOverflowError`

### 검사 예외에는 복구에 필요한 정보를 제공하는 메서드를 함께 제공하라

```java
// 검사 예외 - 복구 정보 제공
public class InsufficientFundsException extends Exception {
    private final BigDecimal shortfall;

    public InsufficientFundsException(BigDecimal shortfall) {
        super("부족 금액: " + shortfall);
        this.shortfall = shortfall;
    }

    // 부족한 금액을 알려주는 접근자 메서드
    public BigDecimal getShortfall() {
        return shortfall;
    }
}
```

## 아이템 71: 필요 없는 검사 예외 사용은 피하라

### 검사 예외의 부담

```java
// 검사 예외를 던지는 메서드 - catch 블록 또는 throws 필요
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // 예외 상황에 대처한다
}

// 또는 더 바깥으로 던진다
public void someMethod() throws TheCheckedException {
    obj.action(args);
}
```

### 검사 예외 회피 방법

#### 1. Optional 반환

```java
// 검사 예외 대신 빈 옵셔널 반환
public Optional<Result> action(Args args) {
    try {
        return Optional.of(performAction(args));
    } catch (Exception e) {
        return Optional.empty();  // 실패 정보는 제공할 수 없음
    }
}
```

#### 2. 검사 예외를 던지는 메서드를 2개로 쪼개기

```java
// 검사 예외를 던지는 메서드
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // 예외 상황 대처
}

// 리팩터링 - 상태 검사 메서드와 비검사 예외로 분리
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황 대처
}
```

## 아이템 72: 표준 예외를 사용하라

### 자주 사용되는 표준 예외

| 예외                              | 사용 시점                                                                |
| --------------------------------- | ------------------------------------------------------------------------ |
| `IllegalArgumentException`        | 허용하지 않는 값이 인수로 건네졌을 때 (null은 따로 NullPointerException) |
| `IllegalStateException`           | 객체가 메서드를 수행하기에 적절하지 않은 상태일 때                       |
| `NullPointerException`            | null을 허용하지 않는 메서드에 null을 건넸을 때                           |
| `IndexOutOfBoundsException`       | 인덱스가 범위를 넘어섰을 때                                              |
| `ConcurrentModificationException` | 허용하지 않는 동시 수정이 발견됐을 때                                    |
| `UnsupportedOperationException`   | 호출한 메서드를 지원하지 않을 때                                         |

### 예시

```java
// IllegalArgumentException
public void setAge(int age) {
    if (age < 0)
        throw new IllegalArgumentException("나이는 음수일 수 없습니다: " + age);
    this.age = age;
}

// IllegalStateException
public void withdraw(BigDecimal amount) {
    if (!isOpen)
        throw new IllegalStateException("계좌가 닫혀 있습니다");
    // 출금 처리
}

// NullPointerException
public void process(String input) {
    Objects.requireNonNull(input, "input은 null일 수 없습니다");
    // 처리
}

// UnsupportedOperationException
public void remove() {
    throw new UnsupportedOperationException("이 컬렉션은 불변입니다");
}
```

### 주의사항

- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말라
- 예외는 직렬화할 수 있다는 사실을 기억하라

## 아이템 73: 추상화 수준에 맞는 예외를 던지라

### 예외 번역 (Exception Translation)

```java
// 예외 번역 - 저수준 예외를 잡아 고수준 예외로 던진다
try {
    // 저수준 추상화를 이용한다
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);
}
```

### 실제 예: AbstractSequentialList의 get 메서드

```java
/**
 * 이 리스트 안의 지정한 위치의 원소를 반환한다.
 * @throws IndexOutOfBoundsException index가 범위 밖이면, 즉
 *         ({@code index < 0 || index >= size()})이면 발생한다.
 */
public E get(int index) {
    ListIterator<E> i = listIterator(index);
    try {
        return i.next();
    } catch (NoSuchElementException e) {
        throw new IndexOutOfBoundsException("인덱스: " + index);
    }
}
```

### 예외 연쇄 (Exception Chaining)

```java
// 예외 연쇄 - 근본 원인을 고수준 예외에 실어 보낸다
try {
    // 저수준 추상화를 이용한다
} catch (LowerLevelException cause) {
    throw new HigherLevelException(cause);
}

// 예외 연쇄용 생성자
class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

### 원칙

- 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선
- 아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 조용히 처리하여 문제를 API 호출자에게 전파하지 않는 방법이 있음
- 그것도 불가능하다면 예외 번역 사용

## 아이템 74: 메서드가 던지는 모든 예외를 문서화하라

### 검사 예외 문서화

```java
/**
 * 이 리스트에서 지정한 위치의 원소를 반환한다.
 *
 * @param index 반환할 원소의 인덱스; 0 이상이고 리스트 크기보다 작아야 한다.
 * @return 이 리스트에서 지정한 위치의 원소
 * @throws IndexOutOfBoundsException index가 범위를 벗어나면,
 *         즉 ({@code index < 0 || index >= size()})이면 발생한다.
 */
E get(int index);
```

### 원칙

- **검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 JavaDoc의 @throws 태그로 정확히 문서화하라**
- **비검사 예외도 검사 예외처럼 정성껏 문서화하라** (프로그래밍 오류를 알려줌)
- **메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말라**
- **한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 클래스 설명에 추가할 수 있다**

```java
/**
 * 이 클래스의 모든 메서드는 인수로 null이 넘어오면
 * {@link NullPointerException}을 던진다.
 */
public class MyClass {
    // ...
}
```

## 아이템 75: 예외의 상세 메시지에 실패 관련 정보를 담으라

### 유용한 상세 메시지

```java
// IndexOutOfBoundsException - 실패 정보 제공
/**
 * IndexOutOfBoundsException을 생성한다.
 *
 * @param lowerBound 인덱스의 최솟값
 * @param upperBound 인덱스의 최댓값 + 1
 * @param index 인덱스의 실제 값
 */
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {
    // 실패를 적절히 포착하는 상세 메시지를 생성한다
    super(String.format(
            "최솟값: %d, 최댓값: %d, 인덱스: %d",
            lowerBound, upperBound, index));

    // 프로그램에서 이용할 수 있도록 실패 정보를 저장해둔다
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
    this.index = index;
}
```

### 원칙

- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다
- 보안과 관련된 정보는 주의해서 다뤄라 (패스워드, 암호 키 등)
- 문서와 소스코드에서 얻을 수 있는 정보는 긴 설명보다는 짧게 요약하라

## 아이템 76: 가능한 한 실패 원자적으로 만들라

### 실패 원자성 (Failure Atomicity)

**호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다**

### 실패 원자성 달성 방법

#### 1. 불변 객체로 설계

```java
// 불변 객체 - 실패 원자성을 공짜로 제공
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    // 불변이므로 실패해도 상태가 변하지 않음
}
```

#### 2. 작업 수행 전에 매개변수 유효성 검사

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;  // 다 쓴 참조 해제
    return result;
}
```

#### 3. 실패할 가능성이 있는 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치

```java
// TreeMap.put 예시
public V put(K key, V value) {
    Entry<K,V> t = root;
    if (t == null) {
        compare(key, key);  // type 검사를 목적으로 비교 (타입 체크)

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    // ...
}
```

#### 4. 객체의 임시 복사본에서 작업 수행 후 성공하면 원래 객체와 교체

```java
// 정렬 전에 배열을 복사
public void sort() {
    Object[] a = toArray();
    Arrays.sort(a);
    // 정렬이 성공한 후에만 원래 리스트에 반영
    for (int i = 0; i < a.length; i++) {
        set(i, (E)a[i]);
    }
}
```

#### 5. 작업 도중 발생하는 실패를 가로채는 복구 코드 작성

- 드물게 사용
- 주로 내구성(durability)을 보장해야 하는 자료구조에 사용

### 권장사항

- 실패 원자성은 권장되지만 항상 달성할 수 있는 것은 아니다
- Error는 복구를 시도조차 할 필요가 없다
- 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 경우가 있다
- 메서드 명세에 기술한 예외라면, 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙

## 아이템 77: 예외를 무시하지 말라

### 나쁜 예

```java
// 예외를 무시하는 코드 - 따라 하지 말 것!
try {
    ...
} catch (SomeException e) {
}
```

### 예외를 무시해도 되는 경우

```java
// 예외를 무시해도 되는 드문 경우
FileInputStream stream = null;
try {
    stream = new FileInputStream("file.txt");
    // stream 사용
} catch (IOException e) {
    // 파일을 열 수 없을 때 처리
} finally {
    if (stream != null) {
        try {
            stream.close();
        } catch (IOException e) {
            // close 실패 시 복구할 방법이 없으므로 무시해도 좋다
            // 하지만 로그는 남겨야 한다
        }
    }
}

// 더 나은 방법 - try-with-resources
try (FileInputStream stream = new FileInputStream("file.txt")) {
    // stream 사용
} catch (IOException e) {
    // 파일을 열 수 없을 때 처리
}
```

### 예외를 무시하기로 했다면

```java
try {
    ...
} catch (SomeException e) {
    // 예외를 무시하기로 한 이유를 주석으로 남기고
    // 예외 변수의 이름도 ignored로 바꿔놓자
}

// 명확한 이유 설명
try {
    numColors = f.get(1L, TimeUnit.SECONDS);
} catch (TimeoutException | ExecutionException ignored) {
    // 기본값을 사용한다 (색상은 무엇이든 괜찮다)
}
```

### 원칙

- **빈 catch 블록을 보면 의심하라**
- **예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓자**
- **검사 예외와 비검사 예외 모두 해당**

## 핵심 정리

1. 예외는 진짜 예외 상황에만 사용하라
2. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
3. 필요 없는 검사 예외 사용은 피하라
4. 표준 예외를 사용하라
5. 추상화 수준에 맞는 예외를 던지라
6. 메서드가 던지는 모든 예외를 문서화하라
7. 예외의 상세 메시지에 실패 관련 정보를 담으라
8. 가능한 한 실패 원자적으로 만들라
9. 예외를 무시하지 말라
