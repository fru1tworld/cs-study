# 04 클래스와 인터페이스

클래스와 인터페이스는 자바 언어의 심장과도 같다. 이 장에서는 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내한다.

## 아이템 15: 클래스와 멤버의 접근 권한을 최소화하라

### 정보 은닉의 장점

- 시스템 개발 속도를 높인다 (여러 컴포넌트를 병렬로 개발)
- 시스템 관리 비용을 낮춘다 (각 컴포넌트를 빠르게 파악)
- 성능 최적화에 도움을 준다 (다른 컴포넌트에 영향 없이 최적화)
- 소프트웨어 재사용성을 높인다
- 큰 시스템 제작 난이도를 낮춘다

### 접근 제한자 활용

- **private**: 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- **package-private**: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 (기본 접근 수준)
- **protected**: package-private 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- **public**: 모든 곳에서 접근 가능

### 원칙

- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다
- public static final 필드는 반드시 불변 객체를 참조해야 한다

## 아이템 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

### 나쁜 예

```java
class Point {
    public double x;
    public double y;
}
```

### 좋은 예

```java
class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }
    public double getY() { return y; }

    public void setX(double x) { this.x = x; }
    public void setY(double y) { this.y = y; }
}
```

### 예외

- package-private 클래스나 private 중첩 클래스라면 데이터 필드를 노출해도 문제없다

## 아이템 17: 변경 가능성을 최소화하라

### 불변 클래스를 만드는 5가지 규칙

1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
2. 클래스를 확장할 수 없도록 한다 (final 클래스로 선언)
3. 모든 필드를 final로 선언한다
4. 모든 필드를 private으로 선언한다
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다

### 불변 복소수 클래스 예시

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() { return re; }
    public double imaginaryPart() { return im; }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }
}
```

### 불변 클래스의 장점

- 단순하다
- 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다
- 안심하고 공유할 수 있다
- 불변 객체끼리는 내부 데이터를 공유할 수 있다
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다
- 실패 원자성을 제공한다

### 단점

- 값이 다르면 반드시 독립된 객체로 만들어야 한다

## 아이템 18: 상속보다는 컴포지션을 사용하라

### 상속의 문제점

- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다
- 상위 클래스의 구현이 달라지면 하위 클래스가 오동작할 수 있다

### 컴포지션(Composition)

```java
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;

    public ForwardingSet(Set<E> s) { this.s = s; }

    public void clear() { s.clear(); }
    public boolean contains(Object o) { return s.contains(o); }
    public boolean add(E e) { return s.add(e); }
    // ... 나머지 메서드들도 전달
}

public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    public int getAddCount() {
        return addCount;
    }
}
```

### 상속을 사용해도 되는 경우

- 하위 클래스가 정말 상위 클래스의 '하위 타입'인 상황일 때만

## 아이템 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 상속용 클래스의 문서화

- 재정의 가능 메서드를 내부적으로 어떻게 이용하는지 문서로 남겨야 한다
- @implSpec 태그를 사용하여 메서드의 내부 동작 방식을 설명

### 상속용 클래스의 제약

- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다

### 상속을 금지하는 방법

1. 클래스를 final로 선언
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 제공

## 아이템 20: 추상 클래스보다는 인터페이스를 우선하라

### 인터페이스의 장점

- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다
- 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다
- 래퍼 클래스와 함께 사용하면 기능을 향상시키는 안전하고 강력한 수단이 된다

### 디폴트 메서드

```java
public interface Comparator<T> {
    int compare(T o1, T o2);

    default Comparator<T> reversed() {
        return Collections.reverseOrder(this);
    }
}
```

### 골격 구현 (skeletal implementation)

```java
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {
    // 변경 가능한 엔트리는 이 메서드를 반드시 재정의해야 한다
    @Override public V setValue(V value) {
        throw new UnsupportedOperationException();
    }

    // Map.Entry.equals의 일반 규약을 구현한다
    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?,?> e = (Map.Entry) o;
        return Objects.equals(e.getKey(), getKey())
            && Objects.equals(e.getValue(), getValue());
    }

    @Override public int hashCode() {
        return Objects.hashCode(getKey())
             ^ Objects.hashCode(getValue());
    }
}
```

## 아이템 21: 인터페이스는 구현하는 쪽을 생각해 설계하라

- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다
- 인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있지만, 절대 그 가능성에 기대서는 안 된다

## 아이템 22: 인터페이스는 타입을 정의하는 용도로만 사용하라

### 안티패턴: 상수 인터페이스

```java
// 사용 금지!
public interface PhysicalConstants {
    static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
}
```

### 대안: 상수 유틸리티 클래스

```java
public class PhysicalConstants {
    private PhysicalConstants() { }  // 인스턴스화 방지

    public static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    public static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
}
```

## 아이템 23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라

### 나쁜 예: 태그 달린 클래스

```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };

    final Shape shape;

    double length;
    double width;
    double radius;

    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

### 좋은 예: 클래스 계층구조

```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;

    Circle(double radius) { this.radius = radius; }

    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override double area() { return length * width; }
}
```

## 아이템 24: 멤버 클래스는 되도록 static으로 만들라

### 중첩 클래스의 종류

1. **정적 멤버 클래스**
2. **비정적 멤버 클래스**
3. 익명 클래스
4. 지역 클래스

### 정적 멤버 클래스

- 바깥 클래스의 private 멤버에도 접근할 수 있다
- 바깥 인스턴스 없이도 생성할 수 있다

### 비정적 멤버 클래스

- 바깥 클래스의 인스턴스와 암묵적으로 연결된다
- 어댑터를 정의할 때 자주 쓰인다

### 원칙

- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자

## 아이템 25: 톱레벨 클래스는 한 파일에 하나만 담으라

- 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자
- 이 규칙만 따른다면 컴파일러가 한 클래스에 대한 정의를 여러 개 만들어내는 일은 사라진다
