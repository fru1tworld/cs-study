# 7장 람다와 스트림

## 개요

Java 8에서 함수형 인터페이스, 람다, 메서드 참조 개념이 추가되어 함수 객체를 쉽게 만들 수 있게 되었다. 스트림 API도 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원한다.

## 아이템 42: 익명 클래스보다는 람다를 사용하라

### 익명 클래스의 문제점

```java
// 구식 방식 - 익명 클래스의 인스턴스를 함수 객체로 사용
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

### 람다 사용

```java
// 람다식을 함수 객체로 사용 - 익명 클래스 대체
Collections.sort(words,
    (s1, s2) -> Integer.compare(s1.length(), s2.length()));

// 비교자 생성 메서드 사용 (더 간결)
Collections.sort(words, comparingInt(String::length));

// List 인터페이스의 sort 메서드 사용
words.sort(comparingInt(String::length));
```

### 주의사항

- 람다는 이름이 없고 문서화도 못 함. 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 쓰지 말아야 함
- 람다는 한 줄일 때 가장 좋고, 길어야 세 줄 안에 끝내는 게 좋음
- 람다는 함수형 인터페이스에서만 사용

### 람다를 쓸 수 없는 경우

- 추상 클래스의 인스턴스를 만들 때
- 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때
- 람다는 자신을 참조할 수 없음 (`this`는 바깥 인스턴스)

## 아이템 43: 람다보다는 메서드 참조를 사용하라

### 메서드 참조의 간결함

```java
// 람다
map.merge(key, 1, (count, incr) -> count + incr);

// 메서드 참조 (더 간결)
map.merge(key, 1, Integer::sum);
```

### 메서드 참조 유형

#### 1. 정적 메서드 참조

```java
Integer::parseInt
str -> Integer.parseInt(str)
```

#### 2. 한정적(bound) 인스턴스 메서드 참조

```java
Instant.now()::isAfter
Instant then = Instant.now();
t -> then.isAfter(t)
```

#### 3. 비한정적(unbound) 인스턴스 메서드 참조

```java
String::toLowerCase
str -> str.toLowerCase()
```

#### 4. 클래스 생성자

```java
TreeMap<K,V>::new
() -> new TreeMap<K,V>()
```

#### 5. 배열 생성자

```java
int[]::new
len -> new int[len]
```

## 아이템 44: 표준 함수형 인터페이스를 사용하라

### 표준 함수형 인터페이스

| 인터페이스          | 함수 시그니처         | 예                    |
| ------------------- | --------------------- | --------------------- |
| `UnaryOperator<T>`  | `T apply(T t)`        | `String::toLowerCase` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | `BigInteger::add`     |
| `Predicate<T>`      | `boolean test(T t)`   | `Collection::isEmpty` |
| `Function<T,R>`     | `R apply(T t)`        | `Arrays::asList`      |
| `Supplier<T>`       | `T get()`             | `Instant::now`        |
| `Consumer<T>`       | `void accept(T t)`    | `System.out::println` |

### 기본 타입 특화 인터페이스

- `IntPredicate`, `LongBinaryOperator`, `DoubleFunction` 등
- 박싱된 기본 타입을 넣어 사용하지 말 것 (성능 저하)

### 직접 작성해야 하는 경우

- 표준 인터페이스 중 필요한 용도에 맞는 게 없을 때
- 구조적으로 똑같은 표준 함수형 인터페이스가 있더라도:
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명
  - 반드시 따라야 하는 규약이 있음
  - 유용한 디폴트 메서드를 제공할 수 있음

예: `Comparator<T>`

### @FunctionalInterface 애너테이션

- 해당 인터페이스가 람다용으로 설계된 것임을 알려줌
- 추상 메서드를 오직 하나만 가지고 있어야 컴파일됨
- 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아줌

## 아이템 45: 스트림은 주의해서 사용하라

### 스트림 API의 핵심 추상 개념

#### 1. 스트림(Stream)

- 데이터 원소의 유한 혹은 무한 시퀀스

#### 2. 스트림 파이프라인(Stream Pipeline)

- 이 원소들로 수행하는 연산 단계

### 스트림 파이프라인 구조

```java
// 중간 연산 + 종단 연산
words.stream()
     .filter(w -> w.length() > 5)     // 중간 연산
     .map(String::toLowerCase)         // 중간 연산
     .sorted()                         // 중간 연산
     .collect(toList());               // 종단 연산
```

### 스트림을 과용한 예

```java
// 과하게 사용한 스트림 - 읽기 어려움!
public class Anagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                groupingBy(word -> word.chars().sorted()
                    .collect(StringBuilder::new,
                        (sb, c) -> sb.append((char) c),
                        StringBuilder::append).toString()))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .map(group -> group.size() + ": " + group)
                .forEach(System.out::println);
        }
    }
}
```

### 적절히 사용한 예

```java
// 스트림을 적절히 사용하면 깔끔하고 명확
public class Anagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> alphabetize(word)))
                 .values().stream()
                 .filter(group -> group.size() >= minGroupSize)
                 .forEach(g -> System.out.println(g.size() + ": " + g));
        }
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

### 스트림 사용 지침

**스트림을 사용하면 안 되는 경우:**

- 지역변수를 읽고 수정해야 하는 경우
- return, break, continue를 사용하거나 예외를 던져야 하는 경우

**스트림이 적합한 경우:**

- 원소들의 시퀀스를 일관되게 변환
- 원소들의 시퀀스를 필터링
- 원소들의 시퀀스를 하나의 연산을 사용해 결합 (더하기, 연결, 최솟값 구하기 등)
- 원소들의 시퀀스를 컬렉션에 모으기
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소 찾기

## 아이템 46: 스트림에서는 부작용 없는 함수를 사용하라

### 스트림 패러다임

스트림은 함수형 프로그래밍에 기초한 패러다임. 각 변환 단계는 이전 단계의 결과를 받아 처리하는 순수 함수여야 함.

### 나쁜 예

```java
// 스트림 패러다임을 이해하지 못한 채 API만 사용 - 따라 하지 말 것!
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()) {
    words.forEach(word -> {
        freq.merge(word.toLowerCase(), 1L, Long::sum);
    });
}
```

### 올바른 예

```java
// 스트림을 제대로 활용
Map<String, Long> freq;
try (Stream<String> words = new Scanner(file).tokens()) {
    freq = words
        .collect(groupingBy(String::toLowerCase, counting()));
}
```

### Collector (수집기)

#### 빈도표에서 가장 흔한 단어 10개 추출

```java
List<String> topTen = freq.keySet().stream()
    .sorted(comparing(freq::get).reversed())
    .limit(10)
    .collect(toList());
```

#### toMap 수집기

```java
// 키와 값 매핑
private static final Map<String, Operation> stringToEnum =
    Stream.of(values()).collect(
        toMap(Object::toString, e -> e));

// 충돌 시 마지막 값 취하기
toMap(keyMapper, valueMapper, (oldVal, newVal) -> newVal)

// 특정 맵 구현체 지정
toMap(keyMapper, valueMapper, (oldVal, newVal) -> newVal, TreeMap::new)
```

#### groupingBy 수집기

```java
// 단순 그룹화
words.collect(groupingBy(word -> alphabetize(word)))

// 다운스트림 수집기와 함께 사용
Map<String, Long> freq = words
    .collect(groupingBy(String::toLowerCase, counting()));

// 맵 팩터리와 함께 사용
Map<City, Set<String>> namesByCity = people.collect(
    groupingBy(Person::getCity, TreeMap::new,
               mapping(Person::getLastName, toSet())));
```

## 아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다

### 스트림 vs Iterable

- Stream은 Iterable을 확장(extend)하지 않아 for-each로 반복할 수 없음
- 반복문에서 사용하려면 어댑터 필요

### 컬렉션 반환의 장점

- Collection 인터페이스는 Iterable의 하위 타입이고 stream 메서드도 제공
- 반복과 스트림을 동시에 지원

### 반환 타입 선택 지침

1. 원소 시퀀스를 반환하는 공개 API의 반환 타입으로는 Collection이나 그 하위 타입 사용
2. 반환할 시퀀스가 크지만 표현을 간결하게 할 수 있다면 전용 컬렉션 구현 고려
3. 컬렉션을 반환하는 게 불가능하면 스트림과 Iterable 중 더 자연스러운 것 반환

## 아이템 48: 스트림 병렬화는 주의해서 적용하라

### 병렬화의 위험성

```java
// 절대 병렬화하지 말 것!
public static void main(String[] args) {
    primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .parallel()  // 스트림 라이브러리가 병렬화 방법을 찾아내지 못함
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(System.out::println);
}
```

### 병렬화가 효과적인 경우

- `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스
- 배열, int 범위, long 범위
- 위 자료구조들의 공통점:
  - 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있음
  - 참조 지역성(locality of reference)이 뛰어남

### 종단 연산의 병렬화 친화성

- **축소(reduction)**: `min`, `max`, `count`, `sum` 등
- **조건 충족 검사**: `anyMatch`, `allMatch`, `noneMatch`
- **가변 축소(mutable reduction)**: collect는 병렬화에 적합하지 않음

### 올바른 병렬화 예

```java
// 소수 계산 스트림 파이프라인 - 병렬화에 적합
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
        .parallel()
        .mapToObj(BigInteger::valueOf)
        .filter(i -> i.isProbablePrime(50))
        .count();
}
```

### 병렬화 지침

- 확신 없이는 스트림 파이프라인 병렬화 하지 말 것
- 성능 테스트로 병렬화 가치가 있는지 확인
- 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 프로세서 코어 수에 비례하는 성능 향상

## 핵심 정리

1. 익명 클래스보다는 람다를 사용하라
2. 람다보다는 메서드 참조를 사용하라 (더 짧고 명확할 때)
3. 표준 함수형 인터페이스를 사용하라
4. 스트림은 주의해서 사용하라 (과용 금지)
5. 스트림에서는 부작용 없는 함수를 사용하라
6. 반환 타입으로는 스트림보다 컬렉션이 낫다
7. 스트림 병렬화는 신중하게 적용하라
