# 9장 일반적인 프로그래밍 원칙

## 개요

지역변수, 제어구조, 라이브러리, 데이터 타입, 리플렉션과 네이티브 메서드, 최적화와 명명 규칙 등 Java 언어의 기본 요소들을 효과적으로 사용하는 방법을 다룬다.

## 아이템 57: 지역변수의 범위를 최소화하라

### 지역변수 범위 최소화 기법

#### 1. 가장 처음 쓰일 때 선언하라

```java
// 나쁜 예
int i;
// ... 많은 코드 ...
for (i = 0; i < n; i++) {
    doSomething(i);
}

// 좋은 예
for (int i = 0; i < n; i++) {
    doSomething(i);
}
```

#### 2. 거의 모든 지역변수는 선언과 동시에 초기화해야 한다

```java
// 나쁜 예
String line;
try {
    line = reader.readLine();
} catch (IOException e) {
    // 처리
}

// 좋은 예
try {
    String line = reader.readLine();
    // line 사용
} catch (IOException e) {
    // 처리
}
```

#### 3. 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 경우가 아니라면 while문보다는 for문을 사용하라

```java
// for문 사용 (권장)
for (int i = 0, n = expensiveComputation(); i < n; i++) {
    // i와 n을 사용
}
// 여기서 i와 n은 유효 범위 밖

// while문 (비권장)
int i = 0;
int n = expensiveComputation();
while (i < n) {
    // i와 n 사용
    i++;
}
// 여기서도 i와 n이 유효 범위 안
```

#### 4. 메서드를 작게 유지하고 한 가지 기능에 집중하라

## 아이템 58: 전통적인 for문보다는 for-each문을 사용하라

### for-each문의 장점

```java
// 전통적인 for문 - 코드가 지저분하고 실수할 여지가 많다
for (int i = 0; i < a.length; i++) {
    // a[i]로 작업
}

for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    // e로 작업
}

// for-each문 (향상된 for문) - 간결하고 명료
for (Element e : elements) {
    // e로 작업
}
```

### 중첩 반복문에서의 for-each 이점

```java
// 버그가 있는 코드 - 실수로 같은 변수를 사용
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,
            NINE, TEN, JACK, QUEEN, KING }

static Collection<Suit> suits = Arrays.asList(Suit.values());
static Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(i.next(), j.next())); // 버그! i.next()가 너무 많이 호출됨

// for-each문으로 해결
for (Suit suit : suits)
    for (Rank rank : ranks)
        deck.add(new Card(suit, rank));
```

### for-each문을 사용할 수 없는 경우

1. **파괴적인 필터링(destructive filtering)**: 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드 호출 필요

   - Java 8부터는 Collection의 `removeIf` 메서드 사용

2. **변형(transforming)**: 리스트나 배열을 순회하면서 그 원소의 값 일부 또는 전체를 교체해야 한다면 인덱스 필요

3. **병렬 반복(parallel iteration)**: 여러 컬렉션을 병렬로 순회해야 한다면 명시적으로 제어 필요

## 아이템 59: 라이브러리를 익히고 사용하라

### 표준 라이브러리 사용의 이점

#### 1. 전문가의 지식과 다른 프로그래머들의 경험을 활용할 수 있다

```java
// 나쁜 예 - 직접 구현한 난수 생성
static Random rnd = new Random();

static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;  // 문제가 많다!
}

// 좋은 예 - 라이브러리 사용
Random rnd = new Random();
int randomNumber = rnd.nextInt(n);

// Java 7 이후 - ThreadLocalRandom
int randomNumber = ThreadLocalRandom.current().nextInt(n);
```

#### 2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다

#### 3. 따로 노력하지 않아도 성능이 지속해서 개선된다

#### 4. 기능이 점점 많아진다

#### 5. 내가 작성한 코드가 많은 사람에게 낯익은 코드가 된다

### 알아야 할 라이브러리

- **java.lang, java.util, java.io**와 그 하위 패키지들
- 컬렉션 프레임워크
- 스트림 라이브러리 (Java 8+)
- java.util.concurrent (동시성)

## 아이템 60: 정확한 답이 필요하다면 float와 double은 피하라

### float와 double의 문제점

```java
// 금융 계산에 부동소수 타입 사용 - 틀린 결과!
System.out.println(1.03 - 0.42);  // 0.6100000000000001
System.out.println(1.00 - 9 * 0.10);  // 0.09999999999999998
```

### 해결 방법

#### 1. BigDecimal 사용

```java
public static void main(String[] args) {
    final BigDecimal TEN_CENTS = new BigDecimal(".10");

    int itemsBought = 0;
    BigDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price = TEN_CENTS;
         funds.compareTo(price) >= 0;
         price = price.add(TEN_CENTS)) {
        funds = funds.subtract(price);
        itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(달러): " + funds);
}
```

**BigDecimal의 단점:**

- 기본 타입보다 쓰기 불편하다
- 느리다

#### 2. int나 long 사용 (소수점 직접 추적)

```java
public static void main(String[] args) {
    int itemsBought = 0;
    int funds = 100;  // 센트 단위로 관리
    for (int price = 10; funds >= price; price += 10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(센트): " + funds);
}
```

## 아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라

### 기본 타입과 박싱된 기본 타입의 차이

1. **기본 타입은 값만 가지지만, 박싱된 기본 타입은 식별성(identity)를 갖는다**
2. **기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 null을 가질 수 있다**
3. **기본 타입이 시간과 메모리 사용면에서 더 효율적이다**

### 잘못된 Comparator - 박싱된 기본 타입의 == 사용

```java
// 잘못된 비교자 - 문제를 찾아보자!
Comparator<Integer> naturalOrder =
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

naturalOrder.compare(new Integer(42), new Integer(42));  // 1을 반환! (0이 아님)

// 수정된 버전
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;  // 오토박싱
    return i < j ? -1 : (i == j ? 0 : 1);
};

// 더 나은 방법
Comparator<Integer> naturalOrder = Comparator.naturalOrder();
```

### NullPointerException 위험

```java
public class Unbelievable {
    static Integer i;  // 초기화되지 않음 (null)

    public static void main(String[] args) {
        if (i == 42)  // NullPointerException 발생!
            System.out.println("믿을 수 없군!");
    }
}
```

### 성능 문제

```java
// 느림! 박싱과 언박싱이 반복해서 일어난다
public static void main(String[] args) {
    Long sum = 0L;  // Long으로 선언 (문제!)
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;  // 매번 새로운 Long 인스턴스 생성
    }
    System.out.println(sum);
}

// 빠름 - long 사용
public static void main(String[] args) {
    long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

### 박싱된 기본 타입을 써야 하는 경우

1. 컬렉션의 원소, 키, 값으로 쓸 때
2. 리플렉션을 통해 메서드를 호출할 때
3. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다 (`ThreadLocal<Integer>`)

## 아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라

### 문자열을 쓰지 말아야 할 사례

#### 1. 문자열은 다른 값 타입을 대신하기에 적합하지 않다

```java
// 나쁜 예
String temperature = "25";

// 좋은 예
int temperature = 25;
// 또는
BigDecimal temperature = new BigDecimal("25.5");
```

#### 2. 문자열은 열거 타입을 대신하기에 적합하지 않다

```java
// 나쁜 예
public static final String EMPLOYEE = "EMPLOYEE";
public static final String MANAGER = "MANAGER";

// 좋은 예
public enum EmployeeType { EMPLOYEE, MANAGER }
```

#### 3. 문자열은 혼합 타입을 대신하기에 적합하지 않다

```java
// 나쁜 예 - 문자열을 혼합 타입으로 부적절하게 사용
String compoundKey = className + "#" + i.next();

// 좋은 예 - 전용 클래스 사용
private static class CompoundKey {
    private final String className;
    private final int id;

    CompoundKey(String className, int id) {
        this.className = className;
        this.id = id;
    }
    // equals, hashCode, toString 구현
}
```

#### 4. 문자열은 권한을 표현하기에 적합하지 않다

```java
// 잘못된 예
public class ThreadLocal {
    private ThreadLocal() { }  // 객체 생성 불가

    // 문자열 키로 스레드별 지역변수 식별
    public static void set(String key, Object value);
    public static Object get(String key);
}

// 올바른 예 - Key 클래스로 권한 부여
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

## 아이템 63: 문자열 연결은 느리니 주의하라

### 문자열 연결 성능 문제

```java
// 문자열 연결을 잘못 사용한 예 - 느리다!
public String statement() {
    String result = "";
    for (int i = 0; i < numItems(); i++)
        result += lineForItem(i);  // 문자열 연결
    return result;
}
```

**문제:** 문자열은 불변이므로 두 문자열을 연결할 때 양쪽의 내용을 모두 복사해야 함. 성능이 O(n²)

### StringBuilder 사용

```java
// StringBuilder를 사용하면 훨씬 빠르다
public String statement() {
    StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
    for (int i = 0; i < numItems(); i++)
        b.append(lineForItem(i));
    return b.toString();
}
```

## 아이템 64: 객체는 인터페이스를 사용해 참조하라

### 인터페이스 타입으로 사용하기

```java
// 좋은 예 - 인터페이스를 타입으로 사용
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예 - 클래스를 타입으로 사용
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

### 이점

- 프로그램이 훨씬 유연해진다
- 구현 클래스를 교체하고자 한다면 새 클래스의 생성자를 호출해주기만 하면 된다

```java
// 구현 클래스 교체가 쉽다
Set<Son> sonSet = new HashSet<>();  // LinkedHashSet에서 HashSet으로 변경
```

### 주의사항

- 적합한 인터페이스가 없다면 클래스로 참조해야 한다
  - String, BigInteger 같은 값 클래스
  - 클래스 기반으로 작성된 프레임워크가 제공하는 객체
  - 인터페이스에 없는 특별한 메서드를 제공하는 클래스

## 아이템 65: 리플렉션보다는 인터페이스를 사용하라

### 리플렉션의 단점

1. 컴파일타임 타입 검사의 이점을 누릴 수 없다
2. 코드가 지저분하고 장황해진다
3. 성능이 떨어진다

### 리플렉션의 제한적 사용

```java
// 리플렉션으로 생성하고 인터페이스로 참조
public static void main(String[] args) {
    // 클래스 이름을 Class 객체로 변환
    Class<? extends Set<String>> cl = null;
    try {
        cl = (Class<? extends Set<String>>)
                Class.forName(args[0]);
    } catch (ClassNotFoundException e) {
        fatalError("클래스를 찾을 수 없습니다.");
    }

    // 생성자를 얻는다
    Constructor<? extends Set<String>> cons = null;
    try {
        cons = cl.getDeclaredConstructor();
    } catch (NoSuchMethodException e) {
        fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
    }

    // 집합의 인스턴스를 만든다
    Set<String> s = null;
    try {
        s = cons.newInstance();
    } catch (IllegalAccessException e) {
        fatalError("생성자에 접근할 수 없습니다.");
    } catch (InstantiationException e) {
        fatalError("클래스를 인스턴스화할 수 없습니다.");
    } catch (InvocationTargetException e) {
        fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
    } catch (ClassCastException e) {
        fatalError("Set을 구현하지 않은 클래스입니다.");
    }

    // 생성한 집합을 사용한다 (일반 Set 인터페이스 사용)
    s.addAll(Arrays.asList(args).subList(1, args.length));
    System.out.println(s);
}
```

## 아이템 66: 네이티브 메서드는 신중히 사용하라

### Java Native Interface (JNI)

- C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 호출하는 기술

### 네이티브 메서드의 용도

1. 레지스트리 같은 플랫폼 특화 기능 사용
2. 네이티브 코드로 작성된 기존 라이브러리 사용
3. 성능 개선을 목적으로 성능 결정적인 부분만 네이티브 언어로 작성

### 네이티브 메서드의 단점

- 안전하지 않다 (메모리 충돌 오류)
- 플랫폼 종속적
- 디버깅이 어렵다
- 성능을 오히려 떨어뜨릴 수도 있다
- 가비지 컬렉터가 네이티브 메모리를 추적할 수 없다
- 자바 코드와 네이티브 코드 경계를 넘나들 때마다 비용 발생

## 아이템 67: 최적화는 신중히 하라

### 최적화 격언

- "빠른 프로그램보다는 좋은 프로그램을 작성하라"
- "작은 효율성(small efficiency)은 모두 잊자. 섣부른 최적화가 만악의 근원이다" - Donald Knuth
- "최적화를 할 때는 다음 두 규칙을 따르라
  1. 하지 마라
  2. (전문가 한정) 아직 하지 마라"

### 성능 최적화 지침

1. **빠른 프로그램이 아닌 좋은 프로그램을 작성하라**
   - 좋은 설계는 성능도 좋다
2. **성능을 제한하는 설계를 피하라**
   - API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 설계 시 성능을 염두에 두라
3. **API를 설계할 때 성능에 주는 영향을 고려하라**
   - public 타입을 가변으로 만들면 방어적 복사 필요
   - 컴포지션으로 해결할 수 있는데 상속을 사용하면 상위 클래스에 영원히 종속
   - 인터페이스가 있는데 구현 타입을 사용하면 특정 구현체에 종속
4. **성능을 위해 API를 왜곡하지 말라**

5. **최적화 전후로 성능을 측정하라**
   - 프로파일링 도구 사용

## 아이템 68: 일반적으로 통용되는 명명 규칙을 따르라

### 패키지와 모듈

- 계층적, 점(.)으로 구분
- 소문자 알파벳 (숫자는 드물게)
- 조직 밖에서도 사용될 패키지: 인터넷 도메인 이름을 역순으로
  - 예: `com.google`, `org.junit`
- 나머지는 짧게: `utilities`, `awt`

### 클래스와 인터페이스 (열거 타입과 애너테이션 포함)

- 대문자로 시작, 카멜 케이스
- 여러 단어의 첫 글자만 대문자
- 예: `Stream`, `FutureTask`, `LinkedHashMap`
- 약어는 첫 글자만 대문자 (HTTPURL보다는 HttpUrl)

### 메서드와 필드

- 소문자로 시작, 카멜 케이스
- 예: `remove`, `ensureCapacity`
- 상수 필드는 모두 대문자, 단어 사이 밑줄
- 예: `VALUES`, `NEGATIVE_INFINITY`

### 지역변수

- 필드와 비슷하나 약어 허용
- 예: `i`, `denom`, `houseNum`

### 타입 매개변수

- 한 문자로 표현
- `T`: 임의의 타입
- `E`: 컬렉션 원소 타입
- `K`, `V`: 맵의 키와 값
- `X`: 예외
- `R`: 메서드 반환 타입
- `T`, `U`, `V` 또는 `T1`, `T2`, `T3`: 임의 타입 시퀀스

### 메서드 이름 문법 규칙

#### 어떤 동작을 수행하는 메서드

- 동사나 동사구
- 예: `append`, `drawImage`

#### boolean 값을 반환하는 메서드

- `is` 또는 `has`로 시작
- 예: `isDigit`, `hasSiblings`

#### 속성을 반환하는 메서드

- 명사, 명사구, `get`으로 시작하는 동사구
- 예: `size`, `hashCode`, `getTime`

#### 객체의 타입을 바꿔서 다른 타입의 다른 객체를 반환하는 인스턴스 메서드

- `toType` 형태
- 예: `toString`, `toArray`

#### 객체의 내용을 다른 뷰로 보여주는 메서드

- `asType` 형태
- 예: `asList`

#### 객체의 값을 기본 타입 값으로 반환하는 메서드

- `typeValue` 형태
- 예: `intValue`

#### 정적 팩터리 메서드

- `from`, `of`, `valueOf`, `instance`, `getInstance`, `newInstance`, `getType`, `newType`

## 핵심 정리

1. 지역변수의 범위를 최소화하라
2. 전통적인 for문보다는 for-each문을 사용하라
3. 라이브러리를 익히고 사용하라
4. 정확한 답이 필요하다면 float와 double은 피하라
5. 박싱된 기본 타입보다는 기본 타입을 사용하라
6. 다른 타입이 적절하다면 문자열 사용을 피하라
7. 문자열 연결은 느리니 주의하라
8. 객체는 인터페이스를 사용해 참조하라
9. 리플렉션보다는 인터페이스를 사용하라
10. 네이티브 메서드는 신중히 사용하라
11. 최적화는 신중히 하라
12. 일반적으로 통용되는 명명 규칙을 따르라
