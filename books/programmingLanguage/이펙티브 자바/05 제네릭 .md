# 05 제네릭

## 개요

제네릭은 Java 5부터 도입된 기능으로, 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주어 타입 안전성을 제공한다.

## 아이템 26: 로 타입은 사용하지 말라

### 로 타입(Raw Type)이란?

- 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 것
- 예: `List<E>`의 로 타입은 `List`

### 문제점

```java
// 잘못된 예 - 로 타입 사용
List numbers = new ArrayList();
numbers.add(1);
numbers.add("문자열"); // 컴파일 오류 없음!
Integer n = (Integer) numbers.get(1); // 런타임 오류 발생
```

### 올바른 사용

```java
// 올바른 예 - 제네릭 타입 사용
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add("문자열"); // 컴파일 오류 발생
```

### 예외 상황

- `class` 리터럴에는 로 타입을 사용해야 함: `List.class`, `String[].class`
- `instanceof` 연산자 사용 시

## 아이템 27: 비검사 경고를 제거하라

### 비검사 경고란?

- 제네릭을 사용할 때 발생하는 컴파일러 경고
- 종류: 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고 등

### 경고 제거 원칙

1. 모든 비검사 경고는 가능한 한 제거하라
2. 경고를 제거할 수 없지만 타입 안전하다고 확신한다면 `@SuppressWarnings("unchecked")` 사용
3. `@SuppressWarnings` 애너테이션은 가능한 한 좁은 범위에 적용하라
4. 경고를 숨기기로 한 근거를 주석으로 남겨라

## 아이템 28: 배열보다는 리스트를 사용하라

### 배열과 제네릭의 차이

#### 1. 공변성(Covariant) vs 불공변성(Invariant)

```java
// 배열은 공변 - 문제 발생
Object[] objectArray = new Long[1];
objectArray[0] = "문자열"; // 런타임 오류

// 리스트는 불공변 - 안전
List<Object> ol = new ArrayList<Long>(); // 컴파일 오류
```

#### 2. 실체화(Reifiable)

- 배열은 실체화됨: 런타임에도 원소의 타입을 인지하고 확인
- 제네릭은 타입 정보가 런타임에 소거됨(Type Erasure)

### 결론

- 배열과 제네릭은 잘 어우러지지 못함
- 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면 배열을 리스트로 대체하라

## 아이템 29: 이왕이면 제네릭 타입으로 만들라

### 제네릭 타입 만들기

#### 일반 클래스를 제네릭으로 변환

```java
// 변환 전
public class Stack {
    private Object[] elements;
    private int size = 0;

    public void push(Object e) { ... }
    public Object pop() { ... }
}

// 변환 후
public class Stack<E> {
    private E[] elements;
    private int size = 0;

    public void push(E e) { ... }
    public E pop() { ... }
}
```

### 주의사항

- E와 같은 실체화 불가 타입으로는 배열을 만들 수 없음
- 해결책: Object 배열을 생성한 후 제네릭 배열로 형변환

## 아이템 30: 이왕이면 제네릭 메서드로 만들라

### 제네릭 메서드

```java
// 타입 안전하지 않은 메서드
public static Set union(Set s1, Set s2) {
    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}

// 제네릭 메서드로 변환
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}
```

### 제네릭 싱글턴 팩터리

- 불변 객체를 여러 타입으로 활용할 수 있게 만드는 패턴
- 예: `Collections.emptySet()`, `Collections.reverseOrder()`

## 아이템 31: 한정적 와일드카드를 사용해 API 유연성을 높이라

### PECS 원칙

**Producer-Extends, Consumer-Super**

#### Producer - Extends

```java
// 생산자(Producer): 컬렉션으로부터 요소를 읽음
public void pushAll(Iterable<? extends E> src) {
    for (E e : src) {
        push(e);
    }
}
```

#### Consumer - Super

```java
// 소비자(Consumer): 컬렉션에 요소를 씀
public void popAll(Collection<? super E> dst) {
    while (!isEmpty()) {
        dst.add(pop());
    }
}
```

### 원칙

- 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라
- 반환 타입에는 한정적 와일드카드 타입을 사용하면 안 됨
- **PECS**: Producer는 extends, Consumer는 super

## 아이템 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라

### 문제점

```java
// 위험한 메서드
static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringLists;
    objects[0] = intList; // 힙 오염 발생
    String s = stringLists[0].get(0); // ClassCastException
}
```

### 안전한 사용법

- `@SafeVarargs` 애너테이션으로 경고 제거 (메서드가 타입 안전함을 보장할 때만)
- 가변인수 매개변수 배열에 아무것도 저장하지 않기
- 배열의 참조가 밖으로 노출되지 않도록 하기

## 아이템 33: 타입 안전 이종 컨테이너를 고려하라

### 타입 안전 이종 컨테이너 패턴

```java
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), instance);
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}

// 사용 예
Favorites f = new Favorites();
f.putFavorite(String.class, "Java");
f.putFavorite(Integer.class, 123);
f.putFavorite(Class.class, Favorites.class);

String favoriteString = f.getFavorite(String.class);
Integer favoriteInteger = f.getFavorite(Integer.class);
```

### 핵심

- 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있음
- 타입 안전 이종 컨테이너 패턴을 사용하면 타입별로 다른 타입의 원소를 담을 수 있음
- 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공

## 핵심 정리

1. 로 타입은 사용하지 말라 (타입 안전성 X)
2. 모든 경고를 제거하고, 불가피하면 `@SuppressWarnings` 사용
3. 배열보다는 리스트를 사용하라
4. 클라이언트가 형변환을 해야 하는 API는 제네릭으로 만들라
5. PECS 공식을 기억하라
6. 타입 안전 이종 컨테이너로 유연한 설계를 고려하라
