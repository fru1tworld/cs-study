# 06 열거 타입과 애너테이션

## 개요

Java의 열거 타입(enum)과 애너테이션은 특수한 목적의 참조 타입으로, 효과적으로 사용하는 방법을 다룬다.

## 아이템 34: int 상수 대신 열거 타입을 사용하라

### 정수 열거 패턴의 문제점

```java
// 나쁜 예 - 정수 열거 패턴
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE = 1;
public static final int ORANGE_BLOOD = 2;
```

**문제점:**

- 타입 안전성이 없음
- 표현력이 좋지 않음
- 깨지기 쉬움 (컴파일하면 값이 그대로 새겨짐)
- 문자열로 출력하기 어려움

### 열거 타입의 장점

```java
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
```

**장점:**

- 타입 안전성 제공
- 각자의 이름공간이 있어 이름이 같은 상수도 공존 가능
- 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 됨
- 임의의 메서드나 필드 추가 가능
- 임의의 인터페이스 구현 가능

### 데이터와 메서드를 갖는 열거 타입

```java
public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS  (4.869e+24, 6.052e6),
    EARTH  (5.975e+24, 6.378e6),
    MARS   (6.419e+23, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN (5.685e+26, 6.027e7),
    URANUS (8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.477e7);

    private final double mass;           // 질량 (단위: 킬로그램)
    private final double radius;         // 반지름 (단위: 미터)
    private final double surfaceGravity; // 표면중력 (단위: m/s^2)

    // 중력상수 (단위: m^3 / kg s^2)
    private static final double G = 6.67300E-11;

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass()           { return mass; }
    public double radius()         { return radius; }
    public double surfaceGravity() { return surfaceGravity; }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity;
    }
}
```

## 아이템 35: ordinal 메서드 대신 인스턴스 필드를 사용하라

### 나쁜 예

```java
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;

    // 따라 하지 말 것!
    public int numberOfMusicians() { return ordinal() + 1; }
}
```

**문제점:**

- 상수 선언 순서를 바꾸면 오동작
- 이미 사용 중인 정수와 값이 같은 상수는 추가할 방법이 없음
- 중간에 값을 비워둘 수도 없음

### 올바른 예

```java
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
    NONET(9), DECTET(10), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;

    Ensemble(int size) { this.numberOfMusicians = size; }

    public int numberOfMusicians() { return numberOfMusicians; }
}
```

## 아이템 36: 비트 필드 대신 EnumSet을 사용하라

### 비트 필드의 문제점

```java
// 나쁜 예 - 비트 필드
public class Text {
    public static final int STYLE_BOLD          = 1 << 0;  // 1
    public static final int STYLE_ITALIC        = 1 << 1;  // 2
    public static final int STYLE_UNDERLINE     = 1 << 2;  // 4
    public static final int STYLE_STRIKETHROUGH = 1 << 3;  // 8

    public void applyStyles(int styles) { ... }
}

text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```

**문제점:**

- 비트 필드 값이 그대로 출력되면 해석하기 어려움
- 비트 필드 하나에 녹아 있는 모든 원소를 순회하기 어려움
- 최대 몇 비트가 필요한지 미리 예측하여 적절한 타입 선택

### EnumSet 사용

```java
public class Text {
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }

    // 어떤 Set을 넘겨도 되지만, EnumSet이 가장 좋다
    public void applyStyles(Set<Style> styles) { ... }
}

text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

**장점:**

- Set 인터페이스를 완벽히 구현
- 타입 안전
- 다른 어떤 Set 구현체와도 함께 사용 가능
- 내부는 비트 벡터로 구현되어 성능이 비트 필드에 버금감

## 아이템 37: ordinal 인덱싱 대신 EnumMap을 사용하라

### 나쁜 예

```java
// ordinal()을 배열 인덱스로 사용 - 따라하지 말 것!
Set<Plant>[] plantsByLifeCycle = (Set<Plant>[]) new Set[Plant.LifeCycle.values().length];
for (int i = 0; i < plantsByLifeCycle.length; i++) {
    plantsByLifeCycle[i] = new HashSet<>();
}
for (Plant p : garden) {
    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);
}
```

### 올바른 예

```java
Map<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle = new EnumMap<>(Plant.LifeCycle.class);
for (Plant.LifeCycle lc : Plant.LifeCycle.values()) {
    plantsByLifeCycle.put(lc, new HashSet<>());
}
for (Plant p : garden) {
    plantsByLifeCycle.get(p.lifeCycle).add(p);
}
```

**장점:**

- 더 짧고 명료하고 안전하고 성능도 원래 버전과 비슷
- 안전하지 않은 형변환 불필요
- 맵의 키인 열거 타입이 그 자체로 출력용 문자열 제공
- 배열 인덱스 계산 중 오류 가능성 제로

## 아이템 38: 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

### 인터페이스를 이용한 확장 가능 열거 타입

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) { return x / y; }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override public String toString() {
        return symbol;
    }
}

// 확장
public enum ExtendedOperation implements Operation {
    EXP("^") {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    REMAINDER("%") {
        public double apply(double x, double y) {
            return x % y;
        }
    };

    private final String symbol;

    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override public String toString() {
        return symbol;
    }
}
```

## 아이템 39: 명명 패턴보다 애너테이션을 사용하라

### 명명 패턴의 단점

- 오타에 민감 (예: JUnit 3의 `test`로 시작)
- 올바른 프로그램 요소에서만 사용되리라 보증 불가
- 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없음

### 애너테이션의 장점

```java
// 마커 애너테이션 타입 선언
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}

// 사용 예
public class Sample {
    @Test
    public static void m1() { }  // 성공해야 한다

    public static void m2() { }

    @Test
    public static void m3() {    // 실패해야 한다
        throw new RuntimeException("실패");
    }
}
```

**장점:**

- 명명 패턴의 모든 단점 해결
- 매개변수를 받을 수 있음
- 적용 대상을 제한할 수 있음
- 컴파일 타임에 오류 검출 가능

## 아이템 40: @Override 애너테이션을 일관되게 사용하라

### 실수 방지

```java
// 버그 - equals를 재정의한 게 아니라 다중정의함
public class Bigram {
    private final char first;
    private final char second;

    public Bigram(char first, char second) {
        this.first  = first;
        this.second = second;
    }

    // 잘못됨 - Object의 equals를 재정의하지 못함
    public boolean equals(Bigram b) {
        return b.first == first && b.second == second;
    }

    public int hashCode() {
        return 31 * first + second;
    }
}
```

### @Override로 문제 발견

```java
@Override
public boolean equals(Bigram b) {  // 컴파일 오류 발생!
    return b.first == first && b.second == second;
}

// 올바른 수정
@Override
public boolean equals(Object o) {
    if (!(o instanceof Bigram))
        return false;
    Bigram b = (Bigram) o;
    return b.first == first && b.second == second;
}
```

**규칙:** 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달아라

## 아이템 41: 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

### 마커 인터페이스 vs 마커 애너테이션

**마커 인터페이스의 장점:**

1. 타입으로 정의 가능 - 컴파일타임에 오류 검출
2. 적용 대상을 더 정밀하게 지정 가능

예: `Serializable` 인터페이스

**마커 애너테이션의 장점:**

1. 거대한 애너테이션 시스템의 지원
2. 클래스와 인터페이스 외의 요소에도 적용 가능

### 선택 기준

- 마킹된 객체를 매개변수로 받는 메서드를 작성할 일이 있다면 → **마커 인터페이스**
- 클래스나 인터페이스 외의 요소에 마킹해야 한다면 → **마커 애너테이션**
- 애너테이션을 적극 활용하는 프레임워크를 사용한다면 → **마커 애너테이션**

## 핵심 정리

1. int 상수 대신 열거 타입을 사용하라
2. ordinal 메서드는 사용하지 말고 인스턴스 필드를 사용하라
3. 비트 필드 대신 EnumSet을, ordinal 인덱싱 대신 EnumMap을 사용하라
4. 확장이 필요하면 인터페이스를 활용하라
5. 명명 패턴보다 애너테이션을 사용하라
6. @Override 애너테이션을 일관되게 사용하라
7. 마커 인터페이스와 마커 애너테이션의 용도를 구분하라
