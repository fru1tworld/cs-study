# 8장 메서드

## 개요

메서드를 설계할 때 주의할 점: 매개변수와 반환값을 어떻게 처리해야 하는지, 메서드 시그니처를 어떻게 설계해야 하는지, 문서화는 어떻게 해야 하는지를 다룬다.

## 아이템 49: 매개변수가 유효한지 검사하라

### 매개변수 검사의 중요성

- 메서드 몸체가 실행되기 전에 매개변수를 확인하면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있음

### 공개 API의 매개변수 검사

```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
    // 계산 수행
}
```

### Objects.requireNonNull (Java 7+)

```java
// Java의 null 검사 기능 사용
this.strategy = Objects.requireNonNull(strategy, "전략은 null이 될 수 없습니다.");
```

### Java 9의 범위 검사 기능

```java
// Java 9의 Objects 범위 검사 기능
Objects.checkFromIndexSize(int fromIndex, int size, int length)
Objects.checkFromToIndex(int fromIndex, int toIndex, int length)
Objects.checkIndex(int index, int length)
```

### 비공개 메서드의 단언문(assert)

```java
// 비공개 메서드는 assert를 사용해 매개변수 유효성 검증
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    // 계산 수행
}
```

### 예외: 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때

- 계산 과정에서 암묵적으로 검사가 수행될 때
- 예: `Collections.sort(List)` - 정렬 과정에서 상호 비교될 때 자동으로 검사됨

## 아이템 50: 적시에 방어적 복사본을 만들라

### 가변 내부 필드의 위험성

```java
// 잘못된 예 - 불변식을 지키지 못함
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }

    public Date start() { return start; }
    public Date end() { return end; }
}

// 공격 예
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);  // p의 내부를 변경함!
```

### 방어적 복사로 보호

```java
// 생성자에서 방어적 복사
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    // 유효성 검사는 복사본으로 한다
    if (this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(
            this.start + "가 " + this.end + "보다 늦다.");
}

// 접근자에서도 방어적 복사
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```

### 더 나은 방법: 불변 객체 사용

```java
// Date 대신 Instant (또는 LocalDateTime, ZonedDateTime) 사용
public final class Period {
    private final Instant start;
    private final Instant end;

    public Period(Instant start, Instant end) {
        if (start.isAfter(end))
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }

    public Instant start() { return start; }
    public Instant end() { return end; }
}
```

## 아이템 51: 메서드 시그니처를 신중히 설계하라

### 메서드 이름 짓기

- 항상 표준 명명 규칙을 따라라
- 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게
- 개발자 커뮤니티에서 널리 받아들여지는 이름 사용
- 긴 이름은 피하라

### 편의 메서드를 너무 많이 만들지 말라

- 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어려움
- 확신이 서지 않으면 만들지 말라

### 매개변수 목록은 짧게 유지하라

- **4개 이하**가 좋음
- 같은 타입의 매개변수 여러 개가 연달아 나오는 경우 특히 해롭다

#### 긴 매개변수 목록을 짧게 줄이는 기술

**1. 여러 메서드로 쪼갠다**

```java
// 나쁜 예
List<E> subList(int fromIndex, int toIndex, int step)

// 좋은 예 - 두 메서드로 분리
List<E> subList(int fromIndex, int toIndex)
Stream<E> stream().skip(n).limit(size)
```

**2. 매개변수 여러 개를 묶어주는 도우미 클래스**

```java
// 카드 게임: 숫자(rank)와 무늬(suit)를 묶은 도우미 클래스
public class Card {
    private final Rank rank;
    private final Suit suit;
}
```

**3. 빌더 패턴을 메서드 호출에 응용**

```java
// 매개변수가 많고 일부는 생략 가능할 때
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
    .calories(100)
    .sodium(35)
    .carbohydrate(27)
    .build();
```

### 매개변수의 타입으로는 클래스보다 인터페이스가 낫다

```java
// 좋은 예 - 인터페이스 사용
public void processItems(Map<String, Item> items) { ... }

// 나쁜 예 - 구체 클래스 사용
public void processItems(HashMap<String, Item> items) { ... }
```

### boolean보다는 원소 2개짜리 열거 타입이 낫다

```java
// 나쁜 예
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
Thermometer.newInstance(true);  // true가 무엇을 의미?

// 좋은 예
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
Thermometer.newInstance(TemperatureScale.CELSIUS);  // 명확함
```

## 아이템 52: 다중정의는 신중히 사용하라

### 다중정의(Overloading)의 혼란

```java
// 다중정의는 컴파일타임에 결정
public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }

    public static String classify(List<?> lst) {
        return "리스트";
    }

    public static String classify(Collection<?> c) {
        return "그 외";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
            new HashSet<String>(),
            new ArrayList<BigInteger>(),
            new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));  // 모두 "그 외" 출력!
    }
}
```

### 재정의(Overriding)는 런타임에 결정

```java
// 재정의는 런타임에 결정
class Wine {
    String name() { return "포도주"; }
}

class SparklingWine extends Wine {
    @Override String name() { return "발포성 포도주"; }
}

class Champagne extends SparklingWine {
    @Override String name() { return "샴페인"; }
}

public class Overriding {
    public static void main(String[] args) {
        List<Wine> wineList = List.of(
            new Wine(), new SparklingWine(), new Champagne());

        for (Wine wine : wineList)
            System.out.println(wine.name());  // 각각의 실제 타입에 맞게 출력
    }
}
```

### 다중정의 사용 지침

- 안전하고 보수적으로 가려면 **매개변수 수가 같은 다중정의는 만들지 말라**
- 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 함
- 다중정의 대신 메서드 이름을 다르게 지어주자
  - 예: `ObjectOutputStream` 클래스
    - `writeBoolean(boolean)`, `writeInt(int)`, `writeLong(long)`

## 아이템 53: 가변인수는 신중히 사용하라

### 가변인수(varargs) 메서드

```java
// 간단한 가변인수 활용 예
static int sum(int... args) {
    int sum = 0;
    for (int arg : args)
        sum += arg;
    return sum;
}
```

### 인수가 1개 이상이어야 하는 경우

```java
// 잘못된 예 - 런타임에 실패
static int min(int... args) {
    if (args.length == 0)
        throw new IllegalArgumentException("인수가 1개 이상 필요합니다.");
    int min = args[0];
    for (int i = 1; i < args.length; i++)
        if (args[i] < min)
            min = args[i];
    return min;
}

// 올바른 예 - 컴파일타임에 검증
static int min(int firstArg, int... remainingArgs) {
    int min = firstArg;
    for (int arg : remainingArgs)
        if (arg < min)
            min = arg;
    return min;
}
```

### 성능에 민감한 상황

```java
// 성능 최적화를 위한 다중정의
public void foo() { }
public void foo(int a1) { }
public void foo(int a1, int a2) { }
public void foo(int a1, int a2, int a3) { }
public void foo(int a1, int a2, int a3, int... rest) { }
```

## 아이템 54: null이 아닌, 빈 컬렉션이나 배열을 반환하라

### 나쁜 예 - null 반환

```java
// null을 반환하면 클라이언트에서 방어 코드가 필요
private final List<Cheese> cheesesInStock = ...;

public List<Cheese> getCheeses() {
    return cheesesInStock.isEmpty() ? null
        : new ArrayList<>(cheesesInStock);
}

// 클라이언트 코드
List<Cheese> cheeses = shop.getCheeses();
if (cheeses != null && cheeses.contains(Cheese.STILTON))
    System.out.println("좋았어, 바로 그거야.");
```

### 올바른 예 - 빈 컬렉션 반환

```java
// 빈 컬렉션을 반환
public List<Cheese> getCheeses() {
    return new ArrayList<>(cheesesInStock);
}

// 최적화 - 불변 빈 컬렉션 재사용
public List<Cheese> getCheeses() {
    return cheesesInStock.isEmpty() ? Collections.emptyList()
        : new ArrayList<>(cheesesInStock);
}
```

### 배열의 경우

```java
// 길이가 0일 수도 있는 배열 반환
public Cheese[] getCheeses() {
    return cheesesInStock.toArray(new Cheese[0]);
}

// 최적화 - 길이 0짜리 배열 재사용
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];

public Cheese[] getCheeses() {
    return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
}
```

## 아이템 55: 옵셔널 반환은 신중히 하라

### Optional<T>

```java
// 컬렉션에서 최댓값을 구한다 (Optional 사용)
public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
    if (c.isEmpty())
        return Optional.empty();

    E result = null;
    for (E e : c)
        if (result == null || e.compareTo(result) > 0)
            result = Objects.requireNonNull(e);

    return Optional.of(result);
}

// 스트림 버전
public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
    return c.stream().max(Comparator.naturalOrder());
}
```

### Optional 활용 패턴

```java
// 기본값 설정
String lastWordInLexicon = max(words).orElse("단어 없음...");

// 예외 던지기
Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);

// 항상 값이 채워져 있다고 가정
Element lastNobleGas = max(Elements.NOBLE_GASES).get();

// 기본값 설정 (비용이 큰 경우 Supplier 사용)
String lastWord = max(words).orElseGet(() -> calculateDefault());

// Java 9의 stream 메서드
Stream<String> stream = max(words).stream();
```

### Optional 사용 지침

- **컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 됨**
  - `Optional<List<T>>`보다 빈 `List<T>` 반환이 나음
- **박싱된 기본 타입을 담은 옵셔널은 기본 타입 자체보다 무거움**
  - `OptionalInt`, `OptionalLong`, `OptionalDouble` 사용
- **옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없음**

## 아이템 56: 공개된 API 요소에는 항상 문서화 주석을 작성하라

### Javadoc 문서화 주석

```java
/**
 * Returns the element at the specified position in this list.
 *
 * <p>This method is <i>not</i> guaranteed to run in constant
 * time. In some implementations it may run in time proportional
 * to the element position.
 *
 * @param  index index of the element to return; must be
 *         non-negative and less than the size of this list
 * @return the element at the specified position in this list
 * @throws IndexOutOfBoundsException if the index is out of range
 *         ({@code index < 0 || index >= this.size()})
 */
E get(int index);
```

### 문서화 주석 작성 지침

1. **공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아라**
2. **메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술**
   - 무엇을 하는지 기술 (how가 아닌 what)
   - 전제조건(precondition)과 사후조건(postcondition) 나열
   - 부작용(side effect)도 문서화
3. **@param, @return, @throws 태그 사용**
4. **{@code} 태그로 코드용 폰트로 렌더링하고 HTML 이스케이프**
5. **{@literal} 태그로 HTML 마크업이나 자바독 태그를 무시**
6. **첫 번째 문장은 요약 설명**
   - 같은 요약 설명을 가진 멤버가 공존하지 않게 주의
7. **제네릭 타입이나 메서드는 모든 타입 매개변수에 주석**
8. **열거 타입은 상수들에도 주석**
9. **애너테이션 타입은 멤버들에도 주석**
10. **패키지와 모듈도 문서화**

## 핵심 정리

1. 매개변수가 유효한지 검사하라
2. 적시에 방어적 복사본을 만들라
3. 메서드 시그니처를 신중히 설계하라
4. 다중정의는 신중히 사용하라
5. 가변인수는 신중히 사용하라
6. null이 아닌 빈 컬렉션이나 배열을 반환하라
7. 옵셔널 반환은 신중히 하라
8. 공개된 API 요소에는 항상 문서화 주석을 작성하라
