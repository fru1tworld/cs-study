## 2.1 메시지 생산과 소비

레코드라고도 부르는 메시지는 카프카를 통해 흐르는 데이터의 기본 요소다.

메시지는 카프카가 데이터를 표현하는 방식

개별 메시지는 타임스탬프, 값 그리고 선택적으로 키가 있을 수 있음 또는 커스텀 헤더가 추가될 수 있다.

개별 키와 값은 데이터를 직렬화 또는 역직렬화하기 위해 카프카 특유의 방식으로 상호 작용할 수 있다.

## 2.2 브로커란 무엇인가?

브로커는 카프카의 서버 측면으로 생각할 수 있다.

가상 머신과 쿠버네티스 이전에는 하나의 브로커는 호스팅하는 하나의 물리 서버를 보았을 것이다.

토픽을 만들기 위해 --create 옵션으로 셸 창에서 kafka-tocis.sh 명령을 실행할 것이다.

이 스크립트는 카프카 설치 디렉터리에 있는 ~/kafka_2.13-2.7.1/bin 과 같은 경로에서 찾을 수 있을 것이다.

```bash
bin/kafka-topic.sh --create --bootstrap-server localhost:9094 -- topic ka_helloworld --partitions 3 --replication-factor 3
```

```bash
bin/kafka-topics.sh --bootstrap-server localhost:9094 --describe --topic ka_hellowworld

Topic:ka_hellworld PartitionCount:3 ReplicationFactor:3 Configs:
Topic: ka_helloworld Partition: 0 Leader: 0 Replicas: 0,1,2 lsr: 0,1,2
Topic: ka_helloworld Partition: 1 Leader: 1 Replicas: 1,2,0 lsr: 1,2,0
Topic: ka_helloworld Partition: 2 Leader: 2 Replicas: 2,0,1 lsr: 2,0,1

```

파티션 0을 살펴보면 브로커 0에 레플리카 사본이 있고 이 파티션은 브로커 1과 2에도 레플리카가 있다.

lsr은 **동기화된 레플리카**를 표시한다.

오래됐거나 리더보다 뒤처진 사본 레플리카 파티션이 발생하는 문제는 나중에 다룰 것이다.

분산 시스템에서 레플리카 상태는 계속 주시해야 할 사항이라는 점은 여전히 기억해야 한다.

> 그림에서 파티션 리더를 참조할 때 레플리카 리더를 참조한다.
> 파티션이 1개 이상의 레플리카로 구성될 수 있음을 알아야 한다. 리더의 역할이 외부 클라이언트에 의해 업데이트 받지만 리더가 아닌 레플리카는 그 레플리카의 리더로부터만 업데이트 받는다.

토픽을 만들고 존재하는지 확인했다면 이제 실제 메시지를 보낼 수 있다.!

## 2.3 카프카 투어

| 컴포넌트      | 역할                                                    |
| ------------- | ------------------------------------------------------- |
| 프로듀서      | 카프카로 메시지를 보낸다.                               |
| 컨슈머        | 카프카에서 메시지를 조회한다.                           |
| 토픽          | 메시지를 브로커에 저장하기 위한 논리적인 이름           |
| 주키퍼 앙상블 | 클러스터에서 컨센서스를 유지하도록 돕는다.              |
| 브로커        | 커밋 로그를 처리한다. (디스크에 메시지를 저장하는 방법) |

### 2.3.1 프로듀서와 컨슈머

컨슈머는 실행되는 동안 지속적으로 폴링한다.

### 2.3.2 토픽 개요

토픽은 어떤 메시지가 어디로 가야 하는지에 관한 로직을 생각하기 시작하는 곳이다.

토픽은 파티션이라는 단위로 구성된다.

1 개 이상의 파티션이 단일 토픽을 구성한다.

> 단일 파티션의 레플리카는 단 하나의 브로커에서만 존재하며 브로커 간에 분할될 수 없다.

단일 카프카 브로커에 개별 파티션 레플리카의 리더가 존재하는 방식과 그 보다 더 작은 단위로 나눌 수 없다는 점을 보여준다.

첫 번째 예제에 있는 토픽을 떠올려보면 3개의 데이터 복제를 원한다면 이 토픽 자체는 복사될 단일 엔티티가 아니다.

그 대신 각각 3번씩 복제되는 여러 개의 파티션이다.

아 파티션은 세그먼트 파일로 더 세분화되어 디스크 드라이브에 기록된다.

> 세그먼트 파일에 관한 세부 내용과 저장되는 위치닌 브로커에 관해 이야기할 이후의 장에서 다룰 것이다.
> 비록 세그먼트 파일이 파티션을 구성하지만 우리가 세그먼트 파일과 직접 상호 작용하지 않을 가능성이 높으며, 이는 내부의 세부 구현으로만 간주돼야 한다.

여기서 중요한 개념 중 하나는 파티션 복사본 중 하나가 리더가 된다는 개념이다.

예를 들어 파티션 3개로 된 토픽이 있고 각 파티션은 3개의 복사본을 갖고 있다면, 모든 파티션은 각각 리더 레플리카를 선출했을 것이다.

이 리더는 이 파티션 복사본 중 하나가 되며 다른 두 복사본은 파티션 리더로부터 데이터를 업데이트 받는 팔로워가 될 것이다.

프로듀서와 컨슈머는 예외나 오류가 없는 시나리오에서 할당된 각 파티션의 리더 레플리카에서만 읽고 쓴다.

하지만 프로듀서와 컨슈머가 어느 파티션 레플리카가 리더인지 어덯게 알고 있을까 ?

분산 컴퓨팅과 무작위 실패 이벤트에서 이 대답은 우리의 여행의 다음 목적지에서 소개할 주키퍼의 도움이 필요하다

### 2.3.3 주키퍼의 용도

카프카 생태계를 복잡하게 만들어 주는 가장 오래된 원인 중 하나다.

아파치 주키퍼는 디스커버리, 컨피규레이션, 동기화 서비스를 고가용성 방식으로 제공하는 분산 저장소다.

카프카 0.9 버전부터 얼마만큼의 메시지를 컨슈머가 소비했는지(오프셋)에 관한 정보를 주키퍼에 저장하지 않도록 선택할수 있다.

오프셋의 중요성은 이후의 장에서 다룰 것이다.

이렇듯 주키퍼의 사용 범위를 줄였음에도 , 컨세서스와 코디네이션의 필요성은 제거하지 못했다.

> 주키퍼 제거
> 카프카를 실행하기 위한 요구사항을 단순화하기 위해 주키퍼 대신 자체 관리되는 쿼럼으로 교체하자는 제안이 있었다.
> 이 책이 출간될 때 이 작업이 완료되지 않았기 때문에 여전히 논의된다.
> 어떤 이유로 주키퍼가 중요할 까 ?
> 주키퍼가 비록 카프카 레프트(Kafka Raft Metadata)모드로 대체된다고 하더라도 분산 시스템에서 코디네이션의 필요성에 관한 개념은 여전히 유효하며, 현재 주키퍼가 수행하는 역할을 이해하는 것이 이 코디네이션 갠며을 이해하기 위한 기초가 될 것이다.
> 카프카는 내결함성 회복 탄력성, 코디네이션을 제공해야 하는데 주키퍼는 전체 시스템 에서 이러한 부분을 담당한다.
> 주키퍼 내부를 세부적으로 다루지 않겠지만, 이후의 장에서 카프카가 주키퍼를 사용하는 방식은 다룰 것이다.

### 2.3.4 카프카의 고가용성 아키텍처

카프카는 JVM 위에서 돌아가는 스칼라 애플리케이션이라고 생각할 수 있다.

카프카의 핵심 중 하나는 운영체제의 페이지 캐시 사용이다.

브로커가 JVM 힙에 캐시되지 않도록 하여 크기가 큰 힙으로 인해 발생하는 문제를 방지한다.

> 카프카는 JVM 힙 대신 페이지 캐시에 의존하므로 수백만 개의 메시지를 빠르게 처리할 수 있다.

카프카는 자체적인 메시지 프로토콜을 활용한다 AMPQP는 자체적으로 구현했을 때 제약 사항이 많다고 했고 EOS를 구현하기 위해 자체적인 헤더를 추가헀다.

### 2.3.5 커밋 로그

로그는 자바에서 LOGGER.error 메시지와 같은 애플리케이션 프로세서에 있는 로거로부터 출력을 집계하는 로그 사용 사례와는 다른 것을 분명히 이야기한다.

카프카가 사용하는 이 로그는 데이터베이스의 WAL처럼 다른 시스템에서는 숨겨진 세부 정보가 아니다.

오히려 카프카의 중심에 위치하며, 사용자들은 오프셋을 사용해 메시지가 그 로그에서 어디에 위치하는지를 알 수 있다.

커밋 로그를 특별하게 만드는 것은 이벤트가 항상 로그 마지막에 추가되는 추가 전용(append only) 특성 때문이다.

카프카는 로그 데이터 보존기간이 구성 속성을 사용해 시간과 크기로 제한 가능하다는 사실만 이해하자

## 2.4 다양한 소스 코드 패키지와 역할

### 2.4.1 카프카 스트림즈

### 2.4.2 카프카 커넥트

### 2.4.3 AdminClient 패키지

### 2.4.4 ksqlDB

## 2.5 컨플루언트 클라이언트

## 2.6 스트림 처리와 용어

### 2.6.1 스트림 처리

### 2.6.2 정확히 한 번의 의미
