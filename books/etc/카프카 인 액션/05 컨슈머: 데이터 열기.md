# 5 컨슈머: 데이터 열기

## 5.1 예제

### 5.1.1 컨슈머 옵션

| 키                    | 용도                                               |
| --------------------- | -------------------------------------------------- |
| bootstrap.servers     | 시작할 때 연결할 하나 이상의 카프카 브로커         |
| value.deserializer    | 값 역직렬화에 필요                                 |
| key.deserializer      | 키 역직렬화에 필요                                 |
| group.id              | 컨슈머 그룹에 조인하기 위해 사용되는 ID            |
| client.id             | 유저를 식별하기 위한 ID                            |
| heartbeat.interval.ms | 컨슈머가 그룹 코디네이터에게 Ping 신호를 보낼 간격 |

### 5.1.2 코디네이트 이해

오프셋

컨슈머가 브로커에게 보내는 로그의 인덱스 위치로 오프셋을 사용한다.

이를 통해 로그는 소비하려는 메시지 위치를 알 수 있다.

메시지를 찾기 위한 오프셋은 무엇일까 ?

먼저 기록된 파티션을 찾은 다음 인덱스 기반 오프셋을 찾는다.

파티션 간 오프셋 번호는 같아도 괜찮다. 메시지를 구분하는 기능에는 오프셋뿐만 아니라 토픽 내에서 어떤 파티션을 처리하고 있는지에 대한 세부 정보가 포함돼야 한다.

메시지 소비에는 파티션의 수도 영향을 미친다.

파티션보다 컨슈머가 많으면 일부 컨슈머는 작업을 수행하지 않는다.

그룹 코디네이터는 그룹 시작 초기에 어떤 컨슈머가 어떤 파티션을 읽을지 지정하는 것뿐만 아니라 컨슈머가 추가되거나 실패하여 그룹을 종료할 때도 컨슈머를 할당한다.

많은 파티션이 종단 간 대기 시간을 증가 시킬 수 있다.

최신 버전에서는 컨슈머가 주키퍼에 의존하지 않는다.

컨슈머는 주키퍼를 이용해 소비한 오프셋을 저장했지만 이제 오프셋은 카프카 내부 토픽 안에 저장된다.

참고로 컨슈머 클라이언트는 이러한 위치에 오프셋을 저장하지 않아도 되지마 , 일반적으로 오프셋 관리를 위해 이러한 위치 중 하나를 사용한다.

주키퍼 저장소에서 벗어나는 이점 중 하나는 주키퍼에 대한 클라이언트의 의존성을 줄이는 것이다.

## 5.2 컨슈머가 상호 작용하는 방식

컨슈머 그룹 개념이 가장 중요한 이유는 무엇일까 ?

아마 그룹에 컨슈머를 추가하거나 그룹에서 제거함으로써 처리 규모에 영향을 준다.

많은 컨슈머가 동일한 토픽에 대해 읽는 경우가 종종 있다.

새 그룹 ID가 필요한지 여부를 결정하는데 있어 중요한 세부 사항은 컨슈머가 하나의 애플리케이션의 일부로 작업하는지 아니면 별도의 논리 흐름으로 작업하는지다.

다른 컨슈머와 동일한 그룹 id를 활용하는 것은 해당 토픽의 파티션과 오프셋을 하나의 논리적 애플리케이션으로 소비하기 위해 함께 작업하는 것으로 간주한다.

### 5.3.1 그룹 코디네이터

### 5.3.2 파티션 할당 전략

레인지 할당자는 단일 토픽을 사용해 파티션 수를 찾은 다음

분배한다.

라운드 로빈 전략은 컨슈머 밑으로 균일하게 분배되는 방식이다.

## 5.4 작업 위치 표시

애플리케이션이 토픽의 모든 메시지를 읽도록 해야 한다는 것은 고려해야 할 중요한 사항 중 하나다.

몇 개를 놓쳐도 괜찮을지 ? 아니면 각 메시지를 읽었음을 확인해야하는지 ?

요구사항과 실제 트레이드오프로 결정된다.

하나의 옵션은 enable.auto.commit을 true로 하는 것인데 이는 클라이언트

## 5.5 컴팩션된 토픽에서 읽기

컴팩션 토픽을 읽고 있다 사실을 인지해야 한다.

파티션 로그를 컴팩션하고 마지막 키를 제외하고 동일한 키를 가진 레코드는 업데이트해야 한다.

메시지 기록이 필요하지 않고 마지막 값만 필요한 경우 레코드만 추가하는 immutable log에서 이 개념이 어떻게 작동하는지 궁금할 것이다.

### 5.6.1 읽기 옵션

가장 중요한 것은 auto.offset.reset을 earliest로 설정하는 것이다.

컨슈머 그룹 ID를 임의의 UUID로 설정하면 컨슈머 그룹에 대한 오프셋 기록없이 시작하는데 도움이 된다.
